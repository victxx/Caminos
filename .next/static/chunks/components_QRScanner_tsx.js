/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_QRScanner_tsx"],{

/***/ "./node_modules/html5-qrcode/esm/camera/core-impl.js":
/*!***********************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/camera/core-impl.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraImpl: function() { return /* binding */ CameraImpl; }\n/* harmony export */ });\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar AbstractCameraCapability = (function () {\n    function AbstractCameraCapability(name, track) {\n        this.name = name;\n        this.track = track;\n    }\n    AbstractCameraCapability.prototype.isSupported = function () {\n        if (!this.track.getCapabilities) {\n            return false;\n        }\n        return this.name in this.track.getCapabilities();\n    };\n    AbstractCameraCapability.prototype.apply = function (value) {\n        var constraint = {};\n        constraint[this.name] = value;\n        var constraints = { advanced: [constraint] };\n        return this.track.applyConstraints(constraints);\n    };\n    AbstractCameraCapability.prototype.value = function () {\n        var settings = this.track.getSettings();\n        if (this.name in settings) {\n            var settingValue = settings[this.name];\n            return settingValue;\n        }\n        return null;\n    };\n    return AbstractCameraCapability;\n}());\nvar AbstractRangeCameraCapability = (function (_super) {\n    __extends(AbstractRangeCameraCapability, _super);\n    function AbstractRangeCameraCapability(name, track) {\n        return _super.call(this, name, track) || this;\n    }\n    AbstractRangeCameraCapability.prototype.min = function () {\n        return this.getCapabilities().min;\n    };\n    AbstractRangeCameraCapability.prototype.max = function () {\n        return this.getCapabilities().max;\n    };\n    AbstractRangeCameraCapability.prototype.step = function () {\n        return this.getCapabilities().step;\n    };\n    AbstractRangeCameraCapability.prototype.apply = function (value) {\n        var constraint = {};\n        constraint[this.name] = value;\n        var constraints = { advanced: [constraint] };\n        return this.track.applyConstraints(constraints);\n    };\n    AbstractRangeCameraCapability.prototype.getCapabilities = function () {\n        this.failIfNotSupported();\n        var capabilities = this.track.getCapabilities();\n        var capability = capabilities[this.name];\n        return {\n            min: capability.min,\n            max: capability.max,\n            step: capability.step,\n        };\n    };\n    AbstractRangeCameraCapability.prototype.failIfNotSupported = function () {\n        if (!this.isSupported()) {\n            throw new Error(\"\".concat(this.name, \" capability not supported\"));\n        }\n    };\n    return AbstractRangeCameraCapability;\n}(AbstractCameraCapability));\nvar ZoomFeatureImpl = (function (_super) {\n    __extends(ZoomFeatureImpl, _super);\n    function ZoomFeatureImpl(track) {\n        return _super.call(this, \"zoom\", track) || this;\n    }\n    return ZoomFeatureImpl;\n}(AbstractRangeCameraCapability));\nvar TorchFeatureImpl = (function (_super) {\n    __extends(TorchFeatureImpl, _super);\n    function TorchFeatureImpl(track) {\n        return _super.call(this, \"torch\", track) || this;\n    }\n    return TorchFeatureImpl;\n}(AbstractCameraCapability));\nvar CameraCapabilitiesImpl = (function () {\n    function CameraCapabilitiesImpl(track) {\n        this.track = track;\n    }\n    CameraCapabilitiesImpl.prototype.zoomFeature = function () {\n        return new ZoomFeatureImpl(this.track);\n    };\n    CameraCapabilitiesImpl.prototype.torchFeature = function () {\n        return new TorchFeatureImpl(this.track);\n    };\n    return CameraCapabilitiesImpl;\n}());\nvar RenderedCameraImpl = (function () {\n    function RenderedCameraImpl(parentElement, mediaStream, callbacks) {\n        this.isClosed = false;\n        this.parentElement = parentElement;\n        this.mediaStream = mediaStream;\n        this.callbacks = callbacks;\n        this.surface = this.createVideoElement(this.parentElement.clientWidth);\n        parentElement.append(this.surface);\n    }\n    RenderedCameraImpl.prototype.createVideoElement = function (width) {\n        var videoElement = document.createElement(\"video\");\n        videoElement.style.width = \"\".concat(width, \"px\");\n        videoElement.style.display = \"block\";\n        videoElement.muted = true;\n        videoElement.setAttribute(\"muted\", \"true\");\n        videoElement.playsInline = true;\n        return videoElement;\n    };\n    RenderedCameraImpl.prototype.setupSurface = function () {\n        var _this = this;\n        this.surface.onabort = function () {\n            throw \"RenderedCameraImpl video surface onabort() called\";\n        };\n        this.surface.onerror = function () {\n            throw \"RenderedCameraImpl video surface onerror() called\";\n        };\n        var onVideoStart = function () {\n            var videoWidth = _this.surface.clientWidth;\n            var videoHeight = _this.surface.clientHeight;\n            _this.callbacks.onRenderSurfaceReady(videoWidth, videoHeight);\n            _this.surface.removeEventListener(\"playing\", onVideoStart);\n        };\n        this.surface.addEventListener(\"playing\", onVideoStart);\n        this.surface.srcObject = this.mediaStream;\n        this.surface.play();\n    };\n    RenderedCameraImpl.create = function (parentElement, mediaStream, options, callbacks) {\n        return __awaiter(this, void 0, void 0, function () {\n            var renderedCamera, aspectRatioConstraint;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        renderedCamera = new RenderedCameraImpl(parentElement, mediaStream, callbacks);\n                        if (!options.aspectRatio) return [3, 2];\n                        aspectRatioConstraint = {\n                            aspectRatio: options.aspectRatio\n                        };\n                        return [4, renderedCamera.getFirstTrackOrFail().applyConstraints(aspectRatioConstraint)];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        renderedCamera.setupSurface();\n                        return [2, renderedCamera];\n                }\n            });\n        });\n    };\n    RenderedCameraImpl.prototype.failIfClosed = function () {\n        if (this.isClosed) {\n            throw \"The RenderedCamera has already been closed.\";\n        }\n    };\n    RenderedCameraImpl.prototype.getFirstTrackOrFail = function () {\n        this.failIfClosed();\n        if (this.mediaStream.getVideoTracks().length === 0) {\n            throw \"No video tracks found\";\n        }\n        return this.mediaStream.getVideoTracks()[0];\n    };\n    RenderedCameraImpl.prototype.pause = function () {\n        this.failIfClosed();\n        this.surface.pause();\n    };\n    RenderedCameraImpl.prototype.resume = function (onResumeCallback) {\n        this.failIfClosed();\n        var $this = this;\n        var onVideoResume = function () {\n            setTimeout(onResumeCallback, 200);\n            $this.surface.removeEventListener(\"playing\", onVideoResume);\n        };\n        this.surface.addEventListener(\"playing\", onVideoResume);\n        this.surface.play();\n    };\n    RenderedCameraImpl.prototype.isPaused = function () {\n        this.failIfClosed();\n        return this.surface.paused;\n    };\n    RenderedCameraImpl.prototype.getSurface = function () {\n        this.failIfClosed();\n        return this.surface;\n    };\n    RenderedCameraImpl.prototype.getRunningTrackCapabilities = function () {\n        return this.getFirstTrackOrFail().getCapabilities();\n    };\n    RenderedCameraImpl.prototype.getRunningTrackSettings = function () {\n        return this.getFirstTrackOrFail().getSettings();\n    };\n    RenderedCameraImpl.prototype.applyVideoConstraints = function (constraints) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (\"aspectRatio\" in constraints) {\n                    throw \"Changing 'aspectRatio' in run-time is not yet supported.\";\n                }\n                return [2, this.getFirstTrackOrFail().applyConstraints(constraints)];\n            });\n        });\n    };\n    RenderedCameraImpl.prototype.close = function () {\n        if (this.isClosed) {\n            return Promise.resolve();\n        }\n        var $this = this;\n        return new Promise(function (resolve, _) {\n            var tracks = $this.mediaStream.getVideoTracks();\n            var tracksToClose = tracks.length;\n            var tracksClosed = 0;\n            $this.mediaStream.getVideoTracks().forEach(function (videoTrack) {\n                $this.mediaStream.removeTrack(videoTrack);\n                videoTrack.stop();\n                ++tracksClosed;\n                if (tracksClosed >= tracksToClose) {\n                    $this.isClosed = true;\n                    $this.parentElement.removeChild($this.surface);\n                    resolve();\n                }\n            });\n        });\n    };\n    RenderedCameraImpl.prototype.getCapabilities = function () {\n        return new CameraCapabilitiesImpl(this.getFirstTrackOrFail());\n    };\n    return RenderedCameraImpl;\n}());\nvar CameraImpl = (function () {\n    function CameraImpl(mediaStream) {\n        this.mediaStream = mediaStream;\n    }\n    CameraImpl.prototype.render = function (parentElement, options, callbacks) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2, RenderedCameraImpl.create(parentElement, this.mediaStream, options, callbacks)];\n            });\n        });\n    };\n    CameraImpl.create = function (videoConstraints) {\n        return __awaiter(this, void 0, void 0, function () {\n            var constraints, mediaStream;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!navigator.mediaDevices) {\n                            throw \"navigator.mediaDevices not supported\";\n                        }\n                        constraints = {\n                            audio: false,\n                            video: videoConstraints\n                        };\n                        return [4, navigator.mediaDevices.getUserMedia(constraints)];\n                    case 1:\n                        mediaStream = _a.sent();\n                        return [2, new CameraImpl(mediaStream)];\n                }\n            });\n        });\n    };\n    return CameraImpl;\n}());\n\n//# sourceMappingURL=core-impl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jYW1lcmEvY29yZS1pbXBsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0I7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQixTQUFJLElBQUksU0FBSTtBQUMvQixjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDcUI7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vY2FtZXJhL2NvcmUtaW1wbC5qcz9hMTVhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgQWJzdHJhY3RDYW1lcmFDYXBhYmlsaXR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdENhbWVyYUNhcGFiaWxpdHkobmFtZSwgdHJhY2spIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50cmFjayA9IHRyYWNrO1xuICAgIH1cbiAgICBBYnN0cmFjdENhbWVyYUNhcGFiaWxpdHkucHJvdG90eXBlLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMudHJhY2suZ2V0Q2FwYWJpbGl0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSBpbiB0aGlzLnRyYWNrLmdldENhcGFiaWxpdGllcygpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYW1lcmFDYXBhYmlsaXR5LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgY29uc3RyYWludCA9IHt9O1xuICAgICAgICBjb25zdHJhaW50W3RoaXMubmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0geyBhZHZhbmNlZDogW2NvbnN0cmFpbnRdIH07XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrLmFwcGx5Q29uc3RyYWludHMoY29uc3RyYWludHMpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYW1lcmFDYXBhYmlsaXR5LnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy50cmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgICBpZiAodGhpcy5uYW1lIGluIHNldHRpbmdzKSB7XG4gICAgICAgICAgICB2YXIgc2V0dGluZ1ZhbHVlID0gc2V0dGluZ3NbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5nVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RDYW1lcmFDYXBhYmlsaXR5O1xufSgpKTtcbnZhciBBYnN0cmFjdFJhbmdlQ2FtZXJhQ2FwYWJpbGl0eSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFic3RyYWN0UmFuZ2VDYW1lcmFDYXBhYmlsaXR5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0UmFuZ2VDYW1lcmFDYXBhYmlsaXR5KG5hbWUsIHRyYWNrKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCB0cmFjaykgfHwgdGhpcztcbiAgICB9XG4gICAgQWJzdHJhY3RSYW5nZUNhbWVyYUNhcGFiaWxpdHkucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FwYWJpbGl0aWVzKCkubWluO1xuICAgIH07XG4gICAgQWJzdHJhY3RSYW5nZUNhbWVyYUNhcGFiaWxpdHkucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FwYWJpbGl0aWVzKCkubWF4O1xuICAgIH07XG4gICAgQWJzdHJhY3RSYW5nZUNhbWVyYUNhcGFiaWxpdHkucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENhcGFiaWxpdGllcygpLnN0ZXA7XG4gICAgfTtcbiAgICBBYnN0cmFjdFJhbmdlQ2FtZXJhQ2FwYWJpbGl0eS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSB7fTtcbiAgICAgICAgY29uc3RyYWludFt0aGlzLm5hbWVdID0gdmFsdWU7XG4gICAgICAgIHZhciBjb25zdHJhaW50cyA9IHsgYWR2YW5jZWQ6IFtjb25zdHJhaW50XSB9O1xuICAgICAgICByZXR1cm4gdGhpcy50cmFjay5hcHBseUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKTtcbiAgICB9O1xuICAgIEFic3RyYWN0UmFuZ2VDYW1lcmFDYXBhYmlsaXR5LnByb3RvdHlwZS5nZXRDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmFpbElmTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIHZhciBjYXBhYmlsaXRpZXMgPSB0aGlzLnRyYWNrLmdldENhcGFiaWxpdGllcygpO1xuICAgICAgICB2YXIgY2FwYWJpbGl0eSA9IGNhcGFiaWxpdGllc1t0aGlzLm5hbWVdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWluOiBjYXBhYmlsaXR5Lm1pbixcbiAgICAgICAgICAgIG1heDogY2FwYWJpbGl0eS5tYXgsXG4gICAgICAgICAgICBzdGVwOiBjYXBhYmlsaXR5LnN0ZXAsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBYnN0cmFjdFJhbmdlQ2FtZXJhQ2FwYWJpbGl0eS5wcm90b3R5cGUuZmFpbElmTm90U3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCIgY2FwYWJpbGl0eSBub3Qgc3VwcG9ydGVkXCIpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0UmFuZ2VDYW1lcmFDYXBhYmlsaXR5O1xufShBYnN0cmFjdENhbWVyYUNhcGFiaWxpdHkpKTtcbnZhciBab29tRmVhdHVyZUltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab29tRmVhdHVyZUltcGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9vbUZlYXR1cmVJbXBsKHRyYWNrKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcInpvb21cIiwgdHJhY2spIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBab29tRmVhdHVyZUltcGw7XG59KEFic3RyYWN0UmFuZ2VDYW1lcmFDYXBhYmlsaXR5KSk7XG52YXIgVG9yY2hGZWF0dXJlSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRvcmNoRmVhdHVyZUltcGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVG9yY2hGZWF0dXJlSW1wbCh0cmFjaykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJ0b3JjaFwiLCB0cmFjaykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRvcmNoRmVhdHVyZUltcGw7XG59KEFic3RyYWN0Q2FtZXJhQ2FwYWJpbGl0eSkpO1xudmFyIENhbWVyYUNhcGFiaWxpdGllc0ltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbWVyYUNhcGFiaWxpdGllc0ltcGwodHJhY2spIHtcbiAgICAgICAgdGhpcy50cmFjayA9IHRyYWNrO1xuICAgIH1cbiAgICBDYW1lcmFDYXBhYmlsaXRpZXNJbXBsLnByb3RvdHlwZS56b29tRmVhdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab29tRmVhdHVyZUltcGwodGhpcy50cmFjayk7XG4gICAgfTtcbiAgICBDYW1lcmFDYXBhYmlsaXRpZXNJbXBsLnByb3RvdHlwZS50b3JjaEZlYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9yY2hGZWF0dXJlSW1wbCh0aGlzLnRyYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBDYW1lcmFDYXBhYmlsaXRpZXNJbXBsO1xufSgpKTtcbnZhciBSZW5kZXJlZENhbWVyYUltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVkQ2FtZXJhSW1wbChwYXJlbnRFbGVtZW50LCBtZWRpYVN0cmVhbSwgY2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudDtcbiAgICAgICAgdGhpcy5tZWRpYVN0cmVhbSA9IG1lZGlhU3RyZWFtO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICAgICAgdGhpcy5zdXJmYWNlID0gdGhpcy5jcmVhdGVWaWRlb0VsZW1lbnQodGhpcy5wYXJlbnRFbGVtZW50LmNsaWVudFdpZHRoKTtcbiAgICAgICAgcGFyZW50RWxlbWVudC5hcHBlbmQodGhpcy5zdXJmYWNlKTtcbiAgICB9XG4gICAgUmVuZGVyZWRDYW1lcmFJbXBsLnByb3RvdHlwZS5jcmVhdGVWaWRlb0VsZW1lbnQgPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICAgICAgdmFyIHZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcbiAgICAgICAgdmlkZW9FbGVtZW50LnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIik7XG4gICAgICAgIHZpZGVvRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB2aWRlb0VsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKFwibXV0ZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICB2aWRlb0VsZW1lbnQucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmlkZW9FbGVtZW50O1xuICAgIH07XG4gICAgUmVuZGVyZWRDYW1lcmFJbXBsLnByb3RvdHlwZS5zZXR1cFN1cmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3VyZmFjZS5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgXCJSZW5kZXJlZENhbWVyYUltcGwgdmlkZW8gc3VyZmFjZSBvbmFib3J0KCkgY2FsbGVkXCI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3VyZmFjZS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgXCJSZW5kZXJlZENhbWVyYUltcGwgdmlkZW8gc3VyZmFjZSBvbmVycm9yKCkgY2FsbGVkXCI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvblZpZGVvU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmlkZW9XaWR0aCA9IF90aGlzLnN1cmZhY2UuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICB2YXIgdmlkZW9IZWlnaHQgPSBfdGhpcy5zdXJmYWNlLmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIF90aGlzLmNhbGxiYWNrcy5vblJlbmRlclN1cmZhY2VSZWFkeSh2aWRlb1dpZHRoLCB2aWRlb0hlaWdodCk7XG4gICAgICAgICAgICBfdGhpcy5zdXJmYWNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwbGF5aW5nXCIsIG9uVmlkZW9TdGFydCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3VyZmFjZS5hZGRFdmVudExpc3RlbmVyKFwicGxheWluZ1wiLCBvblZpZGVvU3RhcnQpO1xuICAgICAgICB0aGlzLnN1cmZhY2Uuc3JjT2JqZWN0ID0gdGhpcy5tZWRpYVN0cmVhbTtcbiAgICAgICAgdGhpcy5zdXJmYWNlLnBsYXkoKTtcbiAgICB9O1xuICAgIFJlbmRlcmVkQ2FtZXJhSW1wbC5jcmVhdGUgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgbWVkaWFTdHJlYW0sIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRDYW1lcmEsIGFzcGVjdFJhdGlvQ29uc3RyYWludDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkQ2FtZXJhID0gbmV3IFJlbmRlcmVkQ2FtZXJhSW1wbChwYXJlbnRFbGVtZW50LCBtZWRpYVN0cmVhbSwgY2FsbGJhY2tzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5hc3BlY3RSYXRpbykgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvQ29uc3RyYWludCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbzogb3B0aW9ucy5hc3BlY3RSYXRpb1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgcmVuZGVyZWRDYW1lcmEuZ2V0Rmlyc3RUcmFja09yRmFpbCgpLmFwcGx5Q29uc3RyYWludHMoYXNwZWN0UmF0aW9Db25zdHJhaW50KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRDYW1lcmEuc2V0dXBTdXJmYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlbmRlcmVkQ2FtZXJhXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLmZhaWxJZkNsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IFwiVGhlIFJlbmRlcmVkQ2FtZXJhIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLmdldEZpcnN0VHJhY2tPckZhaWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmFpbElmQ2xvc2VkKCk7XG4gICAgICAgIGlmICh0aGlzLm1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBcIk5vIHZpZGVvIHRyYWNrcyBmb3VuZFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZhaWxJZkNsb3NlZCgpO1xuICAgICAgICB0aGlzLnN1cmZhY2UucGF1c2UoKTtcbiAgICB9O1xuICAgIFJlbmRlcmVkQ2FtZXJhSW1wbC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKG9uUmVzdW1lQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5mYWlsSWZDbG9zZWQoKTtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9uVmlkZW9SZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KG9uUmVzdW1lQ2FsbGJhY2ssIDIwMCk7XG4gICAgICAgICAgICAkdGhpcy5zdXJmYWNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwbGF5aW5nXCIsIG9uVmlkZW9SZXN1bWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN1cmZhY2UuYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlpbmdcIiwgb25WaWRlb1Jlc3VtZSk7XG4gICAgICAgIHRoaXMuc3VyZmFjZS5wbGF5KCk7XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZhaWxJZkNsb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdXJmYWNlLnBhdXNlZDtcbiAgICB9O1xuICAgIFJlbmRlcmVkQ2FtZXJhSW1wbC5wcm90b3R5cGUuZ2V0U3VyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mYWlsSWZDbG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VyZmFjZTtcbiAgICB9O1xuICAgIFJlbmRlcmVkQ2FtZXJhSW1wbC5wcm90b3R5cGUuZ2V0UnVubmluZ1RyYWNrQ2FwYWJpbGl0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaXJzdFRyYWNrT3JGYWlsKCkuZ2V0Q2FwYWJpbGl0aWVzKCk7XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLmdldFJ1bm5pbmdUcmFja1NldHRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaXJzdFRyYWNrT3JGYWlsKCkuZ2V0U2V0dGluZ3MoKTtcbiAgICB9O1xuICAgIFJlbmRlcmVkQ2FtZXJhSW1wbC5wcm90b3R5cGUuYXBwbHlWaWRlb0NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJhc3BlY3RSYXRpb1wiIGluIGNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiQ2hhbmdpbmcgJ2FzcGVjdFJhdGlvJyBpbiBydW4tdGltZSBpcyBub3QgeWV0IHN1cHBvcnRlZC5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmdldEZpcnN0VHJhY2tPckZhaWwoKS5hcHBseUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgXykge1xuICAgICAgICAgICAgdmFyIHRyYWNrcyA9ICR0aGlzLm1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICAgICAgICB2YXIgdHJhY2tzVG9DbG9zZSA9IHRyYWNrcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgdHJhY2tzQ2xvc2VkID0gMDtcbiAgICAgICAgICAgICR0aGlzLm1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodmlkZW9UcmFjaykge1xuICAgICAgICAgICAgICAgICR0aGlzLm1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKHZpZGVvVHJhY2spO1xuICAgICAgICAgICAgICAgIHZpZGVvVHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgICsrdHJhY2tzQ2xvc2VkO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja3NDbG9zZWQgPj0gdHJhY2tzVG9DbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoJHRoaXMuc3VyZmFjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLmdldENhcGFiaWxpdGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYW1lcmFDYXBhYmlsaXRpZXNJbXBsKHRoaXMuZ2V0Rmlyc3RUcmFja09yRmFpbCgpKTtcbiAgICB9O1xuICAgIHJldHVybiBSZW5kZXJlZENhbWVyYUltcGw7XG59KCkpO1xudmFyIENhbWVyYUltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbWVyYUltcGwobWVkaWFTdHJlYW0pIHtcbiAgICAgICAgdGhpcy5tZWRpYVN0cmVhbSA9IG1lZGlhU3RyZWFtO1xuICAgIH1cbiAgICBDYW1lcmFJbXBsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIFJlbmRlcmVkQ2FtZXJhSW1wbC5jcmVhdGUocGFyZW50RWxlbWVudCwgdGhpcy5tZWRpYVN0cmVhbSwgb3B0aW9ucywgY2FsbGJhY2tzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYW1lcmFJbXBsLmNyZWF0ZSA9IGZ1bmN0aW9uICh2aWRlb0NvbnN0cmFpbnRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb25zdHJhaW50cywgbWVkaWFTdHJlYW07XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIm5hdmlnYXRvci5tZWRpYURldmljZXMgbm90IHN1cHBvcnRlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvOiB2aWRlb0NvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYVN0cmVhbSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbmV3IENhbWVyYUltcGwobWVkaWFTdHJlYW0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FtZXJhSW1wbDtcbn0oKSk7XG5leHBvcnQgeyBDYW1lcmFJbXBsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLWltcGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/camera/core-impl.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/camera/factories.js":
/*!***********************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/camera/factories.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraFactory: function() { return /* binding */ CameraFactory; }\n/* harmony export */ });\n/* harmony import */ var _core_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core-impl */ \"./node_modules/html5-qrcode/esm/camera/core-impl.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar CameraFactory = (function () {\n    function CameraFactory() {\n    }\n    CameraFactory.failIfNotSupported = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (!navigator.mediaDevices) {\n                    throw \"navigator.mediaDevices not supported\";\n                }\n                return [2, new CameraFactory()];\n            });\n        });\n    };\n    CameraFactory.prototype.create = function (videoConstraints) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2, _core_impl__WEBPACK_IMPORTED_MODULE_0__.CameraImpl.create(videoConstraints)];\n            });\n        });\n    };\n    return CameraFactory;\n}());\n\n//# sourceMappingURL=factories.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jYW1lcmEvZmFjdG9yaWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLFNBQUksSUFBSSxTQUFJO0FBQy9CLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtEQUFVO0FBQ3JDLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDd0I7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vY2FtZXJhL2ZhY3Rvcmllcy5qcz9mN2VlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmltcG9ydCB7IENhbWVyYUltcGwgfSBmcm9tIFwiLi9jb3JlLWltcGxcIjtcbnZhciBDYW1lcmFGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYW1lcmFGYWN0b3J5KCkge1xuICAgIH1cbiAgICBDYW1lcmFGYWN0b3J5LmZhaWxJZk5vdFN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIm5hdmlnYXRvci5tZWRpYURldmljZXMgbm90IHN1cHBvcnRlZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG5ldyBDYW1lcmFGYWN0b3J5KCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FtZXJhRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHZpZGVvQ29uc3RyYWludHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgQ2FtZXJhSW1wbC5jcmVhdGUodmlkZW9Db25zdHJhaW50cyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENhbWVyYUZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0IHsgQ2FtZXJhRmFjdG9yeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFjdG9yaWVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/camera/factories.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/camera/permissions.js":
/*!*************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/camera/permissions.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraPermissions: function() { return /* binding */ CameraPermissions; }\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar CameraPermissions = (function () {\n    function CameraPermissions() {\n    }\n    CameraPermissions.hasPermissions = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var devices, _i, devices_1, device;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4, navigator.mediaDevices.enumerateDevices()];\n                    case 1:\n                        devices = _a.sent();\n                        for (_i = 0, devices_1 = devices; _i < devices_1.length; _i++) {\n                            device = devices_1[_i];\n                            if (device.kind === \"videoinput\" && device.label) {\n                                return [2, true];\n                            }\n                        }\n                        return [2, false];\n                }\n            });\n        });\n    };\n    return CameraPermissions;\n}());\n\n//# sourceMappingURL=permissions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jYW1lcmEvcGVybWlzc2lvbnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQixTQUFJLElBQUksU0FBSTtBQUMvQixjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx1QkFBdUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQzRCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL2NhbWVyYS9wZXJtaXNzaW9ucy5qcz8zNWI2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBDYW1lcmFQZXJtaXNzaW9ucyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FtZXJhUGVybWlzc2lvbnMoKSB7XG4gICAgfVxuICAgIENhbWVyYVBlcm1pc3Npb25zLmhhc1Blcm1pc3Npb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGV2aWNlcywgX2ksIGRldmljZXNfMSwgZGV2aWNlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBkZXZpY2VzXzEgPSBkZXZpY2VzOyBfaSA8IGRldmljZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2UgPSBkZXZpY2VzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2Uua2luZCA9PT0gXCJ2aWRlb2lucHV0XCIgJiYgZGV2aWNlLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENhbWVyYVBlcm1pc3Npb25zO1xufSgpKTtcbmV4cG9ydCB7IENhbWVyYVBlcm1pc3Npb25zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJtaXNzaW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/camera/permissions.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/camera/retriever.js":
/*!***********************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/camera/retriever.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraRetriever: function() { return /* binding */ CameraRetriever; }\n/* harmony export */ });\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../strings */ \"./node_modules/html5-qrcode/esm/strings.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar CameraRetriever = (function () {\n    function CameraRetriever() {\n    }\n    CameraRetriever.retrieve = function () {\n        if (navigator.mediaDevices) {\n            return CameraRetriever.getCamerasFromMediaDevices();\n        }\n        var mst = MediaStreamTrack;\n        if (MediaStreamTrack && mst.getSources) {\n            return CameraRetriever.getCamerasFromMediaStreamTrack();\n        }\n        return CameraRetriever.rejectWithError();\n    };\n    CameraRetriever.rejectWithError = function () {\n        var errorMessage = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeStrings.unableToQuerySupportedDevices();\n        if (!CameraRetriever.isHttpsOrLocalhost()) {\n            errorMessage = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeStrings.insecureContextCameraQueryError();\n        }\n        return Promise.reject(errorMessage);\n    };\n    CameraRetriever.isHttpsOrLocalhost = function () {\n        if (location.protocol === \"https:\") {\n            return true;\n        }\n        var host = location.host.split(\":\")[0];\n        return host === \"127.0.0.1\" || host === \"localhost\";\n    };\n    CameraRetriever.getCamerasFromMediaDevices = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var closeActiveStreams, mediaStream, devices, results, _i, devices_1, device;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        closeActiveStreams = function (stream) {\n                            var tracks = stream.getVideoTracks();\n                            for (var _i = 0, tracks_1 = tracks; _i < tracks_1.length; _i++) {\n                                var track = tracks_1[_i];\n                                track.enabled = false;\n                                track.stop();\n                                stream.removeTrack(track);\n                            }\n                        };\n                        return [4, navigator.mediaDevices.getUserMedia({ audio: false, video: true })];\n                    case 1:\n                        mediaStream = _a.sent();\n                        return [4, navigator.mediaDevices.enumerateDevices()];\n                    case 2:\n                        devices = _a.sent();\n                        results = [];\n                        for (_i = 0, devices_1 = devices; _i < devices_1.length; _i++) {\n                            device = devices_1[_i];\n                            if (device.kind === \"videoinput\") {\n                                results.push({\n                                    id: device.deviceId,\n                                    label: device.label\n                                });\n                            }\n                        }\n                        closeActiveStreams(mediaStream);\n                        return [2, results];\n                }\n            });\n        });\n    };\n    CameraRetriever.getCamerasFromMediaStreamTrack = function () {\n        return new Promise(function (resolve, _) {\n            var callback = function (sourceInfos) {\n                var results = [];\n                for (var _i = 0, sourceInfos_1 = sourceInfos; _i < sourceInfos_1.length; _i++) {\n                    var sourceInfo = sourceInfos_1[_i];\n                    if (sourceInfo.kind === \"video\") {\n                        results.push({\n                            id: sourceInfo.id,\n                            label: sourceInfo.label\n                        });\n                    }\n                }\n                resolve(results);\n            };\n            var mst = MediaStreamTrack;\n            mst.getSources(callback);\n        });\n    };\n    return CameraRetriever;\n}());\n\n//# sourceMappingURL=retriever.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jYW1lcmEvcmV0cmlldmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLFNBQUksSUFBSSxTQUFJO0FBQy9CLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBa0I7QUFDN0M7QUFDQSwyQkFBMkIsd0RBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDJCQUEyQjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsdUJBQXVCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwyQkFBMkI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDMEI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vY2FtZXJhL3JldHJpZXZlci5qcz85ZWFiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmltcG9ydCB7IEh0bWw1UXJjb2RlU3RyaW5ncyB9IGZyb20gXCIuLi9zdHJpbmdzXCI7XG52YXIgQ2FtZXJhUmV0cmlldmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYW1lcmFSZXRyaWV2ZXIoKSB7XG4gICAgfVxuICAgIENhbWVyYVJldHJpZXZlci5yZXRyaWV2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBDYW1lcmFSZXRyaWV2ZXIuZ2V0Q2FtZXJhc0Zyb21NZWRpYURldmljZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbXN0ID0gTWVkaWFTdHJlYW1UcmFjaztcbiAgICAgICAgaWYgKE1lZGlhU3RyZWFtVHJhY2sgJiYgbXN0LmdldFNvdXJjZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBDYW1lcmFSZXRyaWV2ZXIuZ2V0Q2FtZXJhc0Zyb21NZWRpYVN0cmVhbVRyYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhbWVyYVJldHJpZXZlci5yZWplY3RXaXRoRXJyb3IoKTtcbiAgICB9O1xuICAgIENhbWVyYVJldHJpZXZlci5yZWplY3RXaXRoRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBIdG1sNVFyY29kZVN0cmluZ3MudW5hYmxlVG9RdWVyeVN1cHBvcnRlZERldmljZXMoKTtcbiAgICAgICAgaWYgKCFDYW1lcmFSZXRyaWV2ZXIuaXNIdHRwc09yTG9jYWxob3N0KCkpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IEh0bWw1UXJjb2RlU3RyaW5ncy5pbnNlY3VyZUNvbnRleHRDYW1lcmFRdWVyeUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yTWVzc2FnZSk7XG4gICAgfTtcbiAgICBDYW1lcmFSZXRyaWV2ZXIuaXNIdHRwc09yTG9jYWxob3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobG9jYXRpb24ucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob3N0ID0gbG9jYXRpb24uaG9zdC5zcGxpdChcIjpcIilbMF07XG4gICAgICAgIHJldHVybiBob3N0ID09PSBcIjEyNy4wLjAuMVwiIHx8IGhvc3QgPT09IFwibG9jYWxob3N0XCI7XG4gICAgfTtcbiAgICBDYW1lcmFSZXRyaWV2ZXIuZ2V0Q2FtZXJhc0Zyb21NZWRpYURldmljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjbG9zZUFjdGl2ZVN0cmVhbXMsIG1lZGlhU3RyZWFtLCBkZXZpY2VzLCByZXN1bHRzLCBfaSwgZGV2aWNlc18xLCBkZXZpY2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUFjdGl2ZVN0cmVhbXMgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrcyA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgdHJhY2tzXzEgPSB0cmFja3M7IF9pIDwgdHJhY2tzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IHRyYWNrc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyBhdWRpbzogZmFsc2UsIHZpZGVvOiB0cnVlIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFTdHJlYW0gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBkZXZpY2VzXzEgPSBkZXZpY2VzOyBfaSA8IGRldmljZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2UgPSBkZXZpY2VzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2Uua2luZCA9PT0gXCJ2aWRlb2lucHV0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBkZXZpY2UuZGV2aWNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZGV2aWNlLmxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlQWN0aXZlU3RyZWFtcyhtZWRpYVN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc3VsdHNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbWVyYVJldHJpZXZlci5nZXRDYW1lcmFzRnJvbU1lZGlhU3RyZWFtVHJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgXykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKHNvdXJjZUluZm9zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNvdXJjZUluZm9zXzEgPSBzb3VyY2VJbmZvczsgX2kgPCBzb3VyY2VJbmZvc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlSW5mbyA9IHNvdXJjZUluZm9zXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlSW5mby5raW5kID09PSBcInZpZGVvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNvdXJjZUluZm8uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHNvdXJjZUluZm8ubGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG1zdCA9IE1lZGlhU3RyZWFtVHJhY2s7XG4gICAgICAgICAgICBtc3QuZ2V0U291cmNlcyhjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENhbWVyYVJldHJpZXZlcjtcbn0oKSk7XG5leHBvcnQgeyBDYW1lcmFSZXRyaWV2ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJpZXZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/camera/retriever.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/code-decoder.js":
/*!*******************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/code-decoder.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5QrcodeShim: function() { return /* binding */ Html5QrcodeShim; }\n/* harmony export */ });\n/* harmony import */ var _zxing_html5_qrcode_decoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zxing-html5-qrcode-decoder */ \"./node_modules/html5-qrcode/esm/zxing-html5-qrcode-decoder.js\");\n/* harmony import */ var _native_bar_code_detector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./native-bar-code-detector */ \"./node_modules/html5-qrcode/esm/native-bar-code-detector.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\nvar Html5QrcodeShim = (function () {\n    function Html5QrcodeShim(requestedFormats, useBarCodeDetectorIfSupported, verbose, logger) {\n        this.EXECUTIONS_TO_REPORT_PERFORMANCE = 100;\n        this.executions = 0;\n        this.executionResults = [];\n        this.wasPrimaryDecoderUsedInLastDecode = false;\n        this.verbose = verbose;\n        if (useBarCodeDetectorIfSupported\n            && _native_bar_code_detector__WEBPACK_IMPORTED_MODULE_1__.BarcodeDetectorDelegate.isSupported()) {\n            this.primaryDecoder = new _native_bar_code_detector__WEBPACK_IMPORTED_MODULE_1__.BarcodeDetectorDelegate(requestedFormats, verbose, logger);\n            this.secondaryDecoder = new _zxing_html5_qrcode_decoder__WEBPACK_IMPORTED_MODULE_0__.ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger);\n        }\n        else {\n            this.primaryDecoder = new _zxing_html5_qrcode_decoder__WEBPACK_IMPORTED_MODULE_0__.ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger);\n        }\n    }\n    Html5QrcodeShim.prototype.decodeAsync = function (canvas) {\n        return __awaiter(this, void 0, void 0, function () {\n            var startTime;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        startTime = performance.now();\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, , 3, 4]);\n                        return [4, this.getDecoder().decodeAsync(canvas)];\n                    case 2: return [2, _a.sent()];\n                    case 3:\n                        this.possiblyLogPerformance(startTime);\n                        return [7];\n                    case 4: return [2];\n                }\n            });\n        });\n    };\n    Html5QrcodeShim.prototype.decodeRobustlyAsync = function (canvas) {\n        return __awaiter(this, void 0, void 0, function () {\n            var startTime, error_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        startTime = performance.now();\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, 4, 5]);\n                        return [4, this.primaryDecoder.decodeAsync(canvas)];\n                    case 2: return [2, _a.sent()];\n                    case 3:\n                        error_1 = _a.sent();\n                        if (this.secondaryDecoder) {\n                            return [2, this.secondaryDecoder.decodeAsync(canvas)];\n                        }\n                        throw error_1;\n                    case 4:\n                        this.possiblyLogPerformance(startTime);\n                        return [7];\n                    case 5: return [2];\n                }\n            });\n        });\n    };\n    Html5QrcodeShim.prototype.getDecoder = function () {\n        if (!this.secondaryDecoder) {\n            return this.primaryDecoder;\n        }\n        if (this.wasPrimaryDecoderUsedInLastDecode === false) {\n            this.wasPrimaryDecoderUsedInLastDecode = true;\n            return this.primaryDecoder;\n        }\n        this.wasPrimaryDecoderUsedInLastDecode = false;\n        return this.secondaryDecoder;\n    };\n    Html5QrcodeShim.prototype.possiblyLogPerformance = function (startTime) {\n        if (!this.verbose) {\n            return;\n        }\n        var executionTime = performance.now() - startTime;\n        this.executionResults.push(executionTime);\n        this.executions++;\n        this.possiblyFlushPerformanceReport();\n    };\n    Html5QrcodeShim.prototype.possiblyFlushPerformanceReport = function () {\n        if (this.executions < this.EXECUTIONS_TO_REPORT_PERFORMANCE) {\n            return;\n        }\n        var sum = 0;\n        for (var _i = 0, _a = this.executionResults; _i < _a.length; _i++) {\n            var executionTime = _a[_i];\n            sum += executionTime;\n        }\n        var mean = sum / this.executionResults.length;\n        console.log(\"\".concat(mean, \" ms for \").concat(this.executionResults.length, \" last runs.\"));\n        this.executions = 0;\n        this.executionResults = [];\n    };\n    return Html5QrcodeShim;\n}());\n\n//# sourceMappingURL=code-decoder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jb2RlLWRlY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLFNBQUksSUFBSSxTQUFJO0FBQy9CLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDdUU7QUFDRjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4RUFBdUI7QUFDdEMsc0NBQXNDLDhFQUF1QjtBQUM3RCx3Q0FBd0MsZ0ZBQXVCO0FBQy9EO0FBQ0E7QUFDQSxzQ0FBc0MsZ0ZBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDMEI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vY29kZS1kZWNvZGVyLmpzPzIwYTYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuaW1wb3J0IHsgWlhpbmdIdG1sNVFyY29kZURlY29kZXIgfSBmcm9tIFwiLi96eGluZy1odG1sNS1xcmNvZGUtZGVjb2RlclwiO1xuaW1wb3J0IHsgQmFyY29kZURldGVjdG9yRGVsZWdhdGUgfSBmcm9tIFwiLi9uYXRpdmUtYmFyLWNvZGUtZGV0ZWN0b3JcIjtcbnZhciBIdG1sNVFyY29kZVNoaW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWw1UXJjb2RlU2hpbShyZXF1ZXN0ZWRGb3JtYXRzLCB1c2VCYXJDb2RlRGV0ZWN0b3JJZlN1cHBvcnRlZCwgdmVyYm9zZSwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuRVhFQ1VUSU9OU19UT19SRVBPUlRfUEVSRk9STUFOQ0UgPSAxMDA7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9ucyA9IDA7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uUmVzdWx0cyA9IFtdO1xuICAgICAgICB0aGlzLndhc1ByaW1hcnlEZWNvZGVyVXNlZEluTGFzdERlY29kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZlcmJvc2UgPSB2ZXJib3NlO1xuICAgICAgICBpZiAodXNlQmFyQ29kZURldGVjdG9ySWZTdXBwb3J0ZWRcbiAgICAgICAgICAgICYmIEJhcmNvZGVEZXRlY3RvckRlbGVnYXRlLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbWFyeURlY29kZXIgPSBuZXcgQmFyY29kZURldGVjdG9yRGVsZWdhdGUocmVxdWVzdGVkRm9ybWF0cywgdmVyYm9zZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5RGVjb2RlciA9IG5ldyBaWGluZ0h0bWw1UXJjb2RlRGVjb2RlcihyZXF1ZXN0ZWRGb3JtYXRzLCB2ZXJib3NlLCBsb2dnZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcmltYXJ5RGVjb2RlciA9IG5ldyBaWGluZ0h0bWw1UXJjb2RlRGVjb2RlcihyZXF1ZXN0ZWRGb3JtYXRzLCB2ZXJib3NlLCBsb2dnZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEh0bWw1UXJjb2RlU2hpbS5wcm90b3R5cGUuZGVjb2RlQXN5bmMgPSBmdW5jdGlvbiAoY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFRpbWU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAsIDMsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5nZXREZWNvZGVyKCkuZGVjb2RlQXN5bmMoY2FudmFzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc3NpYmx5TG9nUGVyZm9ybWFuY2Uoc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbN107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNoaW0ucHJvdG90eXBlLmRlY29kZVJvYnVzdGx5QXN5bmMgPSBmdW5jdGlvbiAoY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFRpbWUsIGVycm9yXzE7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCA0LCA1XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMucHJpbWFyeURlY29kZXIuZGVjb2RlQXN5bmMoY2FudmFzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5RGVjb2Rlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5zZWNvbmRhcnlEZWNvZGVyLmRlY29kZUFzeW5jKGNhbnZhcyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JfMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NzaWJseUxvZ1BlcmZvcm1hbmNlKHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzddO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTaGltLnByb3RvdHlwZS5nZXREZWNvZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2Vjb25kYXJ5RGVjb2Rlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpbWFyeURlY29kZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2FzUHJpbWFyeURlY29kZXJVc2VkSW5MYXN0RGVjb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy53YXNQcmltYXJ5RGVjb2RlclVzZWRJbkxhc3REZWNvZGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpbWFyeURlY29kZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXNQcmltYXJ5RGVjb2RlclVzZWRJbkxhc3REZWNvZGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kYXJ5RGVjb2RlcjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2hpbS5wcm90b3R5cGUucG9zc2libHlMb2dQZXJmb3JtYW5jZSA9IGZ1bmN0aW9uIChzdGFydFRpbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhlY3V0aW9uVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLmV4ZWN1dGlvblJlc3VsdHMucHVzaChleGVjdXRpb25UaW1lKTtcbiAgICAgICAgdGhpcy5leGVjdXRpb25zKys7XG4gICAgICAgIHRoaXMucG9zc2libHlGbHVzaFBlcmZvcm1hbmNlUmVwb3J0KCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNoaW0ucHJvdG90eXBlLnBvc3NpYmx5Rmx1c2hQZXJmb3JtYW5jZVJlcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9ucyA8IHRoaXMuRVhFQ1VUSU9OU19UT19SRVBPUlRfUEVSRk9STUFOQ0UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZXhlY3V0aW9uUmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBleGVjdXRpb25UaW1lID0gX2FbX2ldO1xuICAgICAgICAgICAgc3VtICs9IGV4ZWN1dGlvblRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lYW4gPSBzdW0gLyB0aGlzLmV4ZWN1dGlvblJlc3VsdHMubGVuZ3RoO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlwiLmNvbmNhdChtZWFuLCBcIiBtcyBmb3IgXCIpLmNvbmNhdCh0aGlzLmV4ZWN1dGlvblJlc3VsdHMubGVuZ3RoLCBcIiBsYXN0IHJ1bnMuXCIpKTtcbiAgICAgICAgdGhpcy5leGVjdXRpb25zID0gMDtcbiAgICAgICAgdGhpcy5leGVjdXRpb25SZXN1bHRzID0gW107XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbDVRcmNvZGVTaGltO1xufSgpKTtcbmV4cG9ydCB7IEh0bWw1UXJjb2RlU2hpbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZS1kZWNvZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/code-decoder.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/core.js":
/*!***********************************************!*\
  !*** ./node_modules/html5-qrcode/esm/core.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseLoggger: function() { return /* binding */ BaseLoggger; },\n/* harmony export */   DecodedTextType: function() { return /* binding */ DecodedTextType; },\n/* harmony export */   Html5QrcodeConstants: function() { return /* binding */ Html5QrcodeConstants; },\n/* harmony export */   Html5QrcodeErrorFactory: function() { return /* binding */ Html5QrcodeErrorFactory; },\n/* harmony export */   Html5QrcodeErrorTypes: function() { return /* binding */ Html5QrcodeErrorTypes; },\n/* harmony export */   Html5QrcodeResultFactory: function() { return /* binding */ Html5QrcodeResultFactory; },\n/* harmony export */   Html5QrcodeScanType: function() { return /* binding */ Html5QrcodeScanType; },\n/* harmony export */   Html5QrcodeSupportedFormats: function() { return /* binding */ Html5QrcodeSupportedFormats; },\n/* harmony export */   QrcodeResultFormat: function() { return /* binding */ QrcodeResultFormat; },\n/* harmony export */   clip: function() { return /* binding */ clip; },\n/* harmony export */   isNullOrUndefined: function() { return /* binding */ isNullOrUndefined; },\n/* harmony export */   isValidHtml5QrcodeSupportedFormats: function() { return /* binding */ isValidHtml5QrcodeSupportedFormats; }\n/* harmony export */ });\nvar Html5QrcodeSupportedFormats;\n(function (Html5QrcodeSupportedFormats) {\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"QR_CODE\"] = 0] = \"QR_CODE\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"AZTEC\"] = 1] = \"AZTEC\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"CODABAR\"] = 2] = \"CODABAR\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"CODE_39\"] = 3] = \"CODE_39\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"CODE_93\"] = 4] = \"CODE_93\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"CODE_128\"] = 5] = \"CODE_128\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"DATA_MATRIX\"] = 6] = \"DATA_MATRIX\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"MAXICODE\"] = 7] = \"MAXICODE\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"ITF\"] = 8] = \"ITF\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"EAN_13\"] = 9] = \"EAN_13\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"EAN_8\"] = 10] = \"EAN_8\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"PDF_417\"] = 11] = \"PDF_417\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"RSS_14\"] = 12] = \"RSS_14\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"RSS_EXPANDED\"] = 13] = \"RSS_EXPANDED\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"UPC_A\"] = 14] = \"UPC_A\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"UPC_E\"] = 15] = \"UPC_E\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"UPC_EAN_EXTENSION\"] = 16] = \"UPC_EAN_EXTENSION\";\n})(Html5QrcodeSupportedFormats || (Html5QrcodeSupportedFormats = {}));\nvar html5QrcodeSupportedFormatsTextMap = new Map([\n    [Html5QrcodeSupportedFormats.QR_CODE, \"QR_CODE\"],\n    [Html5QrcodeSupportedFormats.AZTEC, \"AZTEC\"],\n    [Html5QrcodeSupportedFormats.CODABAR, \"CODABAR\"],\n    [Html5QrcodeSupportedFormats.CODE_39, \"CODE_39\"],\n    [Html5QrcodeSupportedFormats.CODE_93, \"CODE_93\"],\n    [Html5QrcodeSupportedFormats.CODE_128, \"CODE_128\"],\n    [Html5QrcodeSupportedFormats.DATA_MATRIX, \"DATA_MATRIX\"],\n    [Html5QrcodeSupportedFormats.MAXICODE, \"MAXICODE\"],\n    [Html5QrcodeSupportedFormats.ITF, \"ITF\"],\n    [Html5QrcodeSupportedFormats.EAN_13, \"EAN_13\"],\n    [Html5QrcodeSupportedFormats.EAN_8, \"EAN_8\"],\n    [Html5QrcodeSupportedFormats.PDF_417, \"PDF_417\"],\n    [Html5QrcodeSupportedFormats.RSS_14, \"RSS_14\"],\n    [Html5QrcodeSupportedFormats.RSS_EXPANDED, \"RSS_EXPANDED\"],\n    [Html5QrcodeSupportedFormats.UPC_A, \"UPC_A\"],\n    [Html5QrcodeSupportedFormats.UPC_E, \"UPC_E\"],\n    [Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION, \"UPC_EAN_EXTENSION\"]\n]);\nvar DecodedTextType;\n(function (DecodedTextType) {\n    DecodedTextType[DecodedTextType[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    DecodedTextType[DecodedTextType[\"URL\"] = 1] = \"URL\";\n})(DecodedTextType || (DecodedTextType = {}));\nfunction isValidHtml5QrcodeSupportedFormats(format) {\n    return Object.values(Html5QrcodeSupportedFormats).includes(format);\n}\nvar Html5QrcodeScanType;\n(function (Html5QrcodeScanType) {\n    Html5QrcodeScanType[Html5QrcodeScanType[\"SCAN_TYPE_CAMERA\"] = 0] = \"SCAN_TYPE_CAMERA\";\n    Html5QrcodeScanType[Html5QrcodeScanType[\"SCAN_TYPE_FILE\"] = 1] = \"SCAN_TYPE_FILE\";\n})(Html5QrcodeScanType || (Html5QrcodeScanType = {}));\nvar Html5QrcodeConstants = (function () {\n    function Html5QrcodeConstants() {\n    }\n    Html5QrcodeConstants.GITHUB_PROJECT_URL = \"https://github.com/mebjas/html5-qrcode\";\n    Html5QrcodeConstants.SCAN_DEFAULT_FPS = 2;\n    Html5QrcodeConstants.DEFAULT_DISABLE_FLIP = false;\n    Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED = true;\n    Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE = [\n        Html5QrcodeScanType.SCAN_TYPE_CAMERA,\n        Html5QrcodeScanType.SCAN_TYPE_FILE\n    ];\n    return Html5QrcodeConstants;\n}());\n\nvar QrcodeResultFormat = (function () {\n    function QrcodeResultFormat(format, formatName) {\n        this.format = format;\n        this.formatName = formatName;\n    }\n    QrcodeResultFormat.prototype.toString = function () {\n        return this.formatName;\n    };\n    QrcodeResultFormat.create = function (format) {\n        if (!html5QrcodeSupportedFormatsTextMap.has(format)) {\n            throw \"\".concat(format, \" not in html5QrcodeSupportedFormatsTextMap\");\n        }\n        return new QrcodeResultFormat(format, html5QrcodeSupportedFormatsTextMap.get(format));\n    };\n    return QrcodeResultFormat;\n}());\n\nvar Html5QrcodeResultFactory = (function () {\n    function Html5QrcodeResultFactory() {\n    }\n    Html5QrcodeResultFactory.createFromText = function (decodedText) {\n        var qrcodeResult = {\n            text: decodedText\n        };\n        return {\n            decodedText: decodedText,\n            result: qrcodeResult\n        };\n    };\n    Html5QrcodeResultFactory.createFromQrcodeResult = function (qrcodeResult) {\n        return {\n            decodedText: qrcodeResult.text,\n            result: qrcodeResult\n        };\n    };\n    return Html5QrcodeResultFactory;\n}());\n\nvar Html5QrcodeErrorTypes;\n(function (Html5QrcodeErrorTypes) {\n    Html5QrcodeErrorTypes[Html5QrcodeErrorTypes[\"UNKWOWN_ERROR\"] = 0] = \"UNKWOWN_ERROR\";\n    Html5QrcodeErrorTypes[Html5QrcodeErrorTypes[\"IMPLEMENTATION_ERROR\"] = 1] = \"IMPLEMENTATION_ERROR\";\n    Html5QrcodeErrorTypes[Html5QrcodeErrorTypes[\"NO_CODE_FOUND_ERROR\"] = 2] = \"NO_CODE_FOUND_ERROR\";\n})(Html5QrcodeErrorTypes || (Html5QrcodeErrorTypes = {}));\nvar Html5QrcodeErrorFactory = (function () {\n    function Html5QrcodeErrorFactory() {\n    }\n    Html5QrcodeErrorFactory.createFrom = function (error) {\n        return {\n            errorMessage: error,\n            type: Html5QrcodeErrorTypes.UNKWOWN_ERROR\n        };\n    };\n    return Html5QrcodeErrorFactory;\n}());\n\nvar BaseLoggger = (function () {\n    function BaseLoggger(verbose) {\n        this.verbose = verbose;\n    }\n    BaseLoggger.prototype.log = function (message) {\n        if (this.verbose) {\n            console.log(message);\n        }\n    };\n    BaseLoggger.prototype.warn = function (message) {\n        if (this.verbose) {\n            console.warn(message);\n        }\n    };\n    BaseLoggger.prototype.logError = function (message, isExperimental) {\n        if (this.verbose || isExperimental === true) {\n            console.error(message);\n        }\n    };\n    BaseLoggger.prototype.logErrors = function (errors) {\n        if (errors.length === 0) {\n            throw \"Logger#logError called without arguments\";\n        }\n        if (this.verbose) {\n            console.error(errors);\n        }\n    };\n    return BaseLoggger;\n}());\n\nfunction isNullOrUndefined(obj) {\n    return (typeof obj === \"undefined\") || obj === null;\n}\nfunction clip(value, minValue, maxValue) {\n    if (value > maxValue) {\n        return maxValue;\n    }\n    if (value < minValue) {\n        return minValue;\n    }\n    return value;\n}\n//# sourceMappingURL=core.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jb3JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrRUFBa0U7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQ3BDO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Q7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzZCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNtQztBQUM3QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ2tDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNzQjtBQUNoQjtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jb3JlLmpzP2VhMzQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHM7XG4oZnVuY3Rpb24gKEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cykge1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJRUl9DT0RFXCJdID0gMF0gPSBcIlFSX0NPREVcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiQVpURUNcIl0gPSAxXSA9IFwiQVpURUNcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiQ09EQUJBUlwiXSA9IDJdID0gXCJDT0RBQkFSXCI7XG4gICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tcIkNPREVfMzlcIl0gPSAzXSA9IFwiQ09ERV8zOVwiO1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJDT0RFXzkzXCJdID0gNF0gPSBcIkNPREVfOTNcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiQ09ERV8xMjhcIl0gPSA1XSA9IFwiQ09ERV8xMjhcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiREFUQV9NQVRSSVhcIl0gPSA2XSA9IFwiREFUQV9NQVRSSVhcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiTUFYSUNPREVcIl0gPSA3XSA9IFwiTUFYSUNPREVcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiSVRGXCJdID0gOF0gPSBcIklURlwiO1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJFQU5fMTNcIl0gPSA5XSA9IFwiRUFOXzEzXCI7XG4gICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tcIkVBTl84XCJdID0gMTBdID0gXCJFQU5fOFwiO1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJQREZfNDE3XCJdID0gMTFdID0gXCJQREZfNDE3XCI7XG4gICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tcIlJTU18xNFwiXSA9IDEyXSA9IFwiUlNTXzE0XCI7XG4gICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tcIlJTU19FWFBBTkRFRFwiXSA9IDEzXSA9IFwiUlNTX0VYUEFOREVEXCI7XG4gICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tcIlVQQ19BXCJdID0gMTRdID0gXCJVUENfQVwiO1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJVUENfRVwiXSA9IDE1XSA9IFwiVVBDX0VcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiVVBDX0VBTl9FWFRFTlNJT05cIl0gPSAxNl0gPSBcIlVQQ19FQU5fRVhURU5TSU9OXCI7XG59KShIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMgfHwgKEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cyA9IHt9KSk7XG52YXIgaHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzVGV4dE1hcCA9IG5ldyBNYXAoW1xuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUVJfQ09ERSwgXCJRUl9DT0RFXCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuQVpURUMsIFwiQVpURUNcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5DT0RBQkFSLCBcIkNPREFCQVJcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5DT0RFXzM5LCBcIkNPREVfMzlcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5DT0RFXzkzLCBcIkNPREVfOTNcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5DT0RFXzEyOCwgXCJDT0RFXzEyOFwiXSxcbiAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkRBVEFfTUFUUklYLCBcIkRBVEFfTUFUUklYXCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuTUFYSUNPREUsIFwiTUFYSUNPREVcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5JVEYsIFwiSVRGXCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuRUFOXzEzLCBcIkVBTl8xM1wiXSxcbiAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkVBTl84LCBcIkVBTl84XCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUERGXzQxNywgXCJQREZfNDE3XCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUlNTXzE0LCBcIlJTU18xNFwiXSxcbiAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlJTU19FWFBBTkRFRCwgXCJSU1NfRVhQQU5ERURcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5VUENfQSwgXCJVUENfQVwiXSxcbiAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19FLCBcIlVQQ19FXCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuVVBDX0VBTl9FWFRFTlNJT04sIFwiVVBDX0VBTl9FWFRFTlNJT05cIl1cbl0pO1xuZXhwb3J0IHZhciBEZWNvZGVkVGV4dFR5cGU7XG4oZnVuY3Rpb24gKERlY29kZWRUZXh0VHlwZSkge1xuICAgIERlY29kZWRUZXh0VHlwZVtEZWNvZGVkVGV4dFR5cGVbXCJVTktOT1dOXCJdID0gMF0gPSBcIlVOS05PV05cIjtcbiAgICBEZWNvZGVkVGV4dFR5cGVbRGVjb2RlZFRleHRUeXBlW1wiVVJMXCJdID0gMV0gPSBcIlVSTFwiO1xufSkoRGVjb2RlZFRleHRUeXBlIHx8IChEZWNvZGVkVGV4dFR5cGUgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMoZm9ybWF0KSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzKS5pbmNsdWRlcyhmb3JtYXQpO1xufVxuZXhwb3J0IHZhciBIdG1sNVFyY29kZVNjYW5UeXBlO1xuKGZ1bmN0aW9uIChIdG1sNVFyY29kZVNjYW5UeXBlKSB7XG4gICAgSHRtbDVRcmNvZGVTY2FuVHlwZVtIdG1sNVFyY29kZVNjYW5UeXBlW1wiU0NBTl9UWVBFX0NBTUVSQVwiXSA9IDBdID0gXCJTQ0FOX1RZUEVfQ0FNRVJBXCI7XG4gICAgSHRtbDVRcmNvZGVTY2FuVHlwZVtIdG1sNVFyY29kZVNjYW5UeXBlW1wiU0NBTl9UWVBFX0ZJTEVcIl0gPSAxXSA9IFwiU0NBTl9UWVBFX0ZJTEVcIjtcbn0pKEh0bWw1UXJjb2RlU2NhblR5cGUgfHwgKEh0bWw1UXJjb2RlU2NhblR5cGUgPSB7fSkpO1xudmFyIEh0bWw1UXJjb2RlQ29uc3RhbnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNVFyY29kZUNvbnN0YW50cygpIHtcbiAgICB9XG4gICAgSHRtbDVRcmNvZGVDb25zdGFudHMuR0lUSFVCX1BST0pFQ1RfVVJMID0gXCJodHRwczovL2dpdGh1Yi5jb20vbWViamFzL2h0bWw1LXFyY29kZVwiO1xuICAgIEh0bWw1UXJjb2RlQ29uc3RhbnRzLlNDQU5fREVGQVVMVF9GUFMgPSAyO1xuICAgIEh0bWw1UXJjb2RlQ29uc3RhbnRzLkRFRkFVTFRfRElTQUJMRV9GTElQID0gZmFsc2U7XG4gICAgSHRtbDVRcmNvZGVDb25zdGFudHMuREVGQVVMVF9SRU1FTUJFUl9MQVNUX0NBTUVSQV9VU0VEID0gdHJ1ZTtcbiAgICBIdG1sNVFyY29kZUNvbnN0YW50cy5ERUZBVUxUX1NVUFBPUlRFRF9TQ0FOX1RZUEUgPSBbXG4gICAgICAgIEh0bWw1UXJjb2RlU2NhblR5cGUuU0NBTl9UWVBFX0NBTUVSQSxcbiAgICAgICAgSHRtbDVRcmNvZGVTY2FuVHlwZS5TQ0FOX1RZUEVfRklMRVxuICAgIF07XG4gICAgcmV0dXJuIEh0bWw1UXJjb2RlQ29uc3RhbnRzO1xufSgpKTtcbmV4cG9ydCB7IEh0bWw1UXJjb2RlQ29uc3RhbnRzIH07XG52YXIgUXJjb2RlUmVzdWx0Rm9ybWF0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRcmNvZGVSZXN1bHRGb3JtYXQoZm9ybWF0LCBmb3JtYXROYW1lKSB7XG4gICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICB0aGlzLmZvcm1hdE5hbWUgPSBmb3JtYXROYW1lO1xuICAgIH1cbiAgICBRcmNvZGVSZXN1bHRGb3JtYXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXROYW1lO1xuICAgIH07XG4gICAgUXJjb2RlUmVzdWx0Rm9ybWF0LmNyZWF0ZSA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFodG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNUZXh0TWFwLmhhcyhmb3JtYXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlwiLmNvbmNhdChmb3JtYXQsIFwiIG5vdCBpbiBodG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNUZXh0TWFwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUXJjb2RlUmVzdWx0Rm9ybWF0KGZvcm1hdCwgaHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzVGV4dE1hcC5nZXQoZm9ybWF0KSk7XG4gICAgfTtcbiAgICByZXR1cm4gUXJjb2RlUmVzdWx0Rm9ybWF0O1xufSgpKTtcbmV4cG9ydCB7IFFyY29kZVJlc3VsdEZvcm1hdCB9O1xudmFyIEh0bWw1UXJjb2RlUmVzdWx0RmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHRtbDVRcmNvZGVSZXN1bHRGYWN0b3J5KCkge1xuICAgIH1cbiAgICBIdG1sNVFyY29kZVJlc3VsdEZhY3RvcnkuY3JlYXRlRnJvbVRleHQgPSBmdW5jdGlvbiAoZGVjb2RlZFRleHQpIHtcbiAgICAgICAgdmFyIHFyY29kZVJlc3VsdCA9IHtcbiAgICAgICAgICAgIHRleHQ6IGRlY29kZWRUZXh0XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWNvZGVkVGV4dDogZGVjb2RlZFRleHQsXG4gICAgICAgICAgICByZXN1bHQ6IHFyY29kZVJlc3VsdFxuICAgICAgICB9O1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVSZXN1bHRGYWN0b3J5LmNyZWF0ZUZyb21RcmNvZGVSZXN1bHQgPSBmdW5jdGlvbiAocXJjb2RlUmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWNvZGVkVGV4dDogcXJjb2RlUmVzdWx0LnRleHQsXG4gICAgICAgICAgICByZXN1bHQ6IHFyY29kZVJlc3VsdFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWw1UXJjb2RlUmVzdWx0RmFjdG9yeTtcbn0oKSk7XG5leHBvcnQgeyBIdG1sNVFyY29kZVJlc3VsdEZhY3RvcnkgfTtcbmV4cG9ydCB2YXIgSHRtbDVRcmNvZGVFcnJvclR5cGVzO1xuKGZ1bmN0aW9uIChIdG1sNVFyY29kZUVycm9yVHlwZXMpIHtcbiAgICBIdG1sNVFyY29kZUVycm9yVHlwZXNbSHRtbDVRcmNvZGVFcnJvclR5cGVzW1wiVU5LV09XTl9FUlJPUlwiXSA9IDBdID0gXCJVTktXT1dOX0VSUk9SXCI7XG4gICAgSHRtbDVRcmNvZGVFcnJvclR5cGVzW0h0bWw1UXJjb2RlRXJyb3JUeXBlc1tcIklNUExFTUVOVEFUSU9OX0VSUk9SXCJdID0gMV0gPSBcIklNUExFTUVOVEFUSU9OX0VSUk9SXCI7XG4gICAgSHRtbDVRcmNvZGVFcnJvclR5cGVzW0h0bWw1UXJjb2RlRXJyb3JUeXBlc1tcIk5PX0NPREVfRk9VTkRfRVJST1JcIl0gPSAyXSA9IFwiTk9fQ09ERV9GT1VORF9FUlJPUlwiO1xufSkoSHRtbDVRcmNvZGVFcnJvclR5cGVzIHx8IChIdG1sNVFyY29kZUVycm9yVHlwZXMgPSB7fSkpO1xudmFyIEh0bWw1UXJjb2RlRXJyb3JGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNVFyY29kZUVycm9yRmFjdG9yeSgpIHtcbiAgICB9XG4gICAgSHRtbDVRcmNvZGVFcnJvckZhY3RvcnkuY3JlYXRlRnJvbSA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBlcnJvcixcbiAgICAgICAgICAgIHR5cGU6IEh0bWw1UXJjb2RlRXJyb3JUeXBlcy5VTktXT1dOX0VSUk9SXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbDVRcmNvZGVFcnJvckZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0IHsgSHRtbDVRcmNvZGVFcnJvckZhY3RvcnkgfTtcbnZhciBCYXNlTG9nZ2dlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZUxvZ2dnZXIodmVyYm9zZSkge1xuICAgICAgICB0aGlzLnZlcmJvc2UgPSB2ZXJib3NlO1xuICAgIH1cbiAgICBCYXNlTG9nZ2dlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJhc2VMb2dnZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCYXNlTG9nZ2dlci5wcm90b3R5cGUubG9nRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgaXNFeHBlcmltZW50YWwpIHtcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZSB8fCBpc0V4cGVyaW1lbnRhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFzZUxvZ2dnZXIucHJvdG90eXBlLmxvZ0Vycm9ycyA9IGZ1bmN0aW9uIChlcnJvcnMpIHtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IFwiTG9nZ2VyI2xvZ0Vycm9yIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50c1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJhc2VMb2dnZ2VyO1xufSgpKTtcbmV4cG9ydCB7IEJhc2VMb2dnZ2VyIH07XG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiKSB8fCBvYmogPT09IG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gY2xpcCh2YWx1ZSwgbWluVmFsdWUsIG1heFZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1heFZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCBtaW5WYWx1ZSkge1xuICAgICAgICByZXR1cm4gbWluVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/core.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/html5-qrcode-scanner.js":
/*!***************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/html5-qrcode-scanner.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5QrcodeScanner: function() { return /* binding */ Html5QrcodeScanner; }\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"./node_modules/html5-qrcode/esm/core.js\");\n/* harmony import */ var _html5_qrcode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./html5-qrcode */ \"./node_modules/html5-qrcode/esm/html5-qrcode.js\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./strings */ \"./node_modules/html5-qrcode/esm/strings.js\");\n/* harmony import */ var _image_assets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./image-assets */ \"./node_modules/html5-qrcode/esm/image-assets.js\");\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./storage */ \"./node_modules/html5-qrcode/esm/storage.js\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ui */ \"./node_modules/html5-qrcode/esm/ui.js\");\n/* harmony import */ var _camera_permissions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./camera/permissions */ \"./node_modules/html5-qrcode/esm/camera/permissions.js\");\n/* harmony import */ var _ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ui/scanner/scan-type-selector */ \"./node_modules/html5-qrcode/esm/ui/scanner/scan-type-selector.js\");\n/* harmony import */ var _ui_scanner_torch_button__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ui/scanner/torch-button */ \"./node_modules/html5-qrcode/esm/ui/scanner/torch-button.js\");\n/* harmony import */ var _ui_scanner_file_selection_ui__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ui/scanner/file-selection-ui */ \"./node_modules/html5-qrcode/esm/ui/scanner/file-selection-ui.js\");\n/* harmony import */ var _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ui/scanner/base */ \"./node_modules/html5-qrcode/esm/ui/scanner/base.js\");\n/* harmony import */ var _ui_scanner_camera_selection_ui__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ui/scanner/camera-selection-ui */ \"./node_modules/html5-qrcode/esm/ui/scanner/camera-selection-ui.js\");\n/* harmony import */ var _ui_scanner_camera_zoom_ui__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ui/scanner/camera-zoom-ui */ \"./node_modules/html5-qrcode/esm/ui/scanner/camera-zoom-ui.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Html5QrcodeScannerStatus;\n(function (Html5QrcodeScannerStatus) {\n    Html5QrcodeScannerStatus[Html5QrcodeScannerStatus[\"STATUS_DEFAULT\"] = 0] = \"STATUS_DEFAULT\";\n    Html5QrcodeScannerStatus[Html5QrcodeScannerStatus[\"STATUS_SUCCESS\"] = 1] = \"STATUS_SUCCESS\";\n    Html5QrcodeScannerStatus[Html5QrcodeScannerStatus[\"STATUS_WARNING\"] = 2] = \"STATUS_WARNING\";\n    Html5QrcodeScannerStatus[Html5QrcodeScannerStatus[\"STATUS_REQUESTING_PERMISSION\"] = 3] = \"STATUS_REQUESTING_PERMISSION\";\n})(Html5QrcodeScannerStatus || (Html5QrcodeScannerStatus = {}));\nfunction toHtml5QrcodeCameraScanConfig(config) {\n    return {\n        fps: config.fps,\n        qrbox: config.qrbox,\n        aspectRatio: config.aspectRatio,\n        disableFlip: config.disableFlip,\n        videoConstraints: config.videoConstraints\n    };\n}\nfunction toHtml5QrcodeFullConfig(config, verbose) {\n    return {\n        formatsToSupport: config.formatsToSupport,\n        useBarCodeDetectorIfSupported: config.useBarCodeDetectorIfSupported,\n        experimentalFeatures: config.experimentalFeatures,\n        verbose: verbose\n    };\n}\nvar Html5QrcodeScanner = (function () {\n    function Html5QrcodeScanner(elementId, config, verbose) {\n        this.lastMatchFound = null;\n        this.cameraScanImage = null;\n        this.fileScanImage = null;\n        this.fileSelectionUi = null;\n        this.elementId = elementId;\n        this.config = this.createConfig(config);\n        this.verbose = verbose === true;\n        if (!document.getElementById(elementId)) {\n            throw \"HTML Element with id=\".concat(elementId, \" not found\");\n        }\n        this.scanTypeSelector = new _ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector(this.config.supportedScanTypes);\n        this.currentScanType = this.scanTypeSelector.getDefaultScanType();\n        this.sectionSwapAllowed = true;\n        this.logger = new _core__WEBPACK_IMPORTED_MODULE_0__.BaseLoggger(this.verbose);\n        this.persistedDataManager = new _storage__WEBPACK_IMPORTED_MODULE_4__.PersistedDataManager();\n        if (config.rememberLastUsedCamera !== true) {\n            this.persistedDataManager.reset();\n        }\n    }\n    Html5QrcodeScanner.prototype.render = function (qrCodeSuccessCallback, qrCodeErrorCallback) {\n        var _this = this;\n        this.lastMatchFound = null;\n        this.qrCodeSuccessCallback\n            = function (decodedText, result) {\n                if (qrCodeSuccessCallback) {\n                    qrCodeSuccessCallback(decodedText, result);\n                }\n                else {\n                    if (_this.lastMatchFound === decodedText) {\n                        return;\n                    }\n                    _this.lastMatchFound = decodedText;\n                    _this.setHeaderMessage(_strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.lastMatch(decodedText), Html5QrcodeScannerStatus.STATUS_SUCCESS);\n                }\n            };\n        this.qrCodeErrorCallback =\n            function (errorMessage, error) {\n                if (qrCodeErrorCallback) {\n                    qrCodeErrorCallback(errorMessage, error);\n                }\n            };\n        var container = document.getElementById(this.elementId);\n        if (!container) {\n            throw \"HTML Element with id=\".concat(this.elementId, \" not found\");\n        }\n        container.innerHTML = \"\";\n        this.createBasicLayout(container);\n        this.html5Qrcode = new _html5_qrcode__WEBPACK_IMPORTED_MODULE_1__.Html5Qrcode(this.getScanRegionId(), toHtml5QrcodeFullConfig(this.config, this.verbose));\n    };\n    Html5QrcodeScanner.prototype.pause = function (shouldPauseVideo) {\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(shouldPauseVideo) || shouldPauseVideo !== true) {\n            shouldPauseVideo = false;\n        }\n        this.getHtml5QrcodeOrFail().pause(shouldPauseVideo);\n    };\n    Html5QrcodeScanner.prototype.resume = function () {\n        this.getHtml5QrcodeOrFail().resume();\n    };\n    Html5QrcodeScanner.prototype.getState = function () {\n        return this.getHtml5QrcodeOrFail().getState();\n    };\n    Html5QrcodeScanner.prototype.clear = function () {\n        var _this = this;\n        var emptyHtmlContainer = function () {\n            var mainContainer = document.getElementById(_this.elementId);\n            if (mainContainer) {\n                mainContainer.innerHTML = \"\";\n                _this.resetBasicLayout(mainContainer);\n            }\n        };\n        if (this.html5Qrcode) {\n            return new Promise(function (resolve, reject) {\n                if (!_this.html5Qrcode) {\n                    resolve();\n                    return;\n                }\n                if (_this.html5Qrcode.isScanning) {\n                    _this.html5Qrcode.stop().then(function (_) {\n                        if (!_this.html5Qrcode) {\n                            resolve();\n                            return;\n                        }\n                        _this.html5Qrcode.clear();\n                        emptyHtmlContainer();\n                        resolve();\n                    }).catch(function (error) {\n                        if (_this.verbose) {\n                            _this.logger.logError(\"Unable to stop qrcode scanner\", error);\n                        }\n                        reject(error);\n                    });\n                }\n                else {\n                    _this.html5Qrcode.clear();\n                    emptyHtmlContainer();\n                    resolve();\n                }\n            });\n        }\n        return Promise.resolve();\n    };\n    Html5QrcodeScanner.prototype.getRunningTrackCapabilities = function () {\n        return this.getHtml5QrcodeOrFail().getRunningTrackCapabilities();\n    };\n    Html5QrcodeScanner.prototype.getRunningTrackSettings = function () {\n        return this.getHtml5QrcodeOrFail().getRunningTrackSettings();\n    };\n    Html5QrcodeScanner.prototype.applyVideoConstraints = function (videoConstaints) {\n        return this.getHtml5QrcodeOrFail().applyVideoConstraints(videoConstaints);\n    };\n    Html5QrcodeScanner.prototype.getHtml5QrcodeOrFail = function () {\n        if (!this.html5Qrcode) {\n            throw \"Code scanner not initialized.\";\n        }\n        return this.html5Qrcode;\n    };\n    Html5QrcodeScanner.prototype.createConfig = function (config) {\n        if (config) {\n            if (!config.fps) {\n                config.fps = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.SCAN_DEFAULT_FPS;\n            }\n            if (config.rememberLastUsedCamera !== (!_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED)) {\n                config.rememberLastUsedCamera\n                    = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED;\n            }\n            if (!config.supportedScanTypes) {\n                config.supportedScanTypes\n                    = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE;\n            }\n            return config;\n        }\n        return {\n            fps: _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.SCAN_DEFAULT_FPS,\n            rememberLastUsedCamera: _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED,\n            supportedScanTypes: _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE\n        };\n    };\n    Html5QrcodeScanner.prototype.createBasicLayout = function (parent) {\n        parent.style.position = \"relative\";\n        parent.style.padding = \"0px\";\n        parent.style.border = \"1px solid silver\";\n        this.createHeader(parent);\n        var qrCodeScanRegion = document.createElement(\"div\");\n        var scanRegionId = this.getScanRegionId();\n        qrCodeScanRegion.id = scanRegionId;\n        qrCodeScanRegion.style.width = \"100%\";\n        qrCodeScanRegion.style.minHeight = \"100px\";\n        qrCodeScanRegion.style.textAlign = \"center\";\n        parent.appendChild(qrCodeScanRegion);\n        if (_ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isCameraScanType(this.currentScanType)) {\n            this.insertCameraScanImageToScanRegion();\n        }\n        else {\n            this.insertFileScanImageToScanRegion();\n        }\n        var qrCodeDashboard = document.createElement(\"div\");\n        var dashboardId = this.getDashboardId();\n        qrCodeDashboard.id = dashboardId;\n        qrCodeDashboard.style.width = \"100%\";\n        parent.appendChild(qrCodeDashboard);\n        this.setupInitialDashboard(qrCodeDashboard);\n    };\n    Html5QrcodeScanner.prototype.resetBasicLayout = function (mainContainer) {\n        mainContainer.style.border = \"none\";\n    };\n    Html5QrcodeScanner.prototype.setupInitialDashboard = function (dashboard) {\n        this.createSection(dashboard);\n        this.createSectionControlPanel();\n        if (this.scanTypeSelector.hasMoreThanOneScanType()) {\n            this.createSectionSwap();\n        }\n    };\n    Html5QrcodeScanner.prototype.createHeader = function (dashboard) {\n        var header = document.createElement(\"div\");\n        header.style.textAlign = \"left\";\n        header.style.margin = \"0px\";\n        dashboard.appendChild(header);\n        var libraryInfo = new _ui__WEBPACK_IMPORTED_MODULE_5__.LibraryInfoContainer();\n        libraryInfo.renderInto(header);\n        var headerMessageContainer = document.createElement(\"div\");\n        headerMessageContainer.id = this.getHeaderMessageContainerId();\n        headerMessageContainer.style.display = \"none\";\n        headerMessageContainer.style.textAlign = \"center\";\n        headerMessageContainer.style.fontSize = \"14px\";\n        headerMessageContainer.style.padding = \"2px 10px\";\n        headerMessageContainer.style.margin = \"4px\";\n        headerMessageContainer.style.borderTop = \"1px solid #f6f6f6\";\n        header.appendChild(headerMessageContainer);\n    };\n    Html5QrcodeScanner.prototype.createSection = function (dashboard) {\n        var section = document.createElement(\"div\");\n        section.id = this.getDashboardSectionId();\n        section.style.width = \"100%\";\n        section.style.padding = \"10px 0px 10px 0px\";\n        section.style.textAlign = \"left\";\n        dashboard.appendChild(section);\n    };\n    Html5QrcodeScanner.prototype.createCameraListUi = function (scpCameraScanRegion, requestPermissionContainer, requestPermissionButton) {\n        var $this = this;\n        $this.showHideScanTypeSwapLink(false);\n        $this.setHeaderMessage(_strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.cameraPermissionRequesting());\n        var createPermissionButtonIfNotExists = function () {\n            if (!requestPermissionButton) {\n                $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);\n            }\n        };\n        _html5_qrcode__WEBPACK_IMPORTED_MODULE_1__.Html5Qrcode.getCameras().then(function (cameras) {\n            $this.persistedDataManager.setHasPermission(true);\n            $this.showHideScanTypeSwapLink(true);\n            $this.resetHeaderMessage();\n            if (cameras && cameras.length > 0) {\n                scpCameraScanRegion.removeChild(requestPermissionContainer);\n                $this.renderCameraSelection(cameras);\n            }\n            else {\n                $this.setHeaderMessage(_strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.noCameraFound(), Html5QrcodeScannerStatus.STATUS_WARNING);\n                createPermissionButtonIfNotExists();\n            }\n        }).catch(function (error) {\n            $this.persistedDataManager.setHasPermission(false);\n            if (requestPermissionButton) {\n                requestPermissionButton.disabled = false;\n            }\n            else {\n                createPermissionButtonIfNotExists();\n            }\n            $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);\n            $this.showHideScanTypeSwapLink(true);\n        });\n    };\n    Html5QrcodeScanner.prototype.createPermissionButton = function (scpCameraScanRegion, requestPermissionContainer) {\n        var $this = this;\n        var requestPermissionButton = _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.BaseUiElementFactory\n            .createElement(\"button\", this.getCameraPermissionButtonId());\n        requestPermissionButton.innerText\n            = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.cameraPermissionTitle();\n        requestPermissionButton.addEventListener(\"click\", function () {\n            requestPermissionButton.disabled = true;\n            $this.createCameraListUi(scpCameraScanRegion, requestPermissionContainer, requestPermissionButton);\n        });\n        requestPermissionContainer.appendChild(requestPermissionButton);\n    };\n    Html5QrcodeScanner.prototype.createPermissionsUi = function (scpCameraScanRegion, requestPermissionContainer) {\n        var $this = this;\n        if (_ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isCameraScanType(this.currentScanType)\n            && this.persistedDataManager.hasCameraPermissions()) {\n            _camera_permissions__WEBPACK_IMPORTED_MODULE_6__.CameraPermissions.hasPermissions().then(function (hasPermissions) {\n                if (hasPermissions) {\n                    $this.createCameraListUi(scpCameraScanRegion, requestPermissionContainer);\n                }\n                else {\n                    $this.persistedDataManager.setHasPermission(false);\n                    $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);\n                }\n            }).catch(function (_) {\n                $this.persistedDataManager.setHasPermission(false);\n                $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);\n            });\n            return;\n        }\n        this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);\n    };\n    Html5QrcodeScanner.prototype.createSectionControlPanel = function () {\n        var section = document.getElementById(this.getDashboardSectionId());\n        var sectionControlPanel = document.createElement(\"div\");\n        section.appendChild(sectionControlPanel);\n        var scpCameraScanRegion = document.createElement(\"div\");\n        scpCameraScanRegion.id = this.getDashboardSectionCameraScanRegionId();\n        scpCameraScanRegion.style.display\n            = _ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isCameraScanType(this.currentScanType)\n                ? \"block\" : \"none\";\n        sectionControlPanel.appendChild(scpCameraScanRegion);\n        var requestPermissionContainer = document.createElement(\"div\");\n        requestPermissionContainer.style.textAlign = \"center\";\n        scpCameraScanRegion.appendChild(requestPermissionContainer);\n        if (this.scanTypeSelector.isCameraScanRequired()) {\n            this.createPermissionsUi(scpCameraScanRegion, requestPermissionContainer);\n        }\n        this.renderFileScanUi(sectionControlPanel);\n    };\n    Html5QrcodeScanner.prototype.renderFileScanUi = function (parent) {\n        var showOnRender = _ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isFileScanType(this.currentScanType);\n        var $this = this;\n        var onFileSelected = function (file) {\n            if (!$this.html5Qrcode) {\n                throw \"html5Qrcode not defined\";\n            }\n            if (!_ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isFileScanType($this.currentScanType)) {\n                return;\n            }\n            $this.setHeaderMessage(_strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.loadingImage());\n            $this.html5Qrcode.scanFileV2(file, true)\n                .then(function (html5qrcodeResult) {\n                $this.resetHeaderMessage();\n                $this.qrCodeSuccessCallback(html5qrcodeResult.decodedText, html5qrcodeResult);\n            })\n                .catch(function (error) {\n                $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);\n                $this.qrCodeErrorCallback(error, _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeErrorFactory.createFrom(error));\n            });\n        };\n        this.fileSelectionUi = _ui_scanner_file_selection_ui__WEBPACK_IMPORTED_MODULE_9__.FileSelectionUi.create(parent, showOnRender, onFileSelected);\n    };\n    Html5QrcodeScanner.prototype.renderCameraSelection = function (cameras) {\n        var _this = this;\n        var $this = this;\n        var scpCameraScanRegion = document.getElementById(this.getDashboardSectionCameraScanRegionId());\n        scpCameraScanRegion.style.textAlign = \"center\";\n        var cameraZoomUi = _ui_scanner_camera_zoom_ui__WEBPACK_IMPORTED_MODULE_12__.CameraZoomUi.create(scpCameraScanRegion, false);\n        var renderCameraZoomUiIfSupported = function (cameraCapabilities) {\n            var zoomCapability = cameraCapabilities.zoomFeature();\n            if (!zoomCapability.isSupported()) {\n                return;\n            }\n            cameraZoomUi.setOnCameraZoomValueChangeCallback(function (zoomValue) {\n                zoomCapability.apply(zoomValue);\n            });\n            var defaultZoom = 1;\n            if (_this.config.defaultZoomValueIfSupported) {\n                defaultZoom = _this.config.defaultZoomValueIfSupported;\n            }\n            defaultZoom = (0,_core__WEBPACK_IMPORTED_MODULE_0__.clip)(defaultZoom, zoomCapability.min(), zoomCapability.max());\n            cameraZoomUi.setValues(zoomCapability.min(), zoomCapability.max(), defaultZoom, zoomCapability.step());\n            cameraZoomUi.show();\n        };\n        var cameraSelectUi = _ui_scanner_camera_selection_ui__WEBPACK_IMPORTED_MODULE_11__.CameraSelectionUi.create(scpCameraScanRegion, cameras);\n        var cameraActionContainer = document.createElement(\"span\");\n        var cameraActionStartButton = _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.BaseUiElementFactory.createElement(\"button\", _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.PublicUiElementIdAndClasses.CAMERA_START_BUTTON_ID);\n        cameraActionStartButton.innerText\n            = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.scanButtonStartScanningText();\n        cameraActionContainer.appendChild(cameraActionStartButton);\n        var cameraActionStopButton = _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.BaseUiElementFactory.createElement(\"button\", _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.PublicUiElementIdAndClasses.CAMERA_STOP_BUTTON_ID);\n        cameraActionStopButton.innerText\n            = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.scanButtonStopScanningText();\n        cameraActionStopButton.style.display = \"none\";\n        cameraActionStopButton.disabled = true;\n        cameraActionContainer.appendChild(cameraActionStopButton);\n        var torchButton;\n        var createAndShowTorchButtonIfSupported = function (cameraCapabilities) {\n            if (!cameraCapabilities.torchFeature().isSupported()) {\n                if (torchButton) {\n                    torchButton.hide();\n                }\n                return;\n            }\n            if (!torchButton) {\n                torchButton = _ui_scanner_torch_button__WEBPACK_IMPORTED_MODULE_8__.TorchButton.create(cameraActionContainer, cameraCapabilities.torchFeature(), { display: \"none\", marginLeft: \"5px\" }, function (errorMessage) {\n                    $this.setHeaderMessage(errorMessage, Html5QrcodeScannerStatus.STATUS_WARNING);\n                });\n            }\n            else {\n                torchButton.updateTorchCapability(cameraCapabilities.torchFeature());\n            }\n            torchButton.show();\n        };\n        scpCameraScanRegion.appendChild(cameraActionContainer);\n        var resetCameraActionStartButton = function (shouldShow) {\n            if (!shouldShow) {\n                cameraActionStartButton.style.display = \"none\";\n            }\n            cameraActionStartButton.innerText\n                = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings\n                    .scanButtonStartScanningText();\n            cameraActionStartButton.style.opacity = \"1\";\n            cameraActionStartButton.disabled = false;\n            if (shouldShow) {\n                cameraActionStartButton.style.display = \"inline-block\";\n            }\n        };\n        cameraActionStartButton.addEventListener(\"click\", function (_) {\n            cameraActionStartButton.innerText\n                = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.scanButtonScanningStarting();\n            cameraSelectUi.disable();\n            cameraActionStartButton.disabled = true;\n            cameraActionStartButton.style.opacity = \"0.5\";\n            if (_this.scanTypeSelector.hasMoreThanOneScanType()) {\n                $this.showHideScanTypeSwapLink(false);\n            }\n            $this.resetHeaderMessage();\n            var cameraId = cameraSelectUi.getValue();\n            $this.persistedDataManager.setLastUsedCameraId(cameraId);\n            $this.html5Qrcode.start(cameraId, toHtml5QrcodeCameraScanConfig($this.config), $this.qrCodeSuccessCallback, $this.qrCodeErrorCallback)\n                .then(function (_) {\n                cameraActionStopButton.disabled = false;\n                cameraActionStopButton.style.display = \"inline-block\";\n                resetCameraActionStartButton(false);\n                var cameraCapabilities = $this.html5Qrcode.getRunningTrackCameraCapabilities();\n                if (_this.config.showTorchButtonIfSupported === true) {\n                    createAndShowTorchButtonIfSupported(cameraCapabilities);\n                }\n                if (_this.config.showZoomSliderIfSupported === true) {\n                    renderCameraZoomUiIfSupported(cameraCapabilities);\n                }\n            })\n                .catch(function (error) {\n                $this.showHideScanTypeSwapLink(true);\n                cameraSelectUi.enable();\n                resetCameraActionStartButton(true);\n                $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);\n            });\n        });\n        if (cameraSelectUi.hasSingleItem()) {\n            cameraActionStartButton.click();\n        }\n        cameraActionStopButton.addEventListener(\"click\", function (_) {\n            if (!$this.html5Qrcode) {\n                throw \"html5Qrcode not defined\";\n            }\n            cameraActionStopButton.disabled = true;\n            $this.html5Qrcode.stop()\n                .then(function (_) {\n                if (_this.scanTypeSelector.hasMoreThanOneScanType()) {\n                    $this.showHideScanTypeSwapLink(true);\n                }\n                cameraSelectUi.enable();\n                cameraActionStartButton.disabled = false;\n                cameraActionStopButton.style.display = \"none\";\n                cameraActionStartButton.style.display = \"inline-block\";\n                if (torchButton) {\n                    torchButton.reset();\n                    torchButton.hide();\n                }\n                cameraZoomUi.removeOnCameraZoomValueChangeCallback();\n                cameraZoomUi.hide();\n                $this.insertCameraScanImageToScanRegion();\n            }).catch(function (error) {\n                cameraActionStopButton.disabled = false;\n                $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);\n            });\n        });\n        if ($this.persistedDataManager.getLastUsedCameraId()) {\n            var cameraId = $this.persistedDataManager.getLastUsedCameraId();\n            if (cameraSelectUi.hasValue(cameraId)) {\n                cameraSelectUi.setValue(cameraId);\n                cameraActionStartButton.click();\n            }\n            else {\n                $this.persistedDataManager.resetLastUsedCameraId();\n            }\n        }\n    };\n    Html5QrcodeScanner.prototype.createSectionSwap = function () {\n        var $this = this;\n        var TEXT_IF_CAMERA_SCAN_SELECTED = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.textIfCameraScanSelected();\n        var TEXT_IF_FILE_SCAN_SELECTED = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.textIfFileScanSelected();\n        var section = document.getElementById(this.getDashboardSectionId());\n        var switchContainer = document.createElement(\"div\");\n        switchContainer.style.textAlign = \"center\";\n        var switchScanTypeLink = _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.BaseUiElementFactory.createElement(\"span\", this.getDashboardSectionSwapLinkId());\n        switchScanTypeLink.style.textDecoration = \"underline\";\n        switchScanTypeLink.style.cursor = \"pointer\";\n        switchScanTypeLink.innerText\n            = _ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isCameraScanType(this.currentScanType)\n                ? TEXT_IF_CAMERA_SCAN_SELECTED : TEXT_IF_FILE_SCAN_SELECTED;\n        switchScanTypeLink.addEventListener(\"click\", function () {\n            if (!$this.sectionSwapAllowed) {\n                if ($this.verbose) {\n                    $this.logger.logError(\"Section swap called when not allowed\");\n                }\n                return;\n            }\n            $this.resetHeaderMessage();\n            $this.fileSelectionUi.resetValue();\n            $this.sectionSwapAllowed = false;\n            if (_ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isCameraScanType($this.currentScanType)) {\n                $this.clearScanRegion();\n                $this.getCameraScanRegion().style.display = \"none\";\n                $this.fileSelectionUi.show();\n                switchScanTypeLink.innerText = TEXT_IF_FILE_SCAN_SELECTED;\n                $this.currentScanType = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScanType.SCAN_TYPE_FILE;\n                $this.insertFileScanImageToScanRegion();\n            }\n            else {\n                $this.clearScanRegion();\n                $this.getCameraScanRegion().style.display = \"block\";\n                $this.fileSelectionUi.hide();\n                switchScanTypeLink.innerText = TEXT_IF_CAMERA_SCAN_SELECTED;\n                $this.currentScanType = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScanType.SCAN_TYPE_CAMERA;\n                $this.insertCameraScanImageToScanRegion();\n                $this.startCameraScanIfPermissionExistsOnSwap();\n            }\n            $this.sectionSwapAllowed = true;\n        });\n        switchContainer.appendChild(switchScanTypeLink);\n        section.appendChild(switchContainer);\n    };\n    Html5QrcodeScanner.prototype.startCameraScanIfPermissionExistsOnSwap = function () {\n        var _this = this;\n        var $this = this;\n        if (this.persistedDataManager.hasCameraPermissions()) {\n            _camera_permissions__WEBPACK_IMPORTED_MODULE_6__.CameraPermissions.hasPermissions().then(function (hasPermissions) {\n                if (hasPermissions) {\n                    var permissionButton = document.getElementById($this.getCameraPermissionButtonId());\n                    if (!permissionButton) {\n                        _this.logger.logError(\"Permission button not found, fail;\");\n                        throw \"Permission button not found\";\n                    }\n                    permissionButton.click();\n                }\n                else {\n                    $this.persistedDataManager.setHasPermission(false);\n                }\n            }).catch(function (_) {\n                $this.persistedDataManager.setHasPermission(false);\n            });\n            return;\n        }\n    };\n    Html5QrcodeScanner.prototype.resetHeaderMessage = function () {\n        var messageDiv = document.getElementById(this.getHeaderMessageContainerId());\n        messageDiv.style.display = \"none\";\n    };\n    Html5QrcodeScanner.prototype.setHeaderMessage = function (messageText, scannerStatus) {\n        if (!scannerStatus) {\n            scannerStatus = Html5QrcodeScannerStatus.STATUS_DEFAULT;\n        }\n        var messageDiv = this.getHeaderMessageDiv();\n        messageDiv.innerText = messageText;\n        messageDiv.style.display = \"block\";\n        switch (scannerStatus) {\n            case Html5QrcodeScannerStatus.STATUS_SUCCESS:\n                messageDiv.style.background = \"rgba(106, 175, 80, 0.26)\";\n                messageDiv.style.color = \"#477735\";\n                break;\n            case Html5QrcodeScannerStatus.STATUS_WARNING:\n                messageDiv.style.background = \"rgba(203, 36, 49, 0.14)\";\n                messageDiv.style.color = \"#cb2431\";\n                break;\n            case Html5QrcodeScannerStatus.STATUS_DEFAULT:\n            default:\n                messageDiv.style.background = \"rgba(0, 0, 0, 0)\";\n                messageDiv.style.color = \"rgb(17, 17, 17)\";\n                break;\n        }\n    };\n    Html5QrcodeScanner.prototype.showHideScanTypeSwapLink = function (shouldDisplay) {\n        if (this.scanTypeSelector.hasMoreThanOneScanType()) {\n            if (shouldDisplay !== true) {\n                shouldDisplay = false;\n            }\n            this.sectionSwapAllowed = shouldDisplay;\n            this.getDashboardSectionSwapLink().style.display\n                = shouldDisplay ? \"inline-block\" : \"none\";\n        }\n    };\n    Html5QrcodeScanner.prototype.insertCameraScanImageToScanRegion = function () {\n        var $this = this;\n        var qrCodeScanRegion = document.getElementById(this.getScanRegionId());\n        if (this.cameraScanImage) {\n            qrCodeScanRegion.innerHTML = \"<br>\";\n            qrCodeScanRegion.appendChild(this.cameraScanImage);\n            return;\n        }\n        this.cameraScanImage = new Image;\n        this.cameraScanImage.onload = function (_) {\n            qrCodeScanRegion.innerHTML = \"<br>\";\n            qrCodeScanRegion.appendChild($this.cameraScanImage);\n        };\n        this.cameraScanImage.width = 64;\n        this.cameraScanImage.style.opacity = \"0.8\";\n        this.cameraScanImage.src = _image_assets__WEBPACK_IMPORTED_MODULE_3__.ASSET_CAMERA_SCAN;\n        this.cameraScanImage.alt = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.cameraScanAltText();\n    };\n    Html5QrcodeScanner.prototype.insertFileScanImageToScanRegion = function () {\n        var $this = this;\n        var qrCodeScanRegion = document.getElementById(this.getScanRegionId());\n        if (this.fileScanImage) {\n            qrCodeScanRegion.innerHTML = \"<br>\";\n            qrCodeScanRegion.appendChild(this.fileScanImage);\n            return;\n        }\n        this.fileScanImage = new Image;\n        this.fileScanImage.onload = function (_) {\n            qrCodeScanRegion.innerHTML = \"<br>\";\n            qrCodeScanRegion.appendChild($this.fileScanImage);\n        };\n        this.fileScanImage.width = 64;\n        this.fileScanImage.style.opacity = \"0.8\";\n        this.fileScanImage.src = _image_assets__WEBPACK_IMPORTED_MODULE_3__.ASSET_FILE_SCAN;\n        this.fileScanImage.alt = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.fileScanAltText();\n    };\n    Html5QrcodeScanner.prototype.clearScanRegion = function () {\n        var qrCodeScanRegion = document.getElementById(this.getScanRegionId());\n        qrCodeScanRegion.innerHTML = \"\";\n    };\n    Html5QrcodeScanner.prototype.getDashboardSectionId = function () {\n        return \"\".concat(this.elementId, \"__dashboard_section\");\n    };\n    Html5QrcodeScanner.prototype.getDashboardSectionCameraScanRegionId = function () {\n        return \"\".concat(this.elementId, \"__dashboard_section_csr\");\n    };\n    Html5QrcodeScanner.prototype.getDashboardSectionSwapLinkId = function () {\n        return _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.PublicUiElementIdAndClasses.SCAN_TYPE_CHANGE_ANCHOR_ID;\n    };\n    Html5QrcodeScanner.prototype.getScanRegionId = function () {\n        return \"\".concat(this.elementId, \"__scan_region\");\n    };\n    Html5QrcodeScanner.prototype.getDashboardId = function () {\n        return \"\".concat(this.elementId, \"__dashboard\");\n    };\n    Html5QrcodeScanner.prototype.getHeaderMessageContainerId = function () {\n        return \"\".concat(this.elementId, \"__header_message\");\n    };\n    Html5QrcodeScanner.prototype.getCameraPermissionButtonId = function () {\n        return _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.PublicUiElementIdAndClasses.CAMERA_PERMISSION_BUTTON_ID;\n    };\n    Html5QrcodeScanner.prototype.getCameraScanRegion = function () {\n        return document.getElementById(this.getDashboardSectionCameraScanRegionId());\n    };\n    Html5QrcodeScanner.prototype.getDashboardSectionSwapLink = function () {\n        return document.getElementById(this.getDashboardSectionSwapLinkId());\n    };\n    Html5QrcodeScanner.prototype.getHeaderMessageDiv = function () {\n        return document.getElementById(this.getHeaderMessageContainerId());\n    };\n    return Html5QrcodeScanner;\n}());\n\n//# sourceMappingURL=html5-qrcode-scanner.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9odG1sNS1xcmNvZGUtc2Nhbm5lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFtSTtBQUNyRjtBQUNTO0FBQ2M7QUFDcEI7QUFDTDtBQUNhO0FBQ1U7QUFDWDtBQUNTO0FBQ3FCO0FBQ2pCO0FBQ1Y7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0REFBNEQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0RUFBZ0I7QUFDcEQ7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBVztBQUNyQyx3Q0FBd0MsMERBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsK0RBQXlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0RBQVc7QUFDMUM7QUFDQTtBQUNBLFlBQVksd0RBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdURBQW9CO0FBQ2pEO0FBQ0Esb0RBQW9ELHVEQUFvQjtBQUN4RTtBQUNBLHNCQUFzQix1REFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVEQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1REFBb0I7QUFDckMsb0NBQW9DLHVEQUFvQjtBQUN4RCxnQ0FBZ0MsdURBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRFQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscURBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtEQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLCtEQUF5QjtBQUNoRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUVBQW9CO0FBQzFEO0FBQ0E7QUFDQSxjQUFjLCtEQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRFQUFnQjtBQUM1QjtBQUNBLFlBQVksa0VBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEVBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNEVBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNEVBQWdCO0FBQ2pDO0FBQ0E7QUFDQSxtQ0FBbUMsK0RBQXlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpREFBaUQsMERBQXVCO0FBQ3hFLGFBQWE7QUFDYjtBQUNBLCtCQUErQiwwRUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUVBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtFQUFpQjtBQUM5QztBQUNBLHNDQUFzQyxtRUFBb0IseUJBQXlCLDBFQUEyQjtBQUM5RztBQUNBLGNBQWMsK0RBQXlCO0FBQ3ZDO0FBQ0EscUNBQXFDLG1FQUFvQix5QkFBeUIsMEVBQTJCO0FBQzdHO0FBQ0EsY0FBYywrREFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlFQUFXLG9FQUFvRSxvQ0FBb0M7QUFDako7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtEQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0RBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsK0RBQXlCO0FBQ3BFLHlDQUF5QywrREFBeUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1FQUFvQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRFQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRFQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzREFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0RBQW1CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDREQUFpQjtBQUNwRCxtQ0FBbUMsK0RBQXlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBEQUFlO0FBQ2hELGlDQUFpQywrREFBeUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwRUFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEVBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzZCO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL2h0bWw1LXFyY29kZS1zY2FubmVyLmpzPzg3YjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSHRtbDVRcmNvZGVDb25zdGFudHMsIEh0bWw1UXJjb2RlU2NhblR5cGUsIEh0bWw1UXJjb2RlRXJyb3JGYWN0b3J5LCBCYXNlTG9nZ2dlciwgaXNOdWxsT3JVbmRlZmluZWQsIGNsaXAsIH0gZnJvbSBcIi4vY29yZVwiO1xuaW1wb3J0IHsgSHRtbDVRcmNvZGUsIH0gZnJvbSBcIi4vaHRtbDUtcXJjb2RlXCI7XG5pbXBvcnQgeyBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLCB9IGZyb20gXCIuL3N0cmluZ3NcIjtcbmltcG9ydCB7IEFTU0VUX0ZJTEVfU0NBTiwgQVNTRVRfQ0FNRVJBX1NDQU4sIH0gZnJvbSBcIi4vaW1hZ2UtYXNzZXRzXCI7XG5pbXBvcnQgeyBQZXJzaXN0ZWREYXRhTWFuYWdlciB9IGZyb20gXCIuL3N0b3JhZ2VcIjtcbmltcG9ydCB7IExpYnJhcnlJbmZvQ29udGFpbmVyIH0gZnJvbSBcIi4vdWlcIjtcbmltcG9ydCB7IENhbWVyYVBlcm1pc3Npb25zIH0gZnJvbSBcIi4vY2FtZXJhL3Blcm1pc3Npb25zXCI7XG5pbXBvcnQgeyBTY2FuVHlwZVNlbGVjdG9yIH0gZnJvbSBcIi4vdWkvc2Nhbm5lci9zY2FuLXR5cGUtc2VsZWN0b3JcIjtcbmltcG9ydCB7IFRvcmNoQnV0dG9uIH0gZnJvbSBcIi4vdWkvc2Nhbm5lci90b3JjaC1idXR0b25cIjtcbmltcG9ydCB7IEZpbGVTZWxlY3Rpb25VaSB9IGZyb20gXCIuL3VpL3NjYW5uZXIvZmlsZS1zZWxlY3Rpb24tdWlcIjtcbmltcG9ydCB7IEJhc2VVaUVsZW1lbnRGYWN0b3J5LCBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMgfSBmcm9tIFwiLi91aS9zY2FubmVyL2Jhc2VcIjtcbmltcG9ydCB7IENhbWVyYVNlbGVjdGlvblVpIH0gZnJvbSBcIi4vdWkvc2Nhbm5lci9jYW1lcmEtc2VsZWN0aW9uLXVpXCI7XG5pbXBvcnQgeyBDYW1lcmFab29tVWkgfSBmcm9tIFwiLi91aS9zY2FubmVyL2NhbWVyYS16b29tLXVpXCI7XG52YXIgSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzO1xuKGZ1bmN0aW9uIChIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXMpIHtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXNbSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzW1wiU1RBVFVTX0RFRkFVTFRcIl0gPSAwXSA9IFwiU1RBVFVTX0RFRkFVTFRcIjtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXNbSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzW1wiU1RBVFVTX1NVQ0NFU1NcIl0gPSAxXSA9IFwiU1RBVFVTX1NVQ0NFU1NcIjtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXNbSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzW1wiU1RBVFVTX1dBUk5JTkdcIl0gPSAyXSA9IFwiU1RBVFVTX1dBUk5JTkdcIjtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXNbSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzW1wiU1RBVFVTX1JFUVVFU1RJTkdfUEVSTUlTU0lPTlwiXSA9IDNdID0gXCJTVEFUVVNfUkVRVUVTVElOR19QRVJNSVNTSU9OXCI7XG59KShIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXMgfHwgKEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cyA9IHt9KSk7XG5mdW5jdGlvbiB0b0h0bWw1UXJjb2RlQ2FtZXJhU2NhbkNvbmZpZyhjb25maWcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcHM6IGNvbmZpZy5mcHMsXG4gICAgICAgIHFyYm94OiBjb25maWcucXJib3gsXG4gICAgICAgIGFzcGVjdFJhdGlvOiBjb25maWcuYXNwZWN0UmF0aW8sXG4gICAgICAgIGRpc2FibGVGbGlwOiBjb25maWcuZGlzYWJsZUZsaXAsXG4gICAgICAgIHZpZGVvQ29uc3RyYWludHM6IGNvbmZpZy52aWRlb0NvbnN0cmFpbnRzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvSHRtbDVRcmNvZGVGdWxsQ29uZmlnKGNvbmZpZywgdmVyYm9zZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdHNUb1N1cHBvcnQ6IGNvbmZpZy5mb3JtYXRzVG9TdXBwb3J0LFxuICAgICAgICB1c2VCYXJDb2RlRGV0ZWN0b3JJZlN1cHBvcnRlZDogY29uZmlnLnVzZUJhckNvZGVEZXRlY3RvcklmU3VwcG9ydGVkLFxuICAgICAgICBleHBlcmltZW50YWxGZWF0dXJlczogY29uZmlnLmV4cGVyaW1lbnRhbEZlYXR1cmVzLFxuICAgICAgICB2ZXJib3NlOiB2ZXJib3NlXG4gICAgfTtcbn1cbnZhciBIdG1sNVFyY29kZVNjYW5uZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWw1UXJjb2RlU2Nhbm5lcihlbGVtZW50SWQsIGNvbmZpZywgdmVyYm9zZSkge1xuICAgICAgICB0aGlzLmxhc3RNYXRjaEZvdW5kID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW1lcmFTY2FuSW1hZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbGVTY2FuSW1hZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbGVTZWxlY3Rpb25VaSA9IG51bGw7XG4gICAgICAgIHRoaXMuZWxlbWVudElkID0gZWxlbWVudElkO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHRoaXMuY3JlYXRlQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IHZlcmJvc2UgPT09IHRydWU7XG4gICAgICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElkKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJIVE1MIEVsZW1lbnQgd2l0aCBpZD1cIi5jb25jYXQoZWxlbWVudElkLCBcIiBub3QgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2FuVHlwZVNlbGVjdG9yID0gbmV3IFNjYW5UeXBlU2VsZWN0b3IodGhpcy5jb25maWcuc3VwcG9ydGVkU2NhblR5cGVzKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U2NhblR5cGUgPSB0aGlzLnNjYW5UeXBlU2VsZWN0b3IuZ2V0RGVmYXVsdFNjYW5UeXBlKCk7XG4gICAgICAgIHRoaXMuc2VjdGlvblN3YXBBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBuZXcgQmFzZUxvZ2dnZXIodGhpcy52ZXJib3NlKTtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlciA9IG5ldyBQZXJzaXN0ZWREYXRhTWFuYWdlcigpO1xuICAgICAgICBpZiAoY29uZmlnLnJlbWVtYmVyTGFzdFVzZWRDYW1lcmEgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucGVyc2lzdGVkRGF0YU1hbmFnZXIucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChxckNvZGVTdWNjZXNzQ2FsbGJhY2ssIHFyQ29kZUVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5sYXN0TWF0Y2hGb3VuZCA9IG51bGw7XG4gICAgICAgIHRoaXMucXJDb2RlU3VjY2Vzc0NhbGxiYWNrXG4gICAgICAgICAgICA9IGZ1bmN0aW9uIChkZWNvZGVkVGV4dCwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHFyQ29kZVN1Y2Nlc3NDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBxckNvZGVTdWNjZXNzQ2FsbGJhY2soZGVjb2RlZFRleHQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGFzdE1hdGNoRm91bmQgPT09IGRlY29kZWRUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGFzdE1hdGNoRm91bmQgPSBkZWNvZGVkVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0SGVhZGVyTWVzc2FnZShIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmxhc3RNYXRjaChkZWNvZGVkVGV4dCksIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cy5TVEFUVVNfU1VDQ0VTUyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5xckNvZGVFcnJvckNhbGxiYWNrID1cbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvck1lc3NhZ2UsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHFyQ29kZUVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcXJDb2RlRXJyb3JDYWxsYmFjayhlcnJvck1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5lbGVtZW50SWQpO1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhyb3cgXCJIVE1MIEVsZW1lbnQgd2l0aCBpZD1cIi5jb25jYXQodGhpcy5lbGVtZW50SWQsIFwiIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgdGhpcy5jcmVhdGVCYXNpY0xheW91dChjb250YWluZXIpO1xuICAgICAgICB0aGlzLmh0bWw1UXJjb2RlID0gbmV3IEh0bWw1UXJjb2RlKHRoaXMuZ2V0U2NhblJlZ2lvbklkKCksIHRvSHRtbDVRcmNvZGVGdWxsQ29uZmlnKHRoaXMuY29uZmlnLCB0aGlzLnZlcmJvc2UpKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoc2hvdWxkUGF1c2VWaWRlbykge1xuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoc2hvdWxkUGF1c2VWaWRlbykgfHwgc2hvdWxkUGF1c2VWaWRlbyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgc2hvdWxkUGF1c2VWaWRlbyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0SHRtbDVRcmNvZGVPckZhaWwoKS5wYXVzZShzaG91bGRQYXVzZVZpZGVvKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdldEh0bWw1UXJjb2RlT3JGYWlsKCkucmVzdW1lKCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRIdG1sNVFyY29kZU9yRmFpbCgpLmdldFN0YXRlKCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZW1wdHlIdG1sQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1haW5Db250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChfdGhpcy5lbGVtZW50SWQpO1xuICAgICAgICAgICAgaWYgKG1haW5Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBtYWluQ29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzZXRCYXNpY0xheW91dChtYWluQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuaHRtbDVRcmNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5odG1sNVFyY29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmh0bWw1UXJjb2RlLmlzU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaHRtbDVRcmNvZGUuc3RvcCgpLnRoZW4oZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaHRtbDVRcmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaHRtbDVRcmNvZGUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcHR5SHRtbENvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiVW5hYmxlIHRvIHN0b3AgcXJjb2RlIHNjYW5uZXJcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5odG1sNVFyY29kZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICBlbXB0eUh0bWxDb250YWluZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0UnVubmluZ1RyYWNrQ2FwYWJpbGl0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRIdG1sNVFyY29kZU9yRmFpbCgpLmdldFJ1bm5pbmdUcmFja0NhcGFiaWxpdGllcygpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5nZXRSdW5uaW5nVHJhY2tTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SHRtbDVRcmNvZGVPckZhaWwoKS5nZXRSdW5uaW5nVHJhY2tTZXR0aW5ncygpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5hcHBseVZpZGVvQ29uc3RyYWludHMgPSBmdW5jdGlvbiAodmlkZW9Db25zdGFpbnRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEh0bWw1UXJjb2RlT3JGYWlsKCkuYXBwbHlWaWRlb0NvbnN0cmFpbnRzKHZpZGVvQ29uc3RhaW50cyk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmdldEh0bWw1UXJjb2RlT3JGYWlsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaHRtbDVRcmNvZGUpIHtcbiAgICAgICAgICAgIHRocm93IFwiQ29kZSBzY2FubmVyIG5vdCBpbml0aWFsaXplZC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5odG1sNVFyY29kZTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuY3JlYXRlQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5mcHMpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZnBzID0gSHRtbDVRcmNvZGVDb25zdGFudHMuU0NBTl9ERUZBVUxUX0ZQUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcucmVtZW1iZXJMYXN0VXNlZENhbWVyYSAhPT0gKCFIdG1sNVFyY29kZUNvbnN0YW50cy5ERUZBVUxUX1JFTUVNQkVSX0xBU1RfQ0FNRVJBX1VTRUQpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnJlbWVtYmVyTGFzdFVzZWRDYW1lcmFcbiAgICAgICAgICAgICAgICAgICAgPSBIdG1sNVFyY29kZUNvbnN0YW50cy5ERUZBVUxUX1JFTUVNQkVSX0xBU1RfQ0FNRVJBX1VTRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5zdXBwb3J0ZWRTY2FuVHlwZXMpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuc3VwcG9ydGVkU2NhblR5cGVzXG4gICAgICAgICAgICAgICAgICAgID0gSHRtbDVRcmNvZGVDb25zdGFudHMuREVGQVVMVF9TVVBQT1JURURfU0NBTl9UWVBFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnBzOiBIdG1sNVFyY29kZUNvbnN0YW50cy5TQ0FOX0RFRkFVTFRfRlBTLFxuICAgICAgICAgICAgcmVtZW1iZXJMYXN0VXNlZENhbWVyYTogSHRtbDVRcmNvZGVDb25zdGFudHMuREVGQVVMVF9SRU1FTUJFUl9MQVNUX0NBTUVSQV9VU0VELFxuICAgICAgICAgICAgc3VwcG9ydGVkU2NhblR5cGVzOiBIdG1sNVFyY29kZUNvbnN0YW50cy5ERUZBVUxUX1NVUFBPUlRFRF9TQ0FOX1RZUEVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuY3JlYXRlQmFzaWNMYXlvdXQgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgcGFyZW50LnN0eWxlLnBhZGRpbmcgPSBcIjBweFwiO1xuICAgICAgICBwYXJlbnQuc3R5bGUuYm9yZGVyID0gXCIxcHggc29saWQgc2lsdmVyXCI7XG4gICAgICAgIHRoaXMuY3JlYXRlSGVhZGVyKHBhcmVudCk7XG4gICAgICAgIHZhciBxckNvZGVTY2FuUmVnaW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIHNjYW5SZWdpb25JZCA9IHRoaXMuZ2V0U2NhblJlZ2lvbklkKCk7XG4gICAgICAgIHFyQ29kZVNjYW5SZWdpb24uaWQgPSBzY2FuUmVnaW9uSWQ7XG4gICAgICAgIHFyQ29kZVNjYW5SZWdpb24uc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgcXJDb2RlU2NhblJlZ2lvbi5zdHlsZS5taW5IZWlnaHQgPSBcIjEwMHB4XCI7XG4gICAgICAgIHFyQ29kZVNjYW5SZWdpb24uc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHFyQ29kZVNjYW5SZWdpb24pO1xuICAgICAgICBpZiAoU2NhblR5cGVTZWxlY3Rvci5pc0NhbWVyYVNjYW5UeXBlKHRoaXMuY3VycmVudFNjYW5UeXBlKSkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRDYW1lcmFTY2FuSW1hZ2VUb1NjYW5SZWdpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RmlsZVNjYW5JbWFnZVRvU2NhblJlZ2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxckNvZGVEYXNoYm9hcmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgZGFzaGJvYXJkSWQgPSB0aGlzLmdldERhc2hib2FyZElkKCk7XG4gICAgICAgIHFyQ29kZURhc2hib2FyZC5pZCA9IGRhc2hib2FyZElkO1xuICAgICAgICBxckNvZGVEYXNoYm9hcmQuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHFyQ29kZURhc2hib2FyZCk7XG4gICAgICAgIHRoaXMuc2V0dXBJbml0aWFsRGFzaGJvYXJkKHFyQ29kZURhc2hib2FyZCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLnJlc2V0QmFzaWNMYXlvdXQgPSBmdW5jdGlvbiAobWFpbkNvbnRhaW5lcikge1xuICAgICAgICBtYWluQ29udGFpbmVyLnN0eWxlLmJvcmRlciA9IFwibm9uZVwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5zZXR1cEluaXRpYWxEYXNoYm9hcmQgPSBmdW5jdGlvbiAoZGFzaGJvYXJkKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlU2VjdGlvbihkYXNoYm9hcmQpO1xuICAgICAgICB0aGlzLmNyZWF0ZVNlY3Rpb25Db250cm9sUGFuZWwoKTtcbiAgICAgICAgaWYgKHRoaXMuc2NhblR5cGVTZWxlY3Rvci5oYXNNb3JlVGhhbk9uZVNjYW5UeXBlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU2VjdGlvblN3YXAoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5jcmVhdGVIZWFkZXIgPSBmdW5jdGlvbiAoZGFzaGJvYXJkKSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBoZWFkZXIuc3R5bGUudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgIGhlYWRlci5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICAgICAgICBkYXNoYm9hcmQuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgICAgICAgdmFyIGxpYnJhcnlJbmZvID0gbmV3IExpYnJhcnlJbmZvQ29udGFpbmVyKCk7XG4gICAgICAgIGxpYnJhcnlJbmZvLnJlbmRlckludG8oaGVhZGVyKTtcbiAgICAgICAgdmFyIGhlYWRlck1lc3NhZ2VDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBoZWFkZXJNZXNzYWdlQ29udGFpbmVyLmlkID0gdGhpcy5nZXRIZWFkZXJNZXNzYWdlQ29udGFpbmVySWQoKTtcbiAgICAgICAgaGVhZGVyTWVzc2FnZUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIGhlYWRlck1lc3NhZ2VDb250YWluZXIuc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgaGVhZGVyTWVzc2FnZUNvbnRhaW5lci5zdHlsZS5mb250U2l6ZSA9IFwiMTRweFwiO1xuICAgICAgICBoZWFkZXJNZXNzYWdlQ29udGFpbmVyLnN0eWxlLnBhZGRpbmcgPSBcIjJweCAxMHB4XCI7XG4gICAgICAgIGhlYWRlck1lc3NhZ2VDb250YWluZXIuc3R5bGUubWFyZ2luID0gXCI0cHhcIjtcbiAgICAgICAgaGVhZGVyTWVzc2FnZUNvbnRhaW5lci5zdHlsZS5ib3JkZXJUb3AgPSBcIjFweCBzb2xpZCAjZjZmNmY2XCI7XG4gICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZChoZWFkZXJNZXNzYWdlQ29udGFpbmVyKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuY3JlYXRlU2VjdGlvbiA9IGZ1bmN0aW9uIChkYXNoYm9hcmQpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzZWN0aW9uLmlkID0gdGhpcy5nZXREYXNoYm9hcmRTZWN0aW9uSWQoKTtcbiAgICAgICAgc2VjdGlvbi5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICBzZWN0aW9uLnN0eWxlLnBhZGRpbmcgPSBcIjEwcHggMHB4IDEwcHggMHB4XCI7XG4gICAgICAgIHNlY3Rpb24uc3R5bGUudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgIGRhc2hib2FyZC5hcHBlbmRDaGlsZChzZWN0aW9uKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuY3JlYXRlQ2FtZXJhTGlzdFVpID0gZnVuY3Rpb24gKHNjcENhbWVyYVNjYW5SZWdpb24sIHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyLCByZXF1ZXN0UGVybWlzc2lvbkJ1dHRvbikge1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICAkdGhpcy5zaG93SGlkZVNjYW5UeXBlU3dhcExpbmsoZmFsc2UpO1xuICAgICAgICAkdGhpcy5zZXRIZWFkZXJNZXNzYWdlKEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuY2FtZXJhUGVybWlzc2lvblJlcXVlc3RpbmcoKSk7XG4gICAgICAgIHZhciBjcmVhdGVQZXJtaXNzaW9uQnV0dG9uSWZOb3RFeGlzdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXJlcXVlc3RQZXJtaXNzaW9uQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuY3JlYXRlUGVybWlzc2lvbkJ1dHRvbihzY3BDYW1lcmFTY2FuUmVnaW9uLCByZXF1ZXN0UGVybWlzc2lvbkNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEh0bWw1UXJjb2RlLmdldENhbWVyYXMoKS50aGVuKGZ1bmN0aW9uIChjYW1lcmFzKSB7XG4gICAgICAgICAgICAkdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlci5zZXRIYXNQZXJtaXNzaW9uKHRydWUpO1xuICAgICAgICAgICAgJHRoaXMuc2hvd0hpZGVTY2FuVHlwZVN3YXBMaW5rKHRydWUpO1xuICAgICAgICAgICAgJHRoaXMucmVzZXRIZWFkZXJNZXNzYWdlKCk7XG4gICAgICAgICAgICBpZiAoY2FtZXJhcyAmJiBjYW1lcmFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzY3BDYW1lcmFTY2FuUmVnaW9uLnJlbW92ZUNoaWxkKHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5yZW5kZXJDYW1lcmFTZWxlY3Rpb24oY2FtZXJhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5zZXRIZWFkZXJNZXNzYWdlKEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Mubm9DYW1lcmFGb3VuZCgpLCBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXMuU1RBVFVTX1dBUk5JTkcpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZVBlcm1pc3Npb25CdXR0b25JZk5vdEV4aXN0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICR0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLnNldEhhc1Blcm1pc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQZXJtaXNzaW9uQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFBlcm1pc3Npb25CdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVBlcm1pc3Npb25CdXR0b25JZk5vdEV4aXN0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHRoaXMuc2V0SGVhZGVyTWVzc2FnZShlcnJvciwgSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzLlNUQVRVU19XQVJOSU5HKTtcbiAgICAgICAgICAgICR0aGlzLnNob3dIaWRlU2NhblR5cGVTd2FwTGluayh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmNyZWF0ZVBlcm1pc3Npb25CdXR0b24gPSBmdW5jdGlvbiAoc2NwQ2FtZXJhU2NhblJlZ2lvbiwgcmVxdWVzdFBlcm1pc3Npb25Db250YWluZXIpIHtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlcXVlc3RQZXJtaXNzaW9uQnV0dG9uID0gQmFzZVVpRWxlbWVudEZhY3RvcnlcbiAgICAgICAgICAgIC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHRoaXMuZ2V0Q2FtZXJhUGVybWlzc2lvbkJ1dHRvbklkKCkpO1xuICAgICAgICByZXF1ZXN0UGVybWlzc2lvbkJ1dHRvbi5pbm5lclRleHRcbiAgICAgICAgICAgID0gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5jYW1lcmFQZXJtaXNzaW9uVGl0bGUoKTtcbiAgICAgICAgcmVxdWVzdFBlcm1pc3Npb25CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RQZXJtaXNzaW9uQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICR0aGlzLmNyZWF0ZUNhbWVyYUxpc3RVaShzY3BDYW1lcmFTY2FuUmVnaW9uLCByZXF1ZXN0UGVybWlzc2lvbkNvbnRhaW5lciwgcmVxdWVzdFBlcm1pc3Npb25CdXR0b24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdFBlcm1pc3Npb25Db250YWluZXIuYXBwZW5kQ2hpbGQocmVxdWVzdFBlcm1pc3Npb25CdXR0b24pO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5jcmVhdGVQZXJtaXNzaW9uc1VpID0gZnVuY3Rpb24gKHNjcENhbWVyYVNjYW5SZWdpb24sIHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyKSB7XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChTY2FuVHlwZVNlbGVjdG9yLmlzQ2FtZXJhU2NhblR5cGUodGhpcy5jdXJyZW50U2NhblR5cGUpXG4gICAgICAgICAgICAmJiB0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLmhhc0NhbWVyYVBlcm1pc3Npb25zKCkpIHtcbiAgICAgICAgICAgIENhbWVyYVBlcm1pc3Npb25zLmhhc1Blcm1pc3Npb25zKCkudGhlbihmdW5jdGlvbiAoaGFzUGVybWlzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUGVybWlzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuY3JlYXRlQ2FtZXJhTGlzdFVpKHNjcENhbWVyYVNjYW5SZWdpb24sIHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLnNldEhhc1Blcm1pc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5jcmVhdGVQZXJtaXNzaW9uQnV0dG9uKHNjcENhbWVyYVNjYW5SZWdpb24sIHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgICR0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLnNldEhhc1Blcm1pc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgICAgICR0aGlzLmNyZWF0ZVBlcm1pc3Npb25CdXR0b24oc2NwQ2FtZXJhU2NhblJlZ2lvbiwgcmVxdWVzdFBlcm1pc3Npb25Db250YWluZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmVhdGVQZXJtaXNzaW9uQnV0dG9uKHNjcENhbWVyYVNjYW5SZWdpb24sIHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuY3JlYXRlU2VjdGlvbkNvbnRyb2xQYW5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmdldERhc2hib2FyZFNlY3Rpb25JZCgpKTtcbiAgICAgICAgdmFyIHNlY3Rpb25Db250cm9sUGFuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzZWN0aW9uLmFwcGVuZENoaWxkKHNlY3Rpb25Db250cm9sUGFuZWwpO1xuICAgICAgICB2YXIgc2NwQ2FtZXJhU2NhblJlZ2lvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHNjcENhbWVyYVNjYW5SZWdpb24uaWQgPSB0aGlzLmdldERhc2hib2FyZFNlY3Rpb25DYW1lcmFTY2FuUmVnaW9uSWQoKTtcbiAgICAgICAgc2NwQ2FtZXJhU2NhblJlZ2lvbi5zdHlsZS5kaXNwbGF5XG4gICAgICAgICAgICA9IFNjYW5UeXBlU2VsZWN0b3IuaXNDYW1lcmFTY2FuVHlwZSh0aGlzLmN1cnJlbnRTY2FuVHlwZSlcbiAgICAgICAgICAgICAgICA/IFwiYmxvY2tcIiA6IFwibm9uZVwiO1xuICAgICAgICBzZWN0aW9uQ29udHJvbFBhbmVsLmFwcGVuZENoaWxkKHNjcENhbWVyYVNjYW5SZWdpb24pO1xuICAgICAgICB2YXIgcmVxdWVzdFBlcm1pc3Npb25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICByZXF1ZXN0UGVybWlzc2lvbkNvbnRhaW5lci5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICBzY3BDYW1lcmFTY2FuUmVnaW9uLmFwcGVuZENoaWxkKHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyKTtcbiAgICAgICAgaWYgKHRoaXMuc2NhblR5cGVTZWxlY3Rvci5pc0NhbWVyYVNjYW5SZXF1aXJlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVBlcm1pc3Npb25zVWkoc2NwQ2FtZXJhU2NhblJlZ2lvbiwgcmVxdWVzdFBlcm1pc3Npb25Db250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyRmlsZVNjYW5VaShzZWN0aW9uQ29udHJvbFBhbmVsKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUucmVuZGVyRmlsZVNjYW5VaSA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIHNob3dPblJlbmRlciA9IFNjYW5UeXBlU2VsZWN0b3IuaXNGaWxlU2NhblR5cGUodGhpcy5jdXJyZW50U2NhblR5cGUpO1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb25GaWxlU2VsZWN0ZWQgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgaWYgKCEkdGhpcy5odG1sNVFyY29kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiaHRtbDVRcmNvZGUgbm90IGRlZmluZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghU2NhblR5cGVTZWxlY3Rvci5pc0ZpbGVTY2FuVHlwZSgkdGhpcy5jdXJyZW50U2NhblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHRoaXMuc2V0SGVhZGVyTWVzc2FnZShIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmxvYWRpbmdJbWFnZSgpKTtcbiAgICAgICAgICAgICR0aGlzLmh0bWw1UXJjb2RlLnNjYW5GaWxlVjIoZmlsZSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoaHRtbDVxcmNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5yZXNldEhlYWRlck1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5xckNvZGVTdWNjZXNzQ2FsbGJhY2soaHRtbDVxcmNvZGVSZXN1bHQuZGVjb2RlZFRleHQsIGh0bWw1cXJjb2RlUmVzdWx0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICR0aGlzLnNldEhlYWRlck1lc3NhZ2UoZXJyb3IsIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cy5TVEFUVVNfV0FSTklORyk7XG4gICAgICAgICAgICAgICAgJHRoaXMucXJDb2RlRXJyb3JDYWxsYmFjayhlcnJvciwgSHRtbDVRcmNvZGVFcnJvckZhY3RvcnkuY3JlYXRlRnJvbShlcnJvcikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmlsZVNlbGVjdGlvblVpID0gRmlsZVNlbGVjdGlvblVpLmNyZWF0ZShwYXJlbnQsIHNob3dPblJlbmRlciwgb25GaWxlU2VsZWN0ZWQpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5yZW5kZXJDYW1lcmFTZWxlY3Rpb24gPSBmdW5jdGlvbiAoY2FtZXJhcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2NwQ2FtZXJhU2NhblJlZ2lvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZ2V0RGFzaGJvYXJkU2VjdGlvbkNhbWVyYVNjYW5SZWdpb25JZCgpKTtcbiAgICAgICAgc2NwQ2FtZXJhU2NhblJlZ2lvbi5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB2YXIgY2FtZXJhWm9vbVVpID0gQ2FtZXJhWm9vbVVpLmNyZWF0ZShzY3BDYW1lcmFTY2FuUmVnaW9uLCBmYWxzZSk7XG4gICAgICAgIHZhciByZW5kZXJDYW1lcmFab29tVWlJZlN1cHBvcnRlZCA9IGZ1bmN0aW9uIChjYW1lcmFDYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgICAgIHZhciB6b29tQ2FwYWJpbGl0eSA9IGNhbWVyYUNhcGFiaWxpdGllcy56b29tRmVhdHVyZSgpO1xuICAgICAgICAgICAgaWYgKCF6b29tQ2FwYWJpbGl0eS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FtZXJhWm9vbVVpLnNldE9uQ2FtZXJhWm9vbVZhbHVlQ2hhbmdlQ2FsbGJhY2soZnVuY3Rpb24gKHpvb21WYWx1ZSkge1xuICAgICAgICAgICAgICAgIHpvb21DYXBhYmlsaXR5LmFwcGx5KHpvb21WYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Wm9vbSA9IDE7XG4gICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLmRlZmF1bHRab29tVmFsdWVJZlN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRab29tID0gX3RoaXMuY29uZmlnLmRlZmF1bHRab29tVmFsdWVJZlN1cHBvcnRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHRab29tID0gY2xpcChkZWZhdWx0Wm9vbSwgem9vbUNhcGFiaWxpdHkubWluKCksIHpvb21DYXBhYmlsaXR5Lm1heCgpKTtcbiAgICAgICAgICAgIGNhbWVyYVpvb21VaS5zZXRWYWx1ZXMoem9vbUNhcGFiaWxpdHkubWluKCksIHpvb21DYXBhYmlsaXR5Lm1heCgpLCBkZWZhdWx0Wm9vbSwgem9vbUNhcGFiaWxpdHkuc3RlcCgpKTtcbiAgICAgICAgICAgIGNhbWVyYVpvb21VaS5zaG93KCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjYW1lcmFTZWxlY3RVaSA9IENhbWVyYVNlbGVjdGlvblVpLmNyZWF0ZShzY3BDYW1lcmFTY2FuUmVnaW9uLCBjYW1lcmFzKTtcbiAgICAgICAgdmFyIGNhbWVyYUFjdGlvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB2YXIgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24gPSBCYXNlVWlFbGVtZW50RmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5DQU1FUkFfU1RBUlRfQlVUVE9OX0lEKTtcbiAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uaW5uZXJUZXh0XG4gICAgICAgICAgICA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Muc2NhbkJ1dHRvblN0YXJ0U2Nhbm5pbmdUZXh0KCk7XG4gICAgICAgIGNhbWVyYUFjdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW1lcmFBY3Rpb25TdGFydEJ1dHRvbik7XG4gICAgICAgIHZhciBjYW1lcmFBY3Rpb25TdG9wQnV0dG9uID0gQmFzZVVpRWxlbWVudEZhY3RvcnkuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuQ0FNRVJBX1NUT1BfQlVUVE9OX0lEKTtcbiAgICAgICAgY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbi5pbm5lclRleHRcbiAgICAgICAgICAgID0gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5zY2FuQnV0dG9uU3RvcFNjYW5uaW5nVGV4dCgpO1xuICAgICAgICBjYW1lcmFBY3Rpb25TdG9wQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIGNhbWVyYUFjdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW1lcmFBY3Rpb25TdG9wQnV0dG9uKTtcbiAgICAgICAgdmFyIHRvcmNoQnV0dG9uO1xuICAgICAgICB2YXIgY3JlYXRlQW5kU2hvd1RvcmNoQnV0dG9uSWZTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoY2FtZXJhQ2FwYWJpbGl0aWVzKSB7XG4gICAgICAgICAgICBpZiAoIWNhbWVyYUNhcGFiaWxpdGllcy50b3JjaEZlYXR1cmUoKS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcmNoQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcmNoQnV0dG9uLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0b3JjaEJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHRvcmNoQnV0dG9uID0gVG9yY2hCdXR0b24uY3JlYXRlKGNhbWVyYUFjdGlvbkNvbnRhaW5lciwgY2FtZXJhQ2FwYWJpbGl0aWVzLnRvcmNoRmVhdHVyZSgpLCB7IGRpc3BsYXk6IFwibm9uZVwiLCBtYXJnaW5MZWZ0OiBcIjVweFwiIH0sIGZ1bmN0aW9uIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuc2V0SGVhZGVyTWVzc2FnZShlcnJvck1lc3NhZ2UsIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cy5TVEFUVVNfV0FSTklORyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3JjaEJ1dHRvbi51cGRhdGVUb3JjaENhcGFiaWxpdHkoY2FtZXJhQ2FwYWJpbGl0aWVzLnRvcmNoRmVhdHVyZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvcmNoQnV0dG9uLnNob3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2NwQ2FtZXJhU2NhblJlZ2lvbi5hcHBlbmRDaGlsZChjYW1lcmFBY3Rpb25Db250YWluZXIpO1xuICAgICAgICB2YXIgcmVzZXRDYW1lcmFBY3Rpb25TdGFydEJ1dHRvbiA9IGZ1bmN0aW9uIChzaG91bGRTaG93KSB7XG4gICAgICAgICAgICBpZiAoIXNob3VsZFNob3cpIHtcbiAgICAgICAgICAgICAgICBjYW1lcmFBY3Rpb25TdGFydEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW1lcmFBY3Rpb25TdGFydEJ1dHRvbi5pbm5lclRleHRcbiAgICAgICAgICAgICAgICA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgLnNjYW5CdXR0b25TdGFydFNjYW5uaW5nVGV4dCgpO1xuICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uc3R5bGUub3BhY2l0eSA9IFwiMVwiO1xuICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaG91bGRTaG93KSB7XG4gICAgICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNhbWVyYUFjdGlvblN0YXJ0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uaW5uZXJUZXh0XG4gICAgICAgICAgICAgICAgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnNjYW5CdXR0b25TY2FubmluZ1N0YXJ0aW5nKCk7XG4gICAgICAgICAgICBjYW1lcmFTZWxlY3RVaS5kaXNhYmxlKCk7XG4gICAgICAgICAgICBjYW1lcmFBY3Rpb25TdGFydEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICBjYW1lcmFBY3Rpb25TdGFydEJ1dHRvbi5zdHlsZS5vcGFjaXR5ID0gXCIwLjVcIjtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zY2FuVHlwZVNlbGVjdG9yLmhhc01vcmVUaGFuT25lU2NhblR5cGUoKSkge1xuICAgICAgICAgICAgICAgICR0aGlzLnNob3dIaWRlU2NhblR5cGVTd2FwTGluayhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkdGhpcy5yZXNldEhlYWRlck1lc3NhZ2UoKTtcbiAgICAgICAgICAgIHZhciBjYW1lcmFJZCA9IGNhbWVyYVNlbGVjdFVpLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAkdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlci5zZXRMYXN0VXNlZENhbWVyYUlkKGNhbWVyYUlkKTtcbiAgICAgICAgICAgICR0aGlzLmh0bWw1UXJjb2RlLnN0YXJ0KGNhbWVyYUlkLCB0b0h0bWw1UXJjb2RlQ2FtZXJhU2NhbkNvbmZpZygkdGhpcy5jb25maWcpLCAkdGhpcy5xckNvZGVTdWNjZXNzQ2FsbGJhY2ssICR0aGlzLnFyQ29kZUVycm9yQ2FsbGJhY2spXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICBjYW1lcmFBY3Rpb25TdG9wQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgICAgICAgICByZXNldENhbWVyYUFjdGlvblN0YXJ0QnV0dG9uKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FtZXJhQ2FwYWJpbGl0aWVzID0gJHRoaXMuaHRtbDVRcmNvZGUuZ2V0UnVubmluZ1RyYWNrQ2FtZXJhQ2FwYWJpbGl0aWVzKCk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbmZpZy5zaG93VG9yY2hCdXR0b25JZlN1cHBvcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVBbmRTaG93VG9yY2hCdXR0b25JZlN1cHBvcnRlZChjYW1lcmFDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLnNob3dab29tU2xpZGVySWZTdXBwb3J0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyQ2FtZXJhWm9vbVVpSWZTdXBwb3J0ZWQoY2FtZXJhQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5zaG93SGlkZVNjYW5UeXBlU3dhcExpbmsodHJ1ZSk7XG4gICAgICAgICAgICAgICAgY2FtZXJhU2VsZWN0VWkuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgcmVzZXRDYW1lcmFBY3Rpb25TdGFydEJ1dHRvbih0cnVlKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5zZXRIZWFkZXJNZXNzYWdlKGVycm9yLCBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXMuU1RBVFVTX1dBUk5JTkcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FtZXJhU2VsZWN0VWkuaGFzU2luZ2xlSXRlbSgpKSB7XG4gICAgICAgICAgICBjYW1lcmFBY3Rpb25TdGFydEJ1dHRvbi5jbGljaygpO1xuICAgICAgICB9XG4gICAgICAgIGNhbWVyYUFjdGlvblN0b3BCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoISR0aGlzLmh0bWw1UXJjb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJodG1sNVFyY29kZSBub3QgZGVmaW5lZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAkdGhpcy5odG1sNVFyY29kZS5zdG9wKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zY2FuVHlwZVNlbGVjdG9yLmhhc01vcmVUaGFuT25lU2NhblR5cGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5zaG93SGlkZVNjYW5UeXBlU3dhcExpbmsodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbWVyYVNlbGVjdFVpLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIGNhbWVyYUFjdGlvblN0YXJ0QnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgICAgICAgICAgaWYgKHRvcmNoQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcmNoQnV0dG9uLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRvcmNoQnV0dG9uLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FtZXJhWm9vbVVpLnJlbW92ZU9uQ2FtZXJhWm9vbVZhbHVlQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICBjYW1lcmFab29tVWkuaGlkZSgpO1xuICAgICAgICAgICAgICAgICR0aGlzLmluc2VydENhbWVyYVNjYW5JbWFnZVRvU2NhblJlZ2lvbigpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICR0aGlzLnNldEhlYWRlck1lc3NhZ2UoZXJyb3IsIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cy5TVEFUVVNfV0FSTklORyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgkdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlci5nZXRMYXN0VXNlZENhbWVyYUlkKCkpIHtcbiAgICAgICAgICAgIHZhciBjYW1lcmFJZCA9ICR0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLmdldExhc3RVc2VkQ2FtZXJhSWQoKTtcbiAgICAgICAgICAgIGlmIChjYW1lcmFTZWxlY3RVaS5oYXNWYWx1ZShjYW1lcmFJZCkpIHtcbiAgICAgICAgICAgICAgICBjYW1lcmFTZWxlY3RVaS5zZXRWYWx1ZShjYW1lcmFJZCk7XG4gICAgICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICR0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLnJlc2V0TGFzdFVzZWRDYW1lcmFJZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmNyZWF0ZVNlY3Rpb25Td2FwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgVEVYVF9JRl9DQU1FUkFfU0NBTl9TRUxFQ1RFRCA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MudGV4dElmQ2FtZXJhU2NhblNlbGVjdGVkKCk7XG4gICAgICAgIHZhciBURVhUX0lGX0ZJTEVfU0NBTl9TRUxFQ1RFRCA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MudGV4dElmRmlsZVNjYW5TZWxlY3RlZCgpO1xuICAgICAgICB2YXIgc2VjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZ2V0RGFzaGJvYXJkU2VjdGlvbklkKCkpO1xuICAgICAgICB2YXIgc3dpdGNoQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgc3dpdGNoQ29udGFpbmVyLnN0eWxlLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIHZhciBzd2l0Y2hTY2FuVHlwZUxpbmsgPSBCYXNlVWlFbGVtZW50RmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB0aGlzLmdldERhc2hib2FyZFNlY3Rpb25Td2FwTGlua0lkKCkpO1xuICAgICAgICBzd2l0Y2hTY2FuVHlwZUxpbmsuc3R5bGUudGV4dERlY29yYXRpb24gPSBcInVuZGVybGluZVwiO1xuICAgICAgICBzd2l0Y2hTY2FuVHlwZUxpbmsuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG4gICAgICAgIHN3aXRjaFNjYW5UeXBlTGluay5pbm5lclRleHRcbiAgICAgICAgICAgID0gU2NhblR5cGVTZWxlY3Rvci5pc0NhbWVyYVNjYW5UeXBlKHRoaXMuY3VycmVudFNjYW5UeXBlKVxuICAgICAgICAgICAgICAgID8gVEVYVF9JRl9DQU1FUkFfU0NBTl9TRUxFQ1RFRCA6IFRFWFRfSUZfRklMRV9TQ0FOX1NFTEVDVEVEO1xuICAgICAgICBzd2l0Y2hTY2FuVHlwZUxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghJHRoaXMuc2VjdGlvblN3YXBBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCR0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiU2VjdGlvbiBzd2FwIGNhbGxlZCB3aGVuIG5vdCBhbGxvd2VkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkdGhpcy5yZXNldEhlYWRlck1lc3NhZ2UoKTtcbiAgICAgICAgICAgICR0aGlzLmZpbGVTZWxlY3Rpb25VaS5yZXNldFZhbHVlKCk7XG4gICAgICAgICAgICAkdGhpcy5zZWN0aW9uU3dhcEFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChTY2FuVHlwZVNlbGVjdG9yLmlzQ2FtZXJhU2NhblR5cGUoJHRoaXMuY3VycmVudFNjYW5UeXBlKSkge1xuICAgICAgICAgICAgICAgICR0aGlzLmNsZWFyU2NhblJlZ2lvbigpO1xuICAgICAgICAgICAgICAgICR0aGlzLmdldENhbWVyYVNjYW5SZWdpb24oKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgJHRoaXMuZmlsZVNlbGVjdGlvblVpLnNob3coKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hTY2FuVHlwZUxpbmsuaW5uZXJUZXh0ID0gVEVYVF9JRl9GSUxFX1NDQU5fU0VMRUNURUQ7XG4gICAgICAgICAgICAgICAgJHRoaXMuY3VycmVudFNjYW5UeXBlID0gSHRtbDVRcmNvZGVTY2FuVHlwZS5TQ0FOX1RZUEVfRklMRTtcbiAgICAgICAgICAgICAgICAkdGhpcy5pbnNlcnRGaWxlU2NhbkltYWdlVG9TY2FuUmVnaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5jbGVhclNjYW5SZWdpb24oKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5nZXRDYW1lcmFTY2FuUmVnaW9uKCkuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgICAgICAkdGhpcy5maWxlU2VsZWN0aW9uVWkuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHN3aXRjaFNjYW5UeXBlTGluay5pbm5lclRleHQgPSBURVhUX0lGX0NBTUVSQV9TQ0FOX1NFTEVDVEVEO1xuICAgICAgICAgICAgICAgICR0aGlzLmN1cnJlbnRTY2FuVHlwZSA9IEh0bWw1UXJjb2RlU2NhblR5cGUuU0NBTl9UWVBFX0NBTUVSQTtcbiAgICAgICAgICAgICAgICAkdGhpcy5pbnNlcnRDYW1lcmFTY2FuSW1hZ2VUb1NjYW5SZWdpb24oKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5zdGFydENhbWVyYVNjYW5JZlBlcm1pc3Npb25FeGlzdHNPblN3YXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR0aGlzLnNlY3Rpb25Td2FwQWxsb3dlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBzd2l0Y2hDb250YWluZXIuYXBwZW5kQ2hpbGQoc3dpdGNoU2NhblR5cGVMaW5rKTtcbiAgICAgICAgc2VjdGlvbi5hcHBlbmRDaGlsZChzd2l0Y2hDb250YWluZXIpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5zdGFydENhbWVyYVNjYW5JZlBlcm1pc3Npb25FeGlzdHNPblN3YXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLmhhc0NhbWVyYVBlcm1pc3Npb25zKCkpIHtcbiAgICAgICAgICAgIENhbWVyYVBlcm1pc3Npb25zLmhhc1Blcm1pc3Npb25zKCkudGhlbihmdW5jdGlvbiAoaGFzUGVybWlzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUGVybWlzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcm1pc3Npb25CdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgkdGhpcy5nZXRDYW1lcmFQZXJtaXNzaW9uQnV0dG9uSWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGVybWlzc2lvbkJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiUGVybWlzc2lvbiBidXR0b24gbm90IGZvdW5kLCBmYWlsO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiUGVybWlzc2lvbiBidXR0b24gbm90IGZvdW5kXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbkJ1dHRvbi5jbGljaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMucGVyc2lzdGVkRGF0YU1hbmFnZXIuc2V0SGFzUGVybWlzc2lvbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlci5zZXRIYXNQZXJtaXNzaW9uKGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLnJlc2V0SGVhZGVyTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmdldEhlYWRlck1lc3NhZ2VDb250YWluZXJJZCgpKTtcbiAgICAgICAgbWVzc2FnZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLnNldEhlYWRlck1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZVRleHQsIHNjYW5uZXJTdGF0dXMpIHtcbiAgICAgICAgaWYgKCFzY2FubmVyU3RhdHVzKSB7XG4gICAgICAgICAgICBzY2FubmVyU3RhdHVzID0gSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzLlNUQVRVU19ERUZBVUxUO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXNzYWdlRGl2ID0gdGhpcy5nZXRIZWFkZXJNZXNzYWdlRGl2KCk7XG4gICAgICAgIG1lc3NhZ2VEaXYuaW5uZXJUZXh0ID0gbWVzc2FnZVRleHQ7XG4gICAgICAgIG1lc3NhZ2VEaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgc3dpdGNoIChzY2FubmVyU3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cy5TVEFUVVNfU1VDQ0VTUzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlRGl2LnN0eWxlLmJhY2tncm91bmQgPSBcInJnYmEoMTA2LCAxNzUsIDgwLCAwLjI2KVwiO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VEaXYuc3R5bGUuY29sb3IgPSBcIiM0Nzc3MzVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzLlNUQVRVU19XQVJOSU5HOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2VEaXYuc3R5bGUuYmFja2dyb3VuZCA9IFwicmdiYSgyMDMsIDM2LCA0OSwgMC4xNClcIjtcbiAgICAgICAgICAgICAgICBtZXNzYWdlRGl2LnN0eWxlLmNvbG9yID0gXCIjY2IyNDMxXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cy5TVEFUVVNfREVGQVVMVDpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbWVzc2FnZURpdi5zdHlsZS5iYWNrZ3JvdW5kID0gXCJyZ2JhKDAsIDAsIDAsIDApXCI7XG4gICAgICAgICAgICAgICAgbWVzc2FnZURpdi5zdHlsZS5jb2xvciA9IFwicmdiKDE3LCAxNywgMTcpXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuc2hvd0hpZGVTY2FuVHlwZVN3YXBMaW5rID0gZnVuY3Rpb24gKHNob3VsZERpc3BsYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NhblR5cGVTZWxlY3Rvci5oYXNNb3JlVGhhbk9uZVNjYW5UeXBlKCkpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGREaXNwbGF5ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkRGlzcGxheSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3dhcEFsbG93ZWQgPSBzaG91bGREaXNwbGF5O1xuICAgICAgICAgICAgdGhpcy5nZXREYXNoYm9hcmRTZWN0aW9uU3dhcExpbmsoKS5zdHlsZS5kaXNwbGF5XG4gICAgICAgICAgICAgICAgPSBzaG91bGREaXNwbGF5ID8gXCJpbmxpbmUtYmxvY2tcIiA6IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmluc2VydENhbWVyYVNjYW5JbWFnZVRvU2NhblJlZ2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHFyQ29kZVNjYW5SZWdpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmdldFNjYW5SZWdpb25JZCgpKTtcbiAgICAgICAgaWYgKHRoaXMuY2FtZXJhU2NhbkltYWdlKSB7XG4gICAgICAgICAgICBxckNvZGVTY2FuUmVnaW9uLmlubmVySFRNTCA9IFwiPGJyPlwiO1xuICAgICAgICAgICAgcXJDb2RlU2NhblJlZ2lvbi5hcHBlbmRDaGlsZCh0aGlzLmNhbWVyYVNjYW5JbWFnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW1lcmFTY2FuSW1hZ2UgPSBuZXcgSW1hZ2U7XG4gICAgICAgIHRoaXMuY2FtZXJhU2NhbkltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBxckNvZGVTY2FuUmVnaW9uLmlubmVySFRNTCA9IFwiPGJyPlwiO1xuICAgICAgICAgICAgcXJDb2RlU2NhblJlZ2lvbi5hcHBlbmRDaGlsZCgkdGhpcy5jYW1lcmFTY2FuSW1hZ2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNhbWVyYVNjYW5JbWFnZS53aWR0aCA9IDY0O1xuICAgICAgICB0aGlzLmNhbWVyYVNjYW5JbWFnZS5zdHlsZS5vcGFjaXR5ID0gXCIwLjhcIjtcbiAgICAgICAgdGhpcy5jYW1lcmFTY2FuSW1hZ2Uuc3JjID0gQVNTRVRfQ0FNRVJBX1NDQU47XG4gICAgICAgIHRoaXMuY2FtZXJhU2NhbkltYWdlLmFsdCA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuY2FtZXJhU2NhbkFsdFRleHQoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuaW5zZXJ0RmlsZVNjYW5JbWFnZVRvU2NhblJlZ2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHFyQ29kZVNjYW5SZWdpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmdldFNjYW5SZWdpb25JZCgpKTtcbiAgICAgICAgaWYgKHRoaXMuZmlsZVNjYW5JbWFnZSkge1xuICAgICAgICAgICAgcXJDb2RlU2NhblJlZ2lvbi5pbm5lckhUTUwgPSBcIjxicj5cIjtcbiAgICAgICAgICAgIHFyQ29kZVNjYW5SZWdpb24uYXBwZW5kQ2hpbGQodGhpcy5maWxlU2NhbkltYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbGVTY2FuSW1hZ2UgPSBuZXcgSW1hZ2U7XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcXJDb2RlU2NhblJlZ2lvbi5pbm5lckhUTUwgPSBcIjxicj5cIjtcbiAgICAgICAgICAgIHFyQ29kZVNjYW5SZWdpb24uYXBwZW5kQ2hpbGQoJHRoaXMuZmlsZVNjYW5JbWFnZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbWFnZS53aWR0aCA9IDY0O1xuICAgICAgICB0aGlzLmZpbGVTY2FuSW1hZ2Uuc3R5bGUub3BhY2l0eSA9IFwiMC44XCI7XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbWFnZS5zcmMgPSBBU1NFVF9GSUxFX1NDQU47XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbWFnZS5hbHQgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmZpbGVTY2FuQWx0VGV4dCgpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5jbGVhclNjYW5SZWdpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBxckNvZGVTY2FuUmVnaW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5nZXRTY2FuUmVnaW9uSWQoKSk7XG4gICAgICAgIHFyQ29kZVNjYW5SZWdpb24uaW5uZXJIVE1MID0gXCJcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0RGFzaGJvYXJkU2VjdGlvbklkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5lbGVtZW50SWQsIFwiX19kYXNoYm9hcmRfc2VjdGlvblwiKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0RGFzaGJvYXJkU2VjdGlvbkNhbWVyYVNjYW5SZWdpb25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuZWxlbWVudElkLCBcIl9fZGFzaGJvYXJkX3NlY3Rpb25fY3NyXCIpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5nZXREYXNoYm9hcmRTZWN0aW9uU3dhcExpbmtJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5TQ0FOX1RZUEVfQ0hBTkdFX0FOQ0hPUl9JRDtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0U2NhblJlZ2lvbklkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5lbGVtZW50SWQsIFwiX19zY2FuX3JlZ2lvblwiKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0RGFzaGJvYXJkSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLmVsZW1lbnRJZCwgXCJfX2Rhc2hib2FyZFwiKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0SGVhZGVyTWVzc2FnZUNvbnRhaW5lcklkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5lbGVtZW50SWQsIFwiX19oZWFkZXJfbWVzc2FnZVwiKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0Q2FtZXJhUGVybWlzc2lvbkJ1dHRvbklkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLkNBTUVSQV9QRVJNSVNTSU9OX0JVVFRPTl9JRDtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0Q2FtZXJhU2NhblJlZ2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZ2V0RGFzaGJvYXJkU2VjdGlvbkNhbWVyYVNjYW5SZWdpb25JZCgpKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0RGFzaGJvYXJkU2VjdGlvblN3YXBMaW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5nZXREYXNoYm9hcmRTZWN0aW9uU3dhcExpbmtJZCgpKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0SGVhZGVyTWVzc2FnZURpdiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZ2V0SGVhZGVyTWVzc2FnZUNvbnRhaW5lcklkKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWw1UXJjb2RlU2Nhbm5lcjtcbn0oKSk7XG5leHBvcnQgeyBIdG1sNVFyY29kZVNjYW5uZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0bWw1LXFyY29kZS1zY2FubmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/html5-qrcode-scanner.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/html5-qrcode.js":
/*!*******************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/html5-qrcode.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5Qrcode: function() { return /* binding */ Html5Qrcode; }\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"./node_modules/html5-qrcode/esm/core.js\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./strings */ \"./node_modules/html5-qrcode/esm/strings.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/html5-qrcode/esm/utils.js\");\n/* harmony import */ var _code_decoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./code-decoder */ \"./node_modules/html5-qrcode/esm/code-decoder.js\");\n/* harmony import */ var _camera_factories__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./camera/factories */ \"./node_modules/html5-qrcode/esm/camera/factories.js\");\n/* harmony import */ var _camera_retriever__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./camera/retriever */ \"./node_modules/html5-qrcode/esm/camera/retriever.js\");\n/* harmony import */ var _state_manager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./state-manager */ \"./node_modules/html5-qrcode/esm/state-manager.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\nvar Constants = (function (_super) {\n    __extends(Constants, _super);\n    function Constants() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Constants.DEFAULT_WIDTH = 300;\n    Constants.DEFAULT_WIDTH_OFFSET = 2;\n    Constants.FILE_SCAN_MIN_HEIGHT = 300;\n    Constants.FILE_SCAN_HIDDEN_CANVAS_PADDING = 100;\n    Constants.MIN_QR_BOX_SIZE = 50;\n    Constants.SHADED_LEFT = 1;\n    Constants.SHADED_RIGHT = 2;\n    Constants.SHADED_TOP = 3;\n    Constants.SHADED_BOTTOM = 4;\n    Constants.SHADED_REGION_ELEMENT_ID = \"qr-shaded-region\";\n    Constants.VERBOSE = false;\n    Constants.BORDER_SHADER_DEFAULT_COLOR = \"#ffffff\";\n    Constants.BORDER_SHADER_MATCH_COLOR = \"rgb(90, 193, 56)\";\n    return Constants;\n}(_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants));\nvar InternalHtml5QrcodeConfig = (function () {\n    function InternalHtml5QrcodeConfig(config, logger) {\n        this.logger = logger;\n        this.fps = Constants.SCAN_DEFAULT_FPS;\n        if (!config) {\n            this.disableFlip = Constants.DEFAULT_DISABLE_FLIP;\n        }\n        else {\n            if (config.fps) {\n                this.fps = config.fps;\n            }\n            this.disableFlip = config.disableFlip === true;\n            this.qrbox = config.qrbox;\n            this.aspectRatio = config.aspectRatio;\n            this.videoConstraints = config.videoConstraints;\n        }\n    }\n    InternalHtml5QrcodeConfig.prototype.isMediaStreamConstraintsValid = function () {\n        if (!this.videoConstraints) {\n            this.logger.logError(\"Empty videoConstraints\", true);\n            return false;\n        }\n        return _utils__WEBPACK_IMPORTED_MODULE_2__.VideoConstraintsUtil.isMediaStreamConstraintsValid(this.videoConstraints, this.logger);\n    };\n    InternalHtml5QrcodeConfig.prototype.isShadedBoxEnabled = function () {\n        return !(0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.qrbox);\n    };\n    InternalHtml5QrcodeConfig.create = function (config, logger) {\n        return new InternalHtml5QrcodeConfig(config, logger);\n    };\n    return InternalHtml5QrcodeConfig;\n}());\nvar Html5Qrcode = (function () {\n    function Html5Qrcode(elementId, configOrVerbosityFlag) {\n        this.element = null;\n        this.canvasElement = null;\n        this.scannerPausedUiElement = null;\n        this.hasBorderShaders = null;\n        this.borderShaders = null;\n        this.qrMatch = null;\n        this.renderedCamera = null;\n        this.qrRegion = null;\n        this.context = null;\n        this.lastScanImageFile = null;\n        this.isScanning = false;\n        if (!document.getElementById(elementId)) {\n            throw \"HTML Element with id=\".concat(elementId, \" not found\");\n        }\n        this.elementId = elementId;\n        this.verbose = false;\n        var experimentalFeatureConfig;\n        var configObject;\n        if (typeof configOrVerbosityFlag == \"boolean\") {\n            this.verbose = configOrVerbosityFlag === true;\n        }\n        else if (configOrVerbosityFlag) {\n            configObject = configOrVerbosityFlag;\n            this.verbose = configObject.verbose === true;\n            experimentalFeatureConfig = configObject.experimentalFeatures;\n        }\n        this.logger = new _core__WEBPACK_IMPORTED_MODULE_0__.BaseLoggger(this.verbose);\n        this.qrcode = new _code_decoder__WEBPACK_IMPORTED_MODULE_3__.Html5QrcodeShim(this.getSupportedFormats(configOrVerbosityFlag), this.getUseBarCodeDetectorIfSupported(configObject), this.verbose, this.logger);\n        this.foreverScanTimeout;\n        this.shouldScan = true;\n        this.stateManagerProxy = _state_manager__WEBPACK_IMPORTED_MODULE_6__.StateManagerFactory.create();\n    }\n    Html5Qrcode.prototype.start = function (cameraIdOrConfig, configuration, qrCodeSuccessCallback, qrCodeErrorCallback) {\n        var _this = this;\n        if (!cameraIdOrConfig) {\n            throw \"cameraIdOrConfig is required\";\n        }\n        if (!qrCodeSuccessCallback\n            || typeof qrCodeSuccessCallback != \"function\") {\n            throw \"qrCodeSuccessCallback is required and should be a function.\";\n        }\n        var qrCodeErrorCallbackInternal;\n        if (qrCodeErrorCallback) {\n            qrCodeErrorCallbackInternal = qrCodeErrorCallback;\n        }\n        else {\n            qrCodeErrorCallbackInternal\n                = this.verbose ? this.logger.log : function () { };\n        }\n        var internalConfig = InternalHtml5QrcodeConfig.create(configuration, this.logger);\n        this.clearElement();\n        var videoConstraintsAvailableAndValid = false;\n        if (internalConfig.videoConstraints) {\n            if (!internalConfig.isMediaStreamConstraintsValid()) {\n                this.logger.logError(\"'videoConstraints' is not valid 'MediaStreamConstraints, \"\n                    + \"it will be ignored.'\", true);\n            }\n            else {\n                videoConstraintsAvailableAndValid = true;\n            }\n        }\n        var areVideoConstraintsEnabled = videoConstraintsAvailableAndValid;\n        var element = document.getElementById(this.elementId);\n        var rootElementWidth = element.clientWidth\n            ? element.clientWidth : Constants.DEFAULT_WIDTH;\n        element.style.position = \"relative\";\n        this.shouldScan = true;\n        this.element = element;\n        var $this = this;\n        var toScanningStateChangeTransaction = this.stateManagerProxy.startTransition(_state_manager__WEBPACK_IMPORTED_MODULE_6__.Html5QrcodeScannerState.SCANNING);\n        return new Promise(function (resolve, reject) {\n            var videoConstraints = areVideoConstraintsEnabled\n                ? internalConfig.videoConstraints\n                : $this.createVideoConstraints(cameraIdOrConfig);\n            if (!videoConstraints) {\n                toScanningStateChangeTransaction.cancel();\n                reject(\"videoConstraints should be defined\");\n                return;\n            }\n            var cameraRenderingOptions = {};\n            if (!areVideoConstraintsEnabled || internalConfig.aspectRatio) {\n                cameraRenderingOptions.aspectRatio = internalConfig.aspectRatio;\n            }\n            var renderingCallbacks = {\n                onRenderSurfaceReady: function (viewfinderWidth, viewfinderHeight) {\n                    $this.setupUi(viewfinderWidth, viewfinderHeight, internalConfig);\n                    $this.isScanning = true;\n                    $this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallbackInternal);\n                }\n            };\n            _camera_factories__WEBPACK_IMPORTED_MODULE_4__.CameraFactory.failIfNotSupported().then(function (factory) {\n                factory.create(videoConstraints).then(function (camera) {\n                    return camera.render(_this.element, cameraRenderingOptions, renderingCallbacks)\n                        .then(function (renderedCamera) {\n                        $this.renderedCamera = renderedCamera;\n                        toScanningStateChangeTransaction.execute();\n                        resolve(null);\n                    })\n                        .catch(function (error) {\n                        toScanningStateChangeTransaction.cancel();\n                        reject(error);\n                    });\n                }).catch(function (error) {\n                    toScanningStateChangeTransaction.cancel();\n                    reject(_strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeStrings.errorGettingUserMedia(error));\n                });\n            }).catch(function (_) {\n                toScanningStateChangeTransaction.cancel();\n                reject(_strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeStrings.cameraStreamingNotSupported());\n            });\n        });\n    };\n    Html5Qrcode.prototype.pause = function (shouldPauseVideo) {\n        if (!this.stateManagerProxy.isStrictlyScanning()) {\n            throw \"Cannot pause, scanner is not scanning.\";\n        }\n        this.stateManagerProxy.directTransition(_state_manager__WEBPACK_IMPORTED_MODULE_6__.Html5QrcodeScannerState.PAUSED);\n        this.showPausedState();\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(shouldPauseVideo) || shouldPauseVideo !== true) {\n            shouldPauseVideo = false;\n        }\n        if (shouldPauseVideo && this.renderedCamera) {\n            this.renderedCamera.pause();\n        }\n    };\n    Html5Qrcode.prototype.resume = function () {\n        if (!this.stateManagerProxy.isPaused()) {\n            throw \"Cannot result, scanner is not paused.\";\n        }\n        if (!this.renderedCamera) {\n            throw \"renderedCamera doesn't exist while trying resume()\";\n        }\n        var $this = this;\n        var transitionToScanning = function () {\n            $this.stateManagerProxy.directTransition(_state_manager__WEBPACK_IMPORTED_MODULE_6__.Html5QrcodeScannerState.SCANNING);\n            $this.hidePausedState();\n        };\n        if (!this.renderedCamera.isPaused()) {\n            transitionToScanning();\n            return;\n        }\n        this.renderedCamera.resume(function () {\n            transitionToScanning();\n        });\n    };\n    Html5Qrcode.prototype.getState = function () {\n        return this.stateManagerProxy.getState();\n    };\n    Html5Qrcode.prototype.stop = function () {\n        var _this = this;\n        if (!this.stateManagerProxy.isScanning()) {\n            throw \"Cannot stop, scanner is not running or paused.\";\n        }\n        var toStoppedStateTransaction = this.stateManagerProxy.startTransition(_state_manager__WEBPACK_IMPORTED_MODULE_6__.Html5QrcodeScannerState.NOT_STARTED);\n        this.shouldScan = false;\n        if (this.foreverScanTimeout) {\n            clearTimeout(this.foreverScanTimeout);\n        }\n        var removeQrRegion = function () {\n            if (!_this.element) {\n                return;\n            }\n            var childElement = document.getElementById(Constants.SHADED_REGION_ELEMENT_ID);\n            if (childElement) {\n                _this.element.removeChild(childElement);\n            }\n        };\n        var $this = this;\n        return this.renderedCamera.close().then(function () {\n            $this.renderedCamera = null;\n            if ($this.element) {\n                $this.element.removeChild($this.canvasElement);\n                $this.canvasElement = null;\n            }\n            removeQrRegion();\n            if ($this.qrRegion) {\n                $this.qrRegion = null;\n            }\n            if ($this.context) {\n                $this.context = null;\n            }\n            toStoppedStateTransaction.execute();\n            $this.hidePausedState();\n            $this.isScanning = false;\n            return Promise.resolve();\n        });\n    };\n    Html5Qrcode.prototype.scanFile = function (imageFile, showImage) {\n        return this.scanFileV2(imageFile, showImage)\n            .then(function (html5qrcodeResult) { return html5qrcodeResult.decodedText; });\n    };\n    Html5Qrcode.prototype.scanFileV2 = function (imageFile, showImage) {\n        var _this = this;\n        if (!imageFile || !(imageFile instanceof File)) {\n            throw \"imageFile argument is mandatory and should be instance \"\n                + \"of File. Use 'event.target.files[0]'.\";\n        }\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(showImage)) {\n            showImage = true;\n        }\n        if (!this.stateManagerProxy.canScanFile()) {\n            throw \"Cannot start file scan - ongoing camera scan\";\n        }\n        return new Promise(function (resolve, reject) {\n            _this.possiblyCloseLastScanImageFile();\n            _this.clearElement();\n            _this.lastScanImageFile = URL.createObjectURL(imageFile);\n            var inputImage = new Image;\n            inputImage.onload = function () {\n                var imageWidth = inputImage.width;\n                var imageHeight = inputImage.height;\n                var element = document.getElementById(_this.elementId);\n                var containerWidth = element.clientWidth\n                    ? element.clientWidth : Constants.DEFAULT_WIDTH;\n                var containerHeight = Math.max(element.clientHeight ? element.clientHeight : imageHeight, Constants.FILE_SCAN_MIN_HEIGHT);\n                var config = _this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);\n                if (showImage) {\n                    var visibleCanvas = _this.createCanvasElement(containerWidth, containerHeight, \"qr-canvas-visible\");\n                    visibleCanvas.style.display = \"inline-block\";\n                    element.appendChild(visibleCanvas);\n                    var context_1 = visibleCanvas.getContext(\"2d\");\n                    if (!context_1) {\n                        throw \"Unable to get 2d context from canvas\";\n                    }\n                    context_1.canvas.width = containerWidth;\n                    context_1.canvas.height = containerHeight;\n                    context_1.drawImage(inputImage, 0, 0, imageWidth, imageHeight, config.x, config.y, config.width, config.height);\n                }\n                var padding = Constants.FILE_SCAN_HIDDEN_CANVAS_PADDING;\n                var hiddenImageWidth = Math.max(inputImage.width, config.width);\n                var hiddenImageHeight = Math.max(inputImage.height, config.height);\n                var hiddenCanvasWidth = hiddenImageWidth + 2 * padding;\n                var hiddenCanvasHeight = hiddenImageHeight + 2 * padding;\n                var hiddenCanvas = _this.createCanvasElement(hiddenCanvasWidth, hiddenCanvasHeight);\n                element.appendChild(hiddenCanvas);\n                var context = hiddenCanvas.getContext(\"2d\");\n                if (!context) {\n                    throw \"Unable to get 2d context from canvas\";\n                }\n                context.canvas.width = hiddenCanvasWidth;\n                context.canvas.height = hiddenCanvasHeight;\n                context.drawImage(inputImage, 0, 0, imageWidth, imageHeight, padding, padding, hiddenImageWidth, hiddenImageHeight);\n                try {\n                    _this.qrcode.decodeRobustlyAsync(hiddenCanvas)\n                        .then(function (result) {\n                        resolve(_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeResultFactory.createFromQrcodeResult(result));\n                    })\n                        .catch(reject);\n                }\n                catch (exception) {\n                    reject(\"QR code parse error, error = \".concat(exception));\n                }\n            };\n            inputImage.onerror = reject;\n            inputImage.onabort = reject;\n            inputImage.onstalled = reject;\n            inputImage.onsuspend = reject;\n            inputImage.src = URL.createObjectURL(imageFile);\n        });\n    };\n    Html5Qrcode.prototype.clear = function () {\n        this.clearElement();\n    };\n    Html5Qrcode.getCameras = function () {\n        return _camera_retriever__WEBPACK_IMPORTED_MODULE_5__.CameraRetriever.retrieve();\n    };\n    Html5Qrcode.prototype.getRunningTrackCapabilities = function () {\n        return this.getRenderedCameraOrFail().getRunningTrackCapabilities();\n    };\n    Html5Qrcode.prototype.getRunningTrackSettings = function () {\n        return this.getRenderedCameraOrFail().getRunningTrackSettings();\n    };\n    Html5Qrcode.prototype.getRunningTrackCameraCapabilities = function () {\n        return this.getRenderedCameraOrFail().getCapabilities();\n    };\n    Html5Qrcode.prototype.applyVideoConstraints = function (videoConstaints) {\n        if (!videoConstaints) {\n            throw \"videoConstaints is required argument.\";\n        }\n        else if (!_utils__WEBPACK_IMPORTED_MODULE_2__.VideoConstraintsUtil.isMediaStreamConstraintsValid(videoConstaints, this.logger)) {\n            throw \"invalid videoConstaints passed, check logs for more details\";\n        }\n        return this.getRenderedCameraOrFail().applyVideoConstraints(videoConstaints);\n    };\n    Html5Qrcode.prototype.getRenderedCameraOrFail = function () {\n        if (this.renderedCamera == null) {\n            throw \"Scanning is not in running state, call this API only when\"\n                + \" QR code scanning using camera is in running state.\";\n        }\n        return this.renderedCamera;\n    };\n    Html5Qrcode.prototype.getSupportedFormats = function (configOrVerbosityFlag) {\n        var allFormats = [\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.QR_CODE,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.AZTEC,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODABAR,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_39,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_93,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_128,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.DATA_MATRIX,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.MAXICODE,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.ITF,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.EAN_13,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.EAN_8,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.PDF_417,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.RSS_14,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.RSS_EXPANDED,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.UPC_A,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.UPC_E,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION,\n        ];\n        if (!configOrVerbosityFlag\n            || typeof configOrVerbosityFlag == \"boolean\") {\n            return allFormats;\n        }\n        if (!configOrVerbosityFlag.formatsToSupport) {\n            return allFormats;\n        }\n        if (!Array.isArray(configOrVerbosityFlag.formatsToSupport)) {\n            throw \"configOrVerbosityFlag.formatsToSupport should be undefined \"\n                + \"or an array.\";\n        }\n        if (configOrVerbosityFlag.formatsToSupport.length === 0) {\n            throw \"Atleast 1 formatsToSupport is needed.\";\n        }\n        var supportedFormats = [];\n        for (var _i = 0, _a = configOrVerbosityFlag.formatsToSupport; _i < _a.length; _i++) {\n            var format = _a[_i];\n            if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isValidHtml5QrcodeSupportedFormats)(format)) {\n                supportedFormats.push(format);\n            }\n            else {\n                this.logger.warn(\"Invalid format: \".concat(format, \" passed in config, ignoring.\"));\n            }\n        }\n        if (supportedFormats.length === 0) {\n            throw \"None of formatsToSupport match supported values.\";\n        }\n        return supportedFormats;\n    };\n    Html5Qrcode.prototype.getUseBarCodeDetectorIfSupported = function (config) {\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(config)) {\n            return true;\n        }\n        if (!(0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(config.useBarCodeDetectorIfSupported)) {\n            return config.useBarCodeDetectorIfSupported !== false;\n        }\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(config.experimentalFeatures)) {\n            return true;\n        }\n        var experimentalFeatures = config.experimentalFeatures;\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(experimentalFeatures.useBarCodeDetectorIfSupported)) {\n            return true;\n        }\n        return experimentalFeatures.useBarCodeDetectorIfSupported !== false;\n    };\n    Html5Qrcode.prototype.validateQrboxSize = function (viewfinderWidth, viewfinderHeight, internalConfig) {\n        var _this = this;\n        var qrboxSize = internalConfig.qrbox;\n        this.validateQrboxConfig(qrboxSize);\n        var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);\n        var validateMinSize = function (size) {\n            if (size < Constants.MIN_QR_BOX_SIZE) {\n                throw \"minimum size of 'config.qrbox' dimension value is\"\n                    + \" \".concat(Constants.MIN_QR_BOX_SIZE, \"px.\");\n            }\n        };\n        var correctWidthBasedOnRootElementSize = function (configWidth) {\n            if (configWidth > viewfinderWidth) {\n                _this.logger.warn(\"`qrbox.width` or `qrbox` is larger than the\"\n                    + \" width of the root element. The width will be truncated\"\n                    + \" to the width of root element.\");\n                configWidth = viewfinderWidth;\n            }\n            return configWidth;\n        };\n        validateMinSize(qrDimensions.width);\n        validateMinSize(qrDimensions.height);\n        qrDimensions.width = correctWidthBasedOnRootElementSize(qrDimensions.width);\n    };\n    Html5Qrcode.prototype.validateQrboxConfig = function (qrboxSize) {\n        if (typeof qrboxSize === \"number\") {\n            return;\n        }\n        if (typeof qrboxSize === \"function\") {\n            return;\n        }\n        if (qrboxSize.width === undefined || qrboxSize.height === undefined) {\n            throw \"Invalid instance of QrDimensions passed for \"\n                + \"'config.qrbox'. Both 'width' and 'height' should be set.\";\n        }\n    };\n    Html5Qrcode.prototype.toQrdimensions = function (viewfinderWidth, viewfinderHeight, qrboxSize) {\n        if (typeof qrboxSize === \"number\") {\n            return { width: qrboxSize, height: qrboxSize };\n        }\n        else if (typeof qrboxSize === \"function\") {\n            try {\n                return qrboxSize(viewfinderWidth, viewfinderHeight);\n            }\n            catch (error) {\n                throw new Error(\"qrbox config was passed as a function but it failed with \"\n                    + \"unknown error\" + error);\n            }\n        }\n        return qrboxSize;\n    };\n    Html5Qrcode.prototype.setupUi = function (viewfinderWidth, viewfinderHeight, internalConfig) {\n        if (internalConfig.isShadedBoxEnabled()) {\n            this.validateQrboxSize(viewfinderWidth, viewfinderHeight, internalConfig);\n        }\n        var qrboxSize = (0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(internalConfig.qrbox) ?\n            { width: viewfinderWidth, height: viewfinderHeight } : internalConfig.qrbox;\n        this.validateQrboxConfig(qrboxSize);\n        var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);\n        if (qrDimensions.height > viewfinderHeight) {\n            this.logger.warn(\"[Html5Qrcode] config.qrbox has height that is\"\n                + \"greater than the height of the video stream. Shading will be\"\n                + \" ignored\");\n        }\n        var shouldShadingBeApplied = internalConfig.isShadedBoxEnabled()\n            && qrDimensions.height <= viewfinderHeight;\n        var defaultQrRegion = {\n            x: 0,\n            y: 0,\n            width: viewfinderWidth,\n            height: viewfinderHeight\n        };\n        var qrRegion = shouldShadingBeApplied\n            ? this.getShadedRegionBounds(viewfinderWidth, viewfinderHeight, qrDimensions)\n            : defaultQrRegion;\n        var canvasElement = this.createCanvasElement(qrRegion.width, qrRegion.height);\n        var contextAttributes = { willReadFrequently: true };\n        var context = canvasElement.getContext(\"2d\", contextAttributes);\n        context.canvas.width = qrRegion.width;\n        context.canvas.height = qrRegion.height;\n        this.element.append(canvasElement);\n        if (shouldShadingBeApplied) {\n            this.possiblyInsertShadingElement(this.element, viewfinderWidth, viewfinderHeight, qrDimensions);\n        }\n        this.createScannerPausedUiElement(this.element);\n        this.qrRegion = qrRegion;\n        this.context = context;\n        this.canvasElement = canvasElement;\n    };\n    Html5Qrcode.prototype.createScannerPausedUiElement = function (rootElement) {\n        var scannerPausedUiElement = document.createElement(\"div\");\n        scannerPausedUiElement.innerText = _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeStrings.scannerPaused();\n        scannerPausedUiElement.style.display = \"none\";\n        scannerPausedUiElement.style.position = \"absolute\";\n        scannerPausedUiElement.style.top = \"0px\";\n        scannerPausedUiElement.style.zIndex = \"1\";\n        scannerPausedUiElement.style.background = \"rgba(9, 9, 9, 0.46)\";\n        scannerPausedUiElement.style.color = \"#FFECEC\";\n        scannerPausedUiElement.style.textAlign = \"center\";\n        scannerPausedUiElement.style.width = \"100%\";\n        rootElement.appendChild(scannerPausedUiElement);\n        this.scannerPausedUiElement = scannerPausedUiElement;\n    };\n    Html5Qrcode.prototype.scanContext = function (qrCodeSuccessCallback, qrCodeErrorCallback) {\n        var _this = this;\n        if (this.stateManagerProxy.isPaused()) {\n            return Promise.resolve(false);\n        }\n        return this.qrcode.decodeAsync(this.canvasElement)\n            .then(function (result) {\n            qrCodeSuccessCallback(result.text, _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeResultFactory.createFromQrcodeResult(result));\n            _this.possiblyUpdateShaders(true);\n            return true;\n        }).catch(function (error) {\n            _this.possiblyUpdateShaders(false);\n            var errorMessage = _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeStrings.codeParseError(error);\n            qrCodeErrorCallback(errorMessage, _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeErrorFactory.createFrom(errorMessage));\n            return false;\n        });\n    };\n    Html5Qrcode.prototype.foreverScan = function (internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback) {\n        var _this = this;\n        if (!this.shouldScan) {\n            return;\n        }\n        if (!this.renderedCamera) {\n            return;\n        }\n        var videoElement = this.renderedCamera.getSurface();\n        var widthRatio = videoElement.videoWidth / videoElement.clientWidth;\n        var heightRatio = videoElement.videoHeight / videoElement.clientHeight;\n        if (!this.qrRegion) {\n            throw \"qrRegion undefined when localMediaStream is ready.\";\n        }\n        var sWidthOffset = this.qrRegion.width * widthRatio;\n        var sHeightOffset = this.qrRegion.height * heightRatio;\n        var sxOffset = this.qrRegion.x * widthRatio;\n        var syOffset = this.qrRegion.y * heightRatio;\n        this.context.drawImage(videoElement, sxOffset, syOffset, sWidthOffset, sHeightOffset, 0, 0, this.qrRegion.width, this.qrRegion.height);\n        var triggerNextScan = function () {\n            _this.foreverScanTimeout = setTimeout(function () {\n                _this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback);\n            }, _this.getTimeoutFps(internalConfig.fps));\n        };\n        this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback)\n            .then(function (isSuccessfull) {\n            if (!isSuccessfull && internalConfig.disableFlip !== true) {\n                _this.context.translate(_this.context.canvas.width, 0);\n                _this.context.scale(-1, 1);\n                _this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback)\n                    .finally(function () {\n                    triggerNextScan();\n                });\n            }\n            else {\n                triggerNextScan();\n            }\n        }).catch(function (error) {\n            _this.logger.logError(\"Error happend while scanning context\", error);\n            triggerNextScan();\n        });\n    };\n    Html5Qrcode.prototype.createVideoConstraints = function (cameraIdOrConfig) {\n        if (typeof cameraIdOrConfig == \"string\") {\n            return { deviceId: { exact: cameraIdOrConfig } };\n        }\n        else if (typeof cameraIdOrConfig == \"object\") {\n            var facingModeKey = \"facingMode\";\n            var deviceIdKey = \"deviceId\";\n            var allowedFacingModeValues_1 = { \"user\": true, \"environment\": true };\n            var exactKey = \"exact\";\n            var isValidFacingModeValue = function (value) {\n                if (value in allowedFacingModeValues_1) {\n                    return true;\n                }\n                else {\n                    throw \"config has invalid 'facingMode' value = \"\n                        + \"'\".concat(value, \"'\");\n                }\n            };\n            var keys = Object.keys(cameraIdOrConfig);\n            if (keys.length !== 1) {\n                throw \"'cameraIdOrConfig' object should have exactly 1 key,\"\n                    + \" if passed as an object, found \".concat(keys.length, \" keys\");\n            }\n            var key = Object.keys(cameraIdOrConfig)[0];\n            if (key !== facingModeKey && key !== deviceIdKey) {\n                throw \"Only '\".concat(facingModeKey, \"' and '\").concat(deviceIdKey, \"' \")\n                    + \" are supported for 'cameraIdOrConfig'\";\n            }\n            if (key === facingModeKey) {\n                var facingMode = cameraIdOrConfig.facingMode;\n                if (typeof facingMode == \"string\") {\n                    if (isValidFacingModeValue(facingMode)) {\n                        return { facingMode: facingMode };\n                    }\n                }\n                else if (typeof facingMode == \"object\") {\n                    if (exactKey in facingMode) {\n                        if (isValidFacingModeValue(facingMode[\"\".concat(exactKey)])) {\n                            return {\n                                facingMode: {\n                                    exact: facingMode[\"\".concat(exactKey)]\n                                }\n                            };\n                        }\n                    }\n                    else {\n                        throw \"'facingMode' should be string or object with\"\n                            + \" \".concat(exactKey, \" as key.\");\n                    }\n                }\n                else {\n                    var type_1 = (typeof facingMode);\n                    throw \"Invalid type of 'facingMode' = \".concat(type_1);\n                }\n            }\n            else {\n                var deviceId = cameraIdOrConfig.deviceId;\n                if (typeof deviceId == \"string\") {\n                    return { deviceId: deviceId };\n                }\n                else if (typeof deviceId == \"object\") {\n                    if (exactKey in deviceId) {\n                        return {\n                            deviceId: { exact: deviceId[\"\".concat(exactKey)] }\n                        };\n                    }\n                    else {\n                        throw \"'deviceId' should be string or object with\"\n                            + \" \".concat(exactKey, \" as key.\");\n                    }\n                }\n                else {\n                    var type_2 = (typeof deviceId);\n                    throw \"Invalid type of 'deviceId' = \".concat(type_2);\n                }\n            }\n        }\n        var type = (typeof cameraIdOrConfig);\n        throw \"Invalid type of 'cameraIdOrConfig' = \".concat(type);\n    };\n    Html5Qrcode.prototype.computeCanvasDrawConfig = function (imageWidth, imageHeight, containerWidth, containerHeight) {\n        if (imageWidth <= containerWidth\n            && imageHeight <= containerHeight) {\n            var xoffset = (containerWidth - imageWidth) / 2;\n            var yoffset = (containerHeight - imageHeight) / 2;\n            return {\n                x: xoffset,\n                y: yoffset,\n                width: imageWidth,\n                height: imageHeight\n            };\n        }\n        else {\n            var formerImageWidth = imageWidth;\n            var formerImageHeight = imageHeight;\n            if (imageWidth > containerWidth) {\n                imageHeight = (containerWidth / imageWidth) * imageHeight;\n                imageWidth = containerWidth;\n            }\n            if (imageHeight > containerHeight) {\n                imageWidth = (containerHeight / imageHeight) * imageWidth;\n                imageHeight = containerHeight;\n            }\n            this.logger.log(\"Image downsampled from \"\n                + \"\".concat(formerImageWidth, \"X\").concat(formerImageHeight)\n                + \" to \".concat(imageWidth, \"X\").concat(imageHeight, \".\"));\n            return this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);\n        }\n    };\n    Html5Qrcode.prototype.clearElement = function () {\n        if (this.stateManagerProxy.isScanning()) {\n            throw \"Cannot clear while scan is ongoing, close it first.\";\n        }\n        var element = document.getElementById(this.elementId);\n        if (element) {\n            element.innerHTML = \"\";\n        }\n    };\n    Html5Qrcode.prototype.possiblyUpdateShaders = function (qrMatch) {\n        if (this.qrMatch === qrMatch) {\n            return;\n        }\n        if (this.hasBorderShaders\n            && this.borderShaders\n            && this.borderShaders.length) {\n            this.borderShaders.forEach(function (shader) {\n                shader.style.backgroundColor = qrMatch\n                    ? Constants.BORDER_SHADER_MATCH_COLOR\n                    : Constants.BORDER_SHADER_DEFAULT_COLOR;\n            });\n        }\n        this.qrMatch = qrMatch;\n    };\n    Html5Qrcode.prototype.possiblyCloseLastScanImageFile = function () {\n        if (this.lastScanImageFile) {\n            URL.revokeObjectURL(this.lastScanImageFile);\n            this.lastScanImageFile = null;\n        }\n    };\n    Html5Qrcode.prototype.createCanvasElement = function (width, height, customId) {\n        var canvasWidth = width;\n        var canvasHeight = height;\n        var canvasElement = document.createElement(\"canvas\");\n        canvasElement.style.width = \"\".concat(canvasWidth, \"px\");\n        canvasElement.style.height = \"\".concat(canvasHeight, \"px\");\n        canvasElement.style.display = \"none\";\n        canvasElement.id = (0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(customId)\n            ? \"qr-canvas\" : customId;\n        return canvasElement;\n    };\n    Html5Qrcode.prototype.getShadedRegionBounds = function (width, height, qrboxSize) {\n        if (qrboxSize.width > width || qrboxSize.height > height) {\n            throw \"'config.qrbox' dimensions should not be greater than the \"\n                + \"dimensions of the root HTML element.\";\n        }\n        return {\n            x: (width - qrboxSize.width) / 2,\n            y: (height - qrboxSize.height) / 2,\n            width: qrboxSize.width,\n            height: qrboxSize.height\n        };\n    };\n    Html5Qrcode.prototype.possiblyInsertShadingElement = function (element, width, height, qrboxSize) {\n        if ((width - qrboxSize.width) < 1 || (height - qrboxSize.height) < 1) {\n            return;\n        }\n        var shadingElement = document.createElement(\"div\");\n        shadingElement.style.position = \"absolute\";\n        var rightLeftBorderSize = (width - qrboxSize.width) / 2;\n        var topBottomBorderSize = (height - qrboxSize.height) / 2;\n        shadingElement.style.borderLeft\n            = \"\".concat(rightLeftBorderSize, \"px solid rgba(0, 0, 0, 0.48)\");\n        shadingElement.style.borderRight\n            = \"\".concat(rightLeftBorderSize, \"px solid rgba(0, 0, 0, 0.48)\");\n        shadingElement.style.borderTop\n            = \"\".concat(topBottomBorderSize, \"px solid rgba(0, 0, 0, 0.48)\");\n        shadingElement.style.borderBottom\n            = \"\".concat(topBottomBorderSize, \"px solid rgba(0, 0, 0, 0.48)\");\n        shadingElement.style.boxSizing = \"border-box\";\n        shadingElement.style.top = \"0px\";\n        shadingElement.style.bottom = \"0px\";\n        shadingElement.style.left = \"0px\";\n        shadingElement.style.right = \"0px\";\n        shadingElement.id = \"\".concat(Constants.SHADED_REGION_ELEMENT_ID);\n        if ((width - qrboxSize.width) < 11\n            || (height - qrboxSize.height) < 11) {\n            this.hasBorderShaders = false;\n        }\n        else {\n            var smallSize = 5;\n            var largeSize = 40;\n            this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, null, 0, true);\n            this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, null, 0, false);\n            this.insertShaderBorders(shadingElement, largeSize, smallSize, null, -smallSize, 0, true);\n            this.insertShaderBorders(shadingElement, largeSize, smallSize, null, -smallSize, 0, false);\n            this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, null, -smallSize, true);\n            this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, null, -smallSize, -smallSize, true);\n            this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, null, -smallSize, false);\n            this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, null, -smallSize, -smallSize, false);\n            this.hasBorderShaders = true;\n        }\n        element.append(shadingElement);\n    };\n    Html5Qrcode.prototype.insertShaderBorders = function (shaderElem, width, height, top, bottom, side, isLeft) {\n        var elem = document.createElement(\"div\");\n        elem.style.position = \"absolute\";\n        elem.style.backgroundColor = Constants.BORDER_SHADER_DEFAULT_COLOR;\n        elem.style.width = \"\".concat(width, \"px\");\n        elem.style.height = \"\".concat(height, \"px\");\n        if (top !== null) {\n            elem.style.top = \"\".concat(top, \"px\");\n        }\n        if (bottom !== null) {\n            elem.style.bottom = \"\".concat(bottom, \"px\");\n        }\n        if (isLeft) {\n            elem.style.left = \"\".concat(side, \"px\");\n        }\n        else {\n            elem.style.right = \"\".concat(side, \"px\");\n        }\n        if (!this.borderShaders) {\n            this.borderShaders = [];\n        }\n        this.borderShaders.push(elem);\n        shaderElem.appendChild(elem);\n    };\n    Html5Qrcode.prototype.showPausedState = function () {\n        if (!this.scannerPausedUiElement) {\n            throw \"[internal error] scanner paused UI element not found\";\n        }\n        this.scannerPausedUiElement.style.display = \"block\";\n    };\n    Html5Qrcode.prototype.hidePausedState = function () {\n        if (!this.scannerPausedUiElement) {\n            throw \"[internal error] scanner paused UI element not found\";\n        }\n        this.scannerPausedUiElement.style.display = \"none\";\n    };\n    Html5Qrcode.prototype.getTimeoutFps = function (fps) {\n        return 1000 / fps;\n    };\n    return Html5Qrcode;\n}());\n\n//# sourceMappingURL=html5-qrcode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9odG1sNS1xcmNvZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0I7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNpTTtBQUNuSjtBQUNBO0FBQ0U7QUFDRTtBQUNFO0FBQzBCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLHVEQUFvQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQW9CO0FBQ25DO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQVc7QUFDckMsMEJBQTBCLDBEQUFlO0FBQ3pDO0FBQ0E7QUFDQSxpQ0FBaUMsK0RBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsbUVBQXVCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCLHdEQUFrQjtBQUM3QyxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCLHdEQUFrQjtBQUN6QyxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsbUVBQXVCO0FBQ3ZFO0FBQ0EsWUFBWSx3REFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG1FQUF1QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxtRUFBdUI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVDQUF1QztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQXdCO0FBQ3hELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhEQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkMsWUFBWSw4REFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsZ0JBQWdCO0FBQ3RGO0FBQ0EsZ0JBQWdCLHlFQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFpQjtBQUM3QjtBQUNBO0FBQ0EsYUFBYSx3REFBaUI7QUFDOUI7QUFDQTtBQUNBLFlBQVksd0RBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3REFBaUI7QUFDekMsY0FBYyxtREFBbUQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3REFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDJEQUF3QjtBQUN2RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLHdEQUFrQjtBQUNqRCw4Q0FBOEMsMERBQXVCO0FBQ3JFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDc0I7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vaHRtbDUtcXJjb2RlLmpzPzBjZmQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IEJhc2VMb2dnZ2VyLCBIdG1sNVFyY29kZVJlc3VsdEZhY3RvcnksIEh0bWw1UXJjb2RlRXJyb3JGYWN0b3J5LCBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMsIGlzVmFsaWRIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMsIEh0bWw1UXJjb2RlQ29uc3RhbnRzLCBpc051bGxPclVuZGVmaW5lZCB9IGZyb20gXCIuL2NvcmVcIjtcbmltcG9ydCB7IEh0bWw1UXJjb2RlU3RyaW5ncyB9IGZyb20gXCIuL3N0cmluZ3NcIjtcbmltcG9ydCB7IFZpZGVvQ29uc3RyYWludHNVdGlsIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IEh0bWw1UXJjb2RlU2hpbSB9IGZyb20gXCIuL2NvZGUtZGVjb2RlclwiO1xuaW1wb3J0IHsgQ2FtZXJhRmFjdG9yeSB9IGZyb20gXCIuL2NhbWVyYS9mYWN0b3JpZXNcIjtcbmltcG9ydCB7IENhbWVyYVJldHJpZXZlciB9IGZyb20gXCIuL2NhbWVyYS9yZXRyaWV2ZXJcIjtcbmltcG9ydCB7IFN0YXRlTWFuYWdlckZhY3RvcnksIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlIH0gZnJvbSBcIi4vc3RhdGUtbWFuYWdlclwiO1xudmFyIENvbnN0YW50cyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnN0YW50cywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25zdGFudHMoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ29uc3RhbnRzLkRFRkFVTFRfV0lEVEggPSAzMDA7XG4gICAgQ29uc3RhbnRzLkRFRkFVTFRfV0lEVEhfT0ZGU0VUID0gMjtcbiAgICBDb25zdGFudHMuRklMRV9TQ0FOX01JTl9IRUlHSFQgPSAzMDA7XG4gICAgQ29uc3RhbnRzLkZJTEVfU0NBTl9ISURERU5fQ0FOVkFTX1BBRERJTkcgPSAxMDA7XG4gICAgQ29uc3RhbnRzLk1JTl9RUl9CT1hfU0laRSA9IDUwO1xuICAgIENvbnN0YW50cy5TSEFERURfTEVGVCA9IDE7XG4gICAgQ29uc3RhbnRzLlNIQURFRF9SSUdIVCA9IDI7XG4gICAgQ29uc3RhbnRzLlNIQURFRF9UT1AgPSAzO1xuICAgIENvbnN0YW50cy5TSEFERURfQk9UVE9NID0gNDtcbiAgICBDb25zdGFudHMuU0hBREVEX1JFR0lPTl9FTEVNRU5UX0lEID0gXCJxci1zaGFkZWQtcmVnaW9uXCI7XG4gICAgQ29uc3RhbnRzLlZFUkJPU0UgPSBmYWxzZTtcbiAgICBDb25zdGFudHMuQk9SREVSX1NIQURFUl9ERUZBVUxUX0NPTE9SID0gXCIjZmZmZmZmXCI7XG4gICAgQ29uc3RhbnRzLkJPUkRFUl9TSEFERVJfTUFUQ0hfQ09MT1IgPSBcInJnYig5MCwgMTkzLCA1NilcIjtcbiAgICByZXR1cm4gQ29uc3RhbnRzO1xufShIdG1sNVFyY29kZUNvbnN0YW50cykpO1xudmFyIEludGVybmFsSHRtbDVRcmNvZGVDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEludGVybmFsSHRtbDVRcmNvZGVDb25maWcoY29uZmlnLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMuZnBzID0gQ29uc3RhbnRzLlNDQU5fREVGQVVMVF9GUFM7XG4gICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVGbGlwID0gQ29uc3RhbnRzLkRFRkFVTFRfRElTQUJMRV9GTElQO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5mcHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZwcyA9IGNvbmZpZy5mcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVGbGlwID0gY29uZmlnLmRpc2FibGVGbGlwID09PSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5xcmJveCA9IGNvbmZpZy5xcmJveDtcbiAgICAgICAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSBjb25maWcuYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB0aGlzLnZpZGVvQ29uc3RyYWludHMgPSBjb25maWcudmlkZW9Db25zdHJhaW50cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBJbnRlcm5hbEh0bWw1UXJjb2RlQ29uZmlnLnByb3RvdHlwZS5pc01lZGlhU3RyZWFtQ29uc3RyYWludHNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiRW1wdHkgdmlkZW9Db25zdHJhaW50c1wiLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVmlkZW9Db25zdHJhaW50c1V0aWwuaXNNZWRpYVN0cmVhbUNvbnN0cmFpbnRzVmFsaWQodGhpcy52aWRlb0NvbnN0cmFpbnRzLCB0aGlzLmxvZ2dlcik7XG4gICAgfTtcbiAgICBJbnRlcm5hbEh0bWw1UXJjb2RlQ29uZmlnLnByb3RvdHlwZS5pc1NoYWRlZEJveEVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhaXNOdWxsT3JVbmRlZmluZWQodGhpcy5xcmJveCk7XG4gICAgfTtcbiAgICBJbnRlcm5hbEh0bWw1UXJjb2RlQ29uZmlnLmNyZWF0ZSA9IGZ1bmN0aW9uIChjb25maWcsIGxvZ2dlcikge1xuICAgICAgICByZXR1cm4gbmV3IEludGVybmFsSHRtbDVRcmNvZGVDb25maWcoY29uZmlnLCBsb2dnZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIEludGVybmFsSHRtbDVRcmNvZGVDb25maWc7XG59KCkpO1xudmFyIEh0bWw1UXJjb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNVFyY29kZShlbGVtZW50SWQsIGNvbmZpZ09yVmVyYm9zaXR5RmxhZykge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnNjYW5uZXJQYXVzZWRVaUVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc0JvcmRlclNoYWRlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmJvcmRlclNoYWRlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLnFyTWF0Y2ggPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlcmVkQ2FtZXJhID0gbnVsbDtcbiAgICAgICAgdGhpcy5xclJlZ2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFNjYW5JbWFnZUZpbGUgPSBudWxsO1xuICAgICAgICB0aGlzLmlzU2Nhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkhUTUwgRWxlbWVudCB3aXRoIGlkPVwiLmNvbmNhdChlbGVtZW50SWQsIFwiIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnRJZCA9IGVsZW1lbnRJZDtcbiAgICAgICAgdGhpcy52ZXJib3NlID0gZmFsc2U7XG4gICAgICAgIHZhciBleHBlcmltZW50YWxGZWF0dXJlQ29uZmlnO1xuICAgICAgICB2YXIgY29uZmlnT2JqZWN0O1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZ09yVmVyYm9zaXR5RmxhZyA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhpcy52ZXJib3NlID0gY29uZmlnT3JWZXJib3NpdHlGbGFnID09PSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZ09yVmVyYm9zaXR5RmxhZykge1xuICAgICAgICAgICAgY29uZmlnT2JqZWN0ID0gY29uZmlnT3JWZXJib3NpdHlGbGFnO1xuICAgICAgICAgICAgdGhpcy52ZXJib3NlID0gY29uZmlnT2JqZWN0LnZlcmJvc2UgPT09IHRydWU7XG4gICAgICAgICAgICBleHBlcmltZW50YWxGZWF0dXJlQ29uZmlnID0gY29uZmlnT2JqZWN0LmV4cGVyaW1lbnRhbEZlYXR1cmVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbmV3IEJhc2VMb2dnZ2VyKHRoaXMudmVyYm9zZSk7XG4gICAgICAgIHRoaXMucXJjb2RlID0gbmV3IEh0bWw1UXJjb2RlU2hpbSh0aGlzLmdldFN1cHBvcnRlZEZvcm1hdHMoY29uZmlnT3JWZXJib3NpdHlGbGFnKSwgdGhpcy5nZXRVc2VCYXJDb2RlRGV0ZWN0b3JJZlN1cHBvcnRlZChjb25maWdPYmplY3QpLCB0aGlzLnZlcmJvc2UsIHRoaXMubG9nZ2VyKTtcbiAgICAgICAgdGhpcy5mb3JldmVyU2NhblRpbWVvdXQ7XG4gICAgICAgIHRoaXMuc2hvdWxkU2NhbiA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGVNYW5hZ2VyUHJveHkgPSBTdGF0ZU1hbmFnZXJGYWN0b3J5LmNyZWF0ZSgpO1xuICAgIH1cbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoY2FtZXJhSWRPckNvbmZpZywgY29uZmlndXJhdGlvbiwgcXJDb2RlU3VjY2Vzc0NhbGxiYWNrLCBxckNvZGVFcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghY2FtZXJhSWRPckNvbmZpZykge1xuICAgICAgICAgICAgdGhyb3cgXCJjYW1lcmFJZE9yQ29uZmlnIGlzIHJlcXVpcmVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFxckNvZGVTdWNjZXNzQ2FsbGJhY2tcbiAgICAgICAgICAgIHx8IHR5cGVvZiBxckNvZGVTdWNjZXNzQ2FsbGJhY2sgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBcInFyQ29kZVN1Y2Nlc3NDYWxsYmFjayBpcyByZXF1aXJlZCBhbmQgc2hvdWxkIGJlIGEgZnVuY3Rpb24uXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHFyQ29kZUVycm9yQ2FsbGJhY2tJbnRlcm5hbDtcbiAgICAgICAgaWYgKHFyQ29kZUVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHFyQ29kZUVycm9yQ2FsbGJhY2tJbnRlcm5hbCA9IHFyQ29kZUVycm9yQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxckNvZGVFcnJvckNhbGxiYWNrSW50ZXJuYWxcbiAgICAgICAgICAgICAgICA9IHRoaXMudmVyYm9zZSA/IHRoaXMubG9nZ2VyLmxvZyA6IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJuYWxDb25maWcgPSBJbnRlcm5hbEh0bWw1UXJjb2RlQ29uZmlnLmNyZWF0ZShjb25maWd1cmF0aW9uLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgIHRoaXMuY2xlYXJFbGVtZW50KCk7XG4gICAgICAgIHZhciB2aWRlb0NvbnN0cmFpbnRzQXZhaWxhYmxlQW5kVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGludGVybmFsQ29uZmlnLnZpZGVvQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxDb25maWcuaXNNZWRpYVN0cmVhbUNvbnN0cmFpbnRzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiJ3ZpZGVvQ29uc3RyYWludHMnIGlzIG5vdCB2YWxpZCAnTWVkaWFTdHJlYW1Db25zdHJhaW50cywgXCJcbiAgICAgICAgICAgICAgICAgICAgKyBcIml0IHdpbGwgYmUgaWdub3JlZC4nXCIsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50c0F2YWlsYWJsZUFuZFZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJlVmlkZW9Db25zdHJhaW50c0VuYWJsZWQgPSB2aWRlb0NvbnN0cmFpbnRzQXZhaWxhYmxlQW5kVmFsaWQ7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5lbGVtZW50SWQpO1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnRXaWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICAgICAgICAgID8gZWxlbWVudC5jbGllbnRXaWR0aCA6IENvbnN0YW50cy5ERUZBVUxUX1dJRFRIO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICB0aGlzLnNob3VsZFNjYW4gPSB0cnVlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdG9TY2FubmluZ1N0YXRlQ2hhbmdlVHJhbnNhY3Rpb24gPSB0aGlzLnN0YXRlTWFuYWdlclByb3h5LnN0YXJ0VHJhbnNpdGlvbihIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5TQ0FOTklORyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgdmlkZW9Db25zdHJhaW50cyA9IGFyZVZpZGVvQ29uc3RyYWludHNFbmFibGVkXG4gICAgICAgICAgICAgICAgPyBpbnRlcm5hbENvbmZpZy52aWRlb0NvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgOiAkdGhpcy5jcmVhdGVWaWRlb0NvbnN0cmFpbnRzKGNhbWVyYUlkT3JDb25maWcpO1xuICAgICAgICAgICAgaWYgKCF2aWRlb0NvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICAgICAgdG9TY2FubmluZ1N0YXRlQ2hhbmdlVHJhbnNhY3Rpb24uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFwidmlkZW9Db25zdHJhaW50cyBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2FtZXJhUmVuZGVyaW5nT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgaWYgKCFhcmVWaWRlb0NvbnN0cmFpbnRzRW5hYmxlZCB8fCBpbnRlcm5hbENvbmZpZy5hc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIGNhbWVyYVJlbmRlcmluZ09wdGlvbnMuYXNwZWN0UmF0aW8gPSBpbnRlcm5hbENvbmZpZy5hc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZW5kZXJpbmdDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAgICAgb25SZW5kZXJTdXJmYWNlUmVhZHk6IGZ1bmN0aW9uICh2aWV3ZmluZGVyV2lkdGgsIHZpZXdmaW5kZXJIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuc2V0dXBVaSh2aWV3ZmluZGVyV2lkdGgsIHZpZXdmaW5kZXJIZWlnaHQsIGludGVybmFsQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuaXNTY2FubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmZvcmV2ZXJTY2FuKGludGVybmFsQ29uZmlnLCBxckNvZGVTdWNjZXNzQ2FsbGJhY2ssIHFyQ29kZUVycm9yQ2FsbGJhY2tJbnRlcm5hbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENhbWVyYUZhY3RvcnkuZmFpbElmTm90U3VwcG9ydGVkKCkudGhlbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkuY3JlYXRlKHZpZGVvQ29uc3RyYWludHMpLnRoZW4oZnVuY3Rpb24gKGNhbWVyYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FtZXJhLnJlbmRlcihfdGhpcy5lbGVtZW50LCBjYW1lcmFSZW5kZXJpbmdPcHRpb25zLCByZW5kZXJpbmdDYWxsYmFja3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVuZGVyZWRDYW1lcmEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnJlbmRlcmVkQ2FtZXJhID0gcmVuZGVyZWRDYW1lcmE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1NjYW5uaW5nU3RhdGVDaGFuZ2VUcmFuc2FjdGlvbi5leGVjdXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9TY2FubmluZ1N0YXRlQ2hhbmdlVHJhbnNhY3Rpb24uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9TY2FubmluZ1N0YXRlQ2hhbmdlVHJhbnNhY3Rpb24uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChIdG1sNVFyY29kZVN0cmluZ3MuZXJyb3JHZXR0aW5nVXNlck1lZGlhKGVycm9yKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHRvU2Nhbm5pbmdTdGF0ZUNoYW5nZVRyYW5zYWN0aW9uLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChIdG1sNVFyY29kZVN0cmluZ3MuY2FtZXJhU3RyZWFtaW5nTm90U3VwcG9ydGVkKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKHNob3VsZFBhdXNlVmlkZW8pIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlTWFuYWdlclByb3h5LmlzU3RyaWN0bHlTY2FubmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNhbm5vdCBwYXVzZSwgc2Nhbm5lciBpcyBub3Qgc2Nhbm5pbmcuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZU1hbmFnZXJQcm94eS5kaXJlY3RUcmFuc2l0aW9uKEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLlBBVVNFRCk7XG4gICAgICAgIHRoaXMuc2hvd1BhdXNlZFN0YXRlKCk7XG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChzaG91bGRQYXVzZVZpZGVvKSB8fCBzaG91bGRQYXVzZVZpZGVvICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBzaG91bGRQYXVzZVZpZGVvID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFBhdXNlVmlkZW8gJiYgdGhpcy5yZW5kZXJlZENhbWVyYSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZENhbWVyYS5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGVNYW5hZ2VyUHJveHkuaXNQYXVzZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJDYW5ub3QgcmVzdWx0LCBzY2FubmVyIGlzIG5vdCBwYXVzZWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVkQ2FtZXJhKSB7XG4gICAgICAgICAgICB0aHJvdyBcInJlbmRlcmVkQ2FtZXJhIGRvZXNuJ3QgZXhpc3Qgd2hpbGUgdHJ5aW5nIHJlc3VtZSgpXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRyYW5zaXRpb25Ub1NjYW5uaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHRoaXMuc3RhdGVNYW5hZ2VyUHJveHkuZGlyZWN0VHJhbnNpdGlvbihIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5TQ0FOTklORyk7XG4gICAgICAgICAgICAkdGhpcy5oaWRlUGF1c2VkU3RhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVkQ2FtZXJhLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25Ub1NjYW5uaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJlZENhbWVyYS5yZXN1bWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhbnNpdGlvblRvU2Nhbm5pbmcoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlTWFuYWdlclByb3h5LmdldFN0YXRlKCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlTWFuYWdlclByb3h5LmlzU2Nhbm5pbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJDYW5ub3Qgc3RvcCwgc2Nhbm5lciBpcyBub3QgcnVubmluZyBvciBwYXVzZWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvU3RvcHBlZFN0YXRlVHJhbnNhY3Rpb24gPSB0aGlzLnN0YXRlTWFuYWdlclByb3h5LnN0YXJ0VHJhbnNpdGlvbihIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5OT1RfU1RBUlRFRCk7XG4gICAgICAgIHRoaXMuc2hvdWxkU2NhbiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mb3JldmVyU2NhblRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZvcmV2ZXJTY2FuVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbW92ZVFyUmVnaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKENvbnN0YW50cy5TSEFERURfUkVHSU9OX0VMRU1FTlRfSUQpO1xuICAgICAgICAgICAgaWYgKGNoaWxkRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGRFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWRDYW1lcmEuY2xvc2UoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICR0aGlzLnJlbmRlcmVkQ2FtZXJhID0gbnVsbDtcbiAgICAgICAgICAgIGlmICgkdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCgkdGhpcy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAkdGhpcy5jYW52YXNFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZVFyUmVnaW9uKCk7XG4gICAgICAgICAgICBpZiAoJHRoaXMucXJSZWdpb24pIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5xclJlZ2lvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJHRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgICAgICR0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9TdG9wcGVkU3RhdGVUcmFuc2FjdGlvbi5leGVjdXRlKCk7XG4gICAgICAgICAgICAkdGhpcy5oaWRlUGF1c2VkU3RhdGUoKTtcbiAgICAgICAgICAgICR0aGlzLmlzU2Nhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuc2NhbkZpbGUgPSBmdW5jdGlvbiAoaW1hZ2VGaWxlLCBzaG93SW1hZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkZpbGVWMihpbWFnZUZpbGUsIHNob3dJbWFnZSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChodG1sNXFyY29kZVJlc3VsdCkgeyByZXR1cm4gaHRtbDVxcmNvZGVSZXN1bHQuZGVjb2RlZFRleHQ7IH0pO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnNjYW5GaWxlVjIgPSBmdW5jdGlvbiAoaW1hZ2VGaWxlLCBzaG93SW1hZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFpbWFnZUZpbGUgfHwgIShpbWFnZUZpbGUgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJpbWFnZUZpbGUgYXJndW1lbnQgaXMgbWFuZGF0b3J5IGFuZCBzaG91bGQgYmUgaW5zdGFuY2UgXCJcbiAgICAgICAgICAgICAgICArIFwib2YgRmlsZS4gVXNlICdldmVudC50YXJnZXQuZmlsZXNbMF0nLlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChzaG93SW1hZ2UpKSB7XG4gICAgICAgICAgICBzaG93SW1hZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZU1hbmFnZXJQcm94eS5jYW5TY2FuRmlsZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNhbm5vdCBzdGFydCBmaWxlIHNjYW4gLSBvbmdvaW5nIGNhbWVyYSBzY2FuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLnBvc3NpYmx5Q2xvc2VMYXN0U2NhbkltYWdlRmlsZSgpO1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJFbGVtZW50KCk7XG4gICAgICAgICAgICBfdGhpcy5sYXN0U2NhbkltYWdlRmlsZSA9IFVSTC5jcmVhdGVPYmplY3RVUkwoaW1hZ2VGaWxlKTtcbiAgICAgICAgICAgIHZhciBpbnB1dEltYWdlID0gbmV3IEltYWdlO1xuICAgICAgICAgICAgaW5wdXRJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlV2lkdGggPSBpbnB1dEltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBpbWFnZUhlaWdodCA9IGlucHV0SW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoX3RoaXMuZWxlbWVudElkKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoXG4gICAgICAgICAgICAgICAgICAgID8gZWxlbWVudC5jbGllbnRXaWR0aCA6IENvbnN0YW50cy5ERUZBVUxUX1dJRFRIO1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBNYXRoLm1heChlbGVtZW50LmNsaWVudEhlaWdodCA/IGVsZW1lbnQuY2xpZW50SGVpZ2h0IDogaW1hZ2VIZWlnaHQsIENvbnN0YW50cy5GSUxFX1NDQU5fTUlOX0hFSUdIVCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IF90aGlzLmNvbXB1dGVDYW52YXNEcmF3Q29uZmlnKGltYWdlV2lkdGgsIGltYWdlSGVpZ2h0LCBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvd0ltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlQ2FudmFzID0gX3RoaXMuY3JlYXRlQ2FudmFzRWxlbWVudChjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0LCBcInFyLWNhbnZhcy12aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlQ2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHZpc2libGVDYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dF8xID0gdmlzaWJsZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIlVuYWJsZSB0byBnZXQgMmQgY29udGV4dCBmcm9tIGNhbnZhc1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfMS5jYW52YXMud2lkdGggPSBjb250YWluZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF8xLmNhbnZhcy5oZWlnaHQgPSBjb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfMS5kcmF3SW1hZ2UoaW5wdXRJbWFnZSwgMCwgMCwgaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQsIGNvbmZpZy54LCBjb25maWcueSwgY29uZmlnLndpZHRoLCBjb25maWcuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBDb25zdGFudHMuRklMRV9TQ0FOX0hJRERFTl9DQU5WQVNfUEFERElORztcbiAgICAgICAgICAgICAgICB2YXIgaGlkZGVuSW1hZ2VXaWR0aCA9IE1hdGgubWF4KGlucHV0SW1hZ2Uud2lkdGgsIGNvbmZpZy53aWR0aCk7XG4gICAgICAgICAgICAgICAgdmFyIGhpZGRlbkltYWdlSGVpZ2h0ID0gTWF0aC5tYXgoaW5wdXRJbWFnZS5oZWlnaHQsIGNvbmZpZy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHZhciBoaWRkZW5DYW52YXNXaWR0aCA9IGhpZGRlbkltYWdlV2lkdGggKyAyICogcGFkZGluZztcbiAgICAgICAgICAgICAgICB2YXIgaGlkZGVuQ2FudmFzSGVpZ2h0ID0gaGlkZGVuSW1hZ2VIZWlnaHQgKyAyICogcGFkZGluZztcbiAgICAgICAgICAgICAgICB2YXIgaGlkZGVuQ2FudmFzID0gX3RoaXMuY3JlYXRlQ2FudmFzRWxlbWVudChoaWRkZW5DYW52YXNXaWR0aCwgaGlkZGVuQ2FudmFzSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGhpZGRlbkNhbnZhcyk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBoaWRkZW5DYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIlVuYWJsZSB0byBnZXQgMmQgY29udGV4dCBmcm9tIGNhbnZhc1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LmNhbnZhcy53aWR0aCA9IGhpZGRlbkNhbnZhc1dpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2FudmFzLmhlaWdodCA9IGhpZGRlbkNhbnZhc0hlaWdodDtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbnB1dEltYWdlLCAwLCAwLCBpbWFnZVdpZHRoLCBpbWFnZUhlaWdodCwgcGFkZGluZywgcGFkZGluZywgaGlkZGVuSW1hZ2VXaWR0aCwgaGlkZGVuSW1hZ2VIZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnFyY29kZS5kZWNvZGVSb2J1c3RseUFzeW5jKGhpZGRlbkNhbnZhcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoSHRtbDVRcmNvZGVSZXN1bHRGYWN0b3J5LmNyZWF0ZUZyb21RcmNvZGVSZXN1bHQocmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoXCJRUiBjb2RlIHBhcnNlIGVycm9yLCBlcnJvciA9IFwiLmNvbmNhdChleGNlcHRpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW5wdXRJbWFnZS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgaW5wdXRJbWFnZS5vbmFib3J0ID0gcmVqZWN0O1xuICAgICAgICAgICAgaW5wdXRJbWFnZS5vbnN0YWxsZWQgPSByZWplY3Q7XG4gICAgICAgICAgICBpbnB1dEltYWdlLm9uc3VzcGVuZCA9IHJlamVjdDtcbiAgICAgICAgICAgIGlucHV0SW1hZ2Uuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChpbWFnZUZpbGUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhckVsZW1lbnQoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLmdldENhbWVyYXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBDYW1lcmFSZXRyaWV2ZXIucmV0cmlldmUoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5nZXRSdW5uaW5nVHJhY2tDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVkQ2FtZXJhT3JGYWlsKCkuZ2V0UnVubmluZ1RyYWNrQ2FwYWJpbGl0aWVzKCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuZ2V0UnVubmluZ1RyYWNrU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVkQ2FtZXJhT3JGYWlsKCkuZ2V0UnVubmluZ1RyYWNrU2V0dGluZ3MoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5nZXRSdW5uaW5nVHJhY2tDYW1lcmFDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVkQ2FtZXJhT3JGYWlsKCkuZ2V0Q2FwYWJpbGl0aWVzKCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuYXBwbHlWaWRlb0NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHZpZGVvQ29uc3RhaW50cykge1xuICAgICAgICBpZiAoIXZpZGVvQ29uc3RhaW50cykge1xuICAgICAgICAgICAgdGhyb3cgXCJ2aWRlb0NvbnN0YWludHMgaXMgcmVxdWlyZWQgYXJndW1lbnQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIVZpZGVvQ29uc3RyYWludHNVdGlsLmlzTWVkaWFTdHJlYW1Db25zdHJhaW50c1ZhbGlkKHZpZGVvQ29uc3RhaW50cywgdGhpcy5sb2dnZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBcImludmFsaWQgdmlkZW9Db25zdGFpbnRzIHBhc3NlZCwgY2hlY2sgbG9ncyBmb3IgbW9yZSBkZXRhaWxzXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyZWRDYW1lcmFPckZhaWwoKS5hcHBseVZpZGVvQ29uc3RyYWludHModmlkZW9Db25zdGFpbnRzKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5nZXRSZW5kZXJlZENhbWVyYU9yRmFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRDYW1lcmEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgXCJTY2FubmluZyBpcyBub3QgaW4gcnVubmluZyBzdGF0ZSwgY2FsbCB0aGlzIEFQSSBvbmx5IHdoZW5cIlxuICAgICAgICAgICAgICAgICsgXCIgUVIgY29kZSBzY2FubmluZyB1c2luZyBjYW1lcmEgaXMgaW4gcnVubmluZyBzdGF0ZS5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlZENhbWVyYTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5nZXRTdXBwb3J0ZWRGb3JtYXRzID0gZnVuY3Rpb24gKGNvbmZpZ09yVmVyYm9zaXR5RmxhZykge1xuICAgICAgICB2YXIgYWxsRm9ybWF0cyA9IFtcbiAgICAgICAgICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5RUl9DT0RFLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkFaVEVDLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREFCQVIsXG4gICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuQ09ERV8zOSxcbiAgICAgICAgICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5DT0RFXzkzLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREVfMTI4LFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkRBVEFfTUFUUklYLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLk1BWElDT0RFLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLklURixcbiAgICAgICAgICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5FQU5fMTMsXG4gICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuRUFOXzgsXG4gICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUERGXzQxNyxcbiAgICAgICAgICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5SU1NfMTQsXG4gICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUlNTX0VYUEFOREVELFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19BLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19FLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19FQU5fRVhURU5TSU9OLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoIWNvbmZpZ09yVmVyYm9zaXR5RmxhZ1xuICAgICAgICAgICAgfHwgdHlwZW9mIGNvbmZpZ09yVmVyYm9zaXR5RmxhZyA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIGFsbEZvcm1hdHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWdPclZlcmJvc2l0eUZsYWcuZm9ybWF0c1RvU3VwcG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIGFsbEZvcm1hdHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ09yVmVyYm9zaXR5RmxhZy5mb3JtYXRzVG9TdXBwb3J0KSkge1xuICAgICAgICAgICAgdGhyb3cgXCJjb25maWdPclZlcmJvc2l0eUZsYWcuZm9ybWF0c1RvU3VwcG9ydCBzaG91bGQgYmUgdW5kZWZpbmVkIFwiXG4gICAgICAgICAgICAgICAgKyBcIm9yIGFuIGFycmF5LlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWdPclZlcmJvc2l0eUZsYWcuZm9ybWF0c1RvU3VwcG9ydC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IFwiQXRsZWFzdCAxIGZvcm1hdHNUb1N1cHBvcnQgaXMgbmVlZGVkLlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdXBwb3J0ZWRGb3JtYXRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb25maWdPclZlcmJvc2l0eUZsYWcuZm9ybWF0c1RvU3VwcG9ydDsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cyhmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkRm9ybWF0cy5wdXNoKGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiSW52YWxpZCBmb3JtYXQ6IFwiLmNvbmNhdChmb3JtYXQsIFwiIHBhc3NlZCBpbiBjb25maWcsIGlnbm9yaW5nLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1cHBvcnRlZEZvcm1hdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBcIk5vbmUgb2YgZm9ybWF0c1RvU3VwcG9ydCBtYXRjaCBzdXBwb3J0ZWQgdmFsdWVzLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWRGb3JtYXRzO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLmdldFVzZUJhckNvZGVEZXRlY3RvcklmU3VwcG9ydGVkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoY29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChjb25maWcudXNlQmFyQ29kZURldGVjdG9ySWZTdXBwb3J0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnVzZUJhckNvZGVEZXRlY3RvcklmU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoY29uZmlnLmV4cGVyaW1lbnRhbEZlYXR1cmVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4cGVyaW1lbnRhbEZlYXR1cmVzID0gY29uZmlnLmV4cGVyaW1lbnRhbEZlYXR1cmVzO1xuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoZXhwZXJpbWVudGFsRmVhdHVyZXMudXNlQmFyQ29kZURldGVjdG9ySWZTdXBwb3J0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwZXJpbWVudGFsRmVhdHVyZXMudXNlQmFyQ29kZURldGVjdG9ySWZTdXBwb3J0ZWQgIT09IGZhbHNlO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnZhbGlkYXRlUXJib3hTaXplID0gZnVuY3Rpb24gKHZpZXdmaW5kZXJXaWR0aCwgdmlld2ZpbmRlckhlaWdodCwgaW50ZXJuYWxDb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHFyYm94U2l6ZSA9IGludGVybmFsQ29uZmlnLnFyYm94O1xuICAgICAgICB0aGlzLnZhbGlkYXRlUXJib3hDb25maWcocXJib3hTaXplKTtcbiAgICAgICAgdmFyIHFyRGltZW5zaW9ucyA9IHRoaXMudG9RcmRpbWVuc2lvbnModmlld2ZpbmRlcldpZHRoLCB2aWV3ZmluZGVySGVpZ2h0LCBxcmJveFNpemUpO1xuICAgICAgICB2YXIgdmFsaWRhdGVNaW5TaXplID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICAgIGlmIChzaXplIDwgQ29uc3RhbnRzLk1JTl9RUl9CT1hfU0laRSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwibWluaW11bSBzaXplIG9mICdjb25maWcucXJib3gnIGRpbWVuc2lvbiB2YWx1ZSBpc1wiXG4gICAgICAgICAgICAgICAgICAgICsgXCIgXCIuY29uY2F0KENvbnN0YW50cy5NSU5fUVJfQk9YX1NJWkUsIFwicHguXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29ycmVjdFdpZHRoQmFzZWRPblJvb3RFbGVtZW50U2l6ZSA9IGZ1bmN0aW9uIChjb25maWdXaWR0aCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZ1dpZHRoID4gdmlld2ZpbmRlcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJgcXJib3gud2lkdGhgIG9yIGBxcmJveGAgaXMgbGFyZ2VyIHRoYW4gdGhlXCJcbiAgICAgICAgICAgICAgICAgICAgKyBcIiB3aWR0aCBvZiB0aGUgcm9vdCBlbGVtZW50LiBUaGUgd2lkdGggd2lsbCBiZSB0cnVuY2F0ZWRcIlxuICAgICAgICAgICAgICAgICAgICArIFwiIHRvIHRoZSB3aWR0aCBvZiByb290IGVsZW1lbnQuXCIpO1xuICAgICAgICAgICAgICAgIGNvbmZpZ1dpZHRoID0gdmlld2ZpbmRlcldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ1dpZHRoO1xuICAgICAgICB9O1xuICAgICAgICB2YWxpZGF0ZU1pblNpemUocXJEaW1lbnNpb25zLndpZHRoKTtcbiAgICAgICAgdmFsaWRhdGVNaW5TaXplKHFyRGltZW5zaW9ucy5oZWlnaHQpO1xuICAgICAgICBxckRpbWVuc2lvbnMud2lkdGggPSBjb3JyZWN0V2lkdGhCYXNlZE9uUm9vdEVsZW1lbnRTaXplKHFyRGltZW5zaW9ucy53aWR0aCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUudmFsaWRhdGVRcmJveENvbmZpZyA9IGZ1bmN0aW9uIChxcmJveFNpemUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBxcmJveFNpemUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHFyYm94U2l6ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHFyYm94U2l6ZS53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHFyYm94U2l6ZS5oZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGluc3RhbmNlIG9mIFFyRGltZW5zaW9ucyBwYXNzZWQgZm9yIFwiXG4gICAgICAgICAgICAgICAgKyBcIidjb25maWcucXJib3gnLiBCb3RoICd3aWR0aCcgYW5kICdoZWlnaHQnIHNob3VsZCBiZSBzZXQuXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS50b1FyZGltZW5zaW9ucyA9IGZ1bmN0aW9uICh2aWV3ZmluZGVyV2lkdGgsIHZpZXdmaW5kZXJIZWlnaHQsIHFyYm94U2l6ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHFyYm94U2l6ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHFyYm94U2l6ZSwgaGVpZ2h0OiBxcmJveFNpemUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcXJib3hTaXplID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFyYm94U2l6ZSh2aWV3ZmluZGVyV2lkdGgsIHZpZXdmaW5kZXJIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicXJib3ggY29uZmlnIHdhcyBwYXNzZWQgYXMgYSBmdW5jdGlvbiBidXQgaXQgZmFpbGVkIHdpdGggXCJcbiAgICAgICAgICAgICAgICAgICAgKyBcInVua25vd24gZXJyb3JcIiArIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXJib3hTaXplO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnNldHVwVWkgPSBmdW5jdGlvbiAodmlld2ZpbmRlcldpZHRoLCB2aWV3ZmluZGVySGVpZ2h0LCBpbnRlcm5hbENvbmZpZykge1xuICAgICAgICBpZiAoaW50ZXJuYWxDb25maWcuaXNTaGFkZWRCb3hFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVRcmJveFNpemUodmlld2ZpbmRlcldpZHRoLCB2aWV3ZmluZGVySGVpZ2h0LCBpbnRlcm5hbENvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHFyYm94U2l6ZSA9IGlzTnVsbE9yVW5kZWZpbmVkKGludGVybmFsQ29uZmlnLnFyYm94KSA/XG4gICAgICAgICAgICB7IHdpZHRoOiB2aWV3ZmluZGVyV2lkdGgsIGhlaWdodDogdmlld2ZpbmRlckhlaWdodCB9IDogaW50ZXJuYWxDb25maWcucXJib3g7XG4gICAgICAgIHRoaXMudmFsaWRhdGVRcmJveENvbmZpZyhxcmJveFNpemUpO1xuICAgICAgICB2YXIgcXJEaW1lbnNpb25zID0gdGhpcy50b1FyZGltZW5zaW9ucyh2aWV3ZmluZGVyV2lkdGgsIHZpZXdmaW5kZXJIZWlnaHQsIHFyYm94U2l6ZSk7XG4gICAgICAgIGlmIChxckRpbWVuc2lvbnMuaGVpZ2h0ID4gdmlld2ZpbmRlckhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIltIdG1sNVFyY29kZV0gY29uZmlnLnFyYm94IGhhcyBoZWlnaHQgdGhhdCBpc1wiXG4gICAgICAgICAgICAgICAgKyBcImdyZWF0ZXIgdGhhbiB0aGUgaGVpZ2h0IG9mIHRoZSB2aWRlbyBzdHJlYW0uIFNoYWRpbmcgd2lsbCBiZVwiXG4gICAgICAgICAgICAgICAgKyBcIiBpZ25vcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaG91bGRTaGFkaW5nQmVBcHBsaWVkID0gaW50ZXJuYWxDb25maWcuaXNTaGFkZWRCb3hFbmFibGVkKClcbiAgICAgICAgICAgICYmIHFyRGltZW5zaW9ucy5oZWlnaHQgPD0gdmlld2ZpbmRlckhlaWdodDtcbiAgICAgICAgdmFyIGRlZmF1bHRRclJlZ2lvbiA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IHZpZXdmaW5kZXJXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdmlld2ZpbmRlckhlaWdodFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcXJSZWdpb24gPSBzaG91bGRTaGFkaW5nQmVBcHBsaWVkXG4gICAgICAgICAgICA/IHRoaXMuZ2V0U2hhZGVkUmVnaW9uQm91bmRzKHZpZXdmaW5kZXJXaWR0aCwgdmlld2ZpbmRlckhlaWdodCwgcXJEaW1lbnNpb25zKVxuICAgICAgICAgICAgOiBkZWZhdWx0UXJSZWdpb247XG4gICAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy5jcmVhdGVDYW52YXNFbGVtZW50KHFyUmVnaW9uLndpZHRoLCBxclJlZ2lvbi5oZWlnaHQpO1xuICAgICAgICB2YXIgY29udGV4dEF0dHJpYnV0ZXMgPSB7IHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZSB9O1xuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRBdHRyaWJ1dGVzKTtcbiAgICAgICAgY29udGV4dC5jYW52YXMud2lkdGggPSBxclJlZ2lvbi53aWR0aDtcbiAgICAgICAgY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gcXJSZWdpb24uaGVpZ2h0O1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKGNhbnZhc0VsZW1lbnQpO1xuICAgICAgICBpZiAoc2hvdWxkU2hhZGluZ0JlQXBwbGllZCkge1xuICAgICAgICAgICAgdGhpcy5wb3NzaWJseUluc2VydFNoYWRpbmdFbGVtZW50KHRoaXMuZWxlbWVudCwgdmlld2ZpbmRlcldpZHRoLCB2aWV3ZmluZGVySGVpZ2h0LCBxckRpbWVuc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlU2Nhbm5lclBhdXNlZFVpRWxlbWVudCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLnFyUmVnaW9uID0gcXJSZWdpb247XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuY2FudmFzRWxlbWVudCA9IGNhbnZhc0VsZW1lbnQ7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuY3JlYXRlU2Nhbm5lclBhdXNlZFVpRWxlbWVudCA9IGZ1bmN0aW9uIChyb290RWxlbWVudCkge1xuICAgICAgICB2YXIgc2Nhbm5lclBhdXNlZFVpRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuaW5uZXJUZXh0ID0gSHRtbDVRcmNvZGVTdHJpbmdzLnNjYW5uZXJQYXVzZWQoKTtcbiAgICAgICAgc2Nhbm5lclBhdXNlZFVpRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIHNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgICAgc2Nhbm5lclBhdXNlZFVpRWxlbWVudC5zdHlsZS56SW5kZXggPSBcIjFcIjtcbiAgICAgICAgc2Nhbm5lclBhdXNlZFVpRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kID0gXCJyZ2JhKDksIDksIDksIDAuNDYpXCI7XG4gICAgICAgIHNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuc3R5bGUuY29sb3IgPSBcIiNGRkVDRUNcIjtcbiAgICAgICAgc2Nhbm5lclBhdXNlZFVpRWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICBzY2FubmVyUGF1c2VkVWlFbGVtZW50LnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgIHJvb3RFbGVtZW50LmFwcGVuZENoaWxkKHNjYW5uZXJQYXVzZWRVaUVsZW1lbnQpO1xuICAgICAgICB0aGlzLnNjYW5uZXJQYXVzZWRVaUVsZW1lbnQgPSBzY2FubmVyUGF1c2VkVWlFbGVtZW50O1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnNjYW5Db250ZXh0ID0gZnVuY3Rpb24gKHFyQ29kZVN1Y2Nlc3NDYWxsYmFjaywgcXJDb2RlRXJyb3JDYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZU1hbmFnZXJQcm94eS5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5xcmNvZGUuZGVjb2RlQXN5bmModGhpcy5jYW52YXNFbGVtZW50KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgcXJDb2RlU3VjY2Vzc0NhbGxiYWNrKHJlc3VsdC50ZXh0LCBIdG1sNVFyY29kZVJlc3VsdEZhY3RvcnkuY3JlYXRlRnJvbVFyY29kZVJlc3VsdChyZXN1bHQpKTtcbiAgICAgICAgICAgIF90aGlzLnBvc3NpYmx5VXBkYXRlU2hhZGVycyh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLnBvc3NpYmx5VXBkYXRlU2hhZGVycyhmYWxzZSk7XG4gICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gSHRtbDVRcmNvZGVTdHJpbmdzLmNvZGVQYXJzZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHFyQ29kZUVycm9yQ2FsbGJhY2soZXJyb3JNZXNzYWdlLCBIdG1sNVFyY29kZUVycm9yRmFjdG9yeS5jcmVhdGVGcm9tKGVycm9yTWVzc2FnZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5mb3JldmVyU2NhbiA9IGZ1bmN0aW9uIChpbnRlcm5hbENvbmZpZywgcXJDb2RlU3VjY2Vzc0NhbGxiYWNrLCBxckNvZGVFcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zaG91bGRTY2FuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVkQ2FtZXJhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpZGVvRWxlbWVudCA9IHRoaXMucmVuZGVyZWRDYW1lcmEuZ2V0U3VyZmFjZSgpO1xuICAgICAgICB2YXIgd2lkdGhSYXRpbyA9IHZpZGVvRWxlbWVudC52aWRlb1dpZHRoIC8gdmlkZW9FbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0UmF0aW8gPSB2aWRlb0VsZW1lbnQudmlkZW9IZWlnaHQgLyB2aWRlb0VsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAoIXRoaXMucXJSZWdpb24pIHtcbiAgICAgICAgICAgIHRocm93IFwicXJSZWdpb24gdW5kZWZpbmVkIHdoZW4gbG9jYWxNZWRpYVN0cmVhbSBpcyByZWFkeS5cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc1dpZHRoT2Zmc2V0ID0gdGhpcy5xclJlZ2lvbi53aWR0aCAqIHdpZHRoUmF0aW87XG4gICAgICAgIHZhciBzSGVpZ2h0T2Zmc2V0ID0gdGhpcy5xclJlZ2lvbi5oZWlnaHQgKiBoZWlnaHRSYXRpbztcbiAgICAgICAgdmFyIHN4T2Zmc2V0ID0gdGhpcy5xclJlZ2lvbi54ICogd2lkdGhSYXRpbztcbiAgICAgICAgdmFyIHN5T2Zmc2V0ID0gdGhpcy5xclJlZ2lvbi55ICogaGVpZ2h0UmF0aW87XG4gICAgICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UodmlkZW9FbGVtZW50LCBzeE9mZnNldCwgc3lPZmZzZXQsIHNXaWR0aE9mZnNldCwgc0hlaWdodE9mZnNldCwgMCwgMCwgdGhpcy5xclJlZ2lvbi53aWR0aCwgdGhpcy5xclJlZ2lvbi5oZWlnaHQpO1xuICAgICAgICB2YXIgdHJpZ2dlck5leHRTY2FuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZm9yZXZlclNjYW5UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZm9yZXZlclNjYW4oaW50ZXJuYWxDb25maWcsIHFyQ29kZVN1Y2Nlc3NDYWxsYmFjaywgcXJDb2RlRXJyb3JDYWxsYmFjayk7XG4gICAgICAgICAgICB9LCBfdGhpcy5nZXRUaW1lb3V0RnBzKGludGVybmFsQ29uZmlnLmZwcykpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNjYW5Db250ZXh0KHFyQ29kZVN1Y2Nlc3NDYWxsYmFjaywgcXJDb2RlRXJyb3JDYWxsYmFjaylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChpc1N1Y2Nlc3NmdWxsKSB7XG4gICAgICAgICAgICBpZiAoIWlzU3VjY2Vzc2Z1bGwgJiYgaW50ZXJuYWxDb25maWcuZGlzYWJsZUZsaXAgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250ZXh0LnRyYW5zbGF0ZShfdGhpcy5jb250ZXh0LmNhbnZhcy53aWR0aCwgMCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGV4dC5zY2FsZSgtMSwgMSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2NhbkNvbnRleHQocXJDb2RlU3VjY2Vzc0NhbGxiYWNrLCBxckNvZGVFcnJvckNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJOZXh0U2NhbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlck5leHRTY2FuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiRXJyb3IgaGFwcGVuZCB3aGlsZSBzY2FubmluZyBjb250ZXh0XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHRyaWdnZXJOZXh0U2NhbigpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5jcmVhdGVWaWRlb0NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGNhbWVyYUlkT3JDb25maWcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYW1lcmFJZE9yQ29uZmlnID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRldmljZUlkOiB7IGV4YWN0OiBjYW1lcmFJZE9yQ29uZmlnIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2FtZXJhSWRPckNvbmZpZyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB2YXIgZmFjaW5nTW9kZUtleSA9IFwiZmFjaW5nTW9kZVwiO1xuICAgICAgICAgICAgdmFyIGRldmljZUlkS2V5ID0gXCJkZXZpY2VJZFwiO1xuICAgICAgICAgICAgdmFyIGFsbG93ZWRGYWNpbmdNb2RlVmFsdWVzXzEgPSB7IFwidXNlclwiOiB0cnVlLCBcImVudmlyb25tZW50XCI6IHRydWUgfTtcbiAgICAgICAgICAgIHZhciBleGFjdEtleSA9IFwiZXhhY3RcIjtcbiAgICAgICAgICAgIHZhciBpc1ZhbGlkRmFjaW5nTW9kZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluIGFsbG93ZWRGYWNpbmdNb2RlVmFsdWVzXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcImNvbmZpZyBoYXMgaW52YWxpZCAnZmFjaW5nTW9kZScgdmFsdWUgPSBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBcIidcIi5jb25jYXQodmFsdWUsIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjYW1lcmFJZE9yQ29uZmlnKTtcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiJ2NhbWVyYUlkT3JDb25maWcnIG9iamVjdCBzaG91bGQgaGF2ZSBleGFjdGx5IDEga2V5LFwiXG4gICAgICAgICAgICAgICAgICAgICsgXCIgaWYgcGFzc2VkIGFzIGFuIG9iamVjdCwgZm91bmQgXCIuY29uY2F0KGtleXMubGVuZ3RoLCBcIiBrZXlzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleSA9IE9iamVjdC5rZXlzKGNhbWVyYUlkT3JDb25maWcpWzBdO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gZmFjaW5nTW9kZUtleSAmJiBrZXkgIT09IGRldmljZUlkS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJPbmx5ICdcIi5jb25jYXQoZmFjaW5nTW9kZUtleSwgXCInIGFuZCAnXCIpLmNvbmNhdChkZXZpY2VJZEtleSwgXCInIFwiKVxuICAgICAgICAgICAgICAgICAgICArIFwiIGFyZSBzdXBwb3J0ZWQgZm9yICdjYW1lcmFJZE9yQ29uZmlnJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gZmFjaW5nTW9kZUtleSkge1xuICAgICAgICAgICAgICAgIHZhciBmYWNpbmdNb2RlID0gY2FtZXJhSWRPckNvbmZpZy5mYWNpbmdNb2RlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmFjaW5nTW9kZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkRmFjaW5nTW9kZVZhbHVlKGZhY2luZ01vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmYWNpbmdNb2RlOiBmYWNpbmdNb2RlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZhY2luZ01vZGUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhhY3RLZXkgaW4gZmFjaW5nTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRGYWNpbmdNb2RlVmFsdWUoZmFjaW5nTW9kZVtcIlwiLmNvbmNhdChleGFjdEtleSldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY2luZ01vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWNpbmdNb2RlW1wiXCIuY29uY2F0KGV4YWN0S2V5KV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIidmYWNpbmdNb2RlJyBzaG91bGQgYmUgc3RyaW5nIG9yIG9iamVjdCB3aXRoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIFwiIFwiLmNvbmNhdChleGFjdEtleSwgXCIgYXMga2V5LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVfMSA9ICh0eXBlb2YgZmFjaW5nTW9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCB0eXBlIG9mICdmYWNpbmdNb2RlJyA9IFwiLmNvbmNhdCh0eXBlXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkZXZpY2VJZCA9IGNhbWVyYUlkT3JDb25maWcuZGV2aWNlSWQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXZpY2VJZCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRldmljZUlkOiBkZXZpY2VJZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGV2aWNlSWQgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhhY3RLZXkgaW4gZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlSWQ6IHsgZXhhY3Q6IGRldmljZUlkW1wiXCIuY29uY2F0KGV4YWN0S2V5KV0gfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiJ2RldmljZUlkJyBzaG91bGQgYmUgc3RyaW5nIG9yIG9iamVjdCB3aXRoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIFwiIFwiLmNvbmNhdChleGFjdEtleSwgXCIgYXMga2V5LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVfMiA9ICh0eXBlb2YgZGV2aWNlSWQpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdHlwZSBvZiAnZGV2aWNlSWQnID0gXCIuY29uY2F0KHR5cGVfMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gKHR5cGVvZiBjYW1lcmFJZE9yQ29uZmlnKTtcbiAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHR5cGUgb2YgJ2NhbWVyYUlkT3JDb25maWcnID0gXCIuY29uY2F0KHR5cGUpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLmNvbXB1dGVDYW52YXNEcmF3Q29uZmlnID0gZnVuY3Rpb24gKGltYWdlV2lkdGgsIGltYWdlSGVpZ2h0LCBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KSB7XG4gICAgICAgIGlmIChpbWFnZVdpZHRoIDw9IGNvbnRhaW5lcldpZHRoXG4gICAgICAgICAgICAmJiBpbWFnZUhlaWdodCA8PSBjb250YWluZXJIZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciB4b2Zmc2V0ID0gKGNvbnRhaW5lcldpZHRoIC0gaW1hZ2VXaWR0aCkgLyAyO1xuICAgICAgICAgICAgdmFyIHlvZmZzZXQgPSAoY29udGFpbmVySGVpZ2h0IC0gaW1hZ2VIZWlnaHQpIC8gMjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogeG9mZnNldCxcbiAgICAgICAgICAgICAgICB5OiB5b2Zmc2V0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBpbWFnZVdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaW1hZ2VIZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZm9ybWVySW1hZ2VXaWR0aCA9IGltYWdlV2lkdGg7XG4gICAgICAgICAgICB2YXIgZm9ybWVySW1hZ2VIZWlnaHQgPSBpbWFnZUhlaWdodDtcbiAgICAgICAgICAgIGlmIChpbWFnZVdpZHRoID4gY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpbWFnZUhlaWdodCA9IChjb250YWluZXJXaWR0aCAvIGltYWdlV2lkdGgpICogaW1hZ2VIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaW1hZ2VXaWR0aCA9IGNvbnRhaW5lcldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltYWdlSGVpZ2h0ID4gY29udGFpbmVySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VXaWR0aCA9IChjb250YWluZXJIZWlnaHQgLyBpbWFnZUhlaWdodCkgKiBpbWFnZVdpZHRoO1xuICAgICAgICAgICAgICAgIGltYWdlSGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiSW1hZ2UgZG93bnNhbXBsZWQgZnJvbSBcIlxuICAgICAgICAgICAgICAgICsgXCJcIi5jb25jYXQoZm9ybWVySW1hZ2VXaWR0aCwgXCJYXCIpLmNvbmNhdChmb3JtZXJJbWFnZUhlaWdodClcbiAgICAgICAgICAgICAgICArIFwiIHRvIFwiLmNvbmNhdChpbWFnZVdpZHRoLCBcIlhcIikuY29uY2F0KGltYWdlSGVpZ2h0LCBcIi5cIikpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUNhbnZhc0RyYXdDb25maWcoaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQsIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuY2xlYXJFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZU1hbmFnZXJQcm94eS5pc1NjYW5uaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IFwiQ2Fubm90IGNsZWFyIHdoaWxlIHNjYW4gaXMgb25nb2luZywgY2xvc2UgaXQgZmlyc3QuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmVsZW1lbnRJZCk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5wb3NzaWJseVVwZGF0ZVNoYWRlcnMgPSBmdW5jdGlvbiAocXJNYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5xck1hdGNoID09PSBxck1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzQm9yZGVyU2hhZGVyc1xuICAgICAgICAgICAgJiYgdGhpcy5ib3JkZXJTaGFkZXJzXG4gICAgICAgICAgICAmJiB0aGlzLmJvcmRlclNoYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJvcmRlclNoYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgc2hhZGVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHFyTWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgPyBDb25zdGFudHMuQk9SREVSX1NIQURFUl9NQVRDSF9DT0xPUlxuICAgICAgICAgICAgICAgICAgICA6IENvbnN0YW50cy5CT1JERVJfU0hBREVSX0RFRkFVTFRfQ09MT1I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnFyTWF0Y2ggPSBxck1hdGNoO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnBvc3NpYmx5Q2xvc2VMYXN0U2NhbkltYWdlRmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdFNjYW5JbWFnZUZpbGUpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5sYXN0U2NhbkltYWdlRmlsZSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RTY2FuSW1hZ2VGaWxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLmNyZWF0ZUNhbnZhc0VsZW1lbnQgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgY3VzdG9tSWQpIHtcbiAgICAgICAgdmFyIGNhbnZhc1dpZHRoID0gd2lkdGg7XG4gICAgICAgIHZhciBjYW52YXNIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgY2FudmFzRWxlbWVudC5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KGNhbnZhc1dpZHRoLCBcInB4XCIpO1xuICAgICAgICBjYW52YXNFbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGNhbnZhc0hlaWdodCwgXCJweFwiKTtcbiAgICAgICAgY2FudmFzRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuaWQgPSBpc051bGxPclVuZGVmaW5lZChjdXN0b21JZClcbiAgICAgICAgICAgID8gXCJxci1jYW52YXNcIiA6IGN1c3RvbUlkO1xuICAgICAgICByZXR1cm4gY2FudmFzRWxlbWVudDtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5nZXRTaGFkZWRSZWdpb25Cb3VuZHMgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgcXJib3hTaXplKSB7XG4gICAgICAgIGlmIChxcmJveFNpemUud2lkdGggPiB3aWR0aCB8fCBxcmJveFNpemUuaGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aHJvdyBcIidjb25maWcucXJib3gnIGRpbWVuc2lvbnMgc2hvdWxkIG5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIFwiXG4gICAgICAgICAgICAgICAgKyBcImRpbWVuc2lvbnMgb2YgdGhlIHJvb3QgSFRNTCBlbGVtZW50LlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAod2lkdGggLSBxcmJveFNpemUud2lkdGgpIC8gMixcbiAgICAgICAgICAgIHk6IChoZWlnaHQgLSBxcmJveFNpemUuaGVpZ2h0KSAvIDIsXG4gICAgICAgICAgICB3aWR0aDogcXJib3hTaXplLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBxcmJveFNpemUuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUucG9zc2libHlJbnNlcnRTaGFkaW5nRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCB3aWR0aCwgaGVpZ2h0LCBxcmJveFNpemUpIHtcbiAgICAgICAgaWYgKCh3aWR0aCAtIHFyYm94U2l6ZS53aWR0aCkgPCAxIHx8IChoZWlnaHQgLSBxcmJveFNpemUuaGVpZ2h0KSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hhZGluZ0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzaGFkaW5nRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgdmFyIHJpZ2h0TGVmdEJvcmRlclNpemUgPSAod2lkdGggLSBxcmJveFNpemUud2lkdGgpIC8gMjtcbiAgICAgICAgdmFyIHRvcEJvdHRvbUJvcmRlclNpemUgPSAoaGVpZ2h0IC0gcXJib3hTaXplLmhlaWdodCkgLyAyO1xuICAgICAgICBzaGFkaW5nRWxlbWVudC5zdHlsZS5ib3JkZXJMZWZ0XG4gICAgICAgICAgICA9IFwiXCIuY29uY2F0KHJpZ2h0TGVmdEJvcmRlclNpemUsIFwicHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjQ4KVwiKTtcbiAgICAgICAgc2hhZGluZ0VsZW1lbnQuc3R5bGUuYm9yZGVyUmlnaHRcbiAgICAgICAgICAgID0gXCJcIi5jb25jYXQocmlnaHRMZWZ0Qm9yZGVyU2l6ZSwgXCJweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNDgpXCIpO1xuICAgICAgICBzaGFkaW5nRWxlbWVudC5zdHlsZS5ib3JkZXJUb3BcbiAgICAgICAgICAgID0gXCJcIi5jb25jYXQodG9wQm90dG9tQm9yZGVyU2l6ZSwgXCJweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNDgpXCIpO1xuICAgICAgICBzaGFkaW5nRWxlbWVudC5zdHlsZS5ib3JkZXJCb3R0b21cbiAgICAgICAgICAgID0gXCJcIi5jb25jYXQodG9wQm90dG9tQm9yZGVyU2l6ZSwgXCJweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNDgpXCIpO1xuICAgICAgICBzaGFkaW5nRWxlbWVudC5zdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIjtcbiAgICAgICAgc2hhZGluZ0VsZW1lbnQuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgICAgc2hhZGluZ0VsZW1lbnQuc3R5bGUuYm90dG9tID0gXCIwcHhcIjtcbiAgICAgICAgc2hhZGluZ0VsZW1lbnQuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgIHNoYWRpbmdFbGVtZW50LnN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICAgICAgc2hhZGluZ0VsZW1lbnQuaWQgPSBcIlwiLmNvbmNhdChDb25zdGFudHMuU0hBREVEX1JFR0lPTl9FTEVNRU5UX0lEKTtcbiAgICAgICAgaWYgKCh3aWR0aCAtIHFyYm94U2l6ZS53aWR0aCkgPCAxMVxuICAgICAgICAgICAgfHwgKGhlaWdodCAtIHFyYm94U2l6ZS5oZWlnaHQpIDwgMTEpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQm9yZGVyU2hhZGVycyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNtYWxsU2l6ZSA9IDU7XG4gICAgICAgICAgICB2YXIgbGFyZ2VTaXplID0gNDA7XG4gICAgICAgICAgICB0aGlzLmluc2VydFNoYWRlckJvcmRlcnMoc2hhZGluZ0VsZW1lbnQsIGxhcmdlU2l6ZSwgc21hbGxTaXplLCAtc21hbGxTaXplLCBudWxsLCAwLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhZGVyQm9yZGVycyhzaGFkaW5nRWxlbWVudCwgbGFyZ2VTaXplLCBzbWFsbFNpemUsIC1zbWFsbFNpemUsIG51bGwsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhZGVyQm9yZGVycyhzaGFkaW5nRWxlbWVudCwgbGFyZ2VTaXplLCBzbWFsbFNpemUsIG51bGwsIC1zbWFsbFNpemUsIDAsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRTaGFkZXJCb3JkZXJzKHNoYWRpbmdFbGVtZW50LCBsYXJnZVNpemUsIHNtYWxsU2l6ZSwgbnVsbCwgLXNtYWxsU2l6ZSwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRTaGFkZXJCb3JkZXJzKHNoYWRpbmdFbGVtZW50LCBzbWFsbFNpemUsIGxhcmdlU2l6ZSArIHNtYWxsU2l6ZSwgLXNtYWxsU2l6ZSwgbnVsbCwgLXNtYWxsU2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmluc2VydFNoYWRlckJvcmRlcnMoc2hhZGluZ0VsZW1lbnQsIHNtYWxsU2l6ZSwgbGFyZ2VTaXplICsgc21hbGxTaXplLCBudWxsLCAtc21hbGxTaXplLCAtc21hbGxTaXplLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhZGVyQm9yZGVycyhzaGFkaW5nRWxlbWVudCwgc21hbGxTaXplLCBsYXJnZVNpemUgKyBzbWFsbFNpemUsIC1zbWFsbFNpemUsIG51bGwsIC1zbWFsbFNpemUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhZGVyQm9yZGVycyhzaGFkaW5nRWxlbWVudCwgc21hbGxTaXplLCBsYXJnZVNpemUgKyBzbWFsbFNpemUsIG51bGwsIC1zbWFsbFNpemUsIC1zbWFsbFNpemUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaGFzQm9yZGVyU2hhZGVycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5hcHBlbmQoc2hhZGluZ0VsZW1lbnQpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLmluc2VydFNoYWRlckJvcmRlcnMgPSBmdW5jdGlvbiAoc2hhZGVyRWxlbSwgd2lkdGgsIGhlaWdodCwgdG9wLCBib3R0b20sIHNpZGUsIGlzTGVmdCkge1xuICAgICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIGVsZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gQ29uc3RhbnRzLkJPUkRFUl9TSEFERVJfREVGQVVMVF9DT0xPUjtcbiAgICAgICAgZWxlbS5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpO1xuICAgICAgICBlbGVtLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgaWYgKHRvcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZWxlbS5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdCh0b3AsIFwicHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvdHRvbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5ib3R0b20gPSBcIlwiLmNvbmNhdChib3R0b20sIFwicHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGVmdCkge1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQoc2lkZSwgXCJweFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsZW0uc3R5bGUucmlnaHQgPSBcIlwiLmNvbmNhdChzaWRlLCBcInB4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5ib3JkZXJTaGFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmJvcmRlclNoYWRlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvcmRlclNoYWRlcnMucHVzaChlbGVtKTtcbiAgICAgICAgc2hhZGVyRWxlbS5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5zaG93UGF1c2VkU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zY2FubmVyUGF1c2VkVWlFbGVtZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBcIltpbnRlcm5hbCBlcnJvcl0gc2Nhbm5lciBwYXVzZWQgVUkgZWxlbWVudCBub3QgZm91bmRcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5oaWRlUGF1c2VkU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zY2FubmVyUGF1c2VkVWlFbGVtZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBcIltpbnRlcm5hbCBlcnJvcl0gc2Nhbm5lciBwYXVzZWQgVUkgZWxlbWVudCBub3QgZm91bmRcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLmdldFRpbWVvdXRGcHMgPSBmdW5jdGlvbiAoZnBzKSB7XG4gICAgICAgIHJldHVybiAxMDAwIC8gZnBzO1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWw1UXJjb2RlO1xufSgpKTtcbmV4cG9ydCB7IEh0bWw1UXJjb2RlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odG1sNS1xcmNvZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/html5-qrcode.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/image-assets.js":
/*!*******************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/image-assets.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ASSET_CAMERA_SCAN: function() { return /* binding */ ASSET_CAMERA_SCAN; },\n/* harmony export */   ASSET_CLOSE_ICON_16PX: function() { return /* binding */ ASSET_CLOSE_ICON_16PX; },\n/* harmony export */   ASSET_FILE_SCAN: function() { return /* binding */ ASSET_FILE_SCAN; },\n/* harmony export */   ASSET_INFO_ICON_16PX: function() { return /* binding */ ASSET_INFO_ICON_16PX; }\n/* harmony export */ });\nvar SVG_XML_PREFIX = \"data:image/svg+xml;base64,\";\nvar ASSET_CAMERA_SCAN = SVG_XML_PREFIX + \"PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzNzEuNjQzIDM3MS42NDMiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDM3MS42NDMgMzcxLjY0MyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PHBhdGggZD0iTTEwNS4wODQgMzguMjcxaDE2My43Njh2MjBIMTA1LjA4NHoiLz48cGF0aCBkPSJNMzExLjU5NiAxOTAuMTg5Yy03LjQ0MS05LjM0Ny0xOC40MDMtMTYuMjA2LTMyLjc0My0yMC41MjJWMzBjMC0xNi41NDItMTMuNDU4LTMwLTMwLTMwSDEyNS4wODRjLTE2LjU0MiAwLTMwIDEzLjQ1OC0zMCAzMHYxMjAuMTQzaC04LjI5NmMtMTYuNTQyIDAtMzAgMTMuNDU4LTMwIDMwdjEuMzMzYTI5LjgwNCAyOS44MDQgMCAwIDAgNC42MDMgMTUuOTM5Yy03LjM0IDUuNDc0LTEyLjEwMyAxNC4yMjEtMTIuMTAzIDI0LjA2MXYxLjMzM2MwIDkuODQgNC43NjMgMTguNTg3IDEyLjEwMyAyNC4wNjJhMjkuODEgMjkuODEgMCAwIDAtNC42MDMgMTUuOTM4djEuMzMzYzAgMTYuNTQyIDEzLjQ1OCAzMCAzMCAzMGg4LjMyNGMuNDI3IDExLjYzMSA3LjUwMyAyMS41ODcgMTcuNTM0IDI2LjE3Ny45MzEgMTAuNTAzIDQuMDg0IDMwLjE4NyAxNC43NjggNDUuNTM3YTkuOTg4IDkuOTg4IDAgMCAwIDguMjE2IDQuMjg4IDkuOTU4IDkuOTU4IDAgMCAwIDUuNzA0LTEuNzkzYzQuNTMzLTMuMTU1IDUuNjUtOS4zODggMi40OTUtMTMuOTIxLTYuNzk4LTkuNzY3LTkuNjAyLTIyLjYwOC0xMC43Ni0zMS40aDgyLjY4NWMuMjcyLjQxNC41NDUuODE4LjgxNSAxLjIxIDMuMTQyIDQuNTQxIDkuMzcyIDUuNjc5IDEzLjkxMyAyLjUzNCA0LjU0Mi0zLjE0MiA1LjY3Ny05LjM3MSAyLjUzNS0xMy45MTMtMTEuOTE5LTE3LjIyOS04Ljc4Ny0zNS44ODQgOS41ODEtNTcuMDEyIDMuMDY3LTIuNjUyIDEyLjMwNy0xMS43MzIgMTEuMjE3LTI0LjAzMy0uODI4LTkuMzQzLTcuMTA5LTE3LjE5NC0xOC42NjktMjMuMzM3YTkuODU3IDkuODU3IDAgMCAwLTEuMDYxLS40ODZjLS40NjYtLjE4Mi0xMS40MDMtNC41NzktOS43NDEtMTUuNzA2IDEuMDA3LTYuNzM3IDE0Ljc2OC04LjI3MyAyMy43NjYtNy42NjYgMjMuMTU2IDEuNTY5IDM5LjY5OCA3LjgwMyA0Ny44MzYgMTguMDI2IDUuNzUyIDcuMjI1IDcuNjA3IDE2LjYyMyA1LjY3MyAyOC43MzMtLjQxMyAyLjU4NS0uODI0IDUuMjQxLTEuMjQ1IDcuOTU5LTUuNzU2IDM3LjE5NC0xMi45MTkgODMuNDgzLTQ5Ljg3IDExNC42NjEtNC4yMjEgMy41NjEtNC43NTYgOS44Ny0xLjE5NCAxNC4wOTJhOS45OCA5Ljk4IDAgMCAwIDcuNjQ4IDMuNTUxIDkuOTU1IDkuOTU1IDAgMCAwIDYuNDQ0LTIuMzU4YzQyLjY3Mi0zNi4wMDUgNTAuODAyLTg4LjUzMyA1Ni43MzctMTI2Ljg4OC40MTUtMi42ODQuODIxLTUuMzA5IDEuMjI5LTcuODYzIDIuODM0LTE3LjcyMS0uNDU1LTMyLjY0MS05Ljc3Mi00NC4zNDV6bS0yMzIuMzA4IDQyLjYyYy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi0xLjMzM2MwLTUuNTE0IDQuNDg2LTEwIDEwLTEwaDE1djIxLjMzM2gtMTV6bS0yLjUtNTIuNjY2YzAtNS41MTQgNC40ODYtMTAgMTAtMTBoNy41djIxLjMzM2gtNy41Yy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi0xLjMzM3ptMTcuNSA5My45OTloLTcuNWMtNS41MTQgMC0xMC00LjQ4Ni0xMC0xMHYtMS4zMzNjMC01LjUxNCA0LjQ4Ni0xMCAxMC0xMGg3LjV2MjEuMzMzem0zMC43OTYgMjguODg3Yy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi04LjI3MWg5MS40NTdjLS44NTEgNi42NjgtLjQzNyAxMi43ODcuNzMxIDE4LjI3MWgtODIuMTg4em03OS40ODItMTEzLjY5OGMtMy4xMjQgMjAuOTA2IDEyLjQyNyAzMy4xODQgMjEuNjI1IDM3LjA0IDUuNDQxIDIuOTY4IDcuNTUxIDUuNjQ3IDcuNzAxIDcuMTg4LjIxIDIuMTUtMi41NTMgNS42ODQtNC40NzcgNy4yNTEtLjQ4Mi4zNzgtLjkyOS44LTEuMzM1IDEuMjYxLTYuOTg3IDcuOTM2LTExLjk4MiAxNS41Mi0xNS40MzIgMjIuNjg4aC05Ny41NjRWMzBjMC01LjUxNCA0LjQ4Ni0xMCAxMC0xMGgxMjMuNzY5YzUuNTE0IDAgMTAgNC40ODYgMTAgMTB2MTM1LjU3OWMtMy4wMzItLjM4MS02LjE1LS42OTQtOS4zODktLjkxNC0yNS4xNTktMS42OTQtNDIuMzcgNy43NDgtNDQuODk4IDI0LjY2NnoiLz48cGF0aCBkPSJNMTc5LjEyOSA4My4xNjdoLTI0LjA2YTUgNSAwIDAgMC01IDV2MjQuMDYxYTUgNSAwIDAgMCA1IDVoMjQuMDZhNSA1IDAgMCAwIDUtNVY4OC4xNjdhNSA1IDAgMCAwLTUtNXpNMTcyLjYyOSAxNDIuODZoLTEyLjU2VjEzMC44YTUgNSAwIDEgMC0xMCAwdjE3LjA2MWE1IDUgMCAwIDAgNSA1aDE3LjU2YTUgNSAwIDEgMCAwLTEwLjAwMXpNMjE2LjU2OCA4My4xNjdoLTI0LjA2YTUgNSAwIDAgMC01IDV2MjQuMDYxYTUgNSAwIDAgMCA1IDVoMjQuMDZhNSA1IDAgMCAwIDUtNVY4OC4xNjdhNSA1IDAgMCAwLTUtNXptLTUgMjQuMDYxaC0xNC4wNlY5My4xNjdoMTQuMDZ2MTQuMDYxek0yMTEuNjY5IDEyNS45MzZIMTk3LjQxYTUgNSAwIDAgMC01IDV2MTQuMjU3YTUgNSAwIDAgMCA1IDVoMTQuMjU5YTUgNSAwIDAgMCA1LTV2LTE0LjI1N2E1IDUgMCAwIDAtNS01eiIvPjwvc3ZnPg==\";\nvar ASSET_FILE_SCAN = SVG_XML_PREFIX + \"PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1OS4wMTggNTkuMDE4IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1OS4wMTggNTkuMDE4IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJtNTguNzQxIDU0LjgwOS01Ljk2OS02LjI0NGExMC43NCAxMC43NCAwIDAgMCAyLjgyLTcuMjVjMC01Ljk1My00Ljg0My0xMC43OTYtMTAuNzk2LTEwLjc5NlMzNCAzNS4zNjEgMzQgNDEuMzE0IDM4Ljg0MyA1Mi4xMSA0NC43OTYgNTIuMTFjMi40NDEgMCA0LjY4OC0uODI0IDYuNDk5LTIuMTk2bDYuMDAxIDYuMjc3YS45OTguOTk4IDAgMCAwIDEuNDE0LjAzMiAxIDEgMCAwIDAgLjAzMS0xLjQxNHpNMzYgNDEuMzE0YzAtNC44NSAzLjk0Ni04Ljc5NiA4Ljc5Ni04Ljc5NnM4Ljc5NiAzLjk0NiA4Ljc5NiA4Ljc5Ni0zLjk0NiA4Ljc5Ni04Ljc5NiA4Ljc5NlMzNiA0Ni4xNjQgMzYgNDEuMzE0ek0xMC40MzEgMTYuMDg4YzAgMy4wNyAyLjQ5OCA1LjU2OCA1LjU2OSA1LjU2OHM1LjU2OS0yLjQ5OCA1LjU2OS01LjU2OGMwLTMuMDcxLTIuNDk4LTUuNTY5LTUuNTY5LTUuNTY5cy01LjU2OSAyLjQ5OC01LjU2OSA1LjU2OXptOS4xMzggMGMwIDEuOTY4LTEuNjAyIDMuNTY4LTMuNTY5IDMuNTY4cy0zLjU2OS0xLjYwMS0zLjU2OS0zLjU2OCAxLjYwMi0zLjU2OSAzLjU2OS0zLjU2OSAzLjU2OSAxLjYwMSAzLjU2OSAzLjU2OXoiLz48cGF0aCBkPSJtMzAuODgyIDI4Ljk4NyA5LjE4LTEwLjA1NCAxMS4yNjIgMTAuMzIzYTEgMSAwIDAgMCAxLjM1MS0xLjQ3NWwtMTItMTFhMSAxIDAgMCAwLTEuNDE0LjA2M2wtOS43OTQgMTAuNzI3LTQuNzQzLTQuNzQzYTEuMDAzIDEuMDAzIDAgMCAwLTEuMzY4LS4wNDRMNi4zMzkgMzcuNzY4YTEgMSAwIDEgMCAxLjMyMiAxLjUwMWwxNi4zMTMtMTQuMzYyIDcuMzE5IDcuMzE4YS45OTkuOTk5IDAgMSAwIDEuNDE0LTEuNDE0bC0xLjgyNS0xLjgyNHoiLz48cGF0aCBkPSJNMzAgNDYuNTE4SDJ2LTQyaDU0djI4YTEgMSAwIDEgMCAyIDB2LTI5YTEgMSAwIDAgMC0xLTFIMWExIDEgMCAwIDAtMSAxdjQ0YTEgMSAwIDAgMCAxIDFoMjlhMSAxIDAgMSAwIDAtMnoiLz48L3N2Zz4=\";\nvar ASSET_INFO_ICON_16PX = SVG_XML_PREFIX + \"PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0NjAgNDYwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NjAgNDYwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNMjMwIDBDMTAyLjk3NSAwIDAgMTAyLjk3NSAwIDIzMHMxMDIuOTc1IDIzMCAyMzAgMjMwIDIzMC0xMDIuOTc0IDIzMC0yMzBTMzU3LjAyNSAwIDIzMCAwem0zOC4zMzMgMzc3LjM2YzAgOC42NzYtNy4wMzQgMTUuNzEtMTUuNzEgMTUuNzFoLTQzLjEwMWMtOC42NzYgMC0xNS43MS03LjAzNC0xNS43MS0xNS43MVYyMDIuNDc3YzAtOC42NzYgNy4wMzMtMTUuNzEgMTUuNzEtMTUuNzFoNDMuMTAxYzguNjc2IDAgMTUuNzEgNy4wMzMgMTUuNzEgMTUuNzFWMzc3LjM2ek0yMzAgMTU3Yy0yMS41MzkgMC0zOS0xNy40NjEtMzktMzlzMTcuNDYxLTM5IDM5LTM5IDM5IDE3LjQ2MSAzOSAzOS0xNy40NjEgMzktMzkgMzl6Ii8+PC9zdmc+\";\nvar ASSET_CLOSE_ICON_16PX = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAQgAAAEIBarqQRAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAE1SURBVDiNfdI7S0NBEAXgLya1otFgpbYSbISAgpXYi6CmiH9KCAiChaVga6OiWPgfRDQ+0itaGVNosXtluWwcuMzePfM4M3sq8lbHBubwg1dc4m1E/J/N4ghDPOIsfk/4xiEao5KX0McFljN4C9d4QTPXuY99jP3DsIoDPGM6BY5i5yI5R7O4q+ImFkJY2DCh3cAH2klyB+9J1xUMMAG7eCh1a+Mr+k48b5diXrFVwwLuS+BJ9MfR7+G0FHOHhTHhnXNWS87VDF4pcnfQK4Ep7XScNLmPTZgURNKKYENYWDpzW1BhscS1WHS8CDgURFJQrWcoF3c13KKbgg1BYQfy8xZWEzTTw1QZbAoKu8FqJnktdu5hcVSHmchiILzzuaDQvjBzV2m8yohCE1jHfPx/xhU+y4G/D75ELlRJsSYAAAAASUVORK5CYII=\";\n//# sourceMappingURL=image-assets.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9pbWFnZS1hc3NldHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLHlDQUF5QztBQUNsQztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDbkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vaW1hZ2UtYXNzZXRzLmpzP2MxMTYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFNWR19YTUxfUFJFRklYID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFwiO1xuZXhwb3J0IHZhciBBU1NFVF9DQU1FUkFfU0NBTiA9IFNWR19YTUxfUFJFRklYICsgXCJQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhacFpYZENiM2c5SWpBZ01DQXpOekV1TmpReklETTNNUzQyTkRNaUlITjBlV3hsUFNKbGJtRmliR1V0WW1GamEyZHliM1Z1WkRwdVpYY2dNQ0F3SURNM01TNDJORE1nTXpjeExqWTBNeUlnZUcxc09uTndZV05sUFNKd2NtVnpaWEoyWlNJK1BIQmhkR2dnWkQwaVRURXdOUzR3T0RRZ016Z3VNamN4YURFMk15NDNOamgyTWpCSU1UQTFMakE0TkhvaUx6NDhjR0YwYUNCa1BTSk5NekV4TGpVNU5pQXhPVEF1TVRnNVl5MDNMalEwTVMwNUxqTTBOeTB4T0M0ME1ETXRNVFl1TWpBMkxUTXlMamMwTXkweU1DNDFNakpXTXpCak1DMHhOaTQxTkRJdE1UTXVORFU0TFRNd0xUTXdMVE13U0RFeU5TNHdPRFJqTFRFMkxqVTBNaUF3TFRNd0lERXpMalExT0Mwek1DQXpNSFl4TWpBdU1UUXphQzA0TGpJNU5tTXRNVFl1TlRReUlEQXRNekFnTVRNdU5EVTRMVE13SURNd2RqRXVNek16WVRJNUxqZ3dOQ0F5T1M0NE1EUWdNQ0F3SURBZ05DNDJNRE1nTVRVdU9UTTVZeTAzTGpNMElEVXVORGMwTFRFeUxqRXdNeUF4TkM0eU1qRXRNVEl1TVRBeklESTBMakEyTVhZeExqTXpNMk13SURrdU9EUWdOQzQzTmpNZ01UZ3VOVGczSURFeUxqRXdNeUF5TkM0d05qSmhNamt1T0RFZ01qa3VPREVnTUNBd0lEQXROQzQyTURNZ01UVXVPVE00ZGpFdU16TXpZekFnTVRZdU5UUXlJREV6TGpRMU9DQXpNQ0F6TUNBek1HZzRMak15TkdNdU5ESTNJREV4TGpZek1TQTNMalV3TXlBeU1TNDFPRGNnTVRjdU5UTTBJREkyTGpFM055NDVNekVnTVRBdU5UQXpJRFF1TURnMElETXdMakU0TnlBeE5DNDNOamdnTkRVdU5UTTNZVGt1T1RnNElEa3VPVGc0SURBZ01DQXdJRGd1TWpFMklEUXVNamc0SURrdU9UVTRJRGt1T1RVNElEQWdNQ0F3SURVdU56QTBMVEV1Tnprell6UXVOVE16TFRNdU1UVTFJRFV1TmpVdE9TNHpPRGdnTWk0ME9UVXRNVE11T1RJeExUWXVOems0TFRrdU56WTNMVGt1TmpBeUxUSXlMall3T0MweE1DNDNOaTB6TVM0MGFEZ3lMalk0TldNdU1qY3lMalF4TkM0MU5EVXVPREU0TGpneE5TQXhMakl4SURNdU1UUXlJRFF1TlRReElEa3VNemN5SURVdU5qYzVJREV6TGpreE15QXlMalV6TkNBMExqVTBNaTB6TGpFME1pQTFMalkzTnkwNUxqTTNNU0F5TGpVek5TMHhNeTQ1TVRNdE1URXVPVEU1TFRFM0xqSXlPUzA0TGpjNE55MHpOUzQ0T0RRZ09TNDFPREV0TlRjdU1ERXlJRE11TURZM0xUSXVOalV5SURFeUxqTXdOeTB4TVM0M016SWdNVEV1TWpFM0xUSTBMakF6TXkwdU9ESTRMVGt1TXpRekxUY3VNVEE1TFRFM0xqRTVOQzB4T0M0Mk5qa3RNak11TXpNM1lUa3VPRFUzSURrdU9EVTNJREFnTUNBd0xURXVNRFl4TFM0ME9EWmpMUzQwTmpZdExqRTRNaTB4TVM0ME1ETXROQzQxTnprdE9TNDNOREV0TVRVdU56QTJJREV1TURBM0xUWXVOek0zSURFMExqYzJPQzA0TGpJM015QXlNeTQzTmpZdE55NDJOallnTWpNdU1UVTJJREV1TlRZNUlETTVMalk1T0NBM0xqZ3dNeUEwTnk0NE16WWdNVGd1TURJMklEVXVOelV5SURjdU1qSTFJRGN1TmpBM0lERTJMall5TXlBMUxqWTNNeUF5T0M0M016TXRMalF4TXlBeUxqVTROUzB1T0RJMElEVXVNalF4TFRFdU1qUTFJRGN1T1RVNUxUVXVOelUySURNM0xqRTVOQzB4TWk0NU1Ua2dPRE11TkRnekxUUTVMamczSURFeE5DNDJOakV0TkM0eU1qRWdNeTQxTmpFdE5DNDNOVFlnT1M0NE55MHhMakU1TkNBeE5DNHdPVEpoT1M0NU9DQTVMams0SURBZ01DQXdJRGN1TmpRNElETXVOVFV4SURrdU9UVTFJRGt1T1RVMUlEQWdNQ0F3SURZdU5EUTBMVEl1TXpVNFl6UXlMalkzTWkwek5pNHdNRFVnTlRBdU9EQXlMVGc0TGpVek15QTFOaTQzTXpjdE1USTJMamc0T0M0ME1UVXRNaTQyT0RRdU9ESXhMVFV1TXpBNUlERXVNakk1TFRjdU9EWXpJREl1T0RNMExURTNMamN5TVMwdU5EVTFMVE15TGpZME1TMDVMamMzTWkwME5DNHpORFY2YlMweU16SXVNekE0SURReUxqWXlZeTAxTGpVeE5DQXdMVEV3TFRRdU5EZzJMVEV3TFRFd2RpMHhMak16TTJNd0xUVXVOVEUwSURRdU5EZzJMVEV3SURFd0xURXdhREUxZGpJeExqTXpNMmd0TVRWNmJTMHlMalV0TlRJdU5qWTJZekF0TlM0MU1UUWdOQzQwT0RZdE1UQWdNVEF0TVRCb055NDFkakl4TGpNek0yZ3ROeTQxWXkwMUxqVXhOQ0F3TFRFd0xUUXVORGcyTFRFd0xURXdkaTB4TGpNek0zcHRNVGN1TlNBNU15NDVPVGxvTFRjdU5XTXROUzQxTVRRZ01DMHhNQzAwTGpRNE5pMHhNQzB4TUhZdE1TNHpNek5qTUMwMUxqVXhOQ0EwTGpRNE5pMHhNQ0F4TUMweE1HZzNMalYyTWpFdU16TXplbTB6TUM0M09UWWdNamd1T0RnM1l5MDFMalV4TkNBd0xURXdMVFF1TkRnMkxURXdMVEV3ZGkwNExqSTNNV2c1TVM0ME5UZGpMUzQ0TlRFZ05pNDJOamd0TGpRek55QXhNaTQzT0RjdU56TXhJREU0TGpJM01XZ3RPREl1TVRnNGVtMDNPUzQwT0RJdE1URXpMalk1T0dNdE15NHhNalFnTWpBdU9UQTJJREV5TGpReU55QXpNeTR4T0RRZ01qRXVOakkxSURNM0xqQTBJRFV1TkRReElESXVPVFk0SURjdU5UVXhJRFV1TmpRM0lEY3VOekF4SURjdU1UZzRMakl4SURJdU1UVXRNaTQxTlRNZ05TNDJPRFF0TkM0ME56Y2dOeTR5TlRFdExqUTRNaTR6TnpndExqa3lPUzQ0TFRFdU16TTFJREV1TWpZeExUWXVPVGczSURjdU9UTTJMVEV4TGprNE1pQXhOUzQxTWkweE5TNDBNeklnTWpJdU5qZzRhQzA1Tnk0MU5qUldNekJqTUMwMUxqVXhOQ0EwTGpRNE5pMHhNQ0F4TUMweE1HZ3hNak11TnpZNVl6VXVOVEUwSURBZ01UQWdOQzQwT0RZZ01UQWdNVEIyTVRNMUxqVTNPV010TXk0d016SXRMak00TVMwMkxqRTFMUzQyT1RRdE9TNHpPRGt0TGpreE5DMHlOUzR4TlRrdE1TNDJPVFF0TkRJdU16Y2dOeTQzTkRndE5EUXVPRGs0SURJMExqWTJObm9pTHo0OGNHRjBhQ0JrUFNKTk1UYzVMakV5T1NBNE15NHhOamRvTFRJMExqQTJZVFVnTlNBd0lEQWdNQzAxSURWMk1qUXVNRFl4WVRVZ05TQXdJREFnTUNBMUlEVm9NalF1TURaaE5TQTFJREFnTUNBd0lEVXROVlk0T0M0eE5qZGhOU0ExSURBZ01DQXdMVFV0TlhwTk1UY3lMall5T1NBeE5ESXVPRFpvTFRFeUxqVTJWakV6TUM0NFlUVWdOU0F3SURFZ01DMHhNQ0F3ZGpFM0xqQTJNV0UxSURVZ01DQXdJREFnTlNBMWFERTNMalUyWVRVZ05TQXdJREVnTUNBd0xURXdMakF3TVhwTk1qRTJMalUyT0NBNE15NHhOamRvTFRJMExqQTJZVFVnTlNBd0lEQWdNQzAxSURWMk1qUXVNRFl4WVRVZ05TQXdJREFnTUNBMUlEVm9NalF1TURaaE5TQTFJREFnTUNBd0lEVXROVlk0T0M0eE5qZGhOU0ExSURBZ01DQXdMVFV0TlhwdExUVWdNalF1TURZeGFDMHhOQzR3TmxZNU15NHhOamRvTVRRdU1EWjJNVFF1TURZeGVrMHlNVEV1TmpZNUlERXlOUzQ1TXpaSU1UazNMalF4WVRVZ05TQXdJREFnTUMwMUlEVjJNVFF1TWpVM1lUVWdOU0F3SURBZ01DQTFJRFZvTVRRdU1qVTVZVFVnTlNBd0lEQWdNQ0ExTFRWMkxURTBMakkxTjJFMUlEVWdNQ0F3SURBdE5TMDFlaUl2UGp3dmMzWm5QZz09XCI7XG5leHBvcnQgdmFyIEFTU0VUX0ZJTEVfU0NBTiA9IFNWR19YTUxfUFJFRklYICsgXCJQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhacFpYZENiM2c5SWpBZ01DQTFPUzR3TVRnZ05Ua3VNREU0SWlCemRIbHNaVDBpWlc1aFlteGxMV0poWTJ0bmNtOTFibVE2Ym1WM0lEQWdNQ0ExT1M0d01UZ2dOVGt1TURFNElpQjRiV3c2YzNCaFkyVTlJbkJ5WlhObGNuWmxJajQ4Y0dGMGFDQmtQU0p0TlRndU56UXhJRFUwTGpnd09TMDFMamsyT1MwMkxqSTBOR0V4TUM0M05DQXhNQzQzTkNBd0lEQWdNQ0F5TGpneUxUY3VNalZqTUMwMUxqazFNeTAwTGpnME15MHhNQzQzT1RZdE1UQXVOemsyTFRFd0xqYzVObE16TkNBek5TNHpOakVnTXpRZ05ERXVNekUwSURNNExqZzBNeUExTWk0eE1TQTBOQzQzT1RZZ05USXVNVEZqTWk0ME5ERWdNQ0EwTGpZNE9DMHVPREkwSURZdU5EazVMVEl1TVRrMmJEWXVNREF4SURZdU1qYzNZUzQ1T1RndU9UazRJREFnTUNBd0lERXVOREUwTGpBek1pQXhJREVnTUNBd0lEQWdMakF6TVMweExqUXhOSHBOTXpZZ05ERXVNekUwWXpBdE5DNDROU0F6TGprME5pMDRMamM1TmlBNExqYzVOaTA0TGpjNU5uTTRMamM1TmlBekxqazBOaUE0TGpjNU5pQTRMamM1TmkwekxqazBOaUE0TGpjNU5pMDRMamM1TmlBNExqYzVObE16TmlBME5pNHhOalFnTXpZZ05ERXVNekUwZWsweE1DNDBNekVnTVRZdU1EZzRZekFnTXk0d055QXlMalE1T0NBMUxqVTJPQ0ExTGpVMk9TQTFMalUyT0hNMUxqVTJPUzB5TGpRNU9DQTFMalUyT1MwMUxqVTJPR013TFRNdU1EY3hMVEl1TkRrNExUVXVOVFk1TFRVdU5UWTVMVFV1TlRZNWN5MDFMalUyT1NBeUxqUTVPQzAxTGpVMk9TQTFMalUyT1hwdE9TNHhNemdnTUdNd0lERXVPVFk0TFRFdU5qQXlJRE11TlRZNExUTXVOVFk1SURNdU5UWTRjeTB6TGpVMk9TMHhMall3TVMwekxqVTJPUzB6TGpVMk9DQXhMall3TWkwekxqVTJPU0F6TGpVMk9TMHpMalUyT1NBekxqVTJPU0F4TGpZd01TQXpMalUyT1NBekxqVTJPWG9pTHo0OGNHRjBhQ0JrUFNKdE16QXVPRGd5SURJNExqazROeUE1TGpFNExURXdMakExTkNBeE1TNHlOaklnTVRBdU16SXpZVEVnTVNBd0lEQWdNQ0F4TGpNMU1TMHhMalEzTld3dE1USXRNVEZoTVNBeElEQWdNQ0F3TFRFdU5ERTBMakEyTTJ3dE9TNDNPVFFnTVRBdU56STNMVFF1TnpRekxUUXVOelF6WVRFdU1EQXpJREV1TURBeklEQWdNQ0F3TFRFdU16WTRMUzR3TkRSTU5pNHpNemtnTXpjdU56WTRZVEVnTVNBd0lERWdNQ0F4TGpNeU1pQXhMalV3TVd3eE5pNHpNVE10TVRRdU16WXlJRGN1TXpFNUlEY3VNekU0WVM0NU9Ua3VPVGs1SURBZ01TQXdJREV1TkRFMExURXVOREUwYkMweExqZ3lOUzB4TGpneU5Ib2lMejQ4Y0dGMGFDQmtQU0pOTXpBZ05EWXVOVEU0U0RKMkxUUXlhRFUwZGpJNFlURWdNU0F3SURFZ01DQXlJREIyTFRJNVlURWdNU0F3SURBZ01DMHhMVEZJTVdFeElERWdNQ0F3SURBdE1TQXhkalEwWVRFZ01TQXdJREFnTUNBeElERm9NamxoTVNBeElEQWdNU0F3SURBdE1ub2lMejQ4TDNOMlp6ND1cIjtcbmV4cG9ydCB2YXIgQVNTRVRfSU5GT19JQ09OXzE2UFggPSBTVkdfWE1MX1BSRUZJWCArIFwiUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIWnBaWGRDYjNnOUlqQWdNQ0EwTmpBZ05EWXdJaUJ6ZEhsc1pUMGlaVzVoWW14bExXSmhZMnRuY205MWJtUTZibVYzSURBZ01DQTBOakFnTkRZd0lpQjRiV3c2YzNCaFkyVTlJbkJ5WlhObGNuWmxJajQ4Y0dGMGFDQmtQU0pOTWpNd0lEQkRNVEF5TGprM05TQXdJREFnTVRBeUxqazNOU0F3SURJek1ITXhNREl1T1RjMUlESXpNQ0F5TXpBZ01qTXdJREl6TUMweE1ESXVPVGMwSURJek1DMHlNekJUTXpVM0xqQXlOU0F3SURJek1DQXdlbTB6T0M0ek16TWdNemMzTGpNMll6QWdPQzQyTnpZdE55NHdNelFnTVRVdU56RXRNVFV1TnpFZ01UVXVOekZvTFRRekxqRXdNV010T0M0Mk56WWdNQzB4TlM0M01TMDNMakF6TkMweE5TNDNNUzB4TlM0M01WWXlNREl1TkRjM1l6QXRPQzQyTnpZZ055NHdNek10TVRVdU56RWdNVFV1TnpFdE1UVXVOekZvTkRNdU1UQXhZemd1TmpjMklEQWdNVFV1TnpFZ055NHdNek1nTVRVdU56RWdNVFV1TnpGV016YzNMak0yZWsweU16QWdNVFUzWXkweU1TNDFNemtnTUMwek9TMHhOeTQwTmpFdE16a3RNemx6TVRjdU5EWXhMVE01SURNNUxUTTVJRE01SURFM0xqUTJNU0F6T1NBek9TMHhOeTQwTmpFZ016a3RNemtnTXpsNklpOCtQQzl6ZG1jK1wiO1xuZXhwb3J0IHZhciBBU1NFVF9DTE9TRV9JQ09OXzE2UFggPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBWUFBQUFmOC85aEFBQUFCSE5DU1ZRSUNBZ0lmQWhraUFBQUFBbHdTRmx6QUFBQVFnQUFBRUlCYXJxUVJBQUFBQmwwUlZoMFUyOW1kSGRoY21VQWQzZDNMbWx1YTNOallYQmxMbTl5WjV2dVBCb0FBQUUxU1VSQlZEaU5mZEk3UzBOQkVBWGdMeWExb3RGZ3BiWVNiSVNBZ3BYWWk2Q21pSDlLQ0FpQ2hhVmdhNk9pV1BnZlJEUSswaXRhR1ZOb3NYdGx1V3djdU16ZVBmTTRNM3NxOGxiSEJ1YndnMWRjNG0xRS9KL040Z2hEUE9Jc2ZrLzR4aUVhbzVLWDBNY0Zsak40QzlkNFFUUFh1WTk5alAzRHNJb0RQR002Qlk1aTV5STVSN080cStJbUZrSlkyRENoM2NBSDJrbHlCKzlKMXhVTU1BRzdlQ2gxYStNcitrNDhiNWRpWHJGVnd3THVTK0JKOU1mUjcrRzBGSE9IaFRIaG5YTldTODdWREY0cGNuZlFLNEVwN1hTY05MbVBUWmdVUk5LS1lFTllXRHB6VzFCaHNjUzFXSFM4Q0RnVVJGSlFyV2NvRjNjMTNLS2JnZzFCWVFmeTh4WldFelRUdzFRWmJBb0t1OEZxSm5rdGR1NWhjVlNIbWNoaUlMenp1YURRdmpCelYybTh5b2hDRTFqSGZQeC94aFUreTRHL0Q3NUVMbFJKc1NZQUFBQUFTVVZPUks1Q1lJST1cIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLWFzc2V0cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/image-assets.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5Qrcode: function() { return /* reexport safe */ _html5_qrcode__WEBPACK_IMPORTED_MODULE_0__.Html5Qrcode; },\n/* harmony export */   Html5QrcodeScanType: function() { return /* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScanType; },\n/* harmony export */   Html5QrcodeScanner: function() { return /* reexport safe */ _html5_qrcode_scanner__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeScanner; },\n/* harmony export */   Html5QrcodeScannerState: function() { return /* reexport safe */ _state_manager__WEBPACK_IMPORTED_MODULE_3__.Html5QrcodeScannerState; },\n/* harmony export */   Html5QrcodeSupportedFormats: function() { return /* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeSupportedFormats; }\n/* harmony export */ });\n/* harmony import */ var _html5_qrcode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./html5-qrcode */ \"./node_modules/html5-qrcode/esm/html5-qrcode.js\");\n/* harmony import */ var _html5_qrcode_scanner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./html5-qrcode-scanner */ \"./node_modules/html5-qrcode/esm/html5-qrcode-scanner.js\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core */ \"./node_modules/html5-qrcode/esm/core.js\");\n/* harmony import */ var _state_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./state-manager */ \"./node_modules/html5-qrcode/esm/state-manager.js\");\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBNkM7QUFDZTtBQUNQO0FBQ0s7QUFDYjtBQUM3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9pbmRleC5qcz9lN2FhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IEh0bWw1UXJjb2RlIH0gZnJvbSBcIi4vaHRtbDUtcXJjb2RlXCI7XG5leHBvcnQgeyBIdG1sNVFyY29kZVNjYW5uZXIgfSBmcm9tIFwiLi9odG1sNS1xcmNvZGUtc2Nhbm5lclwiO1xuZXhwb3J0IHsgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzIH0gZnJvbSBcIi4vY29yZVwiO1xuZXhwb3J0IHsgSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUgfSBmcm9tIFwiLi9zdGF0ZS1tYW5hZ2VyXCI7XG5leHBvcnQgeyBIdG1sNVFyY29kZVNjYW5UeXBlIH0gZnJvbSBcIi4vY29yZVwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/index.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/native-bar-code-detector.js":
/*!*******************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/native-bar-code-detector.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BarcodeDetectorDelegate: function() { return /* binding */ BarcodeDetectorDelegate; }\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"./node_modules/html5-qrcode/esm/core.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar BarcodeDetectorDelegate = (function () {\n    function BarcodeDetectorDelegate(requestedFormats, verbose, logger) {\n        this.formatMap = new Map([\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.QR_CODE, \"qr_code\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.AZTEC, \"aztec\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODABAR, \"codabar\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_39, \"code_39\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_93, \"code_93\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_128, \"code_128\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.DATA_MATRIX, \"data_matrix\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.ITF, \"itf\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.EAN_13, \"ean_13\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.EAN_8, \"ean_8\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.PDF_417, \"pdf417\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.UPC_A, \"upc_a\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.UPC_E, \"upc_e\"]\n        ]);\n        this.reverseFormatMap = this.createReverseFormatMap();\n        if (!BarcodeDetectorDelegate.isSupported()) {\n            throw \"Use html5qrcode.min.js without edit, Use \"\n                + \"BarcodeDetectorDelegate only if it isSupported();\";\n        }\n        this.verbose = verbose;\n        this.logger = logger;\n        var formats = this.createBarcodeDetectorFormats(requestedFormats);\n        this.detector = new BarcodeDetector(formats);\n        if (!this.detector) {\n            throw \"BarcodeDetector detector not supported\";\n        }\n    }\n    BarcodeDetectorDelegate.isSupported = function () {\n        if (!(\"BarcodeDetector\" in window)) {\n            return false;\n        }\n        var dummyDetector = new BarcodeDetector({ formats: [\"qr_code\"] });\n        return typeof dummyDetector !== \"undefined\";\n    };\n    BarcodeDetectorDelegate.prototype.decodeAsync = function (canvas) {\n        return __awaiter(this, void 0, void 0, function () {\n            var barcodes, largestBarcode;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4, this.detector.detect(canvas)];\n                    case 1:\n                        barcodes = _a.sent();\n                        if (!barcodes || barcodes.length === 0) {\n                            throw \"No barcode or QR code detected.\";\n                        }\n                        largestBarcode = this.selectLargestBarcode(barcodes);\n                        return [2, {\n                                text: largestBarcode.rawValue,\n                                format: _core__WEBPACK_IMPORTED_MODULE_0__.QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(largestBarcode.format)),\n                                debugData: this.createDebugData()\n                            }];\n                }\n            });\n        });\n    };\n    BarcodeDetectorDelegate.prototype.selectLargestBarcode = function (barcodes) {\n        var largestBarcode = null;\n        var maxArea = 0;\n        for (var _i = 0, barcodes_1 = barcodes; _i < barcodes_1.length; _i++) {\n            var barcode = barcodes_1[_i];\n            var area = barcode.boundingBox.width * barcode.boundingBox.height;\n            if (area > maxArea) {\n                maxArea = area;\n                largestBarcode = barcode;\n            }\n        }\n        if (!largestBarcode) {\n            throw \"No largest barcode found\";\n        }\n        return largestBarcode;\n    };\n    BarcodeDetectorDelegate.prototype.createBarcodeDetectorFormats = function (requestedFormats) {\n        var formats = [];\n        for (var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++) {\n            var requestedFormat = requestedFormats_1[_i];\n            if (this.formatMap.has(requestedFormat)) {\n                formats.push(this.formatMap.get(requestedFormat));\n            }\n            else {\n                this.logger.warn(\"\".concat(requestedFormat, \" is not supported by\")\n                    + \"BarcodeDetectorDelegate\");\n            }\n        }\n        return { formats: formats };\n    };\n    BarcodeDetectorDelegate.prototype.toHtml5QrcodeSupportedFormats = function (barcodeDetectorFormat) {\n        if (!this.reverseFormatMap.has(barcodeDetectorFormat)) {\n            throw \"reverseFormatMap doesn't have \".concat(barcodeDetectorFormat);\n        }\n        return this.reverseFormatMap.get(barcodeDetectorFormat);\n    };\n    BarcodeDetectorDelegate.prototype.createReverseFormatMap = function () {\n        var result = new Map();\n        this.formatMap.forEach(function (value, key, _) {\n            result.set(value, key);\n        });\n        return result;\n    };\n    BarcodeDetectorDelegate.prototype.createDebugData = function () {\n        return { decoderName: \"BarcodeDetector\" };\n    };\n    return BarcodeDetectorDelegate;\n}());\n\n//# sourceMappingURL=native-bar-code-detector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9uYXRpdmUtYmFyLWNvZGUtZGV0ZWN0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsU0FBSSxJQUFJLFNBQUk7QUFDL0IsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUN5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhEQUEyQjtBQUN4QyxhQUFhLDhEQUEyQjtBQUN4QyxhQUFhLDhEQUEyQjtBQUN4QyxhQUFhLDhEQUEyQjtBQUN4QyxhQUFhLDhEQUEyQjtBQUN4QyxhQUFhLDhEQUEyQjtBQUN4QyxhQUFhLDhEQUEyQjtBQUN4QyxhQUFhLDhEQUEyQjtBQUN4QyxhQUFhLDhEQUEyQjtBQUN4QyxhQUFhLDhEQUEyQjtBQUN4QyxhQUFhLDhEQUEyQjtBQUN4QyxhQUFhLDhEQUEyQjtBQUN4QyxhQUFhLDhEQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MscURBQWtCO0FBQzFEO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx3QkFBd0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnQ0FBZ0M7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxDQUFDO0FBQ2tDO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL25hdGl2ZS1iYXItY29kZS1kZXRlY3Rvci5qcz9iYWZkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmltcG9ydCB7IFFyY29kZVJlc3VsdEZvcm1hdCwgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzIH0gZnJvbSBcIi4vY29yZVwiO1xudmFyIEJhcmNvZGVEZXRlY3RvckRlbGVnYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZShyZXF1ZXN0ZWRGb3JtYXRzLCB2ZXJib3NlLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5mb3JtYXRNYXAgPSBuZXcgTWFwKFtcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUVJfQ09ERSwgXCJxcl9jb2RlXCJdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5BWlRFQywgXCJhenRlY1wiXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuQ09EQUJBUiwgXCJjb2RhYmFyXCJdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5DT0RFXzM5LCBcImNvZGVfMzlcIl0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREVfOTMsIFwiY29kZV85M1wiXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuQ09ERV8xMjgsIFwiY29kZV8xMjhcIl0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkRBVEFfTUFUUklYLCBcImRhdGFfbWF0cml4XCJdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5JVEYsIFwiaXRmXCJdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5FQU5fMTMsIFwiZWFuXzEzXCJdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5FQU5fOCwgXCJlYW5fOFwiXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUERGXzQxNywgXCJwZGY0MTdcIl0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19BLCBcInVwY19hXCJdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5VUENfRSwgXCJ1cGNfZVwiXVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5yZXZlcnNlRm9ybWF0TWFwID0gdGhpcy5jcmVhdGVSZXZlcnNlRm9ybWF0TWFwKCk7XG4gICAgICAgIGlmICghQmFyY29kZURldGVjdG9yRGVsZWdhdGUuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJVc2UgaHRtbDVxcmNvZGUubWluLmpzIHdpdGhvdXQgZWRpdCwgVXNlIFwiXG4gICAgICAgICAgICAgICAgKyBcIkJhcmNvZGVEZXRlY3RvckRlbGVnYXRlIG9ubHkgaWYgaXQgaXNTdXBwb3J0ZWQoKTtcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcmJvc2UgPSB2ZXJib3NlO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgdmFyIGZvcm1hdHMgPSB0aGlzLmNyZWF0ZUJhcmNvZGVEZXRlY3RvckZvcm1hdHMocmVxdWVzdGVkRm9ybWF0cyk7XG4gICAgICAgIHRoaXMuZGV0ZWN0b3IgPSBuZXcgQmFyY29kZURldGVjdG9yKGZvcm1hdHMpO1xuICAgICAgICBpZiAoIXRoaXMuZGV0ZWN0b3IpIHtcbiAgICAgICAgICAgIHRocm93IFwiQmFyY29kZURldGVjdG9yIGRldGVjdG9yIG5vdCBzdXBwb3J0ZWRcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCEoXCJCYXJjb2RlRGV0ZWN0b3JcIiBpbiB3aW5kb3cpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR1bW15RGV0ZWN0b3IgPSBuZXcgQmFyY29kZURldGVjdG9yKHsgZm9ybWF0czogW1wicXJfY29kZVwiXSB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkdW1teURldGVjdG9yICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIH07XG4gICAgQmFyY29kZURldGVjdG9yRGVsZWdhdGUucHJvdG90eXBlLmRlY29kZUFzeW5jID0gZnVuY3Rpb24gKGNhbnZhcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmFyY29kZXMsIGxhcmdlc3RCYXJjb2RlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIHRoaXMuZGV0ZWN0b3IuZGV0ZWN0KGNhbnZhcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2RlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFyY29kZXMgfHwgYmFyY29kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJObyBiYXJjb2RlIG9yIFFSIGNvZGUgZGV0ZWN0ZWQuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXJnZXN0QmFyY29kZSA9IHRoaXMuc2VsZWN0TGFyZ2VzdEJhcmNvZGUoYmFyY29kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGxhcmdlc3RCYXJjb2RlLnJhd1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IFFyY29kZVJlc3VsdEZvcm1hdC5jcmVhdGUodGhpcy50b0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cyhsYXJnZXN0QmFyY29kZS5mb3JtYXQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdEYXRhOiB0aGlzLmNyZWF0ZURlYnVnRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFyY29kZURldGVjdG9yRGVsZWdhdGUucHJvdG90eXBlLnNlbGVjdExhcmdlc3RCYXJjb2RlID0gZnVuY3Rpb24gKGJhcmNvZGVzKSB7XG4gICAgICAgIHZhciBsYXJnZXN0QmFyY29kZSA9IG51bGw7XG4gICAgICAgIHZhciBtYXhBcmVhID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBiYXJjb2Rlc18xID0gYmFyY29kZXM7IF9pIDwgYmFyY29kZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBiYXJjb2RlID0gYmFyY29kZXNfMVtfaV07XG4gICAgICAgICAgICB2YXIgYXJlYSA9IGJhcmNvZGUuYm91bmRpbmdCb3gud2lkdGggKiBiYXJjb2RlLmJvdW5kaW5nQm94LmhlaWdodDtcbiAgICAgICAgICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xuICAgICAgICAgICAgICAgIG1heEFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgIGxhcmdlc3RCYXJjb2RlID0gYmFyY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxhcmdlc3RCYXJjb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBcIk5vIGxhcmdlc3QgYmFyY29kZSBmb3VuZFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXJnZXN0QmFyY29kZTtcbiAgICB9O1xuICAgIEJhcmNvZGVEZXRlY3RvckRlbGVnYXRlLnByb3RvdHlwZS5jcmVhdGVCYXJjb2RlRGV0ZWN0b3JGb3JtYXRzID0gZnVuY3Rpb24gKHJlcXVlc3RlZEZvcm1hdHMpIHtcbiAgICAgICAgdmFyIGZvcm1hdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByZXF1ZXN0ZWRGb3JtYXRzXzEgPSByZXF1ZXN0ZWRGb3JtYXRzOyBfaSA8IHJlcXVlc3RlZEZvcm1hdHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ZWRGb3JtYXQgPSByZXF1ZXN0ZWRGb3JtYXRzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybWF0TWFwLmhhcyhyZXF1ZXN0ZWRGb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0cy5wdXNoKHRoaXMuZm9ybWF0TWFwLmdldChyZXF1ZXN0ZWRGb3JtYXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJcIi5jb25jYXQocmVxdWVzdGVkRm9ybWF0LCBcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5XCIpXG4gICAgICAgICAgICAgICAgICAgICsgXCJCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3JtYXRzOiBmb3JtYXRzIH07XG4gICAgfTtcbiAgICBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZS5wcm90b3R5cGUudG9IdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMgPSBmdW5jdGlvbiAoYmFyY29kZURldGVjdG9yRm9ybWF0KSB7XG4gICAgICAgIGlmICghdGhpcy5yZXZlcnNlRm9ybWF0TWFwLmhhcyhiYXJjb2RlRGV0ZWN0b3JGb3JtYXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBcInJldmVyc2VGb3JtYXRNYXAgZG9lc24ndCBoYXZlIFwiLmNvbmNhdChiYXJjb2RlRGV0ZWN0b3JGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2VGb3JtYXRNYXAuZ2V0KGJhcmNvZGVEZXRlY3RvckZvcm1hdCk7XG4gICAgfTtcbiAgICBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZS5wcm90b3R5cGUuY3JlYXRlUmV2ZXJzZUZvcm1hdE1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5mb3JtYXRNYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSwgXykge1xuICAgICAgICAgICAgcmVzdWx0LnNldCh2YWx1ZSwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZS5wcm90b3R5cGUuY3JlYXRlRGVidWdEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBkZWNvZGVyTmFtZTogXCJCYXJjb2RlRGV0ZWN0b3JcIiB9O1xuICAgIH07XG4gICAgcmV0dXJuIEJhcmNvZGVEZXRlY3RvckRlbGVnYXRlO1xufSgpKTtcbmV4cG9ydCB7IEJhcmNvZGVEZXRlY3RvckRlbGVnYXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXRpdmUtYmFyLWNvZGUtZGV0ZWN0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/native-bar-code-detector.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/state-manager.js":
/*!********************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/state-manager.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5QrcodeScannerState: function() { return /* binding */ Html5QrcodeScannerState; },\n/* harmony export */   StateManagerFactory: function() { return /* binding */ StateManagerFactory; },\n/* harmony export */   StateManagerProxy: function() { return /* binding */ StateManagerProxy; }\n/* harmony export */ });\nvar Html5QrcodeScannerState;\n(function (Html5QrcodeScannerState) {\n    Html5QrcodeScannerState[Html5QrcodeScannerState[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    Html5QrcodeScannerState[Html5QrcodeScannerState[\"NOT_STARTED\"] = 1] = \"NOT_STARTED\";\n    Html5QrcodeScannerState[Html5QrcodeScannerState[\"SCANNING\"] = 2] = \"SCANNING\";\n    Html5QrcodeScannerState[Html5QrcodeScannerState[\"PAUSED\"] = 3] = \"PAUSED\";\n})(Html5QrcodeScannerState || (Html5QrcodeScannerState = {}));\nvar StateManagerImpl = (function () {\n    function StateManagerImpl() {\n        this.state = Html5QrcodeScannerState.NOT_STARTED;\n        this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;\n    }\n    StateManagerImpl.prototype.directTransition = function (newState) {\n        this.failIfTransitionOngoing();\n        this.validateTransition(newState);\n        this.state = newState;\n    };\n    StateManagerImpl.prototype.startTransition = function (newState) {\n        this.failIfTransitionOngoing();\n        this.validateTransition(newState);\n        this.onGoingTransactionNewState = newState;\n        return this;\n    };\n    StateManagerImpl.prototype.execute = function () {\n        if (this.onGoingTransactionNewState\n            === Html5QrcodeScannerState.UNKNOWN) {\n            throw \"Transaction is already cancelled, cannot execute().\";\n        }\n        var tempNewState = this.onGoingTransactionNewState;\n        this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;\n        this.directTransition(tempNewState);\n    };\n    StateManagerImpl.prototype.cancel = function () {\n        if (this.onGoingTransactionNewState\n            === Html5QrcodeScannerState.UNKNOWN) {\n            throw \"Transaction is already cancelled, cannot cancel().\";\n        }\n        this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;\n    };\n    StateManagerImpl.prototype.getState = function () {\n        return this.state;\n    };\n    StateManagerImpl.prototype.failIfTransitionOngoing = function () {\n        if (this.onGoingTransactionNewState\n            !== Html5QrcodeScannerState.UNKNOWN) {\n            throw \"Cannot transition to a new state, already under transition\";\n        }\n    };\n    StateManagerImpl.prototype.validateTransition = function (newState) {\n        switch (this.state) {\n            case Html5QrcodeScannerState.UNKNOWN:\n                throw \"Transition from unknown is not allowed\";\n            case Html5QrcodeScannerState.NOT_STARTED:\n                this.failIfNewStateIs(newState, [Html5QrcodeScannerState.PAUSED]);\n                break;\n            case Html5QrcodeScannerState.SCANNING:\n                break;\n            case Html5QrcodeScannerState.PAUSED:\n                break;\n        }\n    };\n    StateManagerImpl.prototype.failIfNewStateIs = function (newState, disallowedStatesToTransition) {\n        for (var _i = 0, disallowedStatesToTransition_1 = disallowedStatesToTransition; _i < disallowedStatesToTransition_1.length; _i++) {\n            var disallowedState = disallowedStatesToTransition_1[_i];\n            if (newState === disallowedState) {\n                throw \"Cannot transition from \".concat(this.state, \" to \").concat(newState);\n            }\n        }\n    };\n    return StateManagerImpl;\n}());\nvar StateManagerProxy = (function () {\n    function StateManagerProxy(stateManager) {\n        this.stateManager = stateManager;\n    }\n    StateManagerProxy.prototype.startTransition = function (newState) {\n        return this.stateManager.startTransition(newState);\n    };\n    StateManagerProxy.prototype.directTransition = function (newState) {\n        this.stateManager.directTransition(newState);\n    };\n    StateManagerProxy.prototype.getState = function () {\n        return this.stateManager.getState();\n    };\n    StateManagerProxy.prototype.canScanFile = function () {\n        return this.stateManager.getState() === Html5QrcodeScannerState.NOT_STARTED;\n    };\n    StateManagerProxy.prototype.isScanning = function () {\n        return this.stateManager.getState() !== Html5QrcodeScannerState.NOT_STARTED;\n    };\n    StateManagerProxy.prototype.isStrictlyScanning = function () {\n        return this.stateManager.getState() === Html5QrcodeScannerState.SCANNING;\n    };\n    StateManagerProxy.prototype.isPaused = function () {\n        return this.stateManager.getState() === Html5QrcodeScannerState.PAUSED;\n    };\n    return StateManagerProxy;\n}());\n\nvar StateManagerFactory = (function () {\n    function StateManagerFactory() {\n    }\n    StateManagerFactory.create = function () {\n        return new StateManagerProxy(new StateManagerImpl());\n    };\n    return StateManagerFactory;\n}());\n\n//# sourceMappingURL=state-manager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9zdGF0ZS1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMERBQTBEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLDRDQUE0QztBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDOEI7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vc3RhdGUtbWFuYWdlci5qcz81NzM0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgSHRtbDVRcmNvZGVTY2FubmVyU3RhdGU7XG4oZnVuY3Rpb24gKEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlKSB7XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RhdGVbSHRtbDVRcmNvZGVTY2FubmVyU3RhdGVbXCJVTktOT1dOXCJdID0gMF0gPSBcIlVOS05PV05cIjtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZVtIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZVtcIk5PVF9TVEFSVEVEXCJdID0gMV0gPSBcIk5PVF9TVEFSVEVEXCI7XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RhdGVbSHRtbDVRcmNvZGVTY2FubmVyU3RhdGVbXCJTQ0FOTklOR1wiXSA9IDJdID0gXCJTQ0FOTklOR1wiO1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlW0h0bWw1UXJjb2RlU2Nhbm5lclN0YXRlW1wiUEFVU0VEXCJdID0gM10gPSBcIlBBVVNFRFwiO1xufSkoSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUgfHwgKEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlID0ge30pKTtcbnZhciBTdGF0ZU1hbmFnZXJJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZU1hbmFnZXJJbXBsKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUuTk9UX1NUQVJURUQ7XG4gICAgICAgIHRoaXMub25Hb2luZ1RyYW5zYWN0aW9uTmV3U3RhdGUgPSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5VTktOT1dOO1xuICAgIH1cbiAgICBTdGF0ZU1hbmFnZXJJbXBsLnByb3RvdHlwZS5kaXJlY3RUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuZmFpbElmVHJhbnNpdGlvbk9uZ29pbmcoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVRyYW5zaXRpb24obmV3U3RhdGUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgfTtcbiAgICBTdGF0ZU1hbmFnZXJJbXBsLnByb3RvdHlwZS5zdGFydFRyYW5zaXRpb24gPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5mYWlsSWZUcmFuc2l0aW9uT25nb2luZygpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlVHJhbnNpdGlvbihuZXdTdGF0ZSk7XG4gICAgICAgIHRoaXMub25Hb2luZ1RyYW5zYWN0aW9uTmV3U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTdGF0ZU1hbmFnZXJJbXBsLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vbkdvaW5nVHJhbnNhY3Rpb25OZXdTdGF0ZVxuICAgICAgICAgICAgPT09IEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLlVOS05PV04pIHtcbiAgICAgICAgICAgIHRocm93IFwiVHJhbnNhY3Rpb24gaXMgYWxyZWFkeSBjYW5jZWxsZWQsIGNhbm5vdCBleGVjdXRlKCkuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlbXBOZXdTdGF0ZSA9IHRoaXMub25Hb2luZ1RyYW5zYWN0aW9uTmV3U3RhdGU7XG4gICAgICAgIHRoaXMub25Hb2luZ1RyYW5zYWN0aW9uTmV3U3RhdGUgPSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5VTktOT1dOO1xuICAgICAgICB0aGlzLmRpcmVjdFRyYW5zaXRpb24odGVtcE5ld1N0YXRlKTtcbiAgICB9O1xuICAgIFN0YXRlTWFuYWdlckltcGwucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub25Hb2luZ1RyYW5zYWN0aW9uTmV3U3RhdGVcbiAgICAgICAgICAgID09PSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5VTktOT1dOKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlRyYW5zYWN0aW9uIGlzIGFscmVhZHkgY2FuY2VsbGVkLCBjYW5ub3QgY2FuY2VsKCkuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkdvaW5nVHJhbnNhY3Rpb25OZXdTdGF0ZSA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLlVOS05PV047XG4gICAgfTtcbiAgICBTdGF0ZU1hbmFnZXJJbXBsLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gICAgfTtcbiAgICBTdGF0ZU1hbmFnZXJJbXBsLnByb3RvdHlwZS5mYWlsSWZUcmFuc2l0aW9uT25nb2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub25Hb2luZ1RyYW5zYWN0aW9uTmV3U3RhdGVcbiAgICAgICAgICAgICE9PSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5VTktOT1dOKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNhbm5vdCB0cmFuc2l0aW9uIHRvIGEgbmV3IHN0YXRlLCBhbHJlYWR5IHVuZGVyIHRyYW5zaXRpb25cIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RhdGVNYW5hZ2VySW1wbC5wcm90b3R5cGUudmFsaWRhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5VTktOT1dOOlxuICAgICAgICAgICAgICAgIHRocm93IFwiVHJhbnNpdGlvbiBmcm9tIHVua25vd24gaXMgbm90IGFsbG93ZWRcIjtcbiAgICAgICAgICAgIGNhc2UgSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUuTk9UX1NUQVJURUQ6XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsSWZOZXdTdGF0ZUlzKG5ld1N0YXRlLCBbSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUuUEFVU0VEXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLlNDQU5OSU5HOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5QQVVTRUQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YXRlTWFuYWdlckltcGwucHJvdG90eXBlLmZhaWxJZk5ld1N0YXRlSXMgPSBmdW5jdGlvbiAobmV3U3RhdGUsIGRpc2FsbG93ZWRTdGF0ZXNUb1RyYW5zaXRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBkaXNhbGxvd2VkU3RhdGVzVG9UcmFuc2l0aW9uXzEgPSBkaXNhbGxvd2VkU3RhdGVzVG9UcmFuc2l0aW9uOyBfaSA8IGRpc2FsbG93ZWRTdGF0ZXNUb1RyYW5zaXRpb25fMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBkaXNhbGxvd2VkU3RhdGUgPSBkaXNhbGxvd2VkU3RhdGVzVG9UcmFuc2l0aW9uXzFbX2ldO1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBkaXNhbGxvd2VkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkNhbm5vdCB0cmFuc2l0aW9uIGZyb20gXCIuY29uY2F0KHRoaXMuc3RhdGUsIFwiIHRvIFwiKS5jb25jYXQobmV3U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVNYW5hZ2VySW1wbDtcbn0oKSk7XG52YXIgU3RhdGVNYW5hZ2VyUHJveHkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlTWFuYWdlclByb3h5KHN0YXRlTWFuYWdlcikge1xuICAgICAgICB0aGlzLnN0YXRlTWFuYWdlciA9IHN0YXRlTWFuYWdlcjtcbiAgICB9XG4gICAgU3RhdGVNYW5hZ2VyUHJveHkucHJvdG90eXBlLnN0YXJ0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU1hbmFnZXIuc3RhcnRUcmFuc2l0aW9uKG5ld1N0YXRlKTtcbiAgICB9O1xuICAgIFN0YXRlTWFuYWdlclByb3h5LnByb3RvdHlwZS5kaXJlY3RUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGVNYW5hZ2VyLmRpcmVjdFRyYW5zaXRpb24obmV3U3RhdGUpO1xuICAgIH07XG4gICAgU3RhdGVNYW5hZ2VyUHJveHkucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICB9O1xuICAgIFN0YXRlTWFuYWdlclByb3h5LnByb3RvdHlwZS5jYW5TY2FuRmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCkgPT09IEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLk5PVF9TVEFSVEVEO1xuICAgIH07XG4gICAgU3RhdGVNYW5hZ2VyUHJveHkucHJvdG90eXBlLmlzU2Nhbm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpICE9PSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5OT1RfU1RBUlRFRDtcbiAgICB9O1xuICAgIFN0YXRlTWFuYWdlclByb3h5LnByb3RvdHlwZS5pc1N0cmljdGx5U2Nhbm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpID09PSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5TQ0FOTklORztcbiAgICB9O1xuICAgIFN0YXRlTWFuYWdlclByb3h5LnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCkgPT09IEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLlBBVVNFRDtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZU1hbmFnZXJQcm94eTtcbn0oKSk7XG5leHBvcnQgeyBTdGF0ZU1hbmFnZXJQcm94eSB9O1xudmFyIFN0YXRlTWFuYWdlckZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlTWFuYWdlckZhY3RvcnkoKSB7XG4gICAgfVxuICAgIFN0YXRlTWFuYWdlckZhY3RvcnkuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlTWFuYWdlclByb3h5KG5ldyBTdGF0ZU1hbmFnZXJJbXBsKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlTWFuYWdlckZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0IHsgU3RhdGVNYW5hZ2VyRmFjdG9yeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGUtbWFuYWdlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/state-manager.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/storage.js":
/*!**************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/storage.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PersistedDataManager: function() { return /* binding */ PersistedDataManager; }\n/* harmony export */ });\nvar PersistedDataFactory = (function () {\n    function PersistedDataFactory() {\n    }\n    PersistedDataFactory.createDefault = function () {\n        return {\n            hasPermission: false,\n            lastUsedCameraId: null\n        };\n    };\n    return PersistedDataFactory;\n}());\nvar PersistedDataManager = (function () {\n    function PersistedDataManager() {\n        this.data = PersistedDataFactory.createDefault();\n        var data = localStorage.getItem(PersistedDataManager.LOCAL_STORAGE_KEY);\n        if (!data) {\n            this.reset();\n        }\n        else {\n            this.data = JSON.parse(data);\n        }\n    }\n    PersistedDataManager.prototype.hasCameraPermissions = function () {\n        return this.data.hasPermission;\n    };\n    PersistedDataManager.prototype.getLastUsedCameraId = function () {\n        return this.data.lastUsedCameraId;\n    };\n    PersistedDataManager.prototype.setHasPermission = function (hasPermission) {\n        this.data.hasPermission = hasPermission;\n        this.flush();\n    };\n    PersistedDataManager.prototype.setLastUsedCameraId = function (lastUsedCameraId) {\n        this.data.lastUsedCameraId = lastUsedCameraId;\n        this.flush();\n    };\n    PersistedDataManager.prototype.resetLastUsedCameraId = function () {\n        this.data.lastUsedCameraId = null;\n        this.flush();\n    };\n    PersistedDataManager.prototype.reset = function () {\n        this.data = PersistedDataFactory.createDefault();\n        this.flush();\n    };\n    PersistedDataManager.prototype.flush = function () {\n        localStorage.setItem(PersistedDataManager.LOCAL_STORAGE_KEY, JSON.stringify(this.data));\n    };\n    PersistedDataManager.LOCAL_STORAGE_KEY = \"HTML5_QRCODE_DATA\";\n    return PersistedDataManager;\n}());\n\n//# sourceMappingURL=storage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9zdG9yYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMrQjtBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9zdG9yYWdlLmpzPzNkODYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFBlcnNpc3RlZERhdGFGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQZXJzaXN0ZWREYXRhRmFjdG9yeSgpIHtcbiAgICB9XG4gICAgUGVyc2lzdGVkRGF0YUZhY3RvcnkuY3JlYXRlRGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhhc1Blcm1pc3Npb246IGZhbHNlLFxuICAgICAgICAgICAgbGFzdFVzZWRDYW1lcmFJZDogbnVsbFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFBlcnNpc3RlZERhdGFGYWN0b3J5O1xufSgpKTtcbnZhciBQZXJzaXN0ZWREYXRhTWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGVyc2lzdGVkRGF0YU1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IFBlcnNpc3RlZERhdGFGYWN0b3J5LmNyZWF0ZURlZmF1bHQoKTtcbiAgICAgICAgdmFyIGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShQZXJzaXN0ZWREYXRhTWFuYWdlci5MT0NBTF9TVE9SQUdFX0tFWSk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQZXJzaXN0ZWREYXRhTWFuYWdlci5wcm90b3R5cGUuaGFzQ2FtZXJhUGVybWlzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuaGFzUGVybWlzc2lvbjtcbiAgICB9O1xuICAgIFBlcnNpc3RlZERhdGFNYW5hZ2VyLnByb3RvdHlwZS5nZXRMYXN0VXNlZENhbWVyYUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxhc3RVc2VkQ2FtZXJhSWQ7XG4gICAgfTtcbiAgICBQZXJzaXN0ZWREYXRhTWFuYWdlci5wcm90b3R5cGUuc2V0SGFzUGVybWlzc2lvbiA9IGZ1bmN0aW9uIChoYXNQZXJtaXNzaW9uKSB7XG4gICAgICAgIHRoaXMuZGF0YS5oYXNQZXJtaXNzaW9uID0gaGFzUGVybWlzc2lvbjtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH07XG4gICAgUGVyc2lzdGVkRGF0YU1hbmFnZXIucHJvdG90eXBlLnNldExhc3RVc2VkQ2FtZXJhSWQgPSBmdW5jdGlvbiAobGFzdFVzZWRDYW1lcmFJZCkge1xuICAgICAgICB0aGlzLmRhdGEubGFzdFVzZWRDYW1lcmFJZCA9IGxhc3RVc2VkQ2FtZXJhSWQ7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9O1xuICAgIFBlcnNpc3RlZERhdGFNYW5hZ2VyLnByb3RvdHlwZS5yZXNldExhc3RVc2VkQ2FtZXJhSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0YS5sYXN0VXNlZENhbWVyYUlkID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH07XG4gICAgUGVyc2lzdGVkRGF0YU1hbmFnZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBQZXJzaXN0ZWREYXRhRmFjdG9yeS5jcmVhdGVEZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9O1xuICAgIFBlcnNpc3RlZERhdGFNYW5hZ2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oUGVyc2lzdGVkRGF0YU1hbmFnZXIuTE9DQUxfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHRoaXMuZGF0YSkpO1xuICAgIH07XG4gICAgUGVyc2lzdGVkRGF0YU1hbmFnZXIuTE9DQUxfU1RPUkFHRV9LRVkgPSBcIkhUTUw1X1FSQ09ERV9EQVRBXCI7XG4gICAgcmV0dXJuIFBlcnNpc3RlZERhdGFNYW5hZ2VyO1xufSgpKTtcbmV4cG9ydCB7IFBlcnNpc3RlZERhdGFNYW5hZ2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdG9yYWdlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/storage.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/strings.js":
/*!**************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/strings.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5QrcodeScannerStrings: function() { return /* binding */ Html5QrcodeScannerStrings; },\n/* harmony export */   Html5QrcodeStrings: function() { return /* binding */ Html5QrcodeStrings; },\n/* harmony export */   LibraryInfoStrings: function() { return /* binding */ LibraryInfoStrings; }\n/* harmony export */ });\nvar Html5QrcodeStrings = (function () {\n    function Html5QrcodeStrings() {\n    }\n    Html5QrcodeStrings.codeParseError = function (exception) {\n        return \"QR code parse error, error = \".concat(exception);\n    };\n    Html5QrcodeStrings.errorGettingUserMedia = function (error) {\n        return \"Error getting userMedia, error = \".concat(error);\n    };\n    Html5QrcodeStrings.onlyDeviceSupportedError = function () {\n        return \"The device doesn't support navigator.mediaDevices , only \"\n            + \"supported cameraIdOrConfig in this case is deviceId parameter \"\n            + \"(string).\";\n    };\n    Html5QrcodeStrings.cameraStreamingNotSupported = function () {\n        return \"Camera streaming not supported by the browser.\";\n    };\n    Html5QrcodeStrings.unableToQuerySupportedDevices = function () {\n        return \"Unable to query supported devices, unknown error.\";\n    };\n    Html5QrcodeStrings.insecureContextCameraQueryError = function () {\n        return \"Camera access is only supported in secure context like https \"\n            + \"or localhost.\";\n    };\n    Html5QrcodeStrings.scannerPaused = function () {\n        return \"Scanner paused\";\n    };\n    return Html5QrcodeStrings;\n}());\n\nvar Html5QrcodeScannerStrings = (function () {\n    function Html5QrcodeScannerStrings() {\n    }\n    Html5QrcodeScannerStrings.scanningStatus = function () {\n        return \"Scanning\";\n    };\n    Html5QrcodeScannerStrings.idleStatus = function () {\n        return \"Idle\";\n    };\n    Html5QrcodeScannerStrings.errorStatus = function () {\n        return \"Error\";\n    };\n    Html5QrcodeScannerStrings.permissionStatus = function () {\n        return \"Permission\";\n    };\n    Html5QrcodeScannerStrings.noCameraFoundErrorStatus = function () {\n        return \"No Cameras\";\n    };\n    Html5QrcodeScannerStrings.lastMatch = function (decodedText) {\n        return \"Last Match: \".concat(decodedText);\n    };\n    Html5QrcodeScannerStrings.codeScannerTitle = function () {\n        return \"Code Scanner\";\n    };\n    Html5QrcodeScannerStrings.cameraPermissionTitle = function () {\n        return \"Request Camera Permissions\";\n    };\n    Html5QrcodeScannerStrings.cameraPermissionRequesting = function () {\n        return \"Requesting camera permissions...\";\n    };\n    Html5QrcodeScannerStrings.noCameraFound = function () {\n        return \"No camera found\";\n    };\n    Html5QrcodeScannerStrings.scanButtonStopScanningText = function () {\n        return \"Stop Scanning\";\n    };\n    Html5QrcodeScannerStrings.scanButtonStartScanningText = function () {\n        return \"Start Scanning\";\n    };\n    Html5QrcodeScannerStrings.torchOnButton = function () {\n        return \"Switch On Torch\";\n    };\n    Html5QrcodeScannerStrings.torchOffButton = function () {\n        return \"Switch Off Torch\";\n    };\n    Html5QrcodeScannerStrings.torchOnFailedMessage = function () {\n        return \"Failed to turn on torch\";\n    };\n    Html5QrcodeScannerStrings.torchOffFailedMessage = function () {\n        return \"Failed to turn off torch\";\n    };\n    Html5QrcodeScannerStrings.scanButtonScanningStarting = function () {\n        return \"Launching Camera...\";\n    };\n    Html5QrcodeScannerStrings.textIfCameraScanSelected = function () {\n        return \"Scan an Image File\";\n    };\n    Html5QrcodeScannerStrings.textIfFileScanSelected = function () {\n        return \"Scan using camera directly\";\n    };\n    Html5QrcodeScannerStrings.selectCamera = function () {\n        return \"Select Camera\";\n    };\n    Html5QrcodeScannerStrings.fileSelectionChooseImage = function () {\n        return \"Choose Image\";\n    };\n    Html5QrcodeScannerStrings.fileSelectionChooseAnother = function () {\n        return \"Choose Another\";\n    };\n    Html5QrcodeScannerStrings.fileSelectionNoImageSelected = function () {\n        return \"No image choosen\";\n    };\n    Html5QrcodeScannerStrings.anonymousCameraPrefix = function () {\n        return \"Anonymous Camera\";\n    };\n    Html5QrcodeScannerStrings.dragAndDropMessage = function () {\n        return \"Or drop an image to scan\";\n    };\n    Html5QrcodeScannerStrings.dragAndDropMessageOnlyImages = function () {\n        return \"Or drop an image to scan (other files not supported)\";\n    };\n    Html5QrcodeScannerStrings.zoom = function () {\n        return \"zoom\";\n    };\n    Html5QrcodeScannerStrings.loadingImage = function () {\n        return \"Loading image...\";\n    };\n    Html5QrcodeScannerStrings.cameraScanAltText = function () {\n        return \"Camera based scan\";\n    };\n    Html5QrcodeScannerStrings.fileScanAltText = function () {\n        return \"Fule based scan\";\n    };\n    return Html5QrcodeScannerStrings;\n}());\n\nvar LibraryInfoStrings = (function () {\n    function LibraryInfoStrings() {\n    }\n    LibraryInfoStrings.poweredBy = function () {\n        return \"Powered by \";\n    };\n    LibraryInfoStrings.reportIssues = function () {\n        return \"Report issues\";\n    };\n    return LibraryInfoStrings;\n}());\n\n//# sourceMappingURL=strings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9zdHJpbmdzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM2QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzZCO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL3N0cmluZ3MuanM/ZTUyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSHRtbDVRcmNvZGVTdHJpbmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNVFyY29kZVN0cmluZ3MoKSB7XG4gICAgfVxuICAgIEh0bWw1UXJjb2RlU3RyaW5ncy5jb2RlUGFyc2VFcnJvciA9IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIFwiUVIgY29kZSBwYXJzZSBlcnJvciwgZXJyb3IgPSBcIi5jb25jYXQoZXhjZXB0aW9uKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU3RyaW5ncy5lcnJvckdldHRpbmdVc2VyTWVkaWEgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFwiRXJyb3IgZ2V0dGluZyB1c2VyTWVkaWEsIGVycm9yID0gXCIuY29uY2F0KGVycm9yKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU3RyaW5ncy5vbmx5RGV2aWNlU3VwcG9ydGVkRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlRoZSBkZXZpY2UgZG9lc24ndCBzdXBwb3J0IG5hdmlnYXRvci5tZWRpYURldmljZXMgLCBvbmx5IFwiXG4gICAgICAgICAgICArIFwic3VwcG9ydGVkIGNhbWVyYUlkT3JDb25maWcgaW4gdGhpcyBjYXNlIGlzIGRldmljZUlkIHBhcmFtZXRlciBcIlxuICAgICAgICAgICAgKyBcIihzdHJpbmcpLlwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTdHJpbmdzLmNhbWVyYVN0cmVhbWluZ05vdFN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2FtZXJhIHN0cmVhbWluZyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLlwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTdHJpbmdzLnVuYWJsZVRvUXVlcnlTdXBwb3J0ZWREZXZpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJVbmFibGUgdG8gcXVlcnkgc3VwcG9ydGVkIGRldmljZXMsIHVua25vd24gZXJyb3IuXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVN0cmluZ3MuaW5zZWN1cmVDb250ZXh0Q2FtZXJhUXVlcnlFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2FtZXJhIGFjY2VzcyBpcyBvbmx5IHN1cHBvcnRlZCBpbiBzZWN1cmUgY29udGV4dCBsaWtlIGh0dHBzIFwiXG4gICAgICAgICAgICArIFwib3IgbG9jYWxob3N0LlwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTdHJpbmdzLnNjYW5uZXJQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNjYW5uZXIgcGF1c2VkXCI7XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbDVRcmNvZGVTdHJpbmdzO1xufSgpKTtcbmV4cG9ydCB7IEh0bWw1UXJjb2RlU3RyaW5ncyB9O1xudmFyIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MoKSB7XG4gICAgfVxuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Muc2Nhbm5pbmdTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNjYW5uaW5nXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmlkbGVTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIklkbGVcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuZXJyb3JTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkVycm9yXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnBlcm1pc3Npb25TdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlBlcm1pc3Npb25cIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Mubm9DYW1lcmFGb3VuZEVycm9yU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJObyBDYW1lcmFzXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmxhc3RNYXRjaCA9IGZ1bmN0aW9uIChkZWNvZGVkVGV4dCkge1xuICAgICAgICByZXR1cm4gXCJMYXN0IE1hdGNoOiBcIi5jb25jYXQoZGVjb2RlZFRleHQpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5jb2RlU2Nhbm5lclRpdGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJDb2RlIFNjYW5uZXJcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuY2FtZXJhUGVybWlzc2lvblRpdGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJSZXF1ZXN0IENhbWVyYSBQZXJtaXNzaW9uc1wiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5jYW1lcmFQZXJtaXNzaW9uUmVxdWVzdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiUmVxdWVzdGluZyBjYW1lcmEgcGVybWlzc2lvbnMuLi5cIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Mubm9DYW1lcmFGb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiTm8gY2FtZXJhIGZvdW5kXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnNjYW5CdXR0b25TdG9wU2Nhbm5pbmdUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJTdG9wIFNjYW5uaW5nXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnNjYW5CdXR0b25TdGFydFNjYW5uaW5nVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3RhcnQgU2Nhbm5pbmdcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MudG9yY2hPbkJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3dpdGNoIE9uIFRvcmNoXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnRvcmNoT2ZmQnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJTd2l0Y2ggT2ZmIFRvcmNoXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnRvcmNoT25GYWlsZWRNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJGYWlsZWQgdG8gdHVybiBvbiB0b3JjaFwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy50b3JjaE9mZkZhaWxlZE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkZhaWxlZCB0byB0dXJuIG9mZiB0b3JjaFwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5zY2FuQnV0dG9uU2Nhbm5pbmdTdGFydGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiTGF1bmNoaW5nIENhbWVyYS4uLlwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy50ZXh0SWZDYW1lcmFTY2FuU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNjYW4gYW4gSW1hZ2UgRmlsZVwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy50ZXh0SWZGaWxlU2NhblNlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJTY2FuIHVzaW5nIGNhbWVyYSBkaXJlY3RseVwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5zZWxlY3RDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNlbGVjdCBDYW1lcmFcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuZmlsZVNlbGVjdGlvbkNob29zZUltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJDaG9vc2UgSW1hZ2VcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuZmlsZVNlbGVjdGlvbkNob29zZUFub3RoZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkNob29zZSBBbm90aGVyXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmZpbGVTZWxlY3Rpb25Ob0ltYWdlU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIk5vIGltYWdlIGNob29zZW5cIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuYW5vbnltb3VzQ2FtZXJhUHJlZml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJBbm9ueW1vdXMgQ2FtZXJhXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmRyYWdBbmREcm9wTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiT3IgZHJvcCBhbiBpbWFnZSB0byBzY2FuXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmRyYWdBbmREcm9wTWVzc2FnZU9ubHlJbWFnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIk9yIGRyb3AgYW4gaW1hZ2UgdG8gc2NhbiAob3RoZXIgZmlsZXMgbm90IHN1cHBvcnRlZClcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Muem9vbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiem9vbVwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5sb2FkaW5nSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkxvYWRpbmcgaW1hZ2UuLi5cIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuY2FtZXJhU2NhbkFsdFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkNhbWVyYSBiYXNlZCBzY2FuXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmZpbGVTY2FuQWx0VGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiRnVsZSBiYXNlZCBzY2FuXCI7XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncztcbn0oKSk7XG5leHBvcnQgeyBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzIH07XG52YXIgTGlicmFyeUluZm9TdHJpbmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaWJyYXJ5SW5mb1N0cmluZ3MoKSB7XG4gICAgfVxuICAgIExpYnJhcnlJbmZvU3RyaW5ncy5wb3dlcmVkQnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlBvd2VyZWQgYnkgXCI7XG4gICAgfTtcbiAgICBMaWJyYXJ5SW5mb1N0cmluZ3MucmVwb3J0SXNzdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJSZXBvcnQgaXNzdWVzXCI7XG4gICAgfTtcbiAgICByZXR1cm4gTGlicmFyeUluZm9TdHJpbmdzO1xufSgpKTtcbmV4cG9ydCB7IExpYnJhcnlJbmZvU3RyaW5ncyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5ncy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/strings.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/ui.js":
/*!*********************************************!*\
  !*** ./node_modules/html5-qrcode/esm/ui.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LibraryInfoContainer: function() { return /* binding */ LibraryInfoContainer; }\n/* harmony export */ });\n/* harmony import */ var _image_assets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image-assets */ \"./node_modules/html5-qrcode/esm/image-assets.js\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./strings */ \"./node_modules/html5-qrcode/esm/strings.js\");\n\n\nvar LibraryInfoDiv = (function () {\n    function LibraryInfoDiv() {\n        this.infoDiv = document.createElement(\"div\");\n    }\n    LibraryInfoDiv.prototype.renderInto = function (parent) {\n        this.infoDiv.style.position = \"absolute\";\n        this.infoDiv.style.top = \"10px\";\n        this.infoDiv.style.right = \"10px\";\n        this.infoDiv.style.zIndex = \"2\";\n        this.infoDiv.style.display = \"none\";\n        this.infoDiv.style.padding = \"5pt\";\n        this.infoDiv.style.border = \"1px solid #171717\";\n        this.infoDiv.style.fontSize = \"10pt\";\n        this.infoDiv.style.background = \"rgb(0 0 0 / 69%)\";\n        this.infoDiv.style.borderRadius = \"5px\";\n        this.infoDiv.style.textAlign = \"center\";\n        this.infoDiv.style.fontWeight = \"400\";\n        this.infoDiv.style.color = \"white\";\n        this.infoDiv.innerText = _strings__WEBPACK_IMPORTED_MODULE_1__.LibraryInfoStrings.poweredBy();\n        var projectLink = document.createElement(\"a\");\n        projectLink.innerText = \"ScanApp\";\n        projectLink.href = \"https://scanapp.org\";\n        projectLink.target = \"new\";\n        projectLink.style.color = \"white\";\n        this.infoDiv.appendChild(projectLink);\n        var breakElemFirst = document.createElement(\"br\");\n        var breakElemSecond = document.createElement(\"br\");\n        this.infoDiv.appendChild(breakElemFirst);\n        this.infoDiv.appendChild(breakElemSecond);\n        var reportIssueLink = document.createElement(\"a\");\n        reportIssueLink.innerText = _strings__WEBPACK_IMPORTED_MODULE_1__.LibraryInfoStrings.reportIssues();\n        reportIssueLink.href = \"https://github.com/mebjas/html5-qrcode/issues\";\n        reportIssueLink.target = \"new\";\n        reportIssueLink.style.color = \"white\";\n        this.infoDiv.appendChild(reportIssueLink);\n        parent.appendChild(this.infoDiv);\n    };\n    LibraryInfoDiv.prototype.show = function () {\n        this.infoDiv.style.display = \"block\";\n    };\n    LibraryInfoDiv.prototype.hide = function () {\n        this.infoDiv.style.display = \"none\";\n    };\n    return LibraryInfoDiv;\n}());\nvar LibraryInfoIcon = (function () {\n    function LibraryInfoIcon(onTapIn, onTapOut) {\n        this.isShowingInfoIcon = true;\n        this.onTapIn = onTapIn;\n        this.onTapOut = onTapOut;\n        this.infoIcon = document.createElement(\"img\");\n    }\n    LibraryInfoIcon.prototype.renderInto = function (parent) {\n        var _this = this;\n        this.infoIcon.alt = \"Info icon\";\n        this.infoIcon.src = _image_assets__WEBPACK_IMPORTED_MODULE_0__.ASSET_INFO_ICON_16PX;\n        this.infoIcon.style.position = \"absolute\";\n        this.infoIcon.style.top = \"4px\";\n        this.infoIcon.style.right = \"4px\";\n        this.infoIcon.style.opacity = \"0.6\";\n        this.infoIcon.style.cursor = \"pointer\";\n        this.infoIcon.style.zIndex = \"2\";\n        this.infoIcon.style.width = \"16px\";\n        this.infoIcon.style.height = \"16px\";\n        this.infoIcon.onmouseover = function (_) { return _this.onHoverIn(); };\n        this.infoIcon.onmouseout = function (_) { return _this.onHoverOut(); };\n        this.infoIcon.onclick = function (_) { return _this.onClick(); };\n        parent.appendChild(this.infoIcon);\n    };\n    LibraryInfoIcon.prototype.onHoverIn = function () {\n        if (this.isShowingInfoIcon) {\n            this.infoIcon.style.opacity = \"1\";\n        }\n    };\n    LibraryInfoIcon.prototype.onHoverOut = function () {\n        if (this.isShowingInfoIcon) {\n            this.infoIcon.style.opacity = \"0.6\";\n        }\n    };\n    LibraryInfoIcon.prototype.onClick = function () {\n        if (this.isShowingInfoIcon) {\n            this.isShowingInfoIcon = false;\n            this.onTapIn();\n            this.infoIcon.src = _image_assets__WEBPACK_IMPORTED_MODULE_0__.ASSET_CLOSE_ICON_16PX;\n            this.infoIcon.style.opacity = \"1\";\n        }\n        else {\n            this.isShowingInfoIcon = true;\n            this.onTapOut();\n            this.infoIcon.src = _image_assets__WEBPACK_IMPORTED_MODULE_0__.ASSET_INFO_ICON_16PX;\n            this.infoIcon.style.opacity = \"0.6\";\n        }\n    };\n    return LibraryInfoIcon;\n}());\nvar LibraryInfoContainer = (function () {\n    function LibraryInfoContainer() {\n        var _this = this;\n        this.infoDiv = new LibraryInfoDiv();\n        this.infoIcon = new LibraryInfoIcon(function () {\n            _this.infoDiv.show();\n        }, function () {\n            _this.infoDiv.hide();\n        });\n    }\n    LibraryInfoContainer.prototype.renderInto = function (parent) {\n        this.infoDiv.renderInto(parent);\n        this.infoIcon.renderInto(parent);\n    };\n    return LibraryInfoContainer;\n}());\n\n//# sourceMappingURL=ui.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkU7QUFDOUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdEQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdEQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCxrREFBa0Q7QUFDbEQsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdFQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtEQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMrQjtBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS5qcz85NzRkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFTU0VUX0NMT1NFX0lDT05fMTZQWCwgQVNTRVRfSU5GT19JQ09OXzE2UFggfSBmcm9tIFwiLi9pbWFnZS1hc3NldHNcIjtcbmltcG9ydCB7IExpYnJhcnlJbmZvU3RyaW5ncyB9IGZyb20gXCIuL3N0cmluZ3NcIjtcbnZhciBMaWJyYXJ5SW5mb0RpdiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlicmFyeUluZm9EaXYoKSB7XG4gICAgICAgIHRoaXMuaW5mb0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgfVxuICAgIExpYnJhcnlJbmZvRGl2LnByb3RvdHlwZS5yZW5kZXJJbnRvID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB0aGlzLmluZm9EaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS50b3AgPSBcIjEwcHhcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLnJpZ2h0ID0gXCIxMHB4XCI7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS56SW5kZXggPSBcIjJcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLnBhZGRpbmcgPSBcIjVwdFwiO1xuICAgICAgICB0aGlzLmluZm9EaXYuc3R5bGUuYm9yZGVyID0gXCIxcHggc29saWQgIzE3MTcxN1wiO1xuICAgICAgICB0aGlzLmluZm9EaXYuc3R5bGUuZm9udFNpemUgPSBcIjEwcHRcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLmJhY2tncm91bmQgPSBcInJnYigwIDAgMCAvIDY5JSlcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLmJvcmRlclJhZGl1cyA9IFwiNXB4XCI7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB0aGlzLmluZm9EaXYuc3R5bGUuZm9udFdlaWdodCA9IFwiNDAwXCI7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS5jb2xvciA9IFwid2hpdGVcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LmlubmVyVGV4dCA9IExpYnJhcnlJbmZvU3RyaW5ncy5wb3dlcmVkQnkoKTtcbiAgICAgICAgdmFyIHByb2plY3RMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIHByb2plY3RMaW5rLmlubmVyVGV4dCA9IFwiU2NhbkFwcFwiO1xuICAgICAgICBwcm9qZWN0TGluay5ocmVmID0gXCJodHRwczovL3NjYW5hcHAub3JnXCI7XG4gICAgICAgIHByb2plY3RMaW5rLnRhcmdldCA9IFwibmV3XCI7XG4gICAgICAgIHByb2plY3RMaW5rLnN0eWxlLmNvbG9yID0gXCJ3aGl0ZVwiO1xuICAgICAgICB0aGlzLmluZm9EaXYuYXBwZW5kQ2hpbGQocHJvamVjdExpbmspO1xuICAgICAgICB2YXIgYnJlYWtFbGVtRmlyc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICAgIHZhciBicmVha0VsZW1TZWNvbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5hcHBlbmRDaGlsZChicmVha0VsZW1GaXJzdCk7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5hcHBlbmRDaGlsZChicmVha0VsZW1TZWNvbmQpO1xuICAgICAgICB2YXIgcmVwb3J0SXNzdWVMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIHJlcG9ydElzc3VlTGluay5pbm5lclRleHQgPSBMaWJyYXJ5SW5mb1N0cmluZ3MucmVwb3J0SXNzdWVzKCk7XG4gICAgICAgIHJlcG9ydElzc3VlTGluay5ocmVmID0gXCJodHRwczovL2dpdGh1Yi5jb20vbWViamFzL2h0bWw1LXFyY29kZS9pc3N1ZXNcIjtcbiAgICAgICAgcmVwb3J0SXNzdWVMaW5rLnRhcmdldCA9IFwibmV3XCI7XG4gICAgICAgIHJlcG9ydElzc3VlTGluay5zdHlsZS5jb2xvciA9IFwid2hpdGVcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LmFwcGVuZENoaWxkKHJlcG9ydElzc3VlTGluayk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmluZm9EaXYpO1xuICAgIH07XG4gICAgTGlicmFyeUluZm9EaXYucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIH07XG4gICAgTGlicmFyeUluZm9EaXYucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfTtcbiAgICByZXR1cm4gTGlicmFyeUluZm9EaXY7XG59KCkpO1xudmFyIExpYnJhcnlJbmZvSWNvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlicmFyeUluZm9JY29uKG9uVGFwSW4sIG9uVGFwT3V0KSB7XG4gICAgICAgIHRoaXMuaXNTaG93aW5nSW5mb0ljb24gPSB0cnVlO1xuICAgICAgICB0aGlzLm9uVGFwSW4gPSBvblRhcEluO1xuICAgICAgICB0aGlzLm9uVGFwT3V0ID0gb25UYXBPdXQ7XG4gICAgICAgIHRoaXMuaW5mb0ljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIH1cbiAgICBMaWJyYXJ5SW5mb0ljb24ucHJvdG90eXBlLnJlbmRlckludG8gPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5mb0ljb24uYWx0ID0gXCJJbmZvIGljb25cIjtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5zcmMgPSBBU1NFVF9JTkZPX0lDT05fMTZQWDtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5zdHlsZS50b3AgPSBcIjRweFwiO1xuICAgICAgICB0aGlzLmluZm9JY29uLnN0eWxlLnJpZ2h0ID0gXCI0cHhcIjtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5zdHlsZS5vcGFjaXR5ID0gXCIwLjZcIjtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5zdHlsZS56SW5kZXggPSBcIjJcIjtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5zdHlsZS53aWR0aCA9IFwiMTZweFwiO1xuICAgICAgICB0aGlzLmluZm9JY29uLnN0eWxlLmhlaWdodCA9IFwiMTZweFwiO1xuICAgICAgICB0aGlzLmluZm9JY29uLm9ubW91c2VvdmVyID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLm9uSG92ZXJJbigpOyB9O1xuICAgICAgICB0aGlzLmluZm9JY29uLm9ubW91c2VvdXQgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gX3RoaXMub25Ib3Zlck91dCgpOyB9O1xuICAgICAgICB0aGlzLmluZm9JY29uLm9uY2xpY2sgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gX3RoaXMub25DbGljaygpOyB9O1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5pbmZvSWNvbik7XG4gICAgfTtcbiAgICBMaWJyYXJ5SW5mb0ljb24ucHJvdG90eXBlLm9uSG92ZXJJbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTaG93aW5nSW5mb0ljb24pIHtcbiAgICAgICAgICAgIHRoaXMuaW5mb0ljb24uc3R5bGUub3BhY2l0eSA9IFwiMVwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaWJyYXJ5SW5mb0ljb24ucHJvdG90eXBlLm9uSG92ZXJPdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2hvd2luZ0luZm9JY29uKSB7XG4gICAgICAgICAgICB0aGlzLmluZm9JY29uLnN0eWxlLm9wYWNpdHkgPSBcIjAuNlwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaWJyYXJ5SW5mb0ljb24ucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2hvd2luZ0luZm9JY29uKSB7XG4gICAgICAgICAgICB0aGlzLmlzU2hvd2luZ0luZm9JY29uID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm9uVGFwSW4oKTtcbiAgICAgICAgICAgIHRoaXMuaW5mb0ljb24uc3JjID0gQVNTRVRfQ0xPU0VfSUNPTl8xNlBYO1xuICAgICAgICAgICAgdGhpcy5pbmZvSWNvbi5zdHlsZS5vcGFjaXR5ID0gXCIxXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzU2hvd2luZ0luZm9JY29uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMub25UYXBPdXQoKTtcbiAgICAgICAgICAgIHRoaXMuaW5mb0ljb24uc3JjID0gQVNTRVRfSU5GT19JQ09OXzE2UFg7XG4gICAgICAgICAgICB0aGlzLmluZm9JY29uLnN0eWxlLm9wYWNpdHkgPSBcIjAuNlwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTGlicmFyeUluZm9JY29uO1xufSgpKTtcbnZhciBMaWJyYXJ5SW5mb0NvbnRhaW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlicmFyeUluZm9Db250YWluZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5mb0RpdiA9IG5ldyBMaWJyYXJ5SW5mb0RpdigpO1xuICAgICAgICB0aGlzLmluZm9JY29uID0gbmV3IExpYnJhcnlJbmZvSWNvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pbmZvRGl2LnNob3coKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaW5mb0Rpdi5oaWRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBMaWJyYXJ5SW5mb0NvbnRhaW5lci5wcm90b3R5cGUucmVuZGVySW50byA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnJlbmRlckludG8ocGFyZW50KTtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5yZW5kZXJJbnRvKHBhcmVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGlicmFyeUluZm9Db250YWluZXI7XG59KCkpO1xuZXhwb3J0IHsgTGlicmFyeUluZm9Db250YWluZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/ui.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/ui/scanner/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/ui/scanner/base.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseUiElementFactory: function() { return /* binding */ BaseUiElementFactory; },\n/* harmony export */   PublicUiElementIdAndClasses: function() { return /* binding */ PublicUiElementIdAndClasses; }\n/* harmony export */ });\nvar PublicUiElementIdAndClasses = (function () {\n    function PublicUiElementIdAndClasses() {\n    }\n    PublicUiElementIdAndClasses.ALL_ELEMENT_CLASS = \"html5-qrcode-element\";\n    PublicUiElementIdAndClasses.CAMERA_PERMISSION_BUTTON_ID = \"html5-qrcode-button-camera-permission\";\n    PublicUiElementIdAndClasses.CAMERA_START_BUTTON_ID = \"html5-qrcode-button-camera-start\";\n    PublicUiElementIdAndClasses.CAMERA_STOP_BUTTON_ID = \"html5-qrcode-button-camera-stop\";\n    PublicUiElementIdAndClasses.TORCH_BUTTON_ID = \"html5-qrcode-button-torch\";\n    PublicUiElementIdAndClasses.CAMERA_SELECTION_SELECT_ID = \"html5-qrcode-select-camera\";\n    PublicUiElementIdAndClasses.FILE_SELECTION_BUTTON_ID = \"html5-qrcode-button-file-selection\";\n    PublicUiElementIdAndClasses.ZOOM_SLIDER_ID = \"html5-qrcode-input-range-zoom\";\n    PublicUiElementIdAndClasses.SCAN_TYPE_CHANGE_ANCHOR_ID = \"html5-qrcode-anchor-scan-type-change\";\n    PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_ON = \"html5-qrcode-button-torch-on\";\n    PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_OFF = \"html5-qrcode-button-torch-off\";\n    return PublicUiElementIdAndClasses;\n}());\n\nvar BaseUiElementFactory = (function () {\n    function BaseUiElementFactory() {\n    }\n    BaseUiElementFactory.createElement = function (elementType, elementId) {\n        var element = (document.createElement(elementType));\n        element.id = elementId;\n        element.classList.add(PublicUiElementIdAndClasses.ALL_ELEMENT_CLASS);\n        if (elementType === \"button\") {\n            element.setAttribute(\"type\", \"button\");\n        }\n        return element;\n    };\n    return BaseUiElementFactory;\n}());\n\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3NDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMrQjtBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL2Jhc2UuanM/MWJiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMoKSB7XG4gICAgfVxuICAgIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5BTExfRUxFTUVOVF9DTEFTUyA9IFwiaHRtbDUtcXJjb2RlLWVsZW1lbnRcIjtcbiAgICBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuQ0FNRVJBX1BFUk1JU1NJT05fQlVUVE9OX0lEID0gXCJodG1sNS1xcmNvZGUtYnV0dG9uLWNhbWVyYS1wZXJtaXNzaW9uXCI7XG4gICAgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLkNBTUVSQV9TVEFSVF9CVVRUT05fSUQgPSBcImh0bWw1LXFyY29kZS1idXR0b24tY2FtZXJhLXN0YXJ0XCI7XG4gICAgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLkNBTUVSQV9TVE9QX0JVVFRPTl9JRCA9IFwiaHRtbDUtcXJjb2RlLWJ1dHRvbi1jYW1lcmEtc3RvcFwiO1xuICAgIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5UT1JDSF9CVVRUT05fSUQgPSBcImh0bWw1LXFyY29kZS1idXR0b24tdG9yY2hcIjtcbiAgICBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuQ0FNRVJBX1NFTEVDVElPTl9TRUxFQ1RfSUQgPSBcImh0bWw1LXFyY29kZS1zZWxlY3QtY2FtZXJhXCI7XG4gICAgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLkZJTEVfU0VMRUNUSU9OX0JVVFRPTl9JRCA9IFwiaHRtbDUtcXJjb2RlLWJ1dHRvbi1maWxlLXNlbGVjdGlvblwiO1xuICAgIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5aT09NX1NMSURFUl9JRCA9IFwiaHRtbDUtcXJjb2RlLWlucHV0LXJhbmdlLXpvb21cIjtcbiAgICBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuU0NBTl9UWVBFX0NIQU5HRV9BTkNIT1JfSUQgPSBcImh0bWw1LXFyY29kZS1hbmNob3Itc2Nhbi10eXBlLWNoYW5nZVwiO1xuICAgIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5UT1JDSF9CVVRUT05fQ0xBU1NfVE9SQ0hfT04gPSBcImh0bWw1LXFyY29kZS1idXR0b24tdG9yY2gtb25cIjtcbiAgICBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuVE9SQ0hfQlVUVE9OX0NMQVNTX1RPUkNIX09GRiA9IFwiaHRtbDUtcXJjb2RlLWJ1dHRvbi10b3JjaC1vZmZcIjtcbiAgICByZXR1cm4gUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzO1xufSgpKTtcbmV4cG9ydCB7IFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3NlcyB9O1xudmFyIEJhc2VVaUVsZW1lbnRGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlVWlFbGVtZW50RmFjdG9yeSgpIHtcbiAgICB9XG4gICAgQmFzZVVpRWxlbWVudEZhY3RvcnkuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50VHlwZSwgZWxlbWVudElkKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudFR5cGUpKTtcbiAgICAgICAgZWxlbWVudC5pZCA9IGVsZW1lbnRJZDtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5BTExfRUxFTUVOVF9DTEFTUyk7XG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gXCJidXR0b25cIikge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiYnV0dG9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2VVaUVsZW1lbnRGYWN0b3J5O1xufSgpKTtcbmV4cG9ydCB7IEJhc2VVaUVsZW1lbnRGYWN0b3J5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/ui/scanner/base.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/ui/scanner/camera-selection-ui.js":
/*!*************************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/ui/scanner/camera-selection-ui.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraSelectionUi: function() { return /* binding */ CameraSelectionUi; }\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./node_modules/html5-qrcode/esm/ui/scanner/base.js\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../strings */ \"./node_modules/html5-qrcode/esm/strings.js\");\n\n\nvar CameraSelectionUi = (function () {\n    function CameraSelectionUi(cameras) {\n        this.selectElement = _base__WEBPACK_IMPORTED_MODULE_0__.BaseUiElementFactory\n            .createElement(\"select\", _base__WEBPACK_IMPORTED_MODULE_0__.PublicUiElementIdAndClasses.CAMERA_SELECTION_SELECT_ID);\n        this.cameras = cameras;\n        this.options = [];\n    }\n    CameraSelectionUi.prototype.render = function (parentElement) {\n        var cameraSelectionContainer = document.createElement(\"span\");\n        cameraSelectionContainer.style.marginRight = \"10px\";\n        var numCameras = this.cameras.length;\n        if (numCameras === 0) {\n            throw new Error(\"No cameras found\");\n        }\n        if (numCameras === 1) {\n            cameraSelectionContainer.style.display = \"none\";\n        }\n        else {\n            var selectCameraString = _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeScannerStrings.selectCamera();\n            cameraSelectionContainer.innerText\n                = \"\".concat(selectCameraString, \" (\").concat(this.cameras.length, \")  \");\n        }\n        var anonymousCameraId = 1;\n        for (var _i = 0, _a = this.cameras; _i < _a.length; _i++) {\n            var camera = _a[_i];\n            var value = camera.id;\n            var name_1 = camera.label == null ? value : camera.label;\n            if (!name_1 || name_1 === \"\") {\n                name_1 = [\n                    _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeScannerStrings.anonymousCameraPrefix(),\n                    anonymousCameraId++\n                ].join(\" \");\n            }\n            var option = document.createElement(\"option\");\n            option.value = value;\n            option.innerText = name_1;\n            this.options.push(option);\n            this.selectElement.appendChild(option);\n        }\n        cameraSelectionContainer.appendChild(this.selectElement);\n        parentElement.appendChild(cameraSelectionContainer);\n    };\n    CameraSelectionUi.prototype.disable = function () {\n        this.selectElement.disabled = true;\n    };\n    CameraSelectionUi.prototype.isDisabled = function () {\n        return this.selectElement.disabled === true;\n    };\n    CameraSelectionUi.prototype.enable = function () {\n        this.selectElement.disabled = false;\n    };\n    CameraSelectionUi.prototype.getValue = function () {\n        return this.selectElement.value;\n    };\n    CameraSelectionUi.prototype.hasValue = function (value) {\n        for (var _i = 0, _a = this.options; _i < _a.length; _i++) {\n            var option = _a[_i];\n            if (option.value === value) {\n                return true;\n            }\n        }\n        return false;\n    };\n    CameraSelectionUi.prototype.setValue = function (value) {\n        if (!this.hasValue(value)) {\n            throw new Error(\"\".concat(value, \" is not present in the camera list.\"));\n        }\n        this.selectElement.value = value;\n    };\n    CameraSelectionUi.prototype.hasSingleItem = function () {\n        return this.cameras.length === 1;\n    };\n    CameraSelectionUi.prototype.numCameras = function () {\n        return this.cameras.length;\n    };\n    CameraSelectionUi.create = function (parentElement, cameras) {\n        var cameraSelectUi = new CameraSelectionUi(cameras);\n        cameraSelectUi.render(parentElement);\n        return cameraSelectUi;\n    };\n    return CameraSelectionUi;\n}());\n\n//# sourceMappingURL=camera-selection-ui.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL2NhbWVyYS1zZWxlY3Rpb24tdWkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJFO0FBQ2pCO0FBQzFEO0FBQ0E7QUFDQSw2QkFBNkIsdURBQW9CO0FBQ2pELHFDQUFxQyw4REFBMkI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywrREFBeUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0RBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDNEI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vdWkvc2Nhbm5lci9jYW1lcmEtc2VsZWN0aW9uLXVpLmpzPzY0MjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZVVpRWxlbWVudEZhY3RvcnksIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3NlcyB9IGZyb20gXCIuL2Jhc2VcIjtcbmltcG9ydCB7IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MgfSBmcm9tIFwiLi4vLi4vc3RyaW5nc1wiO1xudmFyIENhbWVyYVNlbGVjdGlvblVpID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYW1lcmFTZWxlY3Rpb25VaShjYW1lcmFzKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0RWxlbWVudCA9IEJhc2VVaUVsZW1lbnRGYWN0b3J5XG4gICAgICAgICAgICAuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiLCBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuQ0FNRVJBX1NFTEVDVElPTl9TRUxFQ1RfSUQpO1xuICAgICAgICB0aGlzLmNhbWVyYXMgPSBjYW1lcmFzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgQ2FtZXJhU2VsZWN0aW9uVWkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgIHZhciBjYW1lcmFTZWxlY3Rpb25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgY2FtZXJhU2VsZWN0aW9uQ29udGFpbmVyLnN0eWxlLm1hcmdpblJpZ2h0ID0gXCIxMHB4XCI7XG4gICAgICAgIHZhciBudW1DYW1lcmFzID0gdGhpcy5jYW1lcmFzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bUNhbWVyYXMgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNhbWVyYXMgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bUNhbWVyYXMgPT09IDEpIHtcbiAgICAgICAgICAgIGNhbWVyYVNlbGVjdGlvbkNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0Q2FtZXJhU3RyaW5nID0gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5zZWxlY3RDYW1lcmEoKTtcbiAgICAgICAgICAgIGNhbWVyYVNlbGVjdGlvbkNvbnRhaW5lci5pbm5lclRleHRcbiAgICAgICAgICAgICAgICA9IFwiXCIuY29uY2F0KHNlbGVjdENhbWVyYVN0cmluZywgXCIgKFwiKS5jb25jYXQodGhpcy5jYW1lcmFzLmxlbmd0aCwgXCIpICBcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFub255bW91c0NhbWVyYUlkID0gMTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2FtZXJhczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjYW1lcmEgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjYW1lcmEuaWQ7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gY2FtZXJhLmxhYmVsID09IG51bGwgPyB2YWx1ZSA6IGNhbWVyYS5sYWJlbDtcbiAgICAgICAgICAgIGlmICghbmFtZV8xIHx8IG5hbWVfMSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIG5hbWVfMSA9IFtcbiAgICAgICAgICAgICAgICAgICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5hbm9ueW1vdXNDYW1lcmFQcmVmaXgoKSxcbiAgICAgICAgICAgICAgICAgICAgYW5vbnltb3VzQ2FtZXJhSWQrK1xuICAgICAgICAgICAgICAgIF0uam9pbihcIiBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIG9wdGlvbi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgb3B0aW9uLmlubmVyVGV4dCA9IG5hbWVfMTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wdXNoKG9wdGlvbik7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEVsZW1lbnQuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjYW1lcmFTZWxlY3Rpb25Db250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3RFbGVtZW50KTtcbiAgICAgICAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChjYW1lcmFTZWxlY3Rpb25Db250YWluZXIpO1xuICAgIH07XG4gICAgQ2FtZXJhU2VsZWN0aW9uVWkucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0RWxlbWVudC5kaXNhYmxlZCA9IHRydWU7XG4gICAgfTtcbiAgICBDYW1lcmFTZWxlY3Rpb25VaS5wcm90b3R5cGUuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0RWxlbWVudC5kaXNhYmxlZCA9PT0gdHJ1ZTtcbiAgICB9O1xuICAgIENhbWVyYVNlbGVjdGlvblVpLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0RWxlbWVudC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgQ2FtZXJhU2VsZWN0aW9uVWkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RFbGVtZW50LnZhbHVlO1xuICAgIH07XG4gICAgQ2FtZXJhU2VsZWN0aW9uVWkucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLm9wdGlvbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKG9wdGlvbi52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBDYW1lcmFTZWxlY3Rpb25VaS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KHZhbHVlLCBcIiBpcyBub3QgcHJlc2VudCBpbiB0aGUgY2FtZXJhIGxpc3QuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdEVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xuICAgIENhbWVyYVNlbGVjdGlvblVpLnByb3RvdHlwZS5oYXNTaW5nbGVJdGVtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW1lcmFzLmxlbmd0aCA9PT0gMTtcbiAgICB9O1xuICAgIENhbWVyYVNlbGVjdGlvblVpLnByb3RvdHlwZS5udW1DYW1lcmFzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW1lcmFzLmxlbmd0aDtcbiAgICB9O1xuICAgIENhbWVyYVNlbGVjdGlvblVpLmNyZWF0ZSA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCBjYW1lcmFzKSB7XG4gICAgICAgIHZhciBjYW1lcmFTZWxlY3RVaSA9IG5ldyBDYW1lcmFTZWxlY3Rpb25VaShjYW1lcmFzKTtcbiAgICAgICAgY2FtZXJhU2VsZWN0VWkucmVuZGVyKHBhcmVudEVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gY2FtZXJhU2VsZWN0VWk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FtZXJhU2VsZWN0aW9uVWk7XG59KCkpO1xuZXhwb3J0IHsgQ2FtZXJhU2VsZWN0aW9uVWkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbWVyYS1zZWxlY3Rpb24tdWkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/ui/scanner/camera-selection-ui.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/ui/scanner/camera-zoom-ui.js":
/*!********************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/ui/scanner/camera-zoom-ui.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraZoomUi: function() { return /* binding */ CameraZoomUi; }\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./node_modules/html5-qrcode/esm/ui/scanner/base.js\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../strings */ \"./node_modules/html5-qrcode/esm/strings.js\");\n\n\nvar CameraZoomUi = (function () {\n    function CameraZoomUi() {\n        this.onChangeCallback = null;\n        this.zoomElementContainer = document.createElement(\"div\");\n        this.rangeInput = _base__WEBPACK_IMPORTED_MODULE_0__.BaseUiElementFactory.createElement(\"input\", _base__WEBPACK_IMPORTED_MODULE_0__.PublicUiElementIdAndClasses.ZOOM_SLIDER_ID);\n        this.rangeInput.type = \"range\";\n        this.rangeText = document.createElement(\"span\");\n        this.rangeInput.min = \"1\";\n        this.rangeInput.max = \"5\";\n        this.rangeInput.value = \"1\";\n        this.rangeInput.step = \"0.1\";\n    }\n    CameraZoomUi.prototype.render = function (parentElement, renderOnCreate) {\n        this.zoomElementContainer.style.display\n            = renderOnCreate ? \"block\" : \"none\";\n        this.zoomElementContainer.style.padding = \"5px 10px\";\n        this.zoomElementContainer.style.textAlign = \"center\";\n        parentElement.appendChild(this.zoomElementContainer);\n        this.rangeInput.style.display = \"inline-block\";\n        this.rangeInput.style.width = \"50%\";\n        this.rangeInput.style.height = \"5px\";\n        this.rangeInput.style.background = \"#d3d3d3\";\n        this.rangeInput.style.outline = \"none\";\n        this.rangeInput.style.opacity = \"0.7\";\n        var zoomString = _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeScannerStrings.zoom();\n        this.rangeText.innerText = \"\".concat(this.rangeInput.value, \"x \").concat(zoomString);\n        this.rangeText.style.marginRight = \"10px\";\n        var $this = this;\n        this.rangeInput.addEventListener(\"input\", function () { return $this.onValueChange(); });\n        this.rangeInput.addEventListener(\"change\", function () { return $this.onValueChange(); });\n        this.zoomElementContainer.appendChild(this.rangeInput);\n        this.zoomElementContainer.appendChild(this.rangeText);\n    };\n    CameraZoomUi.prototype.onValueChange = function () {\n        var zoomString = _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeScannerStrings.zoom();\n        this.rangeText.innerText = \"\".concat(this.rangeInput.value, \"x \").concat(zoomString);\n        if (this.onChangeCallback) {\n            this.onChangeCallback(parseFloat(this.rangeInput.value));\n        }\n    };\n    CameraZoomUi.prototype.setValues = function (minValue, maxValue, defaultValue, step) {\n        this.rangeInput.min = minValue.toString();\n        this.rangeInput.max = maxValue.toString();\n        this.rangeInput.step = step.toString();\n        this.rangeInput.value = defaultValue.toString();\n        this.onValueChange();\n    };\n    CameraZoomUi.prototype.show = function () {\n        this.zoomElementContainer.style.display = \"block\";\n    };\n    CameraZoomUi.prototype.hide = function () {\n        this.zoomElementContainer.style.display = \"none\";\n    };\n    CameraZoomUi.prototype.setOnCameraZoomValueChangeCallback = function (onChangeCallback) {\n        this.onChangeCallback = onChangeCallback;\n    };\n    CameraZoomUi.prototype.removeOnCameraZoomValueChangeCallback = function () {\n        this.onChangeCallback = null;\n    };\n    CameraZoomUi.create = function (parentElement, renderOnCreate) {\n        var cameraZoomUi = new CameraZoomUi();\n        cameraZoomUi.render(parentElement, renderOnCreate);\n        return cameraZoomUi;\n    };\n    return CameraZoomUi;\n}());\n\n//# sourceMappingURL=camera-zoom-ui.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL2NhbWVyYS16b29tLXVpLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyRTtBQUNqQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1REFBb0Isd0JBQXdCLDhEQUEyQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrREFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLCtCQUErQjtBQUMvRixpRUFBaUUsK0JBQStCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtEQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3VCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL3VpL3NjYW5uZXIvY2FtZXJhLXpvb20tdWkuanM/NzE0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlVWlFbGVtZW50RmFjdG9yeSwgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzIH0gZnJvbSBcIi4vYmFzZVwiO1xuaW1wb3J0IHsgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncyB9IGZyb20gXCIuLi8uLi9zdHJpbmdzXCI7XG52YXIgQ2FtZXJhWm9vbVVpID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYW1lcmFab29tVWkoKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuem9vbUVsZW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnJhbmdlSW5wdXQgPSBCYXNlVWlFbGVtZW50RmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLlpPT01fU0xJREVSX0lEKTtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LnR5cGUgPSBcInJhbmdlXCI7XG4gICAgICAgIHRoaXMucmFuZ2VUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5taW4gPSBcIjFcIjtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0Lm1heCA9IFwiNVwiO1xuICAgICAgICB0aGlzLnJhbmdlSW5wdXQudmFsdWUgPSBcIjFcIjtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LnN0ZXAgPSBcIjAuMVwiO1xuICAgIH1cbiAgICBDYW1lcmFab29tVWkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCByZW5kZXJPbkNyZWF0ZSkge1xuICAgICAgICB0aGlzLnpvb21FbGVtZW50Q29udGFpbmVyLnN0eWxlLmRpc3BsYXlcbiAgICAgICAgICAgID0gcmVuZGVyT25DcmVhdGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy56b29tRWxlbWVudENvbnRhaW5lci5zdHlsZS5wYWRkaW5nID0gXCI1cHggMTBweFwiO1xuICAgICAgICB0aGlzLnpvb21FbGVtZW50Q29udGFpbmVyLnN0eWxlLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIHBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy56b29tRWxlbWVudENvbnRhaW5lcik7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LnN0eWxlLndpZHRoID0gXCI1MCVcIjtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LnN0eWxlLmhlaWdodCA9IFwiNXB4XCI7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5zdHlsZS5iYWNrZ3JvdW5kID0gXCIjZDNkM2QzXCI7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5zdHlsZS5vdXRsaW5lID0gXCJub25lXCI7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5zdHlsZS5vcGFjaXR5ID0gXCIwLjdcIjtcbiAgICAgICAgdmFyIHpvb21TdHJpbmcgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnpvb20oKTtcbiAgICAgICAgdGhpcy5yYW5nZVRleHQuaW5uZXJUZXh0ID0gXCJcIi5jb25jYXQodGhpcy5yYW5nZUlucHV0LnZhbHVlLCBcInggXCIpLmNvbmNhdCh6b29tU3RyaW5nKTtcbiAgICAgICAgdGhpcy5yYW5nZVRleHQuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjEwcHhcIjtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiAkdGhpcy5vblZhbHVlQ2hhbmdlKCk7IH0pO1xuICAgICAgICB0aGlzLnJhbmdlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiAkdGhpcy5vblZhbHVlQ2hhbmdlKCk7IH0pO1xuICAgICAgICB0aGlzLnpvb21FbGVtZW50Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucmFuZ2VJbnB1dCk7XG4gICAgICAgIHRoaXMuem9vbUVsZW1lbnRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5yYW5nZVRleHQpO1xuICAgIH07XG4gICAgQ2FtZXJhWm9vbVVpLnByb3RvdHlwZS5vblZhbHVlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgem9vbVN0cmluZyA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Muem9vbSgpO1xuICAgICAgICB0aGlzLnJhbmdlVGV4dC5pbm5lclRleHQgPSBcIlwiLmNvbmNhdCh0aGlzLnJhbmdlSW5wdXQudmFsdWUsIFwieCBcIikuY29uY2F0KHpvb21TdHJpbmcpO1xuICAgICAgICBpZiAodGhpcy5vbkNoYW5nZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2socGFyc2VGbG9hdCh0aGlzLnJhbmdlSW5wdXQudmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FtZXJhWm9vbVVpLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAobWluVmFsdWUsIG1heFZhbHVlLCBkZWZhdWx0VmFsdWUsIHN0ZXApIHtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0Lm1pbiA9IG1pblZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5tYXggPSBtYXhWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLnJhbmdlSW5wdXQuc3RlcCA9IHN0ZXAudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LnZhbHVlID0gZGVmYXVsdFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMub25WYWx1ZUNoYW5nZSgpO1xuICAgIH07XG4gICAgQ2FtZXJhWm9vbVVpLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnpvb21FbGVtZW50Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfTtcbiAgICBDYW1lcmFab29tVWkucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuem9vbUVsZW1lbnRDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH07XG4gICAgQ2FtZXJhWm9vbVVpLnByb3RvdHlwZS5zZXRPbkNhbWVyYVpvb21WYWx1ZUNoYW5nZUNhbGxiYWNrID0gZnVuY3Rpb24gKG9uQ2hhbmdlQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gb25DaGFuZ2VDYWxsYmFjaztcbiAgICB9O1xuICAgIENhbWVyYVpvb21VaS5wcm90b3R5cGUucmVtb3ZlT25DYW1lcmFab29tVmFsdWVDaGFuZ2VDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gbnVsbDtcbiAgICB9O1xuICAgIENhbWVyYVpvb21VaS5jcmVhdGUgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgcmVuZGVyT25DcmVhdGUpIHtcbiAgICAgICAgdmFyIGNhbWVyYVpvb21VaSA9IG5ldyBDYW1lcmFab29tVWkoKTtcbiAgICAgICAgY2FtZXJhWm9vbVVpLnJlbmRlcihwYXJlbnRFbGVtZW50LCByZW5kZXJPbkNyZWF0ZSk7XG4gICAgICAgIHJldHVybiBjYW1lcmFab29tVWk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FtZXJhWm9vbVVpO1xufSgpKTtcbmV4cG9ydCB7IENhbWVyYVpvb21VaSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FtZXJhLXpvb20tdWkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/ui/scanner/camera-zoom-ui.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/ui/scanner/file-selection-ui.js":
/*!***********************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/ui/scanner/file-selection-ui.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FileSelectionUi: function() { return /* binding */ FileSelectionUi; }\n/* harmony export */ });\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../strings */ \"./node_modules/html5-qrcode/esm/strings.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"./node_modules/html5-qrcode/esm/ui/scanner/base.js\");\n\n\nvar FileSelectionUi = (function () {\n    function FileSelectionUi(parentElement, showOnRender, onFileSelected) {\n        this.fileBasedScanRegion = this.createFileBasedScanRegion();\n        this.fileBasedScanRegion.style.display\n            = showOnRender ? \"block\" : \"none\";\n        parentElement.appendChild(this.fileBasedScanRegion);\n        var fileScanLabel = document.createElement(\"label\");\n        fileScanLabel.setAttribute(\"for\", this.getFileScanInputId());\n        fileScanLabel.style.display = \"inline-block\";\n        this.fileBasedScanRegion.appendChild(fileScanLabel);\n        this.fileSelectionButton\n            = _base__WEBPACK_IMPORTED_MODULE_1__.BaseUiElementFactory.createElement(\"button\", _base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.FILE_SELECTION_BUTTON_ID);\n        this.setInitialValueToButton();\n        this.fileSelectionButton.addEventListener(\"click\", function (_) {\n            fileScanLabel.click();\n        });\n        fileScanLabel.append(this.fileSelectionButton);\n        this.fileScanInput\n            = _base__WEBPACK_IMPORTED_MODULE_1__.BaseUiElementFactory.createElement(\"input\", this.getFileScanInputId());\n        this.fileScanInput.type = \"file\";\n        this.fileScanInput.accept = \"image/*\";\n        this.fileScanInput.style.display = \"none\";\n        fileScanLabel.appendChild(this.fileScanInput);\n        var $this = this;\n        this.fileScanInput.addEventListener(\"change\", function (e) {\n            if (e == null || e.target == null) {\n                return;\n            }\n            var target = e.target;\n            if (target.files && target.files.length === 0) {\n                return;\n            }\n            var fileList = target.files;\n            var file = fileList[0];\n            var fileName = file.name;\n            $this.setImageNameToButton(fileName);\n            onFileSelected(file);\n        });\n        var dragAndDropMessage = this.createDragAndDropMessage();\n        this.fileBasedScanRegion.appendChild(dragAndDropMessage);\n        this.fileBasedScanRegion.addEventListener(\"dragenter\", function (event) {\n            $this.fileBasedScanRegion.style.border\n                = $this.fileBasedScanRegionActiveBorder();\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.fileBasedScanRegion.addEventListener(\"dragleave\", function (event) {\n            $this.fileBasedScanRegion.style.border\n                = $this.fileBasedScanRegionDefaultBorder();\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.fileBasedScanRegion.addEventListener(\"dragover\", function (event) {\n            $this.fileBasedScanRegion.style.border\n                = $this.fileBasedScanRegionActiveBorder();\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.fileBasedScanRegion.addEventListener(\"drop\", function (event) {\n            event.stopPropagation();\n            event.preventDefault();\n            $this.fileBasedScanRegion.style.border\n                = $this.fileBasedScanRegionDefaultBorder();\n            var dataTransfer = event.dataTransfer;\n            if (dataTransfer) {\n                var files = dataTransfer.files;\n                if (!files || files.length === 0) {\n                    return;\n                }\n                var isAnyFileImage = false;\n                for (var i = 0; i < files.length; ++i) {\n                    var file = files.item(i);\n                    if (!file) {\n                        continue;\n                    }\n                    var imageType = /image.*/;\n                    if (!file.type.match(imageType)) {\n                        continue;\n                    }\n                    isAnyFileImage = true;\n                    var fileName = file.name;\n                    $this.setImageNameToButton(fileName);\n                    onFileSelected(file);\n                    dragAndDropMessage.innerText\n                        = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.dragAndDropMessage();\n                    break;\n                }\n                if (!isAnyFileImage) {\n                    dragAndDropMessage.innerText\n                        = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings\n                            .dragAndDropMessageOnlyImages();\n                }\n            }\n        });\n    }\n    FileSelectionUi.prototype.hide = function () {\n        this.fileBasedScanRegion.style.display = \"none\";\n        this.fileScanInput.disabled = true;\n    };\n    FileSelectionUi.prototype.show = function () {\n        this.fileBasedScanRegion.style.display = \"block\";\n        this.fileScanInput.disabled = false;\n    };\n    FileSelectionUi.prototype.isShowing = function () {\n        return this.fileBasedScanRegion.style.display === \"block\";\n    };\n    FileSelectionUi.prototype.resetValue = function () {\n        this.fileScanInput.value = \"\";\n        this.setInitialValueToButton();\n    };\n    FileSelectionUi.prototype.createFileBasedScanRegion = function () {\n        var fileBasedScanRegion = document.createElement(\"div\");\n        fileBasedScanRegion.style.textAlign = \"center\";\n        fileBasedScanRegion.style.margin = \"auto\";\n        fileBasedScanRegion.style.width = \"80%\";\n        fileBasedScanRegion.style.maxWidth = \"600px\";\n        fileBasedScanRegion.style.border\n            = this.fileBasedScanRegionDefaultBorder();\n        fileBasedScanRegion.style.padding = \"10px\";\n        fileBasedScanRegion.style.marginBottom = \"10px\";\n        return fileBasedScanRegion;\n    };\n    FileSelectionUi.prototype.fileBasedScanRegionDefaultBorder = function () {\n        return \"6px dashed #ebebeb\";\n    };\n    FileSelectionUi.prototype.fileBasedScanRegionActiveBorder = function () {\n        return \"6px dashed rgb(153 151 151)\";\n    };\n    FileSelectionUi.prototype.createDragAndDropMessage = function () {\n        var dragAndDropMessage = document.createElement(\"div\");\n        dragAndDropMessage.innerText\n            = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.dragAndDropMessage();\n        dragAndDropMessage.style.fontWeight = \"400\";\n        return dragAndDropMessage;\n    };\n    FileSelectionUi.prototype.setImageNameToButton = function (imageFileName) {\n        var MAX_CHARS = 20;\n        if (imageFileName.length > MAX_CHARS) {\n            var start8Chars = imageFileName.substring(0, 8);\n            var length_1 = imageFileName.length;\n            var last8Chars = imageFileName.substring(length_1 - 8, length_1);\n            imageFileName = \"\".concat(start8Chars, \"....\").concat(last8Chars);\n        }\n        var newText = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.fileSelectionChooseAnother()\n            + \" - \"\n            + imageFileName;\n        this.fileSelectionButton.innerText = newText;\n    };\n    FileSelectionUi.prototype.setInitialValueToButton = function () {\n        var initialText = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.fileSelectionChooseImage()\n            + \" - \"\n            + _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.fileSelectionNoImageSelected();\n        this.fileSelectionButton.innerText = initialText;\n    };\n    FileSelectionUi.prototype.getFileScanInputId = function () {\n        return \"html5-qrcode-private-filescan-input\";\n    };\n    FileSelectionUi.create = function (parentElement, showOnRender, onFileSelected) {\n        var button = new FileSelectionUi(parentElement, showOnRender, onFileSelected);\n        return button;\n    };\n    return FileSelectionUi;\n}());\n\n//# sourceMappingURL=file-selection-ui.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL2ZpbGUtc2VsZWN0aW9uLXVpLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwRDtBQUNpQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1REFBb0IseUJBQXlCLDhEQUEyQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWMsdURBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrREFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0RBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0RBQXlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0RBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0RBQXlCO0FBQ25EO0FBQ0EsY0FBYywrREFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzBCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL3VpL3NjYW5uZXIvZmlsZS1zZWxlY3Rpb24tdWkuanM/MWI2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzIH0gZnJvbSBcIi4uLy4uL3N0cmluZ3NcIjtcbmltcG9ydCB7IEJhc2VVaUVsZW1lbnRGYWN0b3J5LCBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMgfSBmcm9tIFwiLi9iYXNlXCI7XG52YXIgRmlsZVNlbGVjdGlvblVpID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWxlU2VsZWN0aW9uVWkocGFyZW50RWxlbWVudCwgc2hvd09uUmVuZGVyLCBvbkZpbGVTZWxlY3RlZCkge1xuICAgICAgICB0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24gPSB0aGlzLmNyZWF0ZUZpbGVCYXNlZFNjYW5SZWdpb24oKTtcbiAgICAgICAgdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uLnN0eWxlLmRpc3BsYXlcbiAgICAgICAgICAgID0gc2hvd09uUmVuZGVyID8gXCJibG9ja1wiIDogXCJub25lXCI7XG4gICAgICAgIHBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uKTtcbiAgICAgICAgdmFyIGZpbGVTY2FuTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICAgIGZpbGVTY2FuTGFiZWwuc2V0QXR0cmlidXRlKFwiZm9yXCIsIHRoaXMuZ2V0RmlsZVNjYW5JbnB1dElkKCkpO1xuICAgICAgICBmaWxlU2NhbkxhYmVsLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICB0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uYXBwZW5kQ2hpbGQoZmlsZVNjYW5MYWJlbCk7XG4gICAgICAgIHRoaXMuZmlsZVNlbGVjdGlvbkJ1dHRvblxuICAgICAgICAgICAgPSBCYXNlVWlFbGVtZW50RmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5GSUxFX1NFTEVDVElPTl9CVVRUT05fSUQpO1xuICAgICAgICB0aGlzLnNldEluaXRpYWxWYWx1ZVRvQnV0dG9uKCk7XG4gICAgICAgIHRoaXMuZmlsZVNlbGVjdGlvbkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGZpbGVTY2FuTGFiZWwuY2xpY2soKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbGVTY2FuTGFiZWwuYXBwZW5kKHRoaXMuZmlsZVNlbGVjdGlvbkJ1dHRvbik7XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbnB1dFxuICAgICAgICAgICAgPSBCYXNlVWlFbGVtZW50RmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgdGhpcy5nZXRGaWxlU2NhbklucHV0SWQoKSk7XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbnB1dC50eXBlID0gXCJmaWxlXCI7XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbnB1dC5hY2NlcHQgPSBcImltYWdlLypcIjtcbiAgICAgICAgdGhpcy5maWxlU2NhbklucHV0LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgZmlsZVNjYW5MYWJlbC5hcHBlbmRDaGlsZCh0aGlzLmZpbGVTY2FuSW5wdXQpO1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmZpbGVTY2FuSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUgPT0gbnVsbCB8fCBlLnRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHRhcmdldC5maWxlcyAmJiB0YXJnZXQuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpbGVMaXN0ID0gdGFyZ2V0LmZpbGVzO1xuICAgICAgICAgICAgdmFyIGZpbGUgPSBmaWxlTGlzdFswXTtcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IGZpbGUubmFtZTtcbiAgICAgICAgICAgICR0aGlzLnNldEltYWdlTmFtZVRvQnV0dG9uKGZpbGVOYW1lKTtcbiAgICAgICAgICAgIG9uRmlsZVNlbGVjdGVkKGZpbGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRyYWdBbmREcm9wTWVzc2FnZSA9IHRoaXMuY3JlYXRlRHJhZ0FuZERyb3BNZXNzYWdlKCk7XG4gICAgICAgIHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbi5hcHBlbmRDaGlsZChkcmFnQW5kRHJvcE1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbnRlclwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICR0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUuYm9yZGVyXG4gICAgICAgICAgICAgICAgPSAkdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uQWN0aXZlQm9yZGVyKCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdsZWF2ZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICR0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUuYm9yZGVyXG4gICAgICAgICAgICAgICAgPSAkdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uRGVmYXVsdEJvcmRlcigpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICR0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUuYm9yZGVyXG4gICAgICAgICAgICAgICAgPSAkdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uQWN0aXZlQm9yZGVyKCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAkdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uLnN0eWxlLmJvcmRlclxuICAgICAgICAgICAgICAgID0gJHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbkRlZmF1bHRCb3JkZXIoKTtcbiAgICAgICAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBldmVudC5kYXRhVHJhbnNmZXI7XG4gICAgICAgICAgICBpZiAoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVzID0gZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgICAgICAgICAgICAgIGlmICghZmlsZXMgfHwgZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGlzQW55RmlsZUltYWdlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IGZpbGVzLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlVHlwZSA9IC9pbWFnZS4qLztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlLnR5cGUubWF0Y2goaW1hZ2VUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNBbnlGaWxlSW1hZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBmaWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnNldEltYWdlTmFtZVRvQnV0dG9uKGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgb25GaWxlU2VsZWN0ZWQoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdBbmREcm9wTWVzc2FnZS5pbm5lclRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgID0gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5kcmFnQW5kRHJvcE1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNBbnlGaWxlSW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0FuZERyb3BNZXNzYWdlLmlubmVyVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRyYWdBbmREcm9wTWVzc2FnZU9ubHlJbWFnZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBGaWxlU2VsZWN0aW9uVWkucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbnB1dC5kaXNhYmxlZCA9IHRydWU7XG4gICAgfTtcbiAgICBGaWxlU2VsZWN0aW9uVWkucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB0aGlzLmZpbGVTY2FuSW5wdXQuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIEZpbGVTZWxlY3Rpb25VaS5wcm90b3R5cGUuaXNTaG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uLnN0eWxlLmRpc3BsYXkgPT09IFwiYmxvY2tcIjtcbiAgICB9O1xuICAgIEZpbGVTZWxlY3Rpb25VaS5wcm90b3R5cGUucmVzZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5maWxlU2NhbklucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5zZXRJbml0aWFsVmFsdWVUb0J1dHRvbigpO1xuICAgIH07XG4gICAgRmlsZVNlbGVjdGlvblVpLnByb3RvdHlwZS5jcmVhdGVGaWxlQmFzZWRTY2FuUmVnaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmlsZUJhc2VkU2NhblJlZ2lvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS5tYXJnaW4gPSBcImF1dG9cIjtcbiAgICAgICAgZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS53aWR0aCA9IFwiODAlXCI7XG4gICAgICAgIGZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUubWF4V2lkdGggPSBcIjYwMHB4XCI7XG4gICAgICAgIGZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUuYm9yZGVyXG4gICAgICAgICAgICA9IHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbkRlZmF1bHRCb3JkZXIoKTtcbiAgICAgICAgZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS5wYWRkaW5nID0gXCIxMHB4XCI7XG4gICAgICAgIGZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUubWFyZ2luQm90dG9tID0gXCIxMHB4XCI7XG4gICAgICAgIHJldHVybiBmaWxlQmFzZWRTY2FuUmVnaW9uO1xuICAgIH07XG4gICAgRmlsZVNlbGVjdGlvblVpLnByb3RvdHlwZS5maWxlQmFzZWRTY2FuUmVnaW9uRGVmYXVsdEJvcmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiNnB4IGRhc2hlZCAjZWJlYmViXCI7XG4gICAgfTtcbiAgICBGaWxlU2VsZWN0aW9uVWkucHJvdG90eXBlLmZpbGVCYXNlZFNjYW5SZWdpb25BY3RpdmVCb3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIjZweCBkYXNoZWQgcmdiKDE1MyAxNTEgMTUxKVwiO1xuICAgIH07XG4gICAgRmlsZVNlbGVjdGlvblVpLnByb3RvdHlwZS5jcmVhdGVEcmFnQW5kRHJvcE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkcmFnQW5kRHJvcE1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkcmFnQW5kRHJvcE1lc3NhZ2UuaW5uZXJUZXh0XG4gICAgICAgICAgICA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuZHJhZ0FuZERyb3BNZXNzYWdlKCk7XG4gICAgICAgIGRyYWdBbmREcm9wTWVzc2FnZS5zdHlsZS5mb250V2VpZ2h0ID0gXCI0MDBcIjtcbiAgICAgICAgcmV0dXJuIGRyYWdBbmREcm9wTWVzc2FnZTtcbiAgICB9O1xuICAgIEZpbGVTZWxlY3Rpb25VaS5wcm90b3R5cGUuc2V0SW1hZ2VOYW1lVG9CdXR0b24gPSBmdW5jdGlvbiAoaW1hZ2VGaWxlTmFtZSkge1xuICAgICAgICB2YXIgTUFYX0NIQVJTID0gMjA7XG4gICAgICAgIGlmIChpbWFnZUZpbGVOYW1lLmxlbmd0aCA+IE1BWF9DSEFSUykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0OENoYXJzID0gaW1hZ2VGaWxlTmFtZS5zdWJzdHJpbmcoMCwgOCk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSBpbWFnZUZpbGVOYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBsYXN0OENoYXJzID0gaW1hZ2VGaWxlTmFtZS5zdWJzdHJpbmcobGVuZ3RoXzEgLSA4LCBsZW5ndGhfMSk7XG4gICAgICAgICAgICBpbWFnZUZpbGVOYW1lID0gXCJcIi5jb25jYXQoc3RhcnQ4Q2hhcnMsIFwiLi4uLlwiKS5jb25jYXQobGFzdDhDaGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1RleHQgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmZpbGVTZWxlY3Rpb25DaG9vc2VBbm90aGVyKClcbiAgICAgICAgICAgICsgXCIgLSBcIlxuICAgICAgICAgICAgKyBpbWFnZUZpbGVOYW1lO1xuICAgICAgICB0aGlzLmZpbGVTZWxlY3Rpb25CdXR0b24uaW5uZXJUZXh0ID0gbmV3VGV4dDtcbiAgICB9O1xuICAgIEZpbGVTZWxlY3Rpb25VaS5wcm90b3R5cGUuc2V0SW5pdGlhbFZhbHVlVG9CdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbml0aWFsVGV4dCA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuZmlsZVNlbGVjdGlvbkNob29zZUltYWdlKClcbiAgICAgICAgICAgICsgXCIgLSBcIlxuICAgICAgICAgICAgKyBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmZpbGVTZWxlY3Rpb25Ob0ltYWdlU2VsZWN0ZWQoKTtcbiAgICAgICAgdGhpcy5maWxlU2VsZWN0aW9uQnV0dG9uLmlubmVyVGV4dCA9IGluaXRpYWxUZXh0O1xuICAgIH07XG4gICAgRmlsZVNlbGVjdGlvblVpLnByb3RvdHlwZS5nZXRGaWxlU2NhbklucHV0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcImh0bWw1LXFyY29kZS1wcml2YXRlLWZpbGVzY2FuLWlucHV0XCI7XG4gICAgfTtcbiAgICBGaWxlU2VsZWN0aW9uVWkuY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIHNob3dPblJlbmRlciwgb25GaWxlU2VsZWN0ZWQpIHtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IG5ldyBGaWxlU2VsZWN0aW9uVWkocGFyZW50RWxlbWVudCwgc2hvd09uUmVuZGVyLCBvbkZpbGVTZWxlY3RlZCk7XG4gICAgICAgIHJldHVybiBidXR0b247XG4gICAgfTtcbiAgICByZXR1cm4gRmlsZVNlbGVjdGlvblVpO1xufSgpKTtcbmV4cG9ydCB7IEZpbGVTZWxlY3Rpb25VaSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZS1zZWxlY3Rpb24tdWkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/ui/scanner/file-selection-ui.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/ui/scanner/scan-type-selector.js":
/*!************************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/ui/scanner/scan-type-selector.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScanTypeSelector: function() { return /* binding */ ScanTypeSelector; }\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ \"./node_modules/html5-qrcode/esm/core.js\");\n\nvar ScanTypeSelector = (function () {\n    function ScanTypeSelector(supportedScanTypes) {\n        this.supportedScanTypes = this.validateAndReturnScanTypes(supportedScanTypes);\n    }\n    ScanTypeSelector.prototype.getDefaultScanType = function () {\n        return this.supportedScanTypes[0];\n    };\n    ScanTypeSelector.prototype.hasMoreThanOneScanType = function () {\n        return this.supportedScanTypes.length > 1;\n    };\n    ScanTypeSelector.prototype.isCameraScanRequired = function () {\n        for (var _i = 0, _a = this.supportedScanTypes; _i < _a.length; _i++) {\n            var scanType = _a[_i];\n            if (ScanTypeSelector.isCameraScanType(scanType)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    ScanTypeSelector.isCameraScanType = function (scanType) {\n        return scanType === _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScanType.SCAN_TYPE_CAMERA;\n    };\n    ScanTypeSelector.isFileScanType = function (scanType) {\n        return scanType === _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScanType.SCAN_TYPE_FILE;\n    };\n    ScanTypeSelector.prototype.validateAndReturnScanTypes = function (supportedScanTypes) {\n        if (!supportedScanTypes || supportedScanTypes.length === 0) {\n            return _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE;\n        }\n        var maxExpectedValues = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE.length;\n        if (supportedScanTypes.length > maxExpectedValues) {\n            throw \"Max \".concat(maxExpectedValues, \" values expected for \")\n                + \"supportedScanTypes\";\n        }\n        for (var _i = 0, supportedScanTypes_1 = supportedScanTypes; _i < supportedScanTypes_1.length; _i++) {\n            var scanType = supportedScanTypes_1[_i];\n            if (!_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE\n                .includes(scanType)) {\n                throw \"Unsupported scan type \".concat(scanType);\n            }\n        }\n        return supportedScanTypes;\n    };\n    return ScanTypeSelector;\n}());\n\n//# sourceMappingURL=scan-type-selector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL3NjYW4tdHlwZS1zZWxlY3Rvci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFtQjtBQUMvQztBQUNBO0FBQ0EsNEJBQTRCLHNEQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdURBQW9CO0FBQ3ZDO0FBQ0EsZ0NBQWdDLHVEQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxrQ0FBa0M7QUFDdEc7QUFDQSxpQkFBaUIsdURBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMyQjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL3NjYW4tdHlwZS1zZWxlY3Rvci5qcz9iMzRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEh0bWw1UXJjb2RlU2NhblR5cGUsIEh0bWw1UXJjb2RlQ29uc3RhbnRzIH0gZnJvbSBcIi4uLy4uL2NvcmVcIjtcbnZhciBTY2FuVHlwZVNlbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2FuVHlwZVNlbGVjdG9yKHN1cHBvcnRlZFNjYW5UeXBlcykge1xuICAgICAgICB0aGlzLnN1cHBvcnRlZFNjYW5UeXBlcyA9IHRoaXMudmFsaWRhdGVBbmRSZXR1cm5TY2FuVHlwZXMoc3VwcG9ydGVkU2NhblR5cGVzKTtcbiAgICB9XG4gICAgU2NhblR5cGVTZWxlY3Rvci5wcm90b3R5cGUuZ2V0RGVmYXVsdFNjYW5UeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBwb3J0ZWRTY2FuVHlwZXNbMF07XG4gICAgfTtcbiAgICBTY2FuVHlwZVNlbGVjdG9yLnByb3RvdHlwZS5oYXNNb3JlVGhhbk9uZVNjYW5UeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBwb3J0ZWRTY2FuVHlwZXMubGVuZ3RoID4gMTtcbiAgICB9O1xuICAgIFNjYW5UeXBlU2VsZWN0b3IucHJvdG90eXBlLmlzQ2FtZXJhU2NhblJlcXVpcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zdXBwb3J0ZWRTY2FuVHlwZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2NhblR5cGUgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAoU2NhblR5cGVTZWxlY3Rvci5pc0NhbWVyYVNjYW5UeXBlKHNjYW5UeXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNjYW5UeXBlU2VsZWN0b3IuaXNDYW1lcmFTY2FuVHlwZSA9IGZ1bmN0aW9uIChzY2FuVHlwZSkge1xuICAgICAgICByZXR1cm4gc2NhblR5cGUgPT09IEh0bWw1UXJjb2RlU2NhblR5cGUuU0NBTl9UWVBFX0NBTUVSQTtcbiAgICB9O1xuICAgIFNjYW5UeXBlU2VsZWN0b3IuaXNGaWxlU2NhblR5cGUgPSBmdW5jdGlvbiAoc2NhblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHNjYW5UeXBlID09PSBIdG1sNVFyY29kZVNjYW5UeXBlLlNDQU5fVFlQRV9GSUxFO1xuICAgIH07XG4gICAgU2NhblR5cGVTZWxlY3Rvci5wcm90b3R5cGUudmFsaWRhdGVBbmRSZXR1cm5TY2FuVHlwZXMgPSBmdW5jdGlvbiAoc3VwcG9ydGVkU2NhblR5cGVzKSB7XG4gICAgICAgIGlmICghc3VwcG9ydGVkU2NhblR5cGVzIHx8IHN1cHBvcnRlZFNjYW5UeXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBIdG1sNVFyY29kZUNvbnN0YW50cy5ERUZBVUxUX1NVUFBPUlRFRF9TQ0FOX1RZUEU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heEV4cGVjdGVkVmFsdWVzID0gSHRtbDVRcmNvZGVDb25zdGFudHMuREVGQVVMVF9TVVBQT1JURURfU0NBTl9UWVBFLmxlbmd0aDtcbiAgICAgICAgaWYgKHN1cHBvcnRlZFNjYW5UeXBlcy5sZW5ndGggPiBtYXhFeHBlY3RlZFZhbHVlcykge1xuICAgICAgICAgICAgdGhyb3cgXCJNYXggXCIuY29uY2F0KG1heEV4cGVjdGVkVmFsdWVzLCBcIiB2YWx1ZXMgZXhwZWN0ZWQgZm9yIFwiKVxuICAgICAgICAgICAgICAgICsgXCJzdXBwb3J0ZWRTY2FuVHlwZXNcIjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHN1cHBvcnRlZFNjYW5UeXBlc18xID0gc3VwcG9ydGVkU2NhblR5cGVzOyBfaSA8IHN1cHBvcnRlZFNjYW5UeXBlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNjYW5UeXBlID0gc3VwcG9ydGVkU2NhblR5cGVzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKCFIdG1sNVFyY29kZUNvbnN0YW50cy5ERUZBVUxUX1NVUFBPUlRFRF9TQ0FOX1RZUEVcbiAgICAgICAgICAgICAgICAuaW5jbHVkZXMoc2NhblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJVbnN1cHBvcnRlZCBzY2FuIHR5cGUgXCIuY29uY2F0KHNjYW5UeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwcG9ydGVkU2NhblR5cGVzO1xuICAgIH07XG4gICAgcmV0dXJuIFNjYW5UeXBlU2VsZWN0b3I7XG59KCkpO1xuZXhwb3J0IHsgU2NhblR5cGVTZWxlY3RvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nhbi10eXBlLXNlbGVjdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/ui/scanner/scan-type-selector.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/ui/scanner/torch-button.js":
/*!******************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/ui/scanner/torch-button.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TorchButton: function() { return /* binding */ TorchButton; }\n/* harmony export */ });\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../strings */ \"./node_modules/html5-qrcode/esm/strings.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"./node_modules/html5-qrcode/esm/ui/scanner/base.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\nvar TorchController = (function () {\n    function TorchController(torchCapability, buttonController, onTorchActionFailureCallback) {\n        this.isTorchOn = false;\n        this.torchCapability = torchCapability;\n        this.buttonController = buttonController;\n        this.onTorchActionFailureCallback = onTorchActionFailureCallback;\n    }\n    TorchController.prototype.isTorchEnabled = function () {\n        return this.isTorchOn;\n    };\n    TorchController.prototype.flipState = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var isTorchOnExpected, error_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.buttonController.disable();\n                        isTorchOnExpected = !this.isTorchOn;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4, this.torchCapability.apply(isTorchOnExpected)];\n                    case 2:\n                        _a.sent();\n                        this.updateUiBasedOnLatestSettings(this.torchCapability.value(), isTorchOnExpected);\n                        return [3, 4];\n                    case 3:\n                        error_1 = _a.sent();\n                        this.propagateFailure(isTorchOnExpected, error_1);\n                        this.buttonController.enable();\n                        return [3, 4];\n                    case 4: return [2];\n                }\n            });\n        });\n    };\n    TorchController.prototype.updateUiBasedOnLatestSettings = function (isTorchOn, isTorchOnExpected) {\n        if (isTorchOn === isTorchOnExpected) {\n            this.buttonController.setText(isTorchOnExpected\n                ? _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOffButton()\n                : _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOnButton());\n            this.isTorchOn = isTorchOnExpected;\n        }\n        else {\n            this.propagateFailure(isTorchOnExpected);\n        }\n        this.buttonController.enable();\n    };\n    TorchController.prototype.propagateFailure = function (isTorchOnExpected, error) {\n        var errorMessage = isTorchOnExpected\n            ? _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOnFailedMessage()\n            : _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOffFailedMessage();\n        if (error) {\n            errorMessage += \"; Error = \" + error;\n        }\n        this.onTorchActionFailureCallback(errorMessage);\n    };\n    TorchController.prototype.reset = function () {\n        this.isTorchOn = false;\n    };\n    return TorchController;\n}());\nvar TorchButton = (function () {\n    function TorchButton(torchCapability, onTorchActionFailureCallback) {\n        this.onTorchActionFailureCallback = onTorchActionFailureCallback;\n        this.torchButton\n            = _base__WEBPACK_IMPORTED_MODULE_1__.BaseUiElementFactory.createElement(\"button\", _base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.TORCH_BUTTON_ID);\n        this.torchController = new TorchController(torchCapability, this, onTorchActionFailureCallback);\n    }\n    TorchButton.prototype.render = function (parentElement, torchButtonOptions) {\n        var _this = this;\n        this.torchButton.innerText\n            = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOnButton();\n        this.torchButton.style.display = torchButtonOptions.display;\n        this.torchButton.style.marginLeft = torchButtonOptions.marginLeft;\n        var $this = this;\n        this.torchButton.addEventListener(\"click\", function (_) { return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4, $this.torchController.flipState()];\n                    case 1:\n                        _a.sent();\n                        if ($this.torchController.isTorchEnabled()) {\n                            $this.torchButton.classList.remove(_base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_OFF);\n                            $this.torchButton.classList.add(_base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_ON);\n                        }\n                        else {\n                            $this.torchButton.classList.remove(_base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_ON);\n                            $this.torchButton.classList.add(_base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_OFF);\n                        }\n                        return [2];\n                }\n            });\n        }); });\n        parentElement.appendChild(this.torchButton);\n    };\n    TorchButton.prototype.updateTorchCapability = function (torchCapability) {\n        this.torchController = new TorchController(torchCapability, this, this.onTorchActionFailureCallback);\n    };\n    TorchButton.prototype.getTorchButton = function () {\n        return this.torchButton;\n    };\n    TorchButton.prototype.hide = function () {\n        this.torchButton.style.display = \"none\";\n    };\n    TorchButton.prototype.show = function () {\n        this.torchButton.style.display = \"inline-block\";\n    };\n    TorchButton.prototype.disable = function () {\n        this.torchButton.disabled = true;\n    };\n    TorchButton.prototype.enable = function () {\n        this.torchButton.disabled = false;\n    };\n    TorchButton.prototype.setText = function (text) {\n        this.torchButton.innerText = text;\n    };\n    TorchButton.prototype.reset = function () {\n        this.torchButton.innerText = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOnButton();\n        this.torchController.reset();\n    };\n    TorchButton.create = function (parentElement, torchCapability, torchButtonOptions, onTorchActionFailureCallback) {\n        var button = new TorchButton(torchCapability, onTorchActionFailureCallback);\n        button.render(parentElement, torchButtonOptions);\n        return button;\n    };\n    return TorchButton;\n}());\n\n//# sourceMappingURL=torch-button.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL3RvcmNoLWJ1dHRvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsU0FBSSxJQUFJLFNBQUk7QUFDL0IsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUMwRDtBQUNpQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtEQUF5QjtBQUMzQyxrQkFBa0IsK0RBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0RBQXlCO0FBQ3ZDLGNBQWMsK0RBQXlCO0FBQ3ZDO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1REFBb0IseUJBQXlCLDhEQUEyQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw4REFBMkI7QUFDMUYsNERBQTRELDhEQUEyQjtBQUN2RjtBQUNBO0FBQ0EsK0RBQStELDhEQUEyQjtBQUMxRiw0REFBNEQsOERBQTJCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0RBQXlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3NCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL3VpL3NjYW5uZXIvdG9yY2gtYnV0dG9uLmpzP2E5YmUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuaW1wb3J0IHsgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncyB9IGZyb20gXCIuLi8uLi9zdHJpbmdzXCI7XG5pbXBvcnQgeyBCYXNlVWlFbGVtZW50RmFjdG9yeSwgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzIH0gZnJvbSBcIi4vYmFzZVwiO1xudmFyIFRvcmNoQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9yY2hDb250cm9sbGVyKHRvcmNoQ2FwYWJpbGl0eSwgYnV0dG9uQ29udHJvbGxlciwgb25Ub3JjaEFjdGlvbkZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgICB0aGlzLmlzVG9yY2hPbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvcmNoQ2FwYWJpbGl0eSA9IHRvcmNoQ2FwYWJpbGl0eTtcbiAgICAgICAgdGhpcy5idXR0b25Db250cm9sbGVyID0gYnV0dG9uQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5vblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrID0gb25Ub3JjaEFjdGlvbkZhaWx1cmVDYWxsYmFjaztcbiAgICB9XG4gICAgVG9yY2hDb250cm9sbGVyLnByb3RvdHlwZS5pc1RvcmNoRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNUb3JjaE9uO1xuICAgIH07XG4gICAgVG9yY2hDb250cm9sbGVyLnByb3RvdHlwZS5mbGlwU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpc1RvcmNoT25FeHBlY3RlZCwgZXJyb3JfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uQ29udHJvbGxlci5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RvcmNoT25FeHBlY3RlZCA9ICF0aGlzLmlzVG9yY2hPbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy50b3JjaENhcGFiaWxpdHkuYXBwbHkoaXNUb3JjaE9uRXhwZWN0ZWQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVVaUJhc2VkT25MYXRlc3RTZXR0aW5ncyh0aGlzLnRvcmNoQ2FwYWJpbGl0eS52YWx1ZSgpLCBpc1RvcmNoT25FeHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVGYWlsdXJlKGlzVG9yY2hPbkV4cGVjdGVkLCBlcnJvcl8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uQ29udHJvbGxlci5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUb3JjaENvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZVVpQmFzZWRPbkxhdGVzdFNldHRpbmdzID0gZnVuY3Rpb24gKGlzVG9yY2hPbiwgaXNUb3JjaE9uRXhwZWN0ZWQpIHtcbiAgICAgICAgaWYgKGlzVG9yY2hPbiA9PT0gaXNUb3JjaE9uRXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uQ29udHJvbGxlci5zZXRUZXh0KGlzVG9yY2hPbkV4cGVjdGVkXG4gICAgICAgICAgICAgICAgPyBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnRvcmNoT2ZmQnV0dG9uKClcbiAgICAgICAgICAgICAgICA6IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MudG9yY2hPbkJ1dHRvbigpKTtcbiAgICAgICAgICAgIHRoaXMuaXNUb3JjaE9uID0gaXNUb3JjaE9uRXhwZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZUZhaWx1cmUoaXNUb3JjaE9uRXhwZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnV0dG9uQ29udHJvbGxlci5lbmFibGUoKTtcbiAgICB9O1xuICAgIFRvcmNoQ29udHJvbGxlci5wcm90b3R5cGUucHJvcGFnYXRlRmFpbHVyZSA9IGZ1bmN0aW9uIChpc1RvcmNoT25FeHBlY3RlZCwgZXJyb3IpIHtcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGlzVG9yY2hPbkV4cGVjdGVkXG4gICAgICAgICAgICA/IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MudG9yY2hPbkZhaWxlZE1lc3NhZ2UoKVxuICAgICAgICAgICAgOiBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnRvcmNoT2ZmRmFpbGVkTWVzc2FnZSgpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBcIjsgRXJyb3IgPSBcIiArIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Ub3JjaEFjdGlvbkZhaWx1cmVDYWxsYmFjayhlcnJvck1lc3NhZ2UpO1xuICAgIH07XG4gICAgVG9yY2hDb250cm9sbGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc1RvcmNoT24gPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBUb3JjaENvbnRyb2xsZXI7XG59KCkpO1xudmFyIFRvcmNoQnV0dG9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb3JjaEJ1dHRvbih0b3JjaENhcGFiaWxpdHksIG9uVG9yY2hBY3Rpb25GYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrID0gb25Ub3JjaEFjdGlvbkZhaWx1cmVDYWxsYmFjaztcbiAgICAgICAgdGhpcy50b3JjaEJ1dHRvblxuICAgICAgICAgICAgPSBCYXNlVWlFbGVtZW50RmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5UT1JDSF9CVVRUT05fSUQpO1xuICAgICAgICB0aGlzLnRvcmNoQ29udHJvbGxlciA9IG5ldyBUb3JjaENvbnRyb2xsZXIodG9yY2hDYXBhYmlsaXR5LCB0aGlzLCBvblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrKTtcbiAgICB9XG4gICAgVG9yY2hCdXR0b24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCB0b3JjaEJ1dHRvbk9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50b3JjaEJ1dHRvbi5pbm5lclRleHRcbiAgICAgICAgICAgID0gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy50b3JjaE9uQnV0dG9uKCk7XG4gICAgICAgIHRoaXMudG9yY2hCdXR0b24uc3R5bGUuZGlzcGxheSA9IHRvcmNoQnV0dG9uT3B0aW9ucy5kaXNwbGF5O1xuICAgICAgICB0aGlzLnRvcmNoQnV0dG9uLnN0eWxlLm1hcmdpbkxlZnQgPSB0b3JjaEJ1dHRvbk9wdGlvbnMubWFyZ2luTGVmdDtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50b3JjaEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCAkdGhpcy50b3JjaENvbnRyb2xsZXIuZmxpcFN0YXRlKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHRoaXMudG9yY2hDb250cm9sbGVyLmlzVG9yY2hFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50b3JjaEJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5UT1JDSF9CVVRUT05fQ0xBU1NfVE9SQ0hfT0ZGKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50b3JjaEJ1dHRvbi5jbGFzc0xpc3QuYWRkKFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5UT1JDSF9CVVRUT05fQ0xBU1NfVE9SQ0hfT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudG9yY2hCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuVE9SQ0hfQlVUVE9OX0NMQVNTX1RPUkNIX09OKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50b3JjaEJ1dHRvbi5jbGFzc0xpc3QuYWRkKFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5UT1JDSF9CVVRUT05fQ0xBU1NfVE9SQ0hfT0ZGKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnRvcmNoQnV0dG9uKTtcbiAgICB9O1xuICAgIFRvcmNoQnV0dG9uLnByb3RvdHlwZS51cGRhdGVUb3JjaENhcGFiaWxpdHkgPSBmdW5jdGlvbiAodG9yY2hDYXBhYmlsaXR5KSB7XG4gICAgICAgIHRoaXMudG9yY2hDb250cm9sbGVyID0gbmV3IFRvcmNoQ29udHJvbGxlcih0b3JjaENhcGFiaWxpdHksIHRoaXMsIHRoaXMub25Ub3JjaEFjdGlvbkZhaWx1cmVDYWxsYmFjayk7XG4gICAgfTtcbiAgICBUb3JjaEJ1dHRvbi5wcm90b3R5cGUuZ2V0VG9yY2hCdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvcmNoQnV0dG9uO1xuICAgIH07XG4gICAgVG9yY2hCdXR0b24ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudG9yY2hCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH07XG4gICAgVG9yY2hCdXR0b24ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudG9yY2hCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgfTtcbiAgICBUb3JjaEJ1dHRvbi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b3JjaEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgfTtcbiAgICBUb3JjaEJ1dHRvbi5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRvcmNoQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICBUb3JjaEJ1dHRvbi5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHRoaXMudG9yY2hCdXR0b24uaW5uZXJUZXh0ID0gdGV4dDtcbiAgICB9O1xuICAgIFRvcmNoQnV0dG9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b3JjaEJ1dHRvbi5pbm5lclRleHQgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnRvcmNoT25CdXR0b24oKTtcbiAgICAgICAgdGhpcy50b3JjaENvbnRyb2xsZXIucmVzZXQoKTtcbiAgICB9O1xuICAgIFRvcmNoQnV0dG9uLmNyZWF0ZSA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCB0b3JjaENhcGFiaWxpdHksIHRvcmNoQnV0dG9uT3B0aW9ucywgb25Ub3JjaEFjdGlvbkZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgICB2YXIgYnV0dG9uID0gbmV3IFRvcmNoQnV0dG9uKHRvcmNoQ2FwYWJpbGl0eSwgb25Ub3JjaEFjdGlvbkZhaWx1cmVDYWxsYmFjayk7XG4gICAgICAgIGJ1dHRvbi5yZW5kZXIocGFyZW50RWxlbWVudCwgdG9yY2hCdXR0b25PcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9O1xuICAgIHJldHVybiBUb3JjaEJ1dHRvbjtcbn0oKSk7XG5leHBvcnQgeyBUb3JjaEJ1dHRvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9yY2gtYnV0dG9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/ui/scanner/torch-button.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/utils.js":
/*!************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/utils.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VideoConstraintsUtil: function() { return /* binding */ VideoConstraintsUtil; }\n/* harmony export */ });\nvar VideoConstraintsUtil = (function () {\n    function VideoConstraintsUtil() {\n    }\n    VideoConstraintsUtil.isMediaStreamConstraintsValid = function (videoConstraints, logger) {\n        if (typeof videoConstraints !== \"object\") {\n            var typeofVideoConstraints = typeof videoConstraints;\n            logger.logError(\"videoConstraints should be of type object, the \"\n                + \"object passed is of type \".concat(typeofVideoConstraints, \".\"), true);\n            return false;\n        }\n        var bannedKeys = [\n            \"autoGainControl\",\n            \"channelCount\",\n            \"echoCancellation\",\n            \"latency\",\n            \"noiseSuppression\",\n            \"sampleRate\",\n            \"sampleSize\",\n            \"volume\"\n        ];\n        var bannedkeysSet = new Set(bannedKeys);\n        var keysInVideoConstraints = Object.keys(videoConstraints);\n        for (var _i = 0, keysInVideoConstraints_1 = keysInVideoConstraints; _i < keysInVideoConstraints_1.length; _i++) {\n            var key = keysInVideoConstraints_1[_i];\n            if (bannedkeysSet.has(key)) {\n                logger.logError(\"\".concat(key, \" is not supported videoConstaints.\"), true);\n                return false;\n            }\n        }\n        return true;\n    };\n    return VideoConstraintsUtil;\n}());\n\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsc0NBQXNDO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDK0I7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vdXRpbHMuanM/OTM2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVmlkZW9Db25zdHJhaW50c1V0aWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZGVvQ29uc3RyYWludHNVdGlsKCkge1xuICAgIH1cbiAgICBWaWRlb0NvbnN0cmFpbnRzVXRpbC5pc01lZGlhU3RyZWFtQ29uc3RyYWludHNWYWxpZCA9IGZ1bmN0aW9uICh2aWRlb0NvbnN0cmFpbnRzLCBsb2dnZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB2YXIgdHlwZW9mVmlkZW9Db25zdHJhaW50cyA9IHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZ0Vycm9yKFwidmlkZW9Db25zdHJhaW50cyBzaG91bGQgYmUgb2YgdHlwZSBvYmplY3QsIHRoZSBcIlxuICAgICAgICAgICAgICAgICsgXCJvYmplY3QgcGFzc2VkIGlzIG9mIHR5cGUgXCIuY29uY2F0KHR5cGVvZlZpZGVvQ29uc3RyYWludHMsIFwiLlwiKSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhbm5lZEtleXMgPSBbXG4gICAgICAgICAgICBcImF1dG9HYWluQ29udHJvbFwiLFxuICAgICAgICAgICAgXCJjaGFubmVsQ291bnRcIixcbiAgICAgICAgICAgIFwiZWNob0NhbmNlbGxhdGlvblwiLFxuICAgICAgICAgICAgXCJsYXRlbmN5XCIsXG4gICAgICAgICAgICBcIm5vaXNlU3VwcHJlc3Npb25cIixcbiAgICAgICAgICAgIFwic2FtcGxlUmF0ZVwiLFxuICAgICAgICAgICAgXCJzYW1wbGVTaXplXCIsXG4gICAgICAgICAgICBcInZvbHVtZVwiXG4gICAgICAgIF07XG4gICAgICAgIHZhciBiYW5uZWRrZXlzU2V0ID0gbmV3IFNldChiYW5uZWRLZXlzKTtcbiAgICAgICAgdmFyIGtleXNJblZpZGVvQ29uc3RyYWludHMgPSBPYmplY3Qua2V5cyh2aWRlb0NvbnN0cmFpbnRzKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBrZXlzSW5WaWRlb0NvbnN0cmFpbnRzXzEgPSBrZXlzSW5WaWRlb0NvbnN0cmFpbnRzOyBfaSA8IGtleXNJblZpZGVvQ29uc3RyYWludHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzSW5WaWRlb0NvbnN0cmFpbnRzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKGJhbm5lZGtleXNTZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nRXJyb3IoXCJcIi5jb25jYXQoa2V5LCBcIiBpcyBub3Qgc3VwcG9ydGVkIHZpZGVvQ29uc3RhaW50cy5cIiksIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBWaWRlb0NvbnN0cmFpbnRzVXRpbDtcbn0oKSk7XG5leHBvcnQgeyBWaWRlb0NvbnN0cmFpbnRzVXRpbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/utils.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/esm/zxing-html5-qrcode-decoder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/html5-qrcode/esm/zxing-html5-qrcode-decoder.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZXingHtml5QrcodeDecoder: function() { return /* binding */ ZXingHtml5QrcodeDecoder; }\n/* harmony export */ });\n/* harmony import */ var _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../third_party/zxing-js.umd */ \"./node_modules/html5-qrcode/third_party/zxing-js.umd.js\");\n/* harmony import */ var _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core */ \"./node_modules/html5-qrcode/esm/core.js\");\n\n\nvar ZXingHtml5QrcodeDecoder = (function () {\n    function ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger) {\n        this.formatMap = new Map([\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.QR_CODE, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.QR_CODE],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.AZTEC, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.AZTEC],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.CODABAR, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.CODABAR],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.CODE_39, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.CODE_39],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.CODE_93, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.CODE_93],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.CODE_128,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.CODE_128\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.DATA_MATRIX,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.DATA_MATRIX\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.MAXICODE,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.MAXICODE\n            ],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.ITF, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.ITF],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.EAN_13, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.EAN_13],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.EAN_8, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.EAN_8],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.PDF_417, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.PDF_417],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.RSS_14, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.RSS_14],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.RSS_EXPANDED,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.RSS_EXPANDED\n            ],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.UPC_A, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.UPC_A],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.UPC_E, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.UPC_E],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.UPC_EAN_EXTENSION\n            ]\n        ]);\n        this.reverseFormatMap = this.createReverseFormatMap();\n        if (!_third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__) {\n            throw \"Use html5qrcode.min.js without edit, ZXing not found.\";\n        }\n        this.verbose = verbose;\n        this.logger = logger;\n        var formats = this.createZXingFormats(requestedFormats);\n        var hints = new Map();\n        hints.set(_third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.DecodeHintType.POSSIBLE_FORMATS, formats);\n        hints.set(_third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.DecodeHintType.TRY_HARDER, false);\n        this.hints = hints;\n    }\n    ZXingHtml5QrcodeDecoder.prototype.decodeAsync = function (canvas) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            try {\n                resolve(_this.decode(canvas));\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    };\n    ZXingHtml5QrcodeDecoder.prototype.decode = function (canvas) {\n        var zxingDecoder = new _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.MultiFormatReader(this.verbose, this.hints);\n        var luminanceSource = new _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.HTMLCanvasElementLuminanceSource(canvas);\n        var binaryBitmap = new _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BinaryBitmap(new _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.HybridBinarizer(luminanceSource));\n        var result = zxingDecoder.decode(binaryBitmap);\n        return {\n            text: result.text,\n            format: _core__WEBPACK_IMPORTED_MODULE_1__.QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(result.format)),\n            debugData: this.createDebugData()\n        };\n    };\n    ZXingHtml5QrcodeDecoder.prototype.createReverseFormatMap = function () {\n        var result = new Map();\n        this.formatMap.forEach(function (value, key, _) {\n            result.set(value, key);\n        });\n        return result;\n    };\n    ZXingHtml5QrcodeDecoder.prototype.toHtml5QrcodeSupportedFormats = function (zxingFormat) {\n        if (!this.reverseFormatMap.has(zxingFormat)) {\n            throw \"reverseFormatMap doesn't have \".concat(zxingFormat);\n        }\n        return this.reverseFormatMap.get(zxingFormat);\n    };\n    ZXingHtml5QrcodeDecoder.prototype.createZXingFormats = function (requestedFormats) {\n        var zxingFormats = [];\n        for (var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++) {\n            var requestedFormat = requestedFormats_1[_i];\n            if (this.formatMap.has(requestedFormat)) {\n                zxingFormats.push(this.formatMap.get(requestedFormat));\n            }\n            else {\n                this.logger.logError(\"\".concat(requestedFormat, \" is not supported by\")\n                    + \"ZXingHtml5QrcodeShim\");\n            }\n        }\n        return zxingFormats;\n    };\n    ZXingHtml5QrcodeDecoder.prototype.createDebugData = function () {\n        return { decoderName: \"zxing-js\" };\n    };\n    return ZXingHtml5QrcodeDecoder;\n}());\n\n//# sourceMappingURL=zxing-html5-qrcode-decoder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS96eGluZy1odG1sNS1xcmNvZGUtZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXFEO0FBQ29CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOERBQTJCLFVBQVUsb0VBQW1CO0FBQ3JFLGFBQWEsOERBQTJCLFFBQVEsb0VBQW1CO0FBQ25FLGFBQWEsOERBQTJCLFVBQVUsb0VBQW1CO0FBQ3JFLGFBQWEsOERBQTJCLFVBQVUsb0VBQW1CO0FBQ3JFLGFBQWEsOERBQTJCLFVBQVUsb0VBQW1CO0FBQ3JFO0FBQ0EsZ0JBQWdCLDhEQUEyQjtBQUMzQyxnQkFBZ0Isb0VBQW1CO0FBQ25DO0FBQ0E7QUFDQSxnQkFBZ0IsOERBQTJCO0FBQzNDLGdCQUFnQixvRUFBbUI7QUFDbkM7QUFDQTtBQUNBLGdCQUFnQiw4REFBMkI7QUFDM0MsZ0JBQWdCLG9FQUFtQjtBQUNuQztBQUNBLGFBQWEsOERBQTJCLE1BQU0sb0VBQW1CO0FBQ2pFLGFBQWEsOERBQTJCLFNBQVMsb0VBQW1CO0FBQ3BFLGFBQWEsOERBQTJCLFFBQVEsb0VBQW1CO0FBQ25FLGFBQWEsOERBQTJCLFVBQVUsb0VBQW1CO0FBQ3JFLGFBQWEsOERBQTJCLFNBQVMsb0VBQW1CO0FBQ3BFO0FBQ0EsZ0JBQWdCLDhEQUEyQjtBQUMzQyxnQkFBZ0Isb0VBQW1CO0FBQ25DO0FBQ0EsYUFBYSw4REFBMkIsUUFBUSxvRUFBbUI7QUFDbkUsYUFBYSw4REFBMkIsUUFBUSxvRUFBbUI7QUFDbkU7QUFDQSxnQkFBZ0IsOERBQTJCO0FBQzNDLGdCQUFnQixvRUFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUVBQW9CO0FBQ3RDLGtCQUFrQixxRUFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0JBQStCLHdFQUF1QjtBQUN0RCxrQ0FBa0MsdUZBQXNDO0FBQ3hFLCtCQUErQixtRUFBa0IsS0FBSyxzRUFBcUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnQ0FBZ0M7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxDQUFDO0FBQ2tDO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL3p4aW5nLWh0bWw1LXFyY29kZS1kZWNvZGVyLmpzP2M0ZjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgWlhpbmcgZnJvbSBcIi4uL3RoaXJkX3BhcnR5L3p4aW5nLWpzLnVtZFwiO1xuaW1wb3J0IHsgUXJjb2RlUmVzdWx0Rm9ybWF0LCBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMgfSBmcm9tIFwiLi9jb3JlXCI7XG52YXIgWlhpbmdIdG1sNVFyY29kZURlY29kZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFpYaW5nSHRtbDVRcmNvZGVEZWNvZGVyKHJlcXVlc3RlZEZvcm1hdHMsIHZlcmJvc2UsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLmZvcm1hdE1hcCA9IG5ldyBNYXAoW1xuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5RUl9DT0RFLCBaWGluZy5CYXJjb2RlRm9ybWF0LlFSX0NPREVdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5BWlRFQywgWlhpbmcuQmFyY29kZUZvcm1hdC5BWlRFQ10sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREFCQVIsIFpYaW5nLkJhcmNvZGVGb3JtYXQuQ09EQUJBUl0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREVfMzksIFpYaW5nLkJhcmNvZGVGb3JtYXQuQ09ERV8zOV0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREVfOTMsIFpYaW5nLkJhcmNvZGVGb3JtYXQuQ09ERV85M10sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREVfMTI4LFxuICAgICAgICAgICAgICAgIFpYaW5nLkJhcmNvZGVGb3JtYXQuQ09ERV8xMjhcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkRBVEFfTUFUUklYLFxuICAgICAgICAgICAgICAgIFpYaW5nLkJhcmNvZGVGb3JtYXQuREFUQV9NQVRSSVhcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLk1BWElDT0RFLFxuICAgICAgICAgICAgICAgIFpYaW5nLkJhcmNvZGVGb3JtYXQuTUFYSUNPREVcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLklURiwgWlhpbmcuQmFyY29kZUZvcm1hdC5JVEZdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5FQU5fMTMsIFpYaW5nLkJhcmNvZGVGb3JtYXQuRUFOXzEzXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuRUFOXzgsIFpYaW5nLkJhcmNvZGVGb3JtYXQuRUFOXzhdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5QREZfNDE3LCBaWGluZy5CYXJjb2RlRm9ybWF0LlBERl80MTddLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5SU1NfMTQsIFpYaW5nLkJhcmNvZGVGb3JtYXQuUlNTXzE0XSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUlNTX0VYUEFOREVELFxuICAgICAgICAgICAgICAgIFpYaW5nLkJhcmNvZGVGb3JtYXQuUlNTX0VYUEFOREVEXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5VUENfQSwgWlhpbmcuQmFyY29kZUZvcm1hdC5VUENfQV0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19FLCBaWGluZy5CYXJjb2RlRm9ybWF0LlVQQ19FXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuVVBDX0VBTl9FWFRFTlNJT04sXG4gICAgICAgICAgICAgICAgWlhpbmcuQmFyY29kZUZvcm1hdC5VUENfRUFOX0VYVEVOU0lPTlxuICAgICAgICAgICAgXVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5yZXZlcnNlRm9ybWF0TWFwID0gdGhpcy5jcmVhdGVSZXZlcnNlRm9ybWF0TWFwKCk7XG4gICAgICAgIGlmICghWlhpbmcpIHtcbiAgICAgICAgICAgIHRocm93IFwiVXNlIGh0bWw1cXJjb2RlLm1pbi5qcyB3aXRob3V0IGVkaXQsIFpYaW5nIG5vdCBmb3VuZC5cIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcmJvc2UgPSB2ZXJib3NlO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgdmFyIGZvcm1hdHMgPSB0aGlzLmNyZWF0ZVpYaW5nRm9ybWF0cyhyZXF1ZXN0ZWRGb3JtYXRzKTtcbiAgICAgICAgdmFyIGhpbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBoaW50cy5zZXQoWlhpbmcuRGVjb2RlSGludFR5cGUuUE9TU0lCTEVfRk9STUFUUywgZm9ybWF0cyk7XG4gICAgICAgIGhpbnRzLnNldChaWGluZy5EZWNvZGVIaW50VHlwZS5UUllfSEFSREVSLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuaGludHMgPSBoaW50cztcbiAgICB9XG4gICAgWlhpbmdIdG1sNVFyY29kZURlY29kZXIucHJvdG90eXBlLmRlY29kZUFzeW5jID0gZnVuY3Rpb24gKGNhbnZhcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzLmRlY29kZShjYW52YXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgWlhpbmdIdG1sNVFyY29kZURlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgICAgdmFyIHp4aW5nRGVjb2RlciA9IG5ldyBaWGluZy5NdWx0aUZvcm1hdFJlYWRlcih0aGlzLnZlcmJvc2UsIHRoaXMuaGludHMpO1xuICAgICAgICB2YXIgbHVtaW5hbmNlU291cmNlID0gbmV3IFpYaW5nLkhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlKGNhbnZhcyk7XG4gICAgICAgIHZhciBiaW5hcnlCaXRtYXAgPSBuZXcgWlhpbmcuQmluYXJ5Qml0bWFwKG5ldyBaWGluZy5IeWJyaWRCaW5hcml6ZXIobHVtaW5hbmNlU291cmNlKSk7XG4gICAgICAgIHZhciByZXN1bHQgPSB6eGluZ0RlY29kZXIuZGVjb2RlKGJpbmFyeUJpdG1hcCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiByZXN1bHQudGV4dCxcbiAgICAgICAgICAgIGZvcm1hdDogUXJjb2RlUmVzdWx0Rm9ybWF0LmNyZWF0ZSh0aGlzLnRvSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzKHJlc3VsdC5mb3JtYXQpKSxcbiAgICAgICAgICAgIGRlYnVnRGF0YTogdGhpcy5jcmVhdGVEZWJ1Z0RhdGEoKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgWlhpbmdIdG1sNVFyY29kZURlY29kZXIucHJvdG90eXBlLmNyZWF0ZVJldmVyc2VGb3JtYXRNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZm9ybWF0TWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXksIF8pIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQodmFsdWUsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgWlhpbmdIdG1sNVFyY29kZURlY29kZXIucHJvdG90eXBlLnRvSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzID0gZnVuY3Rpb24gKHp4aW5nRm9ybWF0KSB7XG4gICAgICAgIGlmICghdGhpcy5yZXZlcnNlRm9ybWF0TWFwLmhhcyh6eGluZ0Zvcm1hdCkpIHtcbiAgICAgICAgICAgIHRocm93IFwicmV2ZXJzZUZvcm1hdE1hcCBkb2Vzbid0IGhhdmUgXCIuY29uY2F0KHp4aW5nRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlRm9ybWF0TWFwLmdldCh6eGluZ0Zvcm1hdCk7XG4gICAgfTtcbiAgICBaWGluZ0h0bWw1UXJjb2RlRGVjb2Rlci5wcm90b3R5cGUuY3JlYXRlWlhpbmdGb3JtYXRzID0gZnVuY3Rpb24gKHJlcXVlc3RlZEZvcm1hdHMpIHtcbiAgICAgICAgdmFyIHp4aW5nRm9ybWF0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHJlcXVlc3RlZEZvcm1hdHNfMSA9IHJlcXVlc3RlZEZvcm1hdHM7IF9pIDwgcmVxdWVzdGVkRm9ybWF0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RlZEZvcm1hdCA9IHJlcXVlc3RlZEZvcm1hdHNfMVtfaV07XG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtYXRNYXAuaGFzKHJlcXVlc3RlZEZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICB6eGluZ0Zvcm1hdHMucHVzaCh0aGlzLmZvcm1hdE1hcC5nZXQocmVxdWVzdGVkRm9ybWF0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2dFcnJvcihcIlwiLmNvbmNhdChyZXF1ZXN0ZWRGb3JtYXQsIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnlcIilcbiAgICAgICAgICAgICAgICAgICAgKyBcIlpYaW5nSHRtbDVRcmNvZGVTaGltXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB6eGluZ0Zvcm1hdHM7XG4gICAgfTtcbiAgICBaWGluZ0h0bWw1UXJjb2RlRGVjb2Rlci5wcm90b3R5cGUuY3JlYXRlRGVidWdEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBkZWNvZGVyTmFtZTogXCJ6eGluZy1qc1wiIH07XG4gICAgfTtcbiAgICByZXR1cm4gWlhpbmdIdG1sNVFyY29kZURlY29kZXI7XG59KCkpO1xuZXhwb3J0IHsgWlhpbmdIdG1sNVFyY29kZURlY29kZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXp4aW5nLWh0bWw1LXFyY29kZS1kZWNvZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/esm/zxing-html5-qrcode-decoder.js\n"));

/***/ }),

/***/ "./node_modules/html5-qrcode/third_party/zxing-js.umd.js":
/*!***************************************************************!*\
  !*** ./node_modules/html5-qrcode/third_party/zxing-js.umd.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (global, factory) {\n     true ? factory(exports) :\n    0;\n}(this, (function (exports) { 'use strict';\n\n    function isNullOrUndefined(obj) {\n        return obj === null || obj === undefined;\n    }\n\n    /*\n     * Copyright 2008 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /* global Reflect, Promise */\n\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\n    function __extends(d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }\n\n    function fixProto(target, prototype) {\n        var setPrototypeOf = Object.setPrototypeOf;\n        setPrototypeOf ? setPrototypeOf(target, prototype) : (target.__proto__ = prototype);\n    }\n\n    function fixStack(target, fn) {\n        if (fn === void 0) {\n            fn = target.constructor;\n        }\n        var captureStackTrace = Error.captureStackTrace;\n        captureStackTrace && captureStackTrace(target, fn);\n    }\n\n    var CustomError = (function (_super) {\n        __extends(CustomError, _super);\n        function CustomError(message) {\n            var _newTarget = this.constructor;\n            var _this = _super.call(this, message) || this;\n            Object.defineProperty(_this, 'name', {\n                value: _newTarget.name,\n                enumerable: false\n            });\n            fixProto(_this, _newTarget.prototype);\n            fixStack(_this);\n            return _this;\n        }\n        \n        return CustomError;\n    })(Error);\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class Exception extends CustomError {\n        /**\n         * Allows Exception to be constructed directly\n         * with some message and prototype definition.\n         */\n        constructor(message = undefined) {\n            super(message);\n            this.message = message;\n        }\n        getKind() {\n            const ex = this.constructor;\n            return ex.kind;\n        }\n    }\n    /**\n     * It's typed as string so it can be extended and overriden.\n     */\n    Exception.kind = 'Exception';\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class ArgumentException extends Exception {\n    }\n    ArgumentException.kind = 'ArgumentException';\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class IllegalArgumentException extends Exception {\n    }\n    IllegalArgumentException.kind = 'IllegalArgumentException';\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    class BinaryBitmap {\n        constructor(binarizer) {\n            this.binarizer = binarizer;\n            if (binarizer === null) {\n                throw new IllegalArgumentException('Binarizer must be non-null.');\n            }\n        }\n        /**\n         * @return The width of the bitmap.\n         */\n        getWidth() {\n            return this.binarizer.getWidth();\n        }\n        /**\n         * @return The height of the bitmap.\n         */\n        getHeight() {\n            return this.binarizer.getHeight();\n        }\n        /**\n         * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return\n         * cached data. Callers should assume this method is expensive and call it as seldom as possible.\n         * This method is intended for decoding 1D barcodes and may choose to apply sharpening.\n         *\n         * @param y The row to fetch, which must be in [0, bitmap height)\n         * @param row An optional preallocated array. If null or too small, it will be ignored.\n         *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.\n         * @return The array of bits for this row (true means black).\n         * @throws NotFoundException if row can't be binarized\n         */\n        getBlackRow(y /*int*/, row) {\n            return this.binarizer.getBlackRow(y, row);\n        }\n        /**\n         * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive\n         * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or\n         * may not apply sharpening. Therefore, a row from this matrix may not be identical to one\n         * fetched using getBlackRow(), so don't mix and match between them.\n         *\n         * @return The 2D array of bits for the image (true means black).\n         * @throws NotFoundException if image can't be binarized to make a matrix\n         */\n        getBlackMatrix() {\n            // The matrix is created on demand the first time it is requested, then cached. There are two\n            // reasons for this:\n            // 1. This work will never be done if the caller only installs 1D Reader objects, or if a\n            //    1D Reader finds a barcode before the 2D Readers run.\n            // 2. This work will only be done once even if the caller installs multiple 2D Readers.\n            if (this.matrix === null || this.matrix === undefined) {\n                this.matrix = this.binarizer.getBlackMatrix();\n            }\n            return this.matrix;\n        }\n        /**\n         * @return Whether this bitmap can be cropped.\n         */\n        isCropSupported() {\n            return this.binarizer.getLuminanceSource().isCropSupported();\n        }\n        /**\n         * Returns a new object with cropped image data. Implementations may keep a reference to the\n         * original data rather than a copy. Only callable if isCropSupported() is true.\n         *\n         * @param left The left coordinate, which must be in [0,getWidth())\n         * @param top The top coordinate, which must be in [0,getHeight())\n         * @param width The width of the rectangle to crop.\n         * @param height The height of the rectangle to crop.\n         * @return A cropped version of this object.\n         */\n        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n            const newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);\n            return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n        }\n        /**\n         * @return Whether this bitmap supports counter-clockwise rotation.\n         */\n        isRotateSupported() {\n            return this.binarizer.getLuminanceSource().isRotateSupported();\n        }\n        /**\n         * Returns a new object with rotated image data by 90 degrees counterclockwise.\n         * Only callable if {@link #isRotateSupported()} is true.\n         *\n         * @return A rotated version of this object.\n         */\n        rotateCounterClockwise() {\n            const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();\n            return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n        }\n        /**\n         * Returns a new object with rotated image data by 45 degrees counterclockwise.\n         * Only callable if {@link #isRotateSupported()} is true.\n         *\n         * @return A rotated version of this object.\n         */\n        rotateCounterClockwise45() {\n            const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();\n            return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n        }\n        /*@Override*/\n        toString() {\n            try {\n                return this.getBlackMatrix().toString();\n            }\n            catch (e /*: NotFoundException*/) {\n                return '';\n            }\n        }\n    }\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class ChecksumException extends Exception {\n        static getChecksumInstance() {\n            return new ChecksumException();\n        }\n    }\n    ChecksumException.kind = 'ChecksumException';\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * This class hierarchy provides a set of methods to convert luminance data to 1 bit data.\n     * It allows the algorithm to vary polymorphically, for example allowing a very expensive\n     * thresholding technique for servers and a fast one for mobile. It also permits the implementation\n     * to vary, e.g. a JNI version for Android and a Java fallback version for other platforms.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class Binarizer {\n        constructor(source) {\n            this.source = source;\n        }\n        getLuminanceSource() {\n            return this.source;\n        }\n        getWidth() {\n            return this.source.getWidth();\n        }\n        getHeight() {\n            return this.source.getHeight();\n        }\n    }\n\n    class System {\n        // public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)\n        /**\n         * Makes a copy of a array.\n         */\n        static arraycopy(src, srcPos, dest, destPos, length) {\n            // TODO: better use split or set?\n            while (length--) {\n                dest[destPos++] = src[srcPos++];\n            }\n        }\n        /**\n         * Returns the current time in milliseconds.\n         */\n        static currentTimeMillis() {\n            return Date.now();\n        }\n    }\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class IndexOutOfBoundsException extends Exception {\n    }\n    IndexOutOfBoundsException.kind = 'IndexOutOfBoundsException';\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException {\n        constructor(index = undefined, message = undefined) {\n            super(message);\n            this.index = index;\n            this.message = message;\n        }\n    }\n    ArrayIndexOutOfBoundsException.kind = 'ArrayIndexOutOfBoundsException';\n\n    class Arrays {\n        /**\n         * Assigns the specified int value to each element of the specified array\n         * of ints.\n         *\n         * @param a the array to be filled\n         * @param val the value to be stored in all elements of the array\n         */\n        static fill(a, val) {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] = val;\n        }\n        /**\n         * Assigns the specified int value to each element of the specified\n         * range of the specified array of ints.  The range to be filled\n         * extends from index {@code fromIndex}, inclusive, to index\n         * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\n         * range to be filled is empty.)\n         *\n         * @param a the array to be filled\n         * @param fromIndex the index of the first element (inclusive) to be\n         *        filled with the specified value\n         * @param toIndex the index of the last element (exclusive) to be\n         *        filled with the specified value\n         * @param val the value to be stored in all elements of the array\n         * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n         * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n         *         {@code toIndex > a.length}\n         */\n        static fillWithin(a, fromIndex, toIndex, val) {\n            Arrays.rangeCheck(a.length, fromIndex, toIndex);\n            for (let i = fromIndex; i < toIndex; i++)\n                a[i] = val;\n        }\n        /**\n         * Checks that {@code fromIndex} and {@code toIndex} are in\n         * the range and throws an exception if they aren't.\n         */\n        static rangeCheck(arrayLength, fromIndex, toIndex) {\n            if (fromIndex > toIndex) {\n                throw new IllegalArgumentException('fromIndex(' + fromIndex + ') > toIndex(' + toIndex + ')');\n            }\n            if (fromIndex < 0) {\n                throw new ArrayIndexOutOfBoundsException(fromIndex);\n            }\n            if (toIndex > arrayLength) {\n                throw new ArrayIndexOutOfBoundsException(toIndex);\n            }\n        }\n        static asList(...args) {\n            return args;\n        }\n        static create(rows, cols, value) {\n            let arr = Array.from({ length: rows });\n            return arr.map(x => Array.from({ length: cols }).fill(value));\n        }\n        static createInt32Array(rows, cols, value) {\n            let arr = Array.from({ length: rows });\n            return arr.map(x => Int32Array.from({ length: cols }).fill(value));\n        }\n        static equals(first, second) {\n            if (!first) {\n                return false;\n            }\n            if (!second) {\n                return false;\n            }\n            if (!first.length) {\n                return false;\n            }\n            if (!second.length) {\n                return false;\n            }\n            if (first.length !== second.length) {\n                return false;\n            }\n            for (let i = 0, length = first.length; i < length; i++) {\n                if (first[i] !== second[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        static hashCode(a) {\n            if (a === null) {\n                return 0;\n            }\n            let result = 1;\n            for (const element of a) {\n                result = 31 * result + element;\n            }\n            return result;\n        }\n        static fillUint8Array(a, value) {\n            for (let i = 0; i !== a.length; i++) {\n                a[i] = value;\n            }\n        }\n        static copyOf(original, newLength) {\n            return original.slice(0, newLength);\n        }\n        static copyOfUint8Array(original, newLength) {\n            if (original.length <= newLength) {\n                const newArray = new Uint8Array(newLength);\n                newArray.set(original);\n                return newArray;\n            }\n            return original.slice(0, newLength);\n        }\n        static copyOfRange(original, from, to) {\n            const newLength = to - from;\n            const copy = new Int32Array(newLength);\n            System.arraycopy(original, from, copy, 0, newLength);\n            return copy;\n        }\n        /*\n        * Returns the index of of the element in a sorted array or (-n-1) where n is the insertion point\n        * for the new element.\n        * Parameters:\n        *     ar - A sorted array\n        *     el - An element to search for\n        *     comparator - A comparator function. The function takes two arguments: (a, b) and returns:\n        *        a negative number  if a is less than b;\n        *        0 if a is equal to b;\n        *        a positive number of a is greater than b.\n        * The array may contain duplicate elements. If there are more than one equal elements in the array,\n        * the returned value can be the index of any one of the equal elements.\n        *\n        * http://jsfiddle.net/aryzhov/pkfst550/\n        */\n        static binarySearch(ar, el, comparator) {\n            if (undefined === comparator) {\n                comparator = Arrays.numberComparator;\n            }\n            let m = 0;\n            let n = ar.length - 1;\n            while (m <= n) {\n                const k = (n + m) >> 1;\n                const cmp = comparator(el, ar[k]);\n                if (cmp > 0) {\n                    m = k + 1;\n                }\n                else if (cmp < 0) {\n                    n = k - 1;\n                }\n                else {\n                    return k;\n                }\n            }\n            return -m - 1;\n        }\n        static numberComparator(a, b) {\n            return a - b;\n        }\n    }\n\n    /**\n     * Ponyfill for Java's Integer class.\n     */\n    class Integer {\n        static numberOfTrailingZeros(i) {\n            let y;\n            if (i === 0)\n                return 32;\n            let n = 31;\n            y = i << 16;\n            if (y !== 0) {\n                n -= 16;\n                i = y;\n            }\n            y = i << 8;\n            if (y !== 0) {\n                n -= 8;\n                i = y;\n            }\n            y = i << 4;\n            if (y !== 0) {\n                n -= 4;\n                i = y;\n            }\n            y = i << 2;\n            if (y !== 0) {\n                n -= 2;\n                i = y;\n            }\n            return n - ((i << 1) >>> 31);\n        }\n        static numberOfLeadingZeros(i) {\n            // HD, Figure 5-6\n            if (i === 0) {\n                return 32;\n            }\n            let n = 1;\n            if (i >>> 16 === 0) {\n                n += 16;\n                i <<= 16;\n            }\n            if (i >>> 24 === 0) {\n                n += 8;\n                i <<= 8;\n            }\n            if (i >>> 28 === 0) {\n                n += 4;\n                i <<= 4;\n            }\n            if (i >>> 30 === 0) {\n                n += 2;\n                i <<= 2;\n            }\n            n -= i >>> 31;\n            return n;\n        }\n        static toHexString(i) {\n            return i.toString(16);\n        }\n        static toBinaryString(intNumber) {\n            return String(parseInt(String(intNumber), 2));\n        }\n        // Returns the number of one-bits in the two's complement binary representation of the specified int value. This function is sometimes referred to as the population count.\n        // Returns:\n        // the number of one-bits in the two's complement binary representation of the specified int value.\n        static bitCount(i) {\n            // HD, Figure 5-2\n            i = i - ((i >>> 1) & 0x55555555);\n            i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);\n            i = (i + (i >>> 4)) & 0x0f0f0f0f;\n            i = i + (i >>> 8);\n            i = i + (i >>> 16);\n            return i & 0x3f;\n        }\n        static truncDivision(dividend, divisor) {\n            return Math.trunc(dividend / divisor);\n        }\n        /**\n         * Converts A string to an integer.\n         * @param s A string to convert into a number.\n         * @param radix A value between 2 and 36 that specifies the base of the number in numString. If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal. All other strings are considered decimal.\n         */\n        static parseInt(num, radix = undefined) {\n            return parseInt(num, radix);\n        }\n    }\n    Integer.MIN_VALUE_32_BITS = -2147483648;\n    Integer.MAX_VALUE = Number.MAX_SAFE_INTEGER;\n\n    /**\n     * <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>\n     *\n     * @author Sean Owen\n     */\n    class BitArray /*implements Cloneable*/ {\n        // For testing only\n        constructor(size /*int*/, bits) {\n            if (undefined === size) {\n                this.size = 0;\n                this.bits = new Int32Array(1);\n            }\n            else {\n                this.size = size;\n                if (undefined === bits || null === bits) {\n                    this.bits = BitArray.makeArray(size);\n                }\n                else {\n                    this.bits = bits;\n                }\n            }\n        }\n        getSize() {\n            return this.size;\n        }\n        getSizeInBytes() {\n            return Math.floor((this.size + 7) / 8);\n        }\n        ensureCapacity(size /*int*/) {\n            if (size > this.bits.length * 32) {\n                const newBits = BitArray.makeArray(size);\n                System.arraycopy(this.bits, 0, newBits, 0, this.bits.length);\n                this.bits = newBits;\n            }\n        }\n        /**\n         * @param i bit to get\n         * @return true iff bit i is set\n         */\n        get(i /*int*/) {\n            return (this.bits[Math.floor(i / 32)] & (1 << (i & 0x1F))) !== 0;\n        }\n        /**\n         * Sets bit i.\n         *\n         * @param i bit to set\n         */\n        set(i /*int*/) {\n            this.bits[Math.floor(i / 32)] |= 1 << (i & 0x1F);\n        }\n        /**\n         * Flips bit i.\n         *\n         * @param i bit to set\n         */\n        flip(i /*int*/) {\n            this.bits[Math.floor(i / 32)] ^= 1 << (i & 0x1F);\n        }\n        /**\n         * @param from first bit to check\n         * @return index of first bit that is set, starting from the given index, or size if none are set\n         *  at or beyond this given index\n         * @see #getNextUnset(int)\n         */\n        getNextSet(from /*int*/) {\n            const size = this.size;\n            if (from >= size) {\n                return size;\n            }\n            const bits = this.bits;\n            let bitsOffset = Math.floor(from / 32);\n            let currentBits = bits[bitsOffset];\n            // mask off lesser bits first\n            currentBits &= ~((1 << (from & 0x1F)) - 1);\n            const length = bits.length;\n            while (currentBits === 0) {\n                if (++bitsOffset === length) {\n                    return size;\n                }\n                currentBits = bits[bitsOffset];\n            }\n            const result = (bitsOffset * 32) + Integer.numberOfTrailingZeros(currentBits);\n            return result > size ? size : result;\n        }\n        /**\n         * @param from index to start looking for unset bit\n         * @return index of next unset bit, or {@code size} if none are unset until the end\n         * @see #getNextSet(int)\n         */\n        getNextUnset(from /*int*/) {\n            const size = this.size;\n            if (from >= size) {\n                return size;\n            }\n            const bits = this.bits;\n            let bitsOffset = Math.floor(from / 32);\n            let currentBits = ~bits[bitsOffset];\n            // mask off lesser bits first\n            currentBits &= ~((1 << (from & 0x1F)) - 1);\n            const length = bits.length;\n            while (currentBits === 0) {\n                if (++bitsOffset === length) {\n                    return size;\n                }\n                currentBits = ~bits[bitsOffset];\n            }\n            const result = (bitsOffset * 32) + Integer.numberOfTrailingZeros(currentBits);\n            return result > size ? size : result;\n        }\n        /**\n         * Sets a block of 32 bits, starting at bit i.\n         *\n         * @param i first bit to set\n         * @param newBits the new value of the next 32 bits. Note again that the least-significant bit\n         * corresponds to bit i, the next-least-significant to i+1, and so on.\n         */\n        setBulk(i /*int*/, newBits /*int*/) {\n            this.bits[Math.floor(i / 32)] = newBits;\n        }\n        /**\n         * Sets a range of bits.\n         *\n         * @param start start of range, inclusive.\n         * @param end end of range, exclusive\n         */\n        setRange(start /*int*/, end /*int*/) {\n            if (end < start || start < 0 || end > this.size) {\n                throw new IllegalArgumentException();\n            }\n            if (end === start) {\n                return;\n            }\n            end--; // will be easier to treat this as the last actually set bit -- inclusive\n            const firstInt = Math.floor(start / 32);\n            const lastInt = Math.floor(end / 32);\n            const bits = this.bits;\n            for (let i = firstInt; i <= lastInt; i++) {\n                const firstBit = i > firstInt ? 0 : start & 0x1F;\n                const lastBit = i < lastInt ? 31 : end & 0x1F;\n                // Ones from firstBit to lastBit, inclusive\n                const mask = (2 << lastBit) - (1 << firstBit);\n                bits[i] |= mask;\n            }\n        }\n        /**\n         * Clears all bits (sets to false).\n         */\n        clear() {\n            const max = this.bits.length;\n            const bits = this.bits;\n            for (let i = 0; i < max; i++) {\n                bits[i] = 0;\n            }\n        }\n        /**\n         * Efficient method to check if a range of bits is set, or not set.\n         *\n         * @param start start of range, inclusive.\n         * @param end end of range, exclusive\n         * @param value if true, checks that bits in range are set, otherwise checks that they are not set\n         * \n         * @return true iff all bits are set or not set in range, according to value argument\n         * @throws IllegalArgumentException if end is less than start or the range is not contained in the array\n         */\n        isRange(start /*int*/, end /*int*/, value) {\n            if (end < start || start < 0 || end > this.size) {\n                throw new IllegalArgumentException();\n            }\n            if (end === start) {\n                return true; // empty range matches\n            }\n            end--; // will be easier to treat this as the last actually set bit -- inclusive\n            const firstInt = Math.floor(start / 32);\n            const lastInt = Math.floor(end / 32);\n            const bits = this.bits;\n            for (let i = firstInt; i <= lastInt; i++) {\n                const firstBit = i > firstInt ? 0 : start & 0x1F;\n                const lastBit = i < lastInt ? 31 : end & 0x1F;\n                // Ones from firstBit to lastBit, inclusive\n                const mask = (2 << lastBit) - (1 << firstBit) & 0xFFFFFFFF;\n                // TYPESCRIPTPORT: & 0xFFFFFFFF added to discard anything after 32 bits, as ES has 53 bits\n                // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (is: that,\n                // equals the mask, or we're looking for 0s and the masked portion is not all 0s\n                if ((bits[i] & mask) !== (value ? mask : 0)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        appendBit(bit) {\n            this.ensureCapacity(this.size + 1);\n            if (bit) {\n                this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 0x1F);\n            }\n            this.size++;\n        }\n        /**\n         * Appends the least-significant bits, from value, in order from most-significant to\n         * least-significant. For example, appending 6 bits from 0x000001E will append the bits\n         * 0, 1, 1, 1, 1, 0 in that order.\n         *\n         * @param value {@code int} containing bits to append\n         * @param numBits bits from value to append\n         */\n        appendBits(value /*int*/, numBits /*int*/) {\n            if (numBits < 0 || numBits > 32) {\n                throw new IllegalArgumentException('Num bits must be between 0 and 32');\n            }\n            this.ensureCapacity(this.size + numBits);\n            // const appendBit = this.appendBit;\n            for (let numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {\n                this.appendBit(((value >> (numBitsLeft - 1)) & 0x01) === 1);\n            }\n        }\n        appendBitArray(other) {\n            const otherSize = other.size;\n            this.ensureCapacity(this.size + otherSize);\n            // const appendBit = this.appendBit;\n            for (let i = 0; i < otherSize; i++) {\n                this.appendBit(other.get(i));\n            }\n        }\n        xor(other) {\n            if (this.size !== other.size) {\n                throw new IllegalArgumentException('Sizes don\\'t match');\n            }\n            const bits = this.bits;\n            for (let i = 0, length = bits.length; i < length; i++) {\n                // The last int could be incomplete (i.e. not have 32 bits in\n                // it) but there is no problem since 0 XOR 0 == 0.\n                bits[i] ^= other.bits[i];\n            }\n        }\n        /**\n         *\n         * @param bitOffset first bit to start writing\n         * @param array array to write into. Bytes are written most-significant byte first. This is the opposite\n         *  of the internal representation, which is exposed by {@link #getBitArray()}\n         * @param offset position in array to start writing\n         * @param numBytes how many bytes to write\n         */\n        toBytes(bitOffset /*int*/, array, offset /*int*/, numBytes /*int*/) {\n            for (let i = 0; i < numBytes; i++) {\n                let theByte = 0;\n                for (let j = 0; j < 8; j++) {\n                    if (this.get(bitOffset)) {\n                        theByte |= 1 << (7 - j);\n                    }\n                    bitOffset++;\n                }\n                array[offset + i] = /*(byte)*/ theByte;\n            }\n        }\n        /**\n         * @return underlying array of ints. The first element holds the first 32 bits, and the least\n         *         significant bit is bit 0.\n         */\n        getBitArray() {\n            return this.bits;\n        }\n        /**\n         * Reverses all bits in the array.\n         */\n        reverse() {\n            const newBits = new Int32Array(this.bits.length);\n            // reverse all int's first\n            const len = Math.floor((this.size - 1) / 32);\n            const oldBitsLen = len + 1;\n            const bits = this.bits;\n            for (let i = 0; i < oldBitsLen; i++) {\n                let x = bits[i];\n                x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);\n                x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);\n                x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);\n                x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);\n                x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);\n                newBits[len - i] = /*(int)*/ x;\n            }\n            // now correct the int's if the bit size isn't a multiple of 32\n            if (this.size !== oldBitsLen * 32) {\n                const leftOffset = oldBitsLen * 32 - this.size;\n                let currentInt = newBits[0] >>> leftOffset;\n                for (let i = 1; i < oldBitsLen; i++) {\n                    const nextInt = newBits[i];\n                    currentInt |= nextInt << (32 - leftOffset);\n                    newBits[i - 1] = currentInt;\n                    currentInt = nextInt >>> leftOffset;\n                }\n                newBits[oldBitsLen - 1] = currentInt;\n            }\n            this.bits = newBits;\n        }\n        static makeArray(size /*int*/) {\n            return new Int32Array(Math.floor((size + 31) / 32));\n        }\n        /*@Override*/\n        equals(o) {\n            if (!(o instanceof BitArray)) {\n                return false;\n            }\n            const other = o;\n            return this.size === other.size && Arrays.equals(this.bits, other.bits);\n        }\n        /*@Override*/\n        hashCode() {\n            return 31 * this.size + Arrays.hashCode(this.bits);\n        }\n        /*@Override*/\n        toString() {\n            let result = '';\n            for (let i = 0, size = this.size; i < size; i++) {\n                if ((i & 0x07) === 0) {\n                    result += ' ';\n                }\n                result += this.get(i) ? 'X' : '.';\n            }\n            return result;\n        }\n        /*@Override*/\n        clone() {\n            return new BitArray(this.size, this.bits.slice());\n        }\n    }\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing {*/\n    /**\n     * Encapsulates a type of hint that a caller may pass to a barcode reader to help it\n     * more quickly or accurately decode it. It is up to implementations to decide what,\n     * if anything, to do with the information that is supplied.\n     *\n     * @author Sean Owen\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @see Reader#decode(BinaryBitmap,java.util.Map)\n     */\n    var DecodeHintType;\n    (function (DecodeHintType) {\n        /**\n         * Unspecified, application-specific hint. Maps to an unspecified {@link Object}.\n         */\n        DecodeHintType[DecodeHintType[\"OTHER\"] = 0] = \"OTHER\"; /*(Object.class)*/\n        /**\n         * Image is a pure monochrome image of a barcode. Doesn't matter what it maps to;\n         * use {@link Boolean#TRUE}.\n         */\n        DecodeHintType[DecodeHintType[\"PURE_BARCODE\"] = 1] = \"PURE_BARCODE\"; /*(Void.class)*/\n        /**\n         * Image is known to be of one of a few possible formats.\n         * Maps to a {@link List} of {@link BarcodeFormat}s.\n         */\n        DecodeHintType[DecodeHintType[\"POSSIBLE_FORMATS\"] = 2] = \"POSSIBLE_FORMATS\"; /*(List.class)*/\n        /**\n         * Spend more time to try to find a barcode; optimize for accuracy, not speed.\n         * Doesn't matter what it maps to; use {@link Boolean#TRUE}.\n         */\n        DecodeHintType[DecodeHintType[\"TRY_HARDER\"] = 3] = \"TRY_HARDER\"; /*(Void.class)*/\n        /**\n         * Specifies what character encoding to use when decoding, where applicable (type String)\n         */\n        DecodeHintType[DecodeHintType[\"CHARACTER_SET\"] = 4] = \"CHARACTER_SET\"; /*(String.class)*/\n        /**\n         * Allowed lengths of encoded data -- reject anything else. Maps to an {@code Int32Array}.\n         */\n        DecodeHintType[DecodeHintType[\"ALLOWED_LENGTHS\"] = 5] = \"ALLOWED_LENGTHS\"; /*(Int32Array.class)*/\n        /**\n         * Assume Code 39 codes employ a check digit. Doesn't matter what it maps to;\n         * use {@link Boolean#TRUE}.\n         */\n        DecodeHintType[DecodeHintType[\"ASSUME_CODE_39_CHECK_DIGIT\"] = 6] = \"ASSUME_CODE_39_CHECK_DIGIT\"; /*(Void.class)*/\n        /**\n         * Assume the barcode is being processed as a GS1 barcode, and modify behavior as needed.\n         * For example this affects FNC1 handling for Code 128 (aka GS1-128). Doesn't matter what it maps to;\n         * use {@link Boolean#TRUE}.\n         */\n        DecodeHintType[DecodeHintType[\"ASSUME_GS1\"] = 7] = \"ASSUME_GS1\"; /*(Void.class)*/\n        /**\n         * If true, return the start and end digits in a Codabar barcode instead of stripping them. They\n         * are alpha, whereas the rest are numeric. By default, they are stripped, but this causes them\n         * to not be. Doesn't matter what it maps to; use {@link Boolean#TRUE}.\n         */\n        DecodeHintType[DecodeHintType[\"RETURN_CODABAR_START_END\"] = 8] = \"RETURN_CODABAR_START_END\"; /*(Void.class)*/\n        /**\n         * The caller needs to be notified via callback when a possible {@link ResultPoint}\n         * is found. Maps to a {@link ResultPointCallback}.\n         */\n        DecodeHintType[DecodeHintType[\"NEED_RESULT_POINT_CALLBACK\"] = 9] = \"NEED_RESULT_POINT_CALLBACK\"; /*(ResultPointCallback.class)*/\n        /**\n         * Allowed extension lengths for EAN or UPC barcodes. Other formats will ignore this.\n         * Maps to an {@code Int32Array} of the allowed extension lengths, for example [2], [5], or [2, 5].\n         * If it is optional to have an extension, do not set this hint. If this is set,\n         * and a UPC or EAN barcode is found but an extension is not, then no result will be returned\n         * at all.\n         */\n        DecodeHintType[DecodeHintType[\"ALLOWED_EAN_EXTENSIONS\"] = 10] = \"ALLOWED_EAN_EXTENSIONS\"; /*(Int32Array.class)*/\n        // End of enumeration values.\n        /**\n         * Data type the hint is expecting.\n         * Among the possible values the {@link Void} stands out as being used for\n         * hints that do not expect a value to be supplied (flag hints). Such hints\n         * will possibly have their value ignored, or replaced by a\n         * {@link Boolean#TRUE}. Hint suppliers should probably use\n         * {@link Boolean#TRUE} as directed by the actual hint documentation.\n         */\n        // private valueType: Class<?>\n        // DecodeHintType(valueType: Class<?>) {\n        //   this.valueType = valueType\n        // }\n        // public getValueType(): Class<?> {\n        //   return valueType\n        // }\n    })(DecodeHintType || (DecodeHintType = {}));\n    var DecodeHintType$1 = DecodeHintType;\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class FormatException extends Exception {\n        static getFormatInstance() {\n            return new FormatException();\n        }\n    }\n    FormatException.kind = 'FormatException';\n\n    /*import java.util.HashMap;*/\n    /*import java.util.Map;*/\n    var CharacterSetValueIdentifiers;\n    (function (CharacterSetValueIdentifiers) {\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp437\"] = 0] = \"Cp437\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_1\"] = 1] = \"ISO8859_1\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_2\"] = 2] = \"ISO8859_2\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_3\"] = 3] = \"ISO8859_3\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_4\"] = 4] = \"ISO8859_4\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_5\"] = 5] = \"ISO8859_5\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_6\"] = 6] = \"ISO8859_6\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_7\"] = 7] = \"ISO8859_7\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_8\"] = 8] = \"ISO8859_8\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_9\"] = 9] = \"ISO8859_9\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_10\"] = 10] = \"ISO8859_10\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_11\"] = 11] = \"ISO8859_11\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_13\"] = 12] = \"ISO8859_13\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_14\"] = 13] = \"ISO8859_14\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_15\"] = 14] = \"ISO8859_15\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_16\"] = 15] = \"ISO8859_16\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"SJIS\"] = 16] = \"SJIS\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1250\"] = 17] = \"Cp1250\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1251\"] = 18] = \"Cp1251\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1252\"] = 19] = \"Cp1252\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1256\"] = 20] = \"Cp1256\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"UnicodeBigUnmarked\"] = 21] = \"UnicodeBigUnmarked\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"UTF8\"] = 22] = \"UTF8\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ASCII\"] = 23] = \"ASCII\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Big5\"] = 24] = \"Big5\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"GB18030\"] = 25] = \"GB18030\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"EUC_KR\"] = 26] = \"EUC_KR\";\n    })(CharacterSetValueIdentifiers || (CharacterSetValueIdentifiers = {}));\n    /**\n     * Encapsulates a Character Set ECI, according to \"Extended Channel Interpretations\" 5.3.1.1\n     * of ISO 18004.\n     *\n     * @author Sean Owen\n     */\n    class CharacterSetECI {\n        constructor(valueIdentifier, valuesParam, name, ...otherEncodingNames) {\n            this.valueIdentifier = valueIdentifier;\n            this.name = name;\n            if (typeof valuesParam === 'number') {\n                this.values = Int32Array.from([valuesParam]);\n            }\n            else {\n                this.values = valuesParam;\n            }\n            this.otherEncodingNames = otherEncodingNames;\n            CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);\n            CharacterSetECI.NAME_TO_ECI.set(name, this);\n            const values = this.values;\n            for (let i = 0, length = values.length; i !== length; i++) {\n                const v = values[i];\n                CharacterSetECI.VALUES_TO_ECI.set(v, this);\n            }\n            for (const otherName of otherEncodingNames) {\n                CharacterSetECI.NAME_TO_ECI.set(otherName, this);\n            }\n        }\n        // CharacterSetECI(value: number /*int*/) {\n        //   this(new Int32Array {value})\n        // }\n        // CharacterSetECI(value: number /*int*/, String... otherEncodingNames) {\n        //   this.values = new Int32Array {value}\n        //   this.otherEncodingNames = otherEncodingNames\n        // }\n        // CharacterSetECI(values: Int32Array, String... otherEncodingNames) {\n        //   this.values = values\n        //   this.otherEncodingNames = otherEncodingNames\n        // }\n        getValueIdentifier() {\n            return this.valueIdentifier;\n        }\n        getName() {\n            return this.name;\n        }\n        getValue() {\n            return this.values[0];\n        }\n        /**\n         * @param value character set ECI value\n         * @return {@code CharacterSetECI} representing ECI of given value, or null if it is legal but\n         *   unsupported\n         * @throws FormatException if ECI value is invalid\n         */\n        static getCharacterSetECIByValue(value /*int*/) {\n            if (value < 0 || value >= 900) {\n                throw new FormatException('incorect value');\n            }\n            const characterSet = CharacterSetECI.VALUES_TO_ECI.get(value);\n            if (undefined === characterSet) {\n                throw new FormatException('incorect value');\n            }\n            return characterSet;\n        }\n        /**\n         * @param name character set ECI encoding name\n         * @return CharacterSetECI representing ECI for character encoding, or null if it is legal\n         *   but unsupported\n         */\n        static getCharacterSetECIByName(name) {\n            const characterSet = CharacterSetECI.NAME_TO_ECI.get(name);\n            if (undefined === characterSet) {\n                throw new FormatException('incorect value');\n            }\n            return characterSet;\n        }\n        equals(o) {\n            if (!(o instanceof CharacterSetECI)) {\n                return false;\n            }\n            const other = o;\n            return this.getName() === other.getName();\n        }\n    }\n    CharacterSetECI.VALUE_IDENTIFIER_TO_ECI = new Map();\n    CharacterSetECI.VALUES_TO_ECI = new Map();\n    CharacterSetECI.NAME_TO_ECI = new Map();\n    // Enum name is a Java encoding valid for java.lang and java.io\n    // TYPESCRIPTPORT: changed the main label for ISO as the TextEncoder did not recognized them in the form from java\n    // (eg ISO8859_1 must be ISO88591 or ISO8859-1 or ISO-8859-1)\n    // later on: well, except 16 wich does not work with ISO885916 so used ISO-8859-1 form for default\n    CharacterSetECI.Cp437 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp437, Int32Array.from([0, 2]), 'Cp437');\n    CharacterSetECI.ISO8859_1 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([1, 3]), 'ISO-8859-1', 'ISO88591', 'ISO8859_1');\n    CharacterSetECI.ISO8859_2 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_2, 4, 'ISO-8859-2', 'ISO88592', 'ISO8859_2');\n    CharacterSetECI.ISO8859_3 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_3, 5, 'ISO-8859-3', 'ISO88593', 'ISO8859_3');\n    CharacterSetECI.ISO8859_4 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_4, 6, 'ISO-8859-4', 'ISO88594', 'ISO8859_4');\n    CharacterSetECI.ISO8859_5 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_5, 7, 'ISO-8859-5', 'ISO88595', 'ISO8859_5');\n    CharacterSetECI.ISO8859_6 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_6, 8, 'ISO-8859-6', 'ISO88596', 'ISO8859_6');\n    CharacterSetECI.ISO8859_7 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_7, 9, 'ISO-8859-7', 'ISO88597', 'ISO8859_7');\n    CharacterSetECI.ISO8859_8 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_8, 10, 'ISO-8859-8', 'ISO88598', 'ISO8859_8');\n    CharacterSetECI.ISO8859_9 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_9, 11, 'ISO-8859-9', 'ISO88599', 'ISO8859_9');\n    CharacterSetECI.ISO8859_10 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_10, 12, 'ISO-8859-10', 'ISO885910', 'ISO8859_10');\n    CharacterSetECI.ISO8859_11 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_11, 13, 'ISO-8859-11', 'ISO885911', 'ISO8859_11');\n    CharacterSetECI.ISO8859_13 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_13, 15, 'ISO-8859-13', 'ISO885913', 'ISO8859_13');\n    CharacterSetECI.ISO8859_14 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_14, 16, 'ISO-8859-14', 'ISO885914', 'ISO8859_14');\n    CharacterSetECI.ISO8859_15 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_15, 17, 'ISO-8859-15', 'ISO885915', 'ISO8859_15');\n    CharacterSetECI.ISO8859_16 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_16, 18, 'ISO-8859-16', 'ISO885916', 'ISO8859_16');\n    CharacterSetECI.SJIS = new CharacterSetECI(CharacterSetValueIdentifiers.SJIS, 20, 'SJIS', 'Shift_JIS');\n    CharacterSetECI.Cp1250 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1250, 21, 'Cp1250', 'windows-1250');\n    CharacterSetECI.Cp1251 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1251, 22, 'Cp1251', 'windows-1251');\n    CharacterSetECI.Cp1252 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1252, 23, 'Cp1252', 'windows-1252');\n    CharacterSetECI.Cp1256 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1256, 24, 'Cp1256', 'windows-1256');\n    CharacterSetECI.UnicodeBigUnmarked = new CharacterSetECI(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, 'UnicodeBigUnmarked', 'UTF-16BE', 'UnicodeBig');\n    CharacterSetECI.UTF8 = new CharacterSetECI(CharacterSetValueIdentifiers.UTF8, 26, 'UTF8', 'UTF-8');\n    CharacterSetECI.ASCII = new CharacterSetECI(CharacterSetValueIdentifiers.ASCII, Int32Array.from([27, 170]), 'ASCII', 'US-ASCII');\n    CharacterSetECI.Big5 = new CharacterSetECI(CharacterSetValueIdentifiers.Big5, 28, 'Big5');\n    CharacterSetECI.GB18030 = new CharacterSetECI(CharacterSetValueIdentifiers.GB18030, 29, 'GB18030', 'GB2312', 'EUC_CN', 'GBK');\n    CharacterSetECI.EUC_KR = new CharacterSetECI(CharacterSetValueIdentifiers.EUC_KR, 30, 'EUC_KR', 'EUC-KR');\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class UnsupportedOperationException extends Exception {\n    }\n    UnsupportedOperationException.kind = 'UnsupportedOperationException';\n\n    /**\n     * Responsible for en/decoding strings.\n     */\n    class StringEncoding {\n        /**\n         * Decodes some Uint8Array to a string format.\n         */\n        static decode(bytes, encoding) {\n            const encodingName = this.encodingName(encoding);\n            if (this.customDecoder) {\n                return this.customDecoder(bytes, encodingName);\n            }\n            // Increases browser support.\n            if (typeof TextDecoder === 'undefined' || this.shouldDecodeOnFallback(encodingName)) {\n                return this.decodeFallback(bytes, encodingName);\n            }\n            return new TextDecoder(encodingName).decode(bytes);\n        }\n        /**\n         * Checks if the decoding method should use the fallback for decoding\n         * once Node TextDecoder doesn't support all encoding formats.\n         *\n         * @param encodingName\n         */\n        static shouldDecodeOnFallback(encodingName) {\n            return !StringEncoding.isBrowser() && encodingName === 'ISO-8859-1';\n        }\n        /**\n         * Encodes some string into a Uint8Array.\n         */\n        static encode(s, encoding) {\n            const encodingName = this.encodingName(encoding);\n            if (this.customEncoder) {\n                return this.customEncoder(s, encodingName);\n            }\n            // Increases browser support.\n            if (typeof TextEncoder === 'undefined') {\n                return this.encodeFallback(s);\n            }\n            // TextEncoder only encodes to UTF8 by default as specified by encoding.spec.whatwg.org\n            return new TextEncoder().encode(s);\n        }\n        static isBrowser() {\n            return (typeof window !== 'undefined' && {}.toString.call(window) === '[object Window]');\n        }\n        /**\n         * Returns the string value from some encoding character set.\n         */\n        static encodingName(encoding) {\n            return typeof encoding === 'string'\n                ? encoding\n                : encoding.getName();\n        }\n        /**\n         * Returns character set from some encoding character set.\n         */\n        static encodingCharacterSet(encoding) {\n            if (encoding instanceof CharacterSetECI) {\n                return encoding;\n            }\n            return CharacterSetECI.getCharacterSetECIByName(encoding);\n        }\n        /**\n         * Runs a fallback for the native decoding funcion.\n         */\n        static decodeFallback(bytes, encoding) {\n            const characterSet = this.encodingCharacterSet(encoding);\n            if (StringEncoding.isDecodeFallbackSupported(characterSet)) {\n                let s = '';\n                for (let i = 0, length = bytes.length; i < length; i++) {\n                    let h = bytes[i].toString(16);\n                    if (h.length < 2) {\n                        h = '0' + h;\n                    }\n                    s += '%' + h;\n                }\n                return decodeURIComponent(s);\n            }\n            if (characterSet.equals(CharacterSetECI.UnicodeBigUnmarked)) {\n                return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));\n            }\n            throw new UnsupportedOperationException(`Encoding ${this.encodingName(encoding)} not supported by fallback.`);\n        }\n        static isDecodeFallbackSupported(characterSet) {\n            return characterSet.equals(CharacterSetECI.UTF8) ||\n                characterSet.equals(CharacterSetECI.ISO8859_1) ||\n                characterSet.equals(CharacterSetECI.ASCII);\n        }\n        /**\n         * Runs a fallback for the native encoding funcion.\n         *\n         * @see https://stackoverflow.com/a/17192845/4367683\n         */\n        static encodeFallback(s) {\n            const encodedURIstring = btoa(unescape(encodeURIComponent(s)));\n            const charList = encodedURIstring.split('');\n            const uintArray = [];\n            for (let i = 0; i < charList.length; i++) {\n                uintArray.push(charList[i].charCodeAt(0));\n            }\n            return new Uint8Array(uintArray);\n        }\n    }\n\n    /*\n     * Copyright (C) 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * Common string-related functions.\n     *\n     * @author Sean Owen\n     * @author Alex Dupre\n     */\n    class StringUtils {\n        // SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||\n        // EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);\n        static castAsNonUtf8Char(code, encoding = null) {\n            // ISO 8859-1 is the Java default as UTF-8 is JavaScripts\n            // you can see this method as a Java version of String.fromCharCode\n            const e = encoding ? encoding.getName() : this.ISO88591;\n            // use passed format (fromCharCode will return UTF8 encoding)\n            return StringEncoding.decode(new Uint8Array([code]), e);\n        }\n        /**\n         * @param bytes bytes encoding a string, whose encoding should be guessed\n         * @param hints decode hints if applicable\n         * @return name of guessed encoding; at the moment will only guess one of:\n         *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform\n         *  default encoding if none of these can possibly be correct\n         */\n        static guessEncoding(bytes, hints) {\n            if (hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType$1.CHARACTER_SET)) {\n                return hints.get(DecodeHintType$1.CHARACTER_SET).toString();\n            }\n            // For now, merely tries to distinguish ISO-8859-1, UTF-8 and Shift_JIS,\n            // which should be by far the most common encodings.\n            const length = bytes.length;\n            let canBeISO88591 = true;\n            let canBeShiftJIS = true;\n            let canBeUTF8 = true;\n            let utf8BytesLeft = 0;\n            // int utf8LowChars = 0\n            let utf2BytesChars = 0;\n            let utf3BytesChars = 0;\n            let utf4BytesChars = 0;\n            let sjisBytesLeft = 0;\n            // int sjisLowChars = 0\n            let sjisKatakanaChars = 0;\n            // int sjisDoubleBytesChars = 0\n            let sjisCurKatakanaWordLength = 0;\n            let sjisCurDoubleBytesWordLength = 0;\n            let sjisMaxKatakanaWordLength = 0;\n            let sjisMaxDoubleBytesWordLength = 0;\n            // int isoLowChars = 0\n            // int isoHighChars = 0\n            let isoHighOther = 0;\n            const utf8bom = bytes.length > 3 &&\n                bytes[0] === /*(byte) */ 0xEF &&\n                bytes[1] === /*(byte) */ 0xBB &&\n                bytes[2] === /*(byte) */ 0xBF;\n            for (let i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++) {\n                const value = bytes[i] & 0xFF;\n                // UTF-8 stuff\n                if (canBeUTF8) {\n                    if (utf8BytesLeft > 0) {\n                        if ((value & 0x80) === 0) {\n                            canBeUTF8 = false;\n                        }\n                        else {\n                            utf8BytesLeft--;\n                        }\n                    }\n                    else if ((value & 0x80) !== 0) {\n                        if ((value & 0x40) === 0) {\n                            canBeUTF8 = false;\n                        }\n                        else {\n                            utf8BytesLeft++;\n                            if ((value & 0x20) === 0) {\n                                utf2BytesChars++;\n                            }\n                            else {\n                                utf8BytesLeft++;\n                                if ((value & 0x10) === 0) {\n                                    utf3BytesChars++;\n                                }\n                                else {\n                                    utf8BytesLeft++;\n                                    if ((value & 0x08) === 0) {\n                                        utf4BytesChars++;\n                                    }\n                                    else {\n                                        canBeUTF8 = false;\n                                    }\n                                }\n                            }\n                        }\n                    } // else {\n                    // utf8LowChars++\n                    // }\n                }\n                // ISO-8859-1 stuff\n                if (canBeISO88591) {\n                    if (value > 0x7F && value < 0xA0) {\n                        canBeISO88591 = false;\n                    }\n                    else if (value > 0x9F) {\n                        if (value < 0xC0 || value === 0xD7 || value === 0xF7) {\n                            isoHighOther++;\n                        } // else {\n                        // isoHighChars++\n                        // }\n                    } // else {\n                    // isoLowChars++\n                    // }\n                }\n                // Shift_JIS stuff\n                if (canBeShiftJIS) {\n                    if (sjisBytesLeft > 0) {\n                        if (value < 0x40 || value === 0x7F || value > 0xFC) {\n                            canBeShiftJIS = false;\n                        }\n                        else {\n                            sjisBytesLeft--;\n                        }\n                    }\n                    else if (value === 0x80 || value === 0xA0 || value > 0xEF) {\n                        canBeShiftJIS = false;\n                    }\n                    else if (value > 0xA0 && value < 0xE0) {\n                        sjisKatakanaChars++;\n                        sjisCurDoubleBytesWordLength = 0;\n                        sjisCurKatakanaWordLength++;\n                        if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {\n                            sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;\n                        }\n                    }\n                    else if (value > 0x7F) {\n                        sjisBytesLeft++;\n                        // sjisDoubleBytesChars++\n                        sjisCurKatakanaWordLength = 0;\n                        sjisCurDoubleBytesWordLength++;\n                        if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {\n                            sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;\n                        }\n                    }\n                    else {\n                        // sjisLowChars++\n                        sjisCurKatakanaWordLength = 0;\n                        sjisCurDoubleBytesWordLength = 0;\n                    }\n                }\n            }\n            if (canBeUTF8 && utf8BytesLeft > 0) {\n                canBeUTF8 = false;\n            }\n            if (canBeShiftJIS && sjisBytesLeft > 0) {\n                canBeShiftJIS = false;\n            }\n            // Easy -- if there is BOM or at least 1 valid not-single byte character (and no evidence it can't be UTF-8), done\n            if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {\n                return StringUtils.UTF8;\n            }\n            // Easy -- if assuming Shift_JIS or at least 3 valid consecutive not-ascii characters (and no evidence it can't be), done\n            if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {\n                return StringUtils.SHIFT_JIS;\n            }\n            // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough for short words. The crude heuristic is:\n            // - If we saw\n            //   - only two consecutive katakana chars in the whole text, or\n            //   - at least 10% of bytes that could be \"upper\" not-alphanumeric Latin1,\n            // - then we conclude Shift_JIS, else ISO-8859-1\n            if (canBeISO88591 && canBeShiftJIS) {\n                return (sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2) || isoHighOther * 10 >= length\n                    ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;\n            }\n            // Otherwise, try in order ISO-8859-1, Shift JIS, UTF-8 and fall back to default platform encoding\n            if (canBeISO88591) {\n                return StringUtils.ISO88591;\n            }\n            if (canBeShiftJIS) {\n                return StringUtils.SHIFT_JIS;\n            }\n            if (canBeUTF8) {\n                return StringUtils.UTF8;\n            }\n            // Otherwise, we take a wild guess with platform encoding\n            return StringUtils.PLATFORM_DEFAULT_ENCODING;\n        }\n        /**\n         *\n         * @see https://stackoverflow.com/a/13439711/4367683\n         *\n         * @param append The new string to append.\n         * @param args Argumets values to be formated.\n         */\n        static format(append, ...args) {\n            let i = -1;\n            function callback(exp, p0, p1, p2, p3, p4) {\n                if (exp === '%%')\n                    return '%';\n                if (args[++i] === undefined)\n                    return undefined;\n                exp = p2 ? parseInt(p2.substr(1)) : undefined;\n                let base = p3 ? parseInt(p3.substr(1)) : undefined;\n                let val;\n                switch (p4) {\n                    case 's':\n                        val = args[i];\n                        break;\n                    case 'c':\n                        val = args[i][0];\n                        break;\n                    case 'f':\n                        val = parseFloat(args[i]).toFixed(exp);\n                        break;\n                    case 'p':\n                        val = parseFloat(args[i]).toPrecision(exp);\n                        break;\n                    case 'e':\n                        val = parseFloat(args[i]).toExponential(exp);\n                        break;\n                    case 'x':\n                        val = parseInt(args[i]).toString(base ? base : 16);\n                        break;\n                    case 'd':\n                        val = parseFloat(parseInt(args[i], base ? base : 10).toPrecision(exp)).toFixed(0);\n                        break;\n                }\n                val = typeof val === 'object' ? JSON.stringify(val) : (+val).toString(base);\n                let size = parseInt(p1); /* padding size */\n                let ch = p1 && (p1[0] + '') === '0' ? '0' : ' '; /* isnull? */\n                while (val.length < size)\n                    val = p0 !== undefined ? val + ch : ch + val; /* isminus? */\n                return val;\n            }\n            let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;\n            return append.replace(regex, callback);\n        }\n        /**\n         *\n         */\n        static getBytes(str, encoding) {\n            return StringEncoding.encode(str, encoding);\n        }\n        /**\n         * Returns the charcode at the specified index or at index zero.\n         */\n        static getCharCode(str, index = 0) {\n            return str.charCodeAt(index);\n        }\n        /**\n         * Returns char for given charcode\n         */\n        static getCharAt(charCode) {\n            return String.fromCharCode(charCode);\n        }\n    }\n    StringUtils.SHIFT_JIS = CharacterSetECI.SJIS.getName(); // \"SJIS\"\n    StringUtils.GB2312 = 'GB2312';\n    StringUtils.ISO88591 = CharacterSetECI.ISO8859_1.getName(); // \"ISO8859_1\"\n    StringUtils.EUC_JP = 'EUC_JP';\n    StringUtils.UTF8 = CharacterSetECI.UTF8.getName(); // \"UTF8\"\n    StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8; // \"UTF8\"//Charset.defaultCharset().name()\n    StringUtils.ASSUME_SHIFT_JIS = false;\n\n    class StringBuilder {\n        constructor(value = '') {\n            this.value = value;\n        }\n        enableDecoding(encoding) {\n            this.encoding = encoding;\n            return this;\n        }\n        append(s) {\n            if (typeof s === 'string') {\n                this.value += s.toString();\n            }\n            else if (this.encoding) {\n                // use passed format (fromCharCode will return UTF8 encoding)\n                this.value += StringUtils.castAsNonUtf8Char(s, this.encoding);\n            }\n            else {\n                // correctly converts from UTF-8, but not other encodings\n                this.value += String.fromCharCode(s);\n            }\n            return this;\n        }\n        appendChars(str, offset, len) {\n            for (let i = offset; offset < offset + len; i++) {\n                this.append(str[i]);\n            }\n            return this;\n        }\n        length() {\n            return this.value.length;\n        }\n        charAt(n) {\n            return this.value.charAt(n);\n        }\n        deleteCharAt(n) {\n            this.value = this.value.substr(0, n) + this.value.substring(n + 1);\n        }\n        setCharAt(n, c) {\n            this.value = this.value.substr(0, n) + c + this.value.substr(n + 1);\n        }\n        substring(start, end) {\n            return this.value.substring(start, end);\n        }\n        /**\n         * @note helper method for RSS Expanded\n         */\n        setLengthToZero() {\n            this.value = '';\n        }\n        toString() {\n            return this.value;\n        }\n        insert(n, c) {\n            this.value = this.value.substr(0, n) + c + this.value.substr(n + c.length);\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Represents a 2D matrix of bits. In function arguments below, and throughout the common\n     * module, x is the column position, and y is the row position. The ordering is always x, y.\n     * The origin is at the top-left.</p>\n     *\n     * <p>Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins\n     * with a new int. This is done intentionally so that we can copy out a row into a BitArray very\n     * efficiently.</p>\n     *\n     * <p>The ordering of bits is row-major. Within each int, the least significant bits are used first,\n     * meaning they represent lower x values. This is compatible with BitArray's implementation.</p>\n     *\n     * @author Sean Owen\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class BitMatrix /*implements Cloneable*/ {\n        /**\n         * Creates an empty square {@link BitMatrix}.\n         *\n         * @param dimension height and width\n         */\n        // public constructor(dimension: number /*int*/) {\n        //   this(dimension, dimension)\n        // }\n        /**\n         * Creates an empty {@link BitMatrix}.\n         *\n         * @param width bit matrix width\n         * @param height bit matrix height\n         */\n        // public constructor(width: number /*int*/, height: number /*int*/) {\n        //   if (width < 1 || height < 1) {\n        //     throw new IllegalArgumentException(\"Both dimensions must be greater than 0\")\n        //   }\n        //   this.width = width\n        //   this.height = height\n        //   this.rowSize = (width + 31) / 32\n        //   bits = new int[rowSize * height];\n        // }\n        constructor(width /*int*/, height /*int*/, rowSize /*int*/, bits) {\n            this.width = width;\n            this.height = height;\n            this.rowSize = rowSize;\n            this.bits = bits;\n            if (undefined === height || null === height) {\n                height = width;\n            }\n            this.height = height;\n            if (width < 1 || height < 1) {\n                throw new IllegalArgumentException('Both dimensions must be greater than 0');\n            }\n            if (undefined === rowSize || null === rowSize) {\n                rowSize = Math.floor((width + 31) / 32);\n            }\n            this.rowSize = rowSize;\n            if (undefined === bits || null === bits) {\n                this.bits = new Int32Array(this.rowSize * this.height);\n            }\n        }\n        /**\n         * Interprets a 2D array of booleans as a {@link BitMatrix}, where \"true\" means an \"on\" bit.\n         *\n         * @function parse\n         * @param image bits of the image, as a row-major 2D array. Elements are arrays representing rows\n         * @return {@link BitMatrix} representation of image\n         */\n        static parseFromBooleanArray(image) {\n            const height = image.length;\n            const width = image[0].length;\n            const bits = new BitMatrix(width, height);\n            for (let i = 0; i < height; i++) {\n                const imageI = image[i];\n                for (let j = 0; j < width; j++) {\n                    if (imageI[j]) {\n                        bits.set(j, i);\n                    }\n                }\n            }\n            return bits;\n        }\n        /**\n         *\n         * @function parse\n         * @param stringRepresentation\n         * @param setString\n         * @param unsetString\n         */\n        static parseFromString(stringRepresentation, setString, unsetString) {\n            if (stringRepresentation === null) {\n                throw new IllegalArgumentException('stringRepresentation cannot be null');\n            }\n            const bits = new Array(stringRepresentation.length);\n            let bitsPos = 0;\n            let rowStartPos = 0;\n            let rowLength = -1;\n            let nRows = 0;\n            let pos = 0;\n            while (pos < stringRepresentation.length) {\n                if (stringRepresentation.charAt(pos) === '\\n' ||\n                    stringRepresentation.charAt(pos) === '\\r') {\n                    if (bitsPos > rowStartPos) {\n                        if (rowLength === -1) {\n                            rowLength = bitsPos - rowStartPos;\n                        }\n                        else if (bitsPos - rowStartPos !== rowLength) {\n                            throw new IllegalArgumentException('row lengths do not match');\n                        }\n                        rowStartPos = bitsPos;\n                        nRows++;\n                    }\n                    pos++;\n                }\n                else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {\n                    pos += setString.length;\n                    bits[bitsPos] = true;\n                    bitsPos++;\n                }\n                else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {\n                    pos += unsetString.length;\n                    bits[bitsPos] = false;\n                    bitsPos++;\n                }\n                else {\n                    throw new IllegalArgumentException('illegal character encountered: ' + stringRepresentation.substring(pos));\n                }\n            }\n            // no EOL at end?\n            if (bitsPos > rowStartPos) {\n                if (rowLength === -1) {\n                    rowLength = bitsPos - rowStartPos;\n                }\n                else if (bitsPos - rowStartPos !== rowLength) {\n                    throw new IllegalArgumentException('row lengths do not match');\n                }\n                nRows++;\n            }\n            const matrix = new BitMatrix(rowLength, nRows);\n            for (let i = 0; i < bitsPos; i++) {\n                if (bits[i]) {\n                    matrix.set(Math.floor(i % rowLength), Math.floor(i / rowLength));\n                }\n            }\n            return matrix;\n        }\n        /**\n         * <p>Gets the requested bit, where true means black.</p>\n         *\n         * @param x The horizontal component (i.e. which column)\n         * @param y The vertical component (i.e. which row)\n         * @return value of given bit in matrix\n         */\n        get(x /*int*/, y /*int*/) {\n            const offset = y * this.rowSize + Math.floor(x / 32);\n            return ((this.bits[offset] >>> (x & 0x1f)) & 1) !== 0;\n        }\n        /**\n         * <p>Sets the given bit to true.</p>\n         *\n         * @param x The horizontal component (i.e. which column)\n         * @param y The vertical component (i.e. which row)\n         */\n        set(x /*int*/, y /*int*/) {\n            const offset = y * this.rowSize + Math.floor(x / 32);\n            this.bits[offset] |= (1 << (x & 0x1f)) & 0xFFFFFFFF;\n        }\n        unset(x /*int*/, y /*int*/) {\n            const offset = y * this.rowSize + Math.floor(x / 32);\n            this.bits[offset] &= ~((1 << (x & 0x1f)) & 0xFFFFFFFF);\n        }\n        /**\n         * <p>Flips the given bit.</p>\n         *\n         * @param x The horizontal component (i.e. which column)\n         * @param y The vertical component (i.e. which row)\n         */\n        flip(x /*int*/, y /*int*/) {\n            const offset = y * this.rowSize + Math.floor(x / 32);\n            this.bits[offset] ^= ((1 << (x & 0x1f)) & 0xFFFFFFFF);\n        }\n        /**\n         * Exclusive-or (XOR): Flip the bit in this {@code BitMatrix} if the corresponding\n         * mask bit is set.\n         *\n         * @param mask XOR mask\n         */\n        xor(mask) {\n            if (this.width !== mask.getWidth() || this.height !== mask.getHeight()\n                || this.rowSize !== mask.getRowSize()) {\n                throw new IllegalArgumentException('input matrix dimensions do not match');\n            }\n            const rowArray = new BitArray(Math.floor(this.width / 32) + 1);\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            for (let y = 0, height = this.height; y < height; y++) {\n                const offset = y * rowSize;\n                const row = mask.getRow(y, rowArray).getBitArray();\n                for (let x = 0; x < rowSize; x++) {\n                    bits[offset + x] ^= row[x];\n                }\n            }\n        }\n        /**\n         * Clears all bits (sets to false).\n         */\n        clear() {\n            const bits = this.bits;\n            const max = bits.length;\n            for (let i = 0; i < max; i++) {\n                bits[i] = 0;\n            }\n        }\n        /**\n         * <p>Sets a square region of the bit matrix to true.</p>\n         *\n         * @param left The horizontal position to begin at (inclusive)\n         * @param top The vertical position to begin at (inclusive)\n         * @param width The width of the region\n         * @param height The height of the region\n         */\n        setRegion(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n            if (top < 0 || left < 0) {\n                throw new IllegalArgumentException('Left and top must be nonnegative');\n            }\n            if (height < 1 || width < 1) {\n                throw new IllegalArgumentException('Height and width must be at least 1');\n            }\n            const right = left + width;\n            const bottom = top + height;\n            if (bottom > this.height || right > this.width) {\n                throw new IllegalArgumentException('The region must fit inside the matrix');\n            }\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            for (let y = top; y < bottom; y++) {\n                const offset = y * rowSize;\n                for (let x = left; x < right; x++) {\n                    bits[offset + Math.floor(x / 32)] |= ((1 << (x & 0x1f)) & 0xFFFFFFFF);\n                }\n            }\n        }\n        /**\n         * A fast method to retrieve one row of data from the matrix as a BitArray.\n         *\n         * @param y The row to retrieve\n         * @param row An optional caller-allocated BitArray, will be allocated if null or too small\n         * @return The resulting BitArray - this reference should always be used even when passing\n         *         your own row\n         */\n        getRow(y /*int*/, row) {\n            if (row === null || row === undefined || row.getSize() < this.width) {\n                row = new BitArray(this.width);\n            }\n            else {\n                row.clear();\n            }\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            const offset = y * rowSize;\n            for (let x = 0; x < rowSize; x++) {\n                row.setBulk(x * 32, bits[offset + x]);\n            }\n            return row;\n        }\n        /**\n         * @param y row to set\n         * @param row {@link BitArray} to copy from\n         */\n        setRow(y /*int*/, row) {\n            System.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);\n        }\n        /**\n         * Modifies this {@code BitMatrix} to represent the same but rotated 180 degrees\n         */\n        rotate180() {\n            const width = this.getWidth();\n            const height = this.getHeight();\n            let topRow = new BitArray(width);\n            let bottomRow = new BitArray(width);\n            for (let i = 0, length = Math.floor((height + 1) / 2); i < length; i++) {\n                topRow = this.getRow(i, topRow);\n                bottomRow = this.getRow(height - 1 - i, bottomRow);\n                topRow.reverse();\n                bottomRow.reverse();\n                this.setRow(i, bottomRow);\n                this.setRow(height - 1 - i, topRow);\n            }\n        }\n        /**\n         * This is useful in detecting the enclosing rectangle of a 'pure' barcode.\n         *\n         * @return {@code left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white\n         */\n        getEnclosingRectangle() {\n            const width = this.width;\n            const height = this.height;\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            let left = width;\n            let top = height;\n            let right = -1;\n            let bottom = -1;\n            for (let y = 0; y < height; y++) {\n                for (let x32 = 0; x32 < rowSize; x32++) {\n                    const theBits = bits[y * rowSize + x32];\n                    if (theBits !== 0) {\n                        if (y < top) {\n                            top = y;\n                        }\n                        if (y > bottom) {\n                            bottom = y;\n                        }\n                        if (x32 * 32 < left) {\n                            let bit = 0;\n                            while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {\n                                bit++;\n                            }\n                            if ((x32 * 32 + bit) < left) {\n                                left = x32 * 32 + bit;\n                            }\n                        }\n                        if (x32 * 32 + 31 > right) {\n                            let bit = 31;\n                            while ((theBits >>> bit) === 0) {\n                                bit--;\n                            }\n                            if ((x32 * 32 + bit) > right) {\n                                right = x32 * 32 + bit;\n                            }\n                        }\n                    }\n                }\n            }\n            if (right < left || bottom < top) {\n                return null;\n            }\n            return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);\n        }\n        /**\n         * This is useful in detecting a corner of a 'pure' barcode.\n         *\n         * @return {@code x,y} coordinate of top-left-most 1 bit, or null if it is all white\n         */\n        getTopLeftOnBit() {\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            let bitsOffset = 0;\n            while (bitsOffset < bits.length && bits[bitsOffset] === 0) {\n                bitsOffset++;\n            }\n            if (bitsOffset === bits.length) {\n                return null;\n            }\n            const y = bitsOffset / rowSize;\n            let x = (bitsOffset % rowSize) * 32;\n            const theBits = bits[bitsOffset];\n            let bit = 0;\n            while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {\n                bit++;\n            }\n            x += bit;\n            return Int32Array.from([x, y]);\n        }\n        getBottomRightOnBit() {\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            let bitsOffset = bits.length - 1;\n            while (bitsOffset >= 0 && bits[bitsOffset] === 0) {\n                bitsOffset--;\n            }\n            if (bitsOffset < 0) {\n                return null;\n            }\n            const y = Math.floor(bitsOffset / rowSize);\n            let x = Math.floor(bitsOffset % rowSize) * 32;\n            const theBits = bits[bitsOffset];\n            let bit = 31;\n            while ((theBits >>> bit) === 0) {\n                bit--;\n            }\n            x += bit;\n            return Int32Array.from([x, y]);\n        }\n        /**\n         * @return The width of the matrix\n         */\n        getWidth() {\n            return this.width;\n        }\n        /**\n         * @return The height of the matrix\n         */\n        getHeight() {\n            return this.height;\n        }\n        /**\n         * @return The row size of the matrix\n         */\n        getRowSize() {\n            return this.rowSize;\n        }\n        /*@Override*/\n        equals(o) {\n            if (!(o instanceof BitMatrix)) {\n                return false;\n            }\n            const other = o;\n            return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize &&\n                Arrays.equals(this.bits, other.bits);\n        }\n        /*@Override*/\n        hashCode() {\n            let hash = this.width;\n            hash = 31 * hash + this.width;\n            hash = 31 * hash + this.height;\n            hash = 31 * hash + this.rowSize;\n            hash = 31 * hash + Arrays.hashCode(this.bits);\n            return hash;\n        }\n        /**\n         * @return string representation using \"X\" for set and \" \" for unset bits\n         */\n        /*@Override*/\n        // public toString(): string {\n        //   return toString(\": \"X, \"  \")\n        // }\n        /**\n         * @param setString representation of a set bit\n         * @param unsetString representation of an unset bit\n         * @return string representation of entire matrix utilizing given strings\n         */\n        // public toString(setString: string = \"X \", unsetString: string = \"  \"): string {\n        //   return this.buildToString(setString, unsetString, \"\\n\")\n        // }\n        /**\n         * @param setString representation of a set bit\n         * @param unsetString representation of an unset bit\n         * @param lineSeparator newline character in string representation\n         * @return string representation of entire matrix utilizing given strings and line separator\n         * @deprecated call {@link #toString(String,String)} only, which uses \\n line separator always\n         */\n        // @Deprecated\n        toString(setString = 'X ', unsetString = '  ', lineSeparator = '\\n') {\n            return this.buildToString(setString, unsetString, lineSeparator);\n        }\n        buildToString(setString, unsetString, lineSeparator) {\n            let result = new StringBuilder();\n            // result.append(lineSeparator);\n            for (let y = 0, height = this.height; y < height; y++) {\n                for (let x = 0, width = this.width; x < width; x++) {\n                    result.append(this.get(x, y) ? setString : unsetString);\n                }\n                result.append(lineSeparator);\n            }\n            return result.toString();\n        }\n        /*@Override*/\n        clone() {\n            return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());\n        }\n    }\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class NotFoundException extends Exception {\n        static getNotFoundInstance() {\n            return new NotFoundException();\n        }\n    }\n    NotFoundException.kind = 'NotFoundException';\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable\n     * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding\n     * algorithm. However, because it picks a global black point, it cannot handle difficult shadows\n     * and gradients.\n     *\n     * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     */\n    class GlobalHistogramBinarizer extends Binarizer {\n        constructor(source) {\n            super(source);\n            this.luminances = GlobalHistogramBinarizer.EMPTY;\n            this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);\n        }\n        // Applies simple sharpening to the row data to improve performance of the 1D Readers.\n        /*@Override*/\n        getBlackRow(y /*int*/, row) {\n            const source = this.getLuminanceSource();\n            const width = source.getWidth();\n            if (row === undefined || row === null || row.getSize() < width) {\n                row = new BitArray(width);\n            }\n            else {\n                row.clear();\n            }\n            this.initArrays(width);\n            const localLuminances = source.getRow(y, this.luminances);\n            const localBuckets = this.buckets;\n            for (let x = 0; x < width; x++) {\n                localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n            }\n            const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n            if (width < 3) {\n                // Special case for very small images\n                for (let x = 0; x < width; x++) {\n                    if ((localLuminances[x] & 0xff) < blackPoint) {\n                        row.set(x);\n                    }\n                }\n            }\n            else {\n                let left = localLuminances[0] & 0xff;\n                let center = localLuminances[1] & 0xff;\n                for (let x = 1; x < width - 1; x++) {\n                    const right = localLuminances[x + 1] & 0xff;\n                    // A simple -1 4 -1 box filter with a weight of 2.\n                    if (((center * 4) - left - right) / 2 < blackPoint) {\n                        row.set(x);\n                    }\n                    left = center;\n                    center = right;\n                }\n            }\n            return row;\n        }\n        // Does not sharpen the data, as this call is intended to only be used by 2D Readers.\n        /*@Override*/\n        getBlackMatrix() {\n            const source = this.getLuminanceSource();\n            const width = source.getWidth();\n            const height = source.getHeight();\n            const matrix = new BitMatrix(width, height);\n            // Quickly calculates the histogram by sampling four rows from the image. This proved to be\n            // more robust on the blackbox tests than sampling a diagonal as we used to do.\n            this.initArrays(width);\n            const localBuckets = this.buckets;\n            for (let y = 1; y < 5; y++) {\n                const row = Math.floor((height * y) / 5);\n                const localLuminances = source.getRow(row, this.luminances);\n                const right = Math.floor((width * 4) / 5);\n                for (let x = Math.floor(width / 5); x < right; x++) {\n                    const pixel = localLuminances[x] & 0xff;\n                    localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n                }\n            }\n            const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n            // We delay reading the entire image luminance until the black point estimation succeeds.\n            // Although we end up reading four rows twice, it is consistent with our motto of\n            // \"fail quickly\" which is necessary for continuous scanning.\n            const localLuminances = source.getMatrix();\n            for (let y = 0; y < height; y++) {\n                const offset = y * width;\n                for (let x = 0; x < width; x++) {\n                    const pixel = localLuminances[offset + x] & 0xff;\n                    if (pixel < blackPoint) {\n                        matrix.set(x, y);\n                    }\n                }\n            }\n            return matrix;\n        }\n        /*@Override*/\n        createBinarizer(source) {\n            return new GlobalHistogramBinarizer(source);\n        }\n        initArrays(luminanceSize /*int*/) {\n            if (this.luminances.length < luminanceSize) {\n                this.luminances = new Uint8ClampedArray(luminanceSize);\n            }\n            const buckets = this.buckets;\n            for (let x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {\n                buckets[x] = 0;\n            }\n        }\n        static estimateBlackPoint(buckets) {\n            // Find the tallest peak in the histogram.\n            const numBuckets = buckets.length;\n            let maxBucketCount = 0;\n            let firstPeak = 0;\n            let firstPeakSize = 0;\n            for (let x = 0; x < numBuckets; x++) {\n                if (buckets[x] > firstPeakSize) {\n                    firstPeak = x;\n                    firstPeakSize = buckets[x];\n                }\n                if (buckets[x] > maxBucketCount) {\n                    maxBucketCount = buckets[x];\n                }\n            }\n            // Find the second-tallest peak which is somewhat far from the tallest peak.\n            let secondPeak = 0;\n            let secondPeakScore = 0;\n            for (let x = 0; x < numBuckets; x++) {\n                const distanceToBiggest = x - firstPeak;\n                // Encourage more distant second peaks by multiplying by square of distance.\n                const score = buckets[x] * distanceToBiggest * distanceToBiggest;\n                if (score > secondPeakScore) {\n                    secondPeak = x;\n                    secondPeakScore = score;\n                }\n            }\n            // Make sure firstPeak corresponds to the black peak.\n            if (firstPeak > secondPeak) {\n                const temp = firstPeak;\n                firstPeak = secondPeak;\n                secondPeak = temp;\n            }\n            // If there is too little contrast in the image to pick a meaningful black point, throw rather\n            // than waste time trying to decode the image, and risk false positives.\n            if (secondPeak - firstPeak <= numBuckets / 16) {\n                throw new NotFoundException();\n            }\n            // Find a valley between them that is low and closer to the white peak.\n            let bestValley = secondPeak - 1;\n            let bestValleyScore = -1;\n            for (let x = secondPeak - 1; x > firstPeak; x--) {\n                const fromFirst = x - firstPeak;\n                const score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);\n                if (score > bestValleyScore) {\n                    bestValley = x;\n                    bestValleyScore = score;\n                }\n            }\n            return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;\n        }\n    }\n    GlobalHistogramBinarizer.LUMINANCE_BITS = 5;\n    GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;\n    GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;\n    GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * This class implements a local thresholding algorithm, which while slower than the\n     * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for\n     * high frequency images of barcodes with black data on white backgrounds. For this application,\n     * it does a much better job than a global blackpoint with severe shadows and gradients.\n     * However it tends to produce artifacts on lower frequency images and is therefore not\n     * a good general purpose binarizer for uses outside ZXing.\n     *\n     * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,\n     * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already\n     * inherently local, and only fails for horizontal gradients. We can revisit that problem later,\n     * but for now it was not a win to use local blocks for 1D.\n     *\n     * This Binarizer is the default for the unit tests and the recommended class for library users.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class HybridBinarizer extends GlobalHistogramBinarizer {\n        constructor(source) {\n            super(source);\n            this.matrix = null;\n        }\n        /**\n         * Calculates the final BitMatrix once for all requests. This could be called once from the\n         * constructor instead, but there are some advantages to doing it lazily, such as making\n         * profiling easier, and not doing heavy lifting when callers don't expect it.\n         */\n        /*@Override*/\n        getBlackMatrix() {\n            if (this.matrix !== null) {\n                return this.matrix;\n            }\n            const source = this.getLuminanceSource();\n            const width = source.getWidth();\n            const height = source.getHeight();\n            if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {\n                const luminances = source.getMatrix();\n                let subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;\n                if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n                    subWidth++;\n                }\n                let subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;\n                if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n                    subHeight++;\n                }\n                const blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);\n                const newMatrix = new BitMatrix(width, height);\n                HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);\n                this.matrix = newMatrix;\n            }\n            else {\n                // If the image is too small, fall back to the global histogram approach.\n                this.matrix = super.getBlackMatrix();\n            }\n            return this.matrix;\n        }\n        /*@Override*/\n        createBinarizer(source) {\n            return new HybridBinarizer(source);\n        }\n        /**\n         * For each block in the image, calculate the average black point using a 5x5 grid\n         * of the blocks around it. Also handles the corner cases (fractional blocks are computed based\n         * on the last pixels in the row/column which are also used in the previous block).\n         */\n        static calculateThresholdForBlock(luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/, blackPoints, matrix) {\n            const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n            const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n            for (let y = 0; y < subHeight; y++) {\n                let yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n                if (yoffset > maxYOffset) {\n                    yoffset = maxYOffset;\n                }\n                const top = HybridBinarizer.cap(y, 2, subHeight - 3);\n                for (let x = 0; x < subWidth; x++) {\n                    let xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n                    if (xoffset > maxXOffset) {\n                        xoffset = maxXOffset;\n                    }\n                    const left = HybridBinarizer.cap(x, 2, subWidth - 3);\n                    let sum = 0;\n                    for (let z = -2; z <= 2; z++) {\n                        const blackRow = blackPoints[top + z];\n                        sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n                    }\n                    const average = sum / 25;\n                    HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n                }\n            }\n        }\n        static cap(value /*int*/, min /*int*/, max /*int*/) {\n            return value < min ? min : value > max ? max : value;\n        }\n        /**\n         * Applies a single threshold to a block of pixels.\n         */\n        static thresholdBlock(luminances, xoffset /*int*/, yoffset /*int*/, threshold /*int*/, stride /*int*/, matrix) {\n            for (let y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {\n                for (let x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {\n                    // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.\n                    if ((luminances[offset + x] & 0xFF) <= threshold) {\n                        matrix.set(xoffset + x, yoffset + y);\n                    }\n                }\n            }\n        }\n        /**\n         * Calculates a single black point for each block of pixels and saves it away.\n         * See the following thread for a discussion of this algorithm:\n         *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0\n         */\n        static calculateBlackPoints(luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/) {\n            const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n            const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n            // tslint:disable-next-line:whitespace\n            const blackPoints = new Array(subHeight); // subWidth\n            for (let y = 0; y < subHeight; y++) {\n                blackPoints[y] = new Int32Array(subWidth);\n                let yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n                if (yoffset > maxYOffset) {\n                    yoffset = maxYOffset;\n                }\n                for (let x = 0; x < subWidth; x++) {\n                    let xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n                    if (xoffset > maxXOffset) {\n                        xoffset = maxXOffset;\n                    }\n                    let sum = 0;\n                    let min = 0xFF;\n                    let max = 0;\n                    for (let yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n                        for (let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n                            const pixel = luminances[offset + xx] & 0xFF;\n                            sum += pixel;\n                            // still looking for good contrast\n                            if (pixel < min) {\n                                min = pixel;\n                            }\n                            if (pixel > max) {\n                                max = pixel;\n                            }\n                        }\n                        // short-circuit min/max tests once dynamic range is met\n                        if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {\n                            // finish the rest of the rows quickly\n                            for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n                                for (let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n                                    sum += luminances[offset + xx] & 0xFF;\n                                }\n                            }\n                        }\n                    }\n                    // The default estimate is the average of the values in the block.\n                    let average = sum >> (HybridBinarizer.BLOCK_SIZE_POWER * 2);\n                    if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {\n                        // If variation within the block is low, assume this is a block with only light or only\n                        // dark pixels. In that case we do not want to use the average, as it would divide this\n                        // low contrast area into black and white pixels, essentially creating data out of noise.\n                        //\n                        // The default assumption is that the block is light/background. Since no estimate for\n                        // the level of dark pixels exists locally, use half the min for the block.\n                        average = min / 2;\n                        if (y > 0 && x > 0) {\n                            // Correct the \"white background\" assumption for blocks that have neighbors by comparing\n                            // the pixels in this block to the previously calculated black points. This is based on\n                            // the fact that dark barcode symbology is always surrounded by some amount of light\n                            // background for which reasonable black point estimates were made. The bp estimated at\n                            // the boundaries is used for the interior.\n                            // The (min < bp) is arbitrary but works better than other heuristics that were tried.\n                            const averageNeighborBlackPoint = (blackPoints[y - 1][x] + (2 * blackPoints[y][x - 1]) + blackPoints[y - 1][x - 1]) / 4;\n                            if (min < averageNeighborBlackPoint) {\n                                average = averageNeighborBlackPoint;\n                            }\n                        }\n                    }\n                    blackPoints[y][x] = average;\n                }\n            }\n            return blackPoints;\n        }\n    }\n    // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels.\n    // So this is the smallest dimension in each axis we can accept.\n    HybridBinarizer.BLOCK_SIZE_POWER = 3;\n    HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER; // ...0100...00\n    HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1; // ...0011...11\n    HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;\n    HybridBinarizer.MIN_DYNAMIC_RANGE = 24;\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing {*/\n    /**\n     * The purpose of this class hierarchy is to abstract different bitmap implementations across\n     * platforms into a standard interface for requesting greyscale luminance values. The interface\n     * only provides immutable methods; therefore crop and rotation create copies. This is to ensure\n     * that one Reader does not modify the original luminance source and leave it in an unknown state\n     * for other Readers in the chain.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class LuminanceSource {\n        constructor(width /*int*/, height /*int*/) {\n            this.width = width;\n            this.height = height;\n        }\n        /**\n         * @return The width of the bitmap.\n         */\n        getWidth() {\n            return this.width;\n        }\n        /**\n         * @return The height of the bitmap.\n         */\n        getHeight() {\n            return this.height;\n        }\n        /**\n         * @return Whether this subclass supports cropping.\n         */\n        isCropSupported() {\n            return false;\n        }\n        /**\n         * Returns a new object with cropped image data. Implementations may keep a reference to the\n         * original data rather than a copy. Only callable if isCropSupported() is true.\n         *\n         * @param left The left coordinate, which must be in [0,getWidth())\n         * @param top The top coordinate, which must be in [0,getHeight())\n         * @param width The width of the rectangle to crop.\n         * @param height The height of the rectangle to crop.\n         * @return A cropped version of this object.\n         */\n        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n            throw new UnsupportedOperationException('This luminance source does not support cropping.');\n        }\n        /**\n         * @return Whether this subclass supports counter-clockwise rotation.\n         */\n        isRotateSupported() {\n            return false;\n        }\n        /**\n         * Returns a new object with rotated image data by 90 degrees counterclockwise.\n         * Only callable if {@link #isRotateSupported()} is true.\n         *\n         * @return A rotated version of this object.\n         */\n        rotateCounterClockwise() {\n            throw new UnsupportedOperationException('This luminance source does not support rotation by 90 degrees.');\n        }\n        /**\n         * Returns a new object with rotated image data by 45 degrees counterclockwise.\n         * Only callable if {@link #isRotateSupported()} is true.\n         *\n         * @return A rotated version of this object.\n         */\n        rotateCounterClockwise45() {\n            throw new UnsupportedOperationException('This luminance source does not support rotation by 45 degrees.');\n        }\n        /*@Override*/\n        toString() {\n            const row = new Uint8ClampedArray(this.width);\n            let result = new StringBuilder();\n            for (let y = 0; y < this.height; y++) {\n                const sourceRow = this.getRow(y, row);\n                for (let x = 0; x < this.width; x++) {\n                    const luminance = sourceRow[x] & 0xFF;\n                    let c;\n                    if (luminance < 0x40) {\n                        c = '#';\n                    }\n                    else if (luminance < 0x80) {\n                        c = '+';\n                    }\n                    else if (luminance < 0xC0) {\n                        c = '.';\n                    }\n                    else {\n                        c = ' ';\n                    }\n                    result.append(c);\n                }\n                result.append('\\n');\n            }\n            return result.toString();\n        }\n    }\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing {*/\n    /**\n     * A wrapper implementation of {@link LuminanceSource} which inverts the luminances it returns -- black becomes\n     * white and vice versa, and each value becomes (255-value).\n     *\n     * @author Sean Owen\n     */\n    class InvertedLuminanceSource extends LuminanceSource {\n        constructor(delegate) {\n            super(delegate.getWidth(), delegate.getHeight());\n            this.delegate = delegate;\n        }\n        /*@Override*/\n        getRow(y /*int*/, row) {\n            const sourceRow = this.delegate.getRow(y, row);\n            const width = this.getWidth();\n            for (let i = 0; i < width; i++) {\n                sourceRow[i] = /*(byte)*/ (255 - (sourceRow[i] & 0xFF));\n            }\n            return sourceRow;\n        }\n        /*@Override*/\n        getMatrix() {\n            const matrix = this.delegate.getMatrix();\n            const length = this.getWidth() * this.getHeight();\n            const invertedMatrix = new Uint8ClampedArray(length);\n            for (let i = 0; i < length; i++) {\n                invertedMatrix[i] = /*(byte)*/ (255 - (matrix[i] & 0xFF));\n            }\n            return invertedMatrix;\n        }\n        /*@Override*/\n        isCropSupported() {\n            return this.delegate.isCropSupported();\n        }\n        /*@Override*/\n        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n            return new InvertedLuminanceSource(this.delegate.crop(left, top, width, height));\n        }\n        /*@Override*/\n        isRotateSupported() {\n            return this.delegate.isRotateSupported();\n        }\n        /**\n         * @return original delegate {@link LuminanceSource} since invert undoes itself\n         */\n        /*@Override*/\n        invert() {\n            return this.delegate;\n        }\n        /*@Override*/\n        rotateCounterClockwise() {\n            return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise());\n        }\n        /*@Override*/\n        rotateCounterClockwise45() {\n            return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise45());\n        }\n    }\n\n    /**\n     * @deprecated Moving to @zxing/browser\n     */\n    class HTMLCanvasElementLuminanceSource extends LuminanceSource {\n        constructor(canvas) {\n            super(canvas.width, canvas.height);\n            this.canvas = canvas;\n            this.tempCanvasElement = null;\n            this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas);\n        }\n        static makeBufferFromCanvasImageData(canvas) {\n            const imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);\n            return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);\n        }\n        static toGrayscaleBuffer(imageBuffer, width, height) {\n            const grayscaleBuffer = new Uint8ClampedArray(width * height);\n            for (let i = 0, j = 0, length = imageBuffer.length; i < length; i += 4, j++) {\n                let gray;\n                const alpha = imageBuffer[i + 3];\n                // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent\n                // black (0 alpha, and then 0 RGB). They are often used, of course as the \"white\" area in a\n                // barcode image. Force any such pixel to be white:\n                if (alpha === 0) {\n                    gray = 0xFF;\n                }\n                else {\n                    const pixelR = imageBuffer[i];\n                    const pixelG = imageBuffer[i + 1];\n                    const pixelB = imageBuffer[i + 2];\n                    // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC),\n                    // (306*R) >> 10 is approximately equal to R*0.299, and so on.\n                    // 0x200 >> 10 is 0.5, it implements rounding.\n                    gray = (306 * pixelR +\n                        601 * pixelG +\n                        117 * pixelB +\n                        0x200) >> 10;\n                }\n                grayscaleBuffer[j] = gray;\n            }\n            return grayscaleBuffer;\n        }\n        getRow(y /*int*/, row) {\n            if (y < 0 || y >= this.getHeight()) {\n                throw new IllegalArgumentException('Requested row is outside the image: ' + y);\n            }\n            const width = this.getWidth();\n            const start = y * width;\n            if (row === null) {\n                row = this.buffer.slice(start, start + width);\n            }\n            else {\n                if (row.length < width) {\n                    row = new Uint8ClampedArray(width);\n                }\n                // The underlying raster of image consists of bytes with the luminance values\n                // TODO: can avoid set/slice?\n                row.set(this.buffer.slice(start, start + width));\n            }\n            return row;\n        }\n        getMatrix() {\n            return this.buffer;\n        }\n        isCropSupported() {\n            return true;\n        }\n        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n            super.crop(left, top, width, height);\n            return this;\n        }\n        /**\n         * This is always true, since the image is a gray-scale image.\n         *\n         * @return true\n         */\n        isRotateSupported() {\n            return true;\n        }\n        rotateCounterClockwise() {\n            this.rotate(-90);\n            return this;\n        }\n        rotateCounterClockwise45() {\n            this.rotate(-45);\n            return this;\n        }\n        getTempCanvasElement() {\n            if (null === this.tempCanvasElement) {\n                const tempCanvasElement = this.canvas.ownerDocument.createElement('canvas');\n                tempCanvasElement.width = this.canvas.width;\n                tempCanvasElement.height = this.canvas.height;\n                this.tempCanvasElement = tempCanvasElement;\n            }\n            return this.tempCanvasElement;\n        }\n        rotate(angle) {\n            const tempCanvasElement = this.getTempCanvasElement();\n            const tempContext = tempCanvasElement.getContext('2d');\n            const angleRadians = angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS;\n            // Calculate and set new dimensions for temp canvas\n            const width = this.canvas.width;\n            const height = this.canvas.height;\n            const newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);\n            const newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);\n            tempCanvasElement.width = newWidth;\n            tempCanvasElement.height = newHeight;\n            // Draw at center of temp canvas to prevent clipping of image data\n            tempContext.translate(newWidth / 2, newHeight / 2);\n            tempContext.rotate(angleRadians);\n            tempContext.drawImage(this.canvas, width / -2, height / -2);\n            this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);\n            return this;\n        }\n        invert() {\n            return new InvertedLuminanceSource(this);\n        }\n    }\n    HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;\n\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * Video input device metadata containing the id and label of the device if available.\n     */\n    class VideoInputDevice {\n        /**\n         * Creates an instance of VideoInputDevice.\n         *\n         * @param {string} deviceId the video input device id\n         * @param {string} label the label of the device if available\n         */\n        constructor(deviceId, label, groupId) {\n            this.deviceId = deviceId;\n            this.label = label;\n            /** @inheritdoc */\n            this.kind = 'videoinput';\n            this.groupId = groupId || undefined;\n        }\n        /** @inheritdoc */\n        toJSON() {\n            return {\n                kind: this.kind,\n                groupId: this.groupId,\n                deviceId: this.deviceId,\n                label: this.label,\n            };\n        }\n    }\n\n    var __awaiter = ((globalThis || __webpack_require__.g || self || window || undefined) && (globalThis || __webpack_require__.g || self || window || undefined).__awaiter) || function (thisArg, _arguments, P, generator) {\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n        return new (P || (P = Promise))(function (resolve, reject) {\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n    };\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * Base class for browser code reader.\n     */\n    class BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserCodeReader.\n         * @param {Reader} reader The reader instance to decode the barcode\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent successful decode tries\n         *\n         * @memberOf BrowserCodeReader\n         */\n        constructor(reader, timeBetweenScansMillis = 500, _hints) {\n            this.reader = reader;\n            this.timeBetweenScansMillis = timeBetweenScansMillis;\n            this._hints = _hints;\n            /**\n             * This will break the loop.\n             */\n            this._stopContinuousDecode = false;\n            /**\n             * This will break the loop.\n             */\n            this._stopAsyncDecode = false;\n            /**\n             * Delay time between decode attempts made by the scanner.\n             */\n            this._timeBetweenDecodingAttempts = 0;\n        }\n        /**\n         * If navigator is present.\n         */\n        get hasNavigator() {\n            return typeof navigator !== 'undefined';\n        }\n        /**\n         * If mediaDevices under navigator is supported.\n         */\n        get isMediaDevicesSuported() {\n            return this.hasNavigator && !!navigator.mediaDevices;\n        }\n        /**\n         * If enumerateDevices under navigator is supported.\n         */\n        get canEnumerateDevices() {\n            return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);\n        }\n        /** Time between two decoding tries in milli seconds. */\n        get timeBetweenDecodingAttempts() {\n            return this._timeBetweenDecodingAttempts;\n        }\n        /**\n         * Change the time span the decoder waits between two decoding tries.\n         *\n         * @param {number} millis Time between two decoding tries in milli seconds.\n         */\n        set timeBetweenDecodingAttempts(millis) {\n            this._timeBetweenDecodingAttempts = millis < 0 ? 0 : millis;\n        }\n        /**\n         * Sets the hints.\n         */\n        set hints(hints) {\n            this._hints = hints || null;\n        }\n        /**\n         * Sets the hints.\n         */\n        get hints() {\n            return this._hints;\n        }\n        /**\n         * Lists all the available video input devices.\n         */\n        listVideoInputDevices() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!this.hasNavigator) {\n                    throw new Error('Can\\'t enumerate devices, navigator is not present.');\n                }\n                if (!this.canEnumerateDevices) {\n                    throw new Error('Can\\'t enumerate devices, method not supported.');\n                }\n                const devices = yield navigator.mediaDevices.enumerateDevices();\n                const videoDevices = [];\n                for (const device of devices) {\n                    const kind = device.kind === 'video' ? 'videoinput' : device.kind;\n                    if (kind !== 'videoinput') {\n                        continue;\n                    }\n                    const deviceId = device.deviceId || device.id;\n                    const label = device.label || `Video device ${videoDevices.length + 1}`;\n                    const groupId = device.groupId;\n                    const videoDevice = { deviceId, label, kind, groupId };\n                    videoDevices.push(videoDevice);\n                }\n                return videoDevices;\n            });\n        }\n        /**\n         * Obtain the list of available devices with type 'videoinput'.\n         *\n         * @returns {Promise<VideoInputDevice[]>} an array of available video input devices\n         *\n         * @memberOf BrowserCodeReader\n         *\n         * @deprecated Use `listVideoInputDevices` instead.\n         */\n        getVideoInputDevices() {\n            return __awaiter(this, void 0, void 0, function* () {\n                const devices = yield this.listVideoInputDevices();\n                return devices.map(d => new VideoInputDevice(d.deviceId, d.label));\n            });\n        }\n        /**\n         * Let's you find a device using it's Id.\n         */\n        findDeviceById(deviceId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const devices = yield this.listVideoInputDevices();\n                if (!devices) {\n                    return null;\n                }\n                return devices.find(x => x.deviceId === deviceId);\n            });\n        }\n        /**\n         * Decodes the barcode from the device specified by deviceId while showing the video in the specified video element.\n         *\n         * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n         * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         *\n         * @deprecated Use `decodeOnceFromVideoDevice` instead.\n         */\n        decodeFromInputVideoDevice(deviceId, videoSource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return yield this.decodeOnceFromVideoDevice(deviceId, videoSource);\n            });\n        }\n        /**\n         * In one attempt, tries to decode the barcode from the device specified by deviceId while showing the video in the specified video element.\n         *\n         * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n         * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeOnceFromVideoDevice(deviceId, videoSource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.reset();\n                let videoConstraints;\n                if (!deviceId) {\n                    videoConstraints = { facingMode: 'environment' };\n                }\n                else {\n                    videoConstraints = { deviceId: { exact: deviceId } };\n                }\n                const constraints = { video: videoConstraints };\n                return yield this.decodeOnceFromConstraints(constraints, videoSource);\n            });\n        }\n        /**\n         * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n         *\n         * @param constraints the media stream constraints to get s valid media stream to decode from\n         * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeOnceFromConstraints(constraints, videoSource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const stream = yield navigator.mediaDevices.getUserMedia(constraints);\n                return yield this.decodeOnceFromStream(stream, videoSource);\n            });\n        }\n        /**\n         * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n         *\n         * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from\n         * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeOnceFromStream(stream, videoSource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.reset();\n                const video = yield this.attachStreamToVideo(stream, videoSource);\n                const result = yield this.decodeOnce(video);\n                return result;\n            });\n        }\n        /**\n         * Continuously decodes the barcode from the device specified by device while showing the video in the specified video element.\n         *\n         * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n         * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns {Promise<void>}\n         *\n         * @memberOf BrowserCodeReader\n         *\n         * @deprecated Use `decodeFromVideoDevice` instead.\n         */\n        decodeFromInputVideoDeviceContinuously(deviceId, videoSource, callbackFn) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return yield this.decodeFromVideoDevice(deviceId, videoSource, callbackFn);\n            });\n        }\n        /**\n         * Continuously tries to decode the barcode from the device specified by device while showing the video in the specified video element.\n         *\n         * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n         * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns {Promise<void>}\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeFromVideoDevice(deviceId, videoSource, callbackFn) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let videoConstraints;\n                if (!deviceId) {\n                    videoConstraints = { facingMode: 'environment' };\n                }\n                else {\n                    videoConstraints = { deviceId: { exact: deviceId } };\n                }\n                const constraints = { video: videoConstraints };\n                return yield this.decodeFromConstraints(constraints, videoSource, callbackFn);\n            });\n        }\n        /**\n         * Continuously tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n         *\n         * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from\n         * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeFromConstraints(constraints, videoSource, callbackFn) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const stream = yield navigator.mediaDevices.getUserMedia(constraints);\n                return yield this.decodeFromStream(stream, videoSource, callbackFn);\n            });\n        }\n        /**\n         * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n         *\n         * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from\n         * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeFromStream(stream, videoSource, callbackFn) {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.reset();\n                const video = yield this.attachStreamToVideo(stream, videoSource);\n                return yield this.decodeContinuously(video, callbackFn);\n            });\n        }\n        /**\n         * Breaks the decoding loop.\n         */\n        stopAsyncDecode() {\n            this._stopAsyncDecode = true;\n        }\n        /**\n         * Breaks the decoding loop.\n         */\n        stopContinuousDecode() {\n            this._stopContinuousDecode = true;\n        }\n        /**\n         * Sets the new stream and request a new decoding-with-delay.\n         *\n         * @param stream The stream to be shown in the video element.\n         * @param decodeFn A callback for the decode method.\n         */\n        attachStreamToVideo(stream, videoSource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const videoElement = this.prepareVideoElement(videoSource);\n                this.addVideoSource(videoElement, stream);\n                this.videoElement = videoElement;\n                this.stream = stream;\n                yield this.playVideoOnLoadAsync(videoElement);\n                return videoElement;\n            });\n        }\n        /**\n         *\n         * @param videoElement\n         */\n        playVideoOnLoadAsync(videoElement) {\n            return new Promise((resolve, reject) => this.playVideoOnLoad(videoElement, () => resolve()));\n        }\n        /**\n         * Binds listeners and callbacks to the videoElement.\n         *\n         * @param element\n         * @param callbackFn\n         */\n        playVideoOnLoad(element, callbackFn) {\n            this.videoEndedListener = () => this.stopStreams();\n            this.videoCanPlayListener = () => this.tryPlayVideo(element);\n            element.addEventListener('ended', this.videoEndedListener);\n            element.addEventListener('canplay', this.videoCanPlayListener);\n            element.addEventListener('playing', callbackFn);\n            // if canplay was already fired, we won't know when to play, so just give it a try\n            this.tryPlayVideo(element);\n        }\n        /**\n         * Checks if the given video element is currently playing.\n         */\n        isVideoPlaying(video) {\n            return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;\n        }\n        /**\n         * Just tries to play the video and logs any errors.\n         * The play call is only made is the video is not already playing.\n         */\n        tryPlayVideo(videoElement) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (this.isVideoPlaying(videoElement)) {\n                    console.warn('Trying to play video that is already playing.');\n                    return;\n                }\n                try {\n                    yield videoElement.play();\n                }\n                catch (_a) {\n                    console.warn('It was not possible to play the video.');\n                }\n            });\n        }\n        /**\n         * Searches and validates a media element.\n         */\n        getMediaElement(mediaElementId, type) {\n            const mediaElement = document.getElementById(mediaElementId);\n            if (!mediaElement) {\n                throw new ArgumentException(`element with id '${mediaElementId}' not found`);\n            }\n            if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {\n                throw new ArgumentException(`element with id '${mediaElementId}' must be an ${type} element`);\n            }\n            return mediaElement;\n        }\n        /**\n         * Decodes the barcode from an image.\n         *\n         * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.\n         * @param {string} [url]\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeFromImage(source, url) {\n            if (!source && !url) {\n                throw new ArgumentException('either imageElement with a src set or an url must be provided');\n            }\n            if (url && !source) {\n                return this.decodeFromImageUrl(url);\n            }\n            return this.decodeFromImageElement(source);\n        }\n        /**\n         * Decodes the barcode from a video.\n         *\n         * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.\n         * @param {string} [url]\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeFromVideo(source, url) {\n            if (!source && !url) {\n                throw new ArgumentException('Either an element with a src set or an URL must be provided');\n            }\n            if (url && !source) {\n                return this.decodeFromVideoUrl(url);\n            }\n            return this.decodeFromVideoElement(source);\n        }\n        /**\n         * Decodes continuously the barcode from a video.\n         *\n         * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.\n         * @param {string} [url]\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         *\n         * @experimental\n         */\n        decodeFromVideoContinuously(source, url, callbackFn) {\n            if (undefined === source && undefined === url) {\n                throw new ArgumentException('Either an element with a src set or an URL must be provided');\n            }\n            if (url && !source) {\n                return this.decodeFromVideoUrlContinuously(url, callbackFn);\n            }\n            return this.decodeFromVideoElementContinuously(source, callbackFn);\n        }\n        /**\n         * Decodes something from an image HTML element.\n         */\n        decodeFromImageElement(source) {\n            if (!source) {\n                throw new ArgumentException('An image element must be provided.');\n            }\n            this.reset();\n            const element = this.prepareImageElement(source);\n            this.imageElement = element;\n            let task;\n            if (this.isImageLoaded(element)) {\n                task = this.decodeOnce(element, false, true);\n            }\n            else {\n                task = this._decodeOnLoadImage(element);\n            }\n            return task;\n        }\n        /**\n         * Decodes something from an image HTML element.\n         */\n        decodeFromVideoElement(source) {\n            const element = this._decodeFromVideoElementSetup(source);\n            return this._decodeOnLoadVideo(element);\n        }\n        /**\n         * Decodes something from an image HTML element.\n         */\n        decodeFromVideoElementContinuously(source, callbackFn) {\n            const element = this._decodeFromVideoElementSetup(source);\n            return this._decodeOnLoadVideoContinuously(element, callbackFn);\n        }\n        /**\n         * Sets up the video source so it can be decoded when loaded.\n         *\n         * @param source The video source element.\n         */\n        _decodeFromVideoElementSetup(source) {\n            if (!source) {\n                throw new ArgumentException('A video element must be provided.');\n            }\n            this.reset();\n            const element = this.prepareVideoElement(source);\n            // defines the video element before starts decoding\n            this.videoElement = element;\n            return element;\n        }\n        /**\n         * Decodes an image from a URL.\n         */\n        decodeFromImageUrl(url) {\n            if (!url) {\n                throw new ArgumentException('An URL must be provided.');\n            }\n            this.reset();\n            const element = this.prepareImageElement();\n            this.imageElement = element;\n            const decodeTask = this._decodeOnLoadImage(element);\n            element.src = url;\n            return decodeTask;\n        }\n        /**\n         * Decodes an image from a URL.\n         */\n        decodeFromVideoUrl(url) {\n            if (!url) {\n                throw new ArgumentException('An URL must be provided.');\n            }\n            this.reset();\n            // creates a new element\n            const element = this.prepareVideoElement();\n            const decodeTask = this.decodeFromVideoElement(element);\n            element.src = url;\n            return decodeTask;\n        }\n        /**\n         * Decodes an image from a URL.\n         *\n         * @experimental\n         */\n        decodeFromVideoUrlContinuously(url, callbackFn) {\n            if (!url) {\n                throw new ArgumentException('An URL must be provided.');\n            }\n            this.reset();\n            // creates a new element\n            const element = this.prepareVideoElement();\n            const decodeTask = this.decodeFromVideoElementContinuously(element, callbackFn);\n            element.src = url;\n            return decodeTask;\n        }\n        _decodeOnLoadImage(element) {\n            return new Promise((resolve, reject) => {\n                this.imageLoadedListener = () => this.decodeOnce(element, false, true).then(resolve, reject);\n                element.addEventListener('load', this.imageLoadedListener);\n            });\n        }\n        _decodeOnLoadVideo(videoElement) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // plays the video\n                yield this.playVideoOnLoadAsync(videoElement);\n                // starts decoding after played the video\n                return yield this.decodeOnce(videoElement);\n            });\n        }\n        _decodeOnLoadVideoContinuously(videoElement, callbackFn) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // plays the video\n                yield this.playVideoOnLoadAsync(videoElement);\n                // starts decoding after played the video\n                this.decodeContinuously(videoElement, callbackFn);\n            });\n        }\n        isImageLoaded(img) {\n            // During the onload event, IE correctly identifies any images that\n            // weren’t downloaded as not complete. Others should too. Gecko-based\n            // browsers act like NS4 in that they report this incorrectly.\n            if (!img.complete) {\n                return false;\n            }\n            // However, they do have two very useful properties: naturalWidth and\n            // naturalHeight. These give the true size of the image. If it failed\n            // to load, either of these should be zero.\n            if (img.naturalWidth === 0) {\n                return false;\n            }\n            // No other way of checking: assume it’s ok.\n            return true;\n        }\n        prepareImageElement(imageSource) {\n            let imageElement;\n            if (typeof imageSource === 'undefined') {\n                imageElement = document.createElement('img');\n                imageElement.width = 200;\n                imageElement.height = 200;\n            }\n            if (typeof imageSource === 'string') {\n                imageElement = this.getMediaElement(imageSource, 'img');\n            }\n            if (imageSource instanceof HTMLImageElement) {\n                imageElement = imageSource;\n            }\n            return imageElement;\n        }\n        /**\n         * Sets a HTMLVideoElement for scanning or creates a new one.\n         *\n         * @param videoSource The HTMLVideoElement to be set.\n         */\n        prepareVideoElement(videoSource) {\n            let videoElement;\n            if (!videoSource && typeof document !== 'undefined') {\n                videoElement = document.createElement('video');\n                videoElement.width = 200;\n                videoElement.height = 200;\n            }\n            if (typeof videoSource === 'string') {\n                videoElement = this.getMediaElement(videoSource, 'video');\n            }\n            if (videoSource instanceof HTMLVideoElement) {\n                videoElement = videoSource;\n            }\n            // Needed for iOS 11\n            videoElement.setAttribute('autoplay', 'true');\n            videoElement.setAttribute('muted', 'true');\n            videoElement.setAttribute('playsinline', 'true');\n            return videoElement;\n        }\n        /**\n         * Tries to decode from the video input until it finds some value.\n         */\n        decodeOnce(element, retryIfNotFound = true, retryIfChecksumOrFormatError = true) {\n            this._stopAsyncDecode = false;\n            const loop = (resolve, reject) => {\n                if (this._stopAsyncDecode) {\n                    reject(new NotFoundException('Video stream has ended before any code could be detected.'));\n                    this._stopAsyncDecode = undefined;\n                    return;\n                }\n                try {\n                    const result = this.decode(element);\n                    resolve(result);\n                }\n                catch (e) {\n                    const ifNotFound = retryIfNotFound && e instanceof NotFoundException;\n                    const isChecksumOrFormatError = e instanceof ChecksumException || e instanceof FormatException;\n                    const ifChecksumOrFormat = isChecksumOrFormatError && retryIfChecksumOrFormatError;\n                    if (ifNotFound || ifChecksumOrFormat) {\n                        // trying again\n                        return setTimeout(loop, this._timeBetweenDecodingAttempts, resolve, reject);\n                    }\n                    reject(e);\n                }\n            };\n            return new Promise((resolve, reject) => loop(resolve, reject));\n        }\n        /**\n         * Continuously decodes from video input.\n         */\n        decodeContinuously(element, callbackFn) {\n            this._stopContinuousDecode = false;\n            const loop = () => {\n                if (this._stopContinuousDecode) {\n                    this._stopContinuousDecode = undefined;\n                    return;\n                }\n                try {\n                    const result = this.decode(element);\n                    callbackFn(result, null);\n                    setTimeout(loop, this.timeBetweenScansMillis);\n                }\n                catch (e) {\n                    callbackFn(null, e);\n                    const isChecksumOrFormatError = e instanceof ChecksumException || e instanceof FormatException;\n                    const isNotFound = e instanceof NotFoundException;\n                    if (isChecksumOrFormatError || isNotFound) {\n                        // trying again\n                        setTimeout(loop, this._timeBetweenDecodingAttempts);\n                    }\n                }\n            };\n            loop();\n        }\n        /**\n         * Gets the BinaryBitmap for ya! (and decodes it)\n         */\n        decode(element) {\n            // get binary bitmap for decode function\n            const binaryBitmap = this.createBinaryBitmap(element);\n            return this.decodeBitmap(binaryBitmap);\n        }\n        /**\n         * Returns true if media element is indeed a {@link HtmlVideoElement}.\n         */\n        _isHTMLVideoElement(mediaElement) {\n            const potentialVideo = mediaElement;\n            return potentialVideo.videoWidth !== 0;\n        }\n        /**\n         * Overwriting this allows you to manipulate the next frame in anyway\n         * you want before decode.\n         */\n        drawFrameOnCanvas(\n            srcElement, dimensions, canvasElementContext) {\n            if (!dimensions) {\n                dimensions = {\n                    sx: 0,\n                    sy: 0,\n                    sWidth: srcElement.videoWidth,\n                    sHeight: srcElement.videoHeight,\n                    dx: 0,\n                    dy: 0,\n                    dWidth: srcElement.videoWidth,\n                    dHeight: srcElement.videoHeight};\n            }\n            if (!canvasElementContext) {\n                canvasElementContext = this.captureCanvasContext;\n            }\n            canvasElementContext.drawImage(\n                srcElement,\n                dimensions.sx,\n                dimensions.sy,\n                dimensions.sWidth,\n                dimensions.sHeight,\n                dimensions.dx,\n                dimensions.dy,\n                dimensions.dWidth,\n                dimensions.dHeight);\n        }\n        /**\n         * Ovewriting this allows you to manipulate the snapshot image in anyway\n         *  you want before decode.\n         */\n        drawImageOnCanvas(\n            srcElement,\n            dimensions,\n            canvasElementContext = this.captureCanvasContext) {\n            if (!dimensions) {\n                dimensions = {\n                    sx: 0,\n                    sy: 0,\n                    sWidth: srcElement.naturalWidth,\n                    sHeight: srcElement.naturalHeight,\n                    dx: 0,\n                    dy: 0,\n                    dWidth: srcElement.naturalWidth,\n                    dHeight: srcElement.naturalHeight\n                };\n            }\n            if (!canvasElementContext) {\n                canvasElementContext = this.captureCanvasContext;\n            }\n            canvasElementContext.drawImage(\n                srcElement,\n                dimensions.sx,\n                dimensions.sy,\n                dimensions.sWidth,\n                dimensions.sHeight,\n                dimensions.dx,\n                dimensions.dy,\n                dimensions.dWidth,\n                dimensions.dHeight);\n        }\n        /**\n         * Creates a binaryBitmap based in some image source.\n         *\n         * @param mediaElement HTML element containing drawable image source.\n         */\n        createBinaryBitmap(mediaElement) {\n            const ctx = this.getCaptureCanvasContext(mediaElement);\n            if (this._isHTMLVideoElement(mediaElement)) {\n                this.drawFrameOnCanvas(mediaElement);\n            } else {\n                this.drawImageOnCanvas(mediaElement);\n            }\n            const canvas = this.getCaptureCanvas(mediaElement);\n            const luminanceSource = new HTMLCanvasElementLuminanceSource(canvas);\n            const hybridBinarizer = new HybridBinarizer(luminanceSource);\n\n            return new BinaryBitmap(hybridBinarizer);\n        }\n\n        getCaptureCanvasContext(mediaElement) {\n            if (!this.captureCanvasContext) {\n                const elem = this.getCaptureCanvas(mediaElement);\n                const ctx = elem.getContext('2d');\n                this.captureCanvasContext = ctx;\n            }\n            return this.captureCanvasContext;\n        }\n        getCaptureCanvas(mediaElement) {\n            if (!this.captureCanvas) {\n                const elem = this.createCaptureCanvas(mediaElement);\n                this.captureCanvas = elem;\n            }\n            return this.captureCanvas;\n        }\n        /**\n         * Call the encapsulated readers decode\n         */\n        decodeBitmap(binaryBitmap) {\n            return this.reader.decode(binaryBitmap, this._hints);\n        }\n        /**\n         * 🖌 Prepares the canvas for capture and scan frames.\n         */\n        createCaptureCanvas(mediaElement) {\n            if (typeof document === 'undefined') {\n                this._destroyCaptureCanvas();\n                return null;\n            }\n            const canvasElement = document.createElement('canvas');\n            let width;\n            let height;\n            if (typeof mediaElement !== 'undefined') {\n                if (mediaElement instanceof HTMLVideoElement) {\n                    width = mediaElement.videoWidth;\n                    height = mediaElement.videoHeight;\n                }\n                else if (mediaElement instanceof HTMLImageElement) {\n                    width = mediaElement.naturalWidth || mediaElement.width;\n                    height = mediaElement.naturalHeight || mediaElement.height;\n                }\n            }\n            canvasElement.style.width = width + 'px';\n            canvasElement.style.height = height + 'px';\n            canvasElement.width = width;\n            canvasElement.height = height;\n            return canvasElement;\n        }\n        /**\n         * Stops the continuous scan and cleans the stream.\n         */\n        stopStreams() {\n            if (this.stream) {\n                this.stream.getVideoTracks().forEach(t => t.stop());\n                this.stream = undefined;\n            }\n            if (this._stopAsyncDecode === false) {\n                this.stopAsyncDecode();\n            }\n            if (this._stopContinuousDecode === false) {\n                this.stopContinuousDecode();\n            }\n        }\n        /**\n         * Resets the code reader to the initial state. Cancels any ongoing barcode scanning from video or camera.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        reset() {\n            // stops the camera, preview and scan 🔴\n            this.stopStreams();\n            // clean and forget about HTML elements\n            this._destroyVideoElement();\n            this._destroyImageElement();\n            this._destroyCaptureCanvas();\n        }\n        _destroyVideoElement() {\n            if (!this.videoElement) {\n                return;\n            }\n            // first gives freedon to the element 🕊\n            if (typeof this.videoEndedListener !== 'undefined') {\n                this.videoElement.removeEventListener('ended', this.videoEndedListener);\n            }\n            if (typeof this.videoPlayingEventListener !== 'undefined') {\n                this.videoElement.removeEventListener('playing', this.videoPlayingEventListener);\n            }\n            if (typeof this.videoCanPlayListener !== 'undefined') {\n                this.videoElement.removeEventListener('loadedmetadata', this.videoCanPlayListener);\n            }\n            // then forgets about that element 😢\n            this.cleanVideoSource(this.videoElement);\n            this.videoElement = undefined;\n        }\n        _destroyImageElement() {\n            if (!this.imageElement) {\n                return;\n            }\n            // first gives freedon to the element 🕊\n            if (undefined !== this.imageLoadedListener) {\n                this.imageElement.removeEventListener('load', this.imageLoadedListener);\n            }\n            // then forget about that element 😢\n            this.imageElement.src = undefined;\n            this.imageElement.removeAttribute('src');\n            this.imageElement = undefined;\n        }\n        /**\n         * Cleans canvas references 🖌\n         */\n        _destroyCaptureCanvas() {\n            // then forget about that element 😢\n            this.captureCanvasContext = undefined;\n            this.captureCanvas = undefined;\n        }\n        /**\n         * Defines what the videoElement src will be.\n         *\n         * @param videoElement\n         * @param stream\n         */\n        addVideoSource(videoElement, stream) {\n            // Older browsers may not have `srcObject`\n            try {\n                // @note Throws Exception if interrupted by a new loaded request\n                videoElement.srcObject = stream;\n            }\n            catch (err) {\n                // @note Avoid using this in new browsers, as it is going away.\n                videoElement.src = URL.createObjectURL(stream);\n            }\n        }\n        /**\n         * Unbinds a HTML video src property.\n         *\n         * @param videoElement\n         */\n        cleanVideoSource(videoElement) {\n            try {\n                videoElement.srcObject = null;\n            }\n            catch (err) {\n                videoElement.src = '';\n            }\n            this.videoElement.removeAttribute('src');\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates the result of decoding a barcode within an image.</p>\n     *\n     * @author Sean Owen\n     */\n    class Result {\n        // public constructor(private text: string,\n        //               Uint8Array rawBytes,\n        //               ResultPoconst resultPoints: Int32Array,\n        //               BarcodeFormat format) {\n        //   this(text, rawBytes, resultPoints, format, System.currentTimeMillis())\n        // }\n        // public constructor(text: string,\n        //               Uint8Array rawBytes,\n        //               ResultPoconst resultPoints: Int32Array,\n        //               BarcodeFormat format,\n        //               long timestamp) {\n        //   this(text, rawBytes, rawBytes == null ? 0 : 8 * rawBytes.length,\n        //        resultPoints, format, timestamp)\n        // }\n        constructor(text, rawBytes, numBits = rawBytes == null ? 0 : 8 * rawBytes.length, resultPoints, format, timestamp = System.currentTimeMillis()) {\n            this.text = text;\n            this.rawBytes = rawBytes;\n            this.numBits = numBits;\n            this.resultPoints = resultPoints;\n            this.format = format;\n            this.timestamp = timestamp;\n            this.text = text;\n            this.rawBytes = rawBytes;\n            if (undefined === numBits || null === numBits) {\n                this.numBits = (rawBytes === null || rawBytes === undefined) ? 0 : 8 * rawBytes.length;\n            }\n            else {\n                this.numBits = numBits;\n            }\n            this.resultPoints = resultPoints;\n            this.format = format;\n            this.resultMetadata = null;\n            if (undefined === timestamp || null === timestamp) {\n                this.timestamp = System.currentTimeMillis();\n            }\n            else {\n                this.timestamp = timestamp;\n            }\n        }\n        /**\n         * @return raw text encoded by the barcode\n         */\n        getText() {\n            return this.text;\n        }\n        /**\n         * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}\n         */\n        getRawBytes() {\n            return this.rawBytes;\n        }\n        /**\n         * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length\n         * @since 3.3.0\n         */\n        getNumBits() {\n            return this.numBits;\n        }\n        /**\n         * @return points related to the barcode in the image. These are typically points\n         *         identifying finder patterns or the corners of the barcode. The exact meaning is\n         *         specific to the type of barcode that was decoded.\n         */\n        getResultPoints() {\n            return this.resultPoints;\n        }\n        /**\n         * @return {@link BarcodeFormat} representing the format of the barcode that was decoded\n         */\n        getBarcodeFormat() {\n            return this.format;\n        }\n        /**\n         * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be\n         *   {@code null}. This contains optional metadata about what was detected about the barcode,\n         *   like orientation.\n         */\n        getResultMetadata() {\n            return this.resultMetadata;\n        }\n        putMetadata(type, value) {\n            if (this.resultMetadata === null) {\n                this.resultMetadata = new Map();\n            }\n            this.resultMetadata.set(type, value);\n        }\n        putAllMetadata(metadata) {\n            if (metadata !== null) {\n                if (this.resultMetadata === null) {\n                    this.resultMetadata = metadata;\n                }\n                else {\n                    this.resultMetadata = new Map(metadata);\n                }\n            }\n        }\n        addResultPoints(newPoints) {\n            const oldPoints = this.resultPoints;\n            if (oldPoints === null) {\n                this.resultPoints = newPoints;\n            }\n            else if (newPoints !== null && newPoints.length > 0) {\n                const allPoints = new Array(oldPoints.length + newPoints.length);\n                System.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);\n                System.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);\n                this.resultPoints = allPoints;\n            }\n        }\n        getTimestamp() {\n            return this.timestamp;\n        }\n        /*@Override*/\n        toString() {\n            return this.text;\n        }\n    }\n\n    /*\n     * Direct port to TypeScript of ZXing by Adrian Toșcă\n     */\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing {*/\n    /**\n     * Enumerates barcode formats known to this package. Please keep alphabetized.\n     *\n     * @author Sean Owen\n     */\n    var BarcodeFormat;\n    (function (BarcodeFormat) {\n        /** Aztec 2D barcode format. */\n        BarcodeFormat[BarcodeFormat[\"AZTEC\"] = 0] = \"AZTEC\";\n        /** CODABAR 1D format. */\n        BarcodeFormat[BarcodeFormat[\"CODABAR\"] = 1] = \"CODABAR\";\n        /** Code 39 1D format. */\n        BarcodeFormat[BarcodeFormat[\"CODE_39\"] = 2] = \"CODE_39\";\n        /** Code 93 1D format. */\n        BarcodeFormat[BarcodeFormat[\"CODE_93\"] = 3] = \"CODE_93\";\n        /** Code 128 1D format. */\n        BarcodeFormat[BarcodeFormat[\"CODE_128\"] = 4] = \"CODE_128\";\n        /** Data Matrix 2D barcode format. */\n        BarcodeFormat[BarcodeFormat[\"DATA_MATRIX\"] = 5] = \"DATA_MATRIX\";\n        /** EAN-8 1D format. */\n        BarcodeFormat[BarcodeFormat[\"EAN_8\"] = 6] = \"EAN_8\";\n        /** EAN-13 1D format. */\n        BarcodeFormat[BarcodeFormat[\"EAN_13\"] = 7] = \"EAN_13\";\n        /** ITF (Interleaved Two of Five) 1D format. */\n        BarcodeFormat[BarcodeFormat[\"ITF\"] = 8] = \"ITF\";\n        /** MaxiCode 2D barcode format. */\n        BarcodeFormat[BarcodeFormat[\"MAXICODE\"] = 9] = \"MAXICODE\";\n        /** PDF417 format. */\n        BarcodeFormat[BarcodeFormat[\"PDF_417\"] = 10] = \"PDF_417\";\n        /** QR Code 2D barcode format. */\n        BarcodeFormat[BarcodeFormat[\"QR_CODE\"] = 11] = \"QR_CODE\";\n        /** RSS 14 */\n        BarcodeFormat[BarcodeFormat[\"RSS_14\"] = 12] = \"RSS_14\";\n        /** RSS EXPANDED */\n        BarcodeFormat[BarcodeFormat[\"RSS_EXPANDED\"] = 13] = \"RSS_EXPANDED\";\n        /** UPC-A 1D format. */\n        BarcodeFormat[BarcodeFormat[\"UPC_A\"] = 14] = \"UPC_A\";\n        /** UPC-E 1D format. */\n        BarcodeFormat[BarcodeFormat[\"UPC_E\"] = 15] = \"UPC_E\";\n        /** UPC/EAN extension format. Not a stand-alone format. */\n        BarcodeFormat[BarcodeFormat[\"UPC_EAN_EXTENSION\"] = 16] = \"UPC_EAN_EXTENSION\";\n    })(BarcodeFormat || (BarcodeFormat = {}));\n    var BarcodeFormat$1 = BarcodeFormat;\n\n    /*namespace com.google.zxing {*/\n    /**\n     * Represents some type of metadata about the result of the decoding that the decoder\n     * wishes to communicate back to the caller.\n     *\n     * @author Sean Owen\n     */\n    var ResultMetadataType;\n    (function (ResultMetadataType) {\n        /**\n         * Unspecified, application-specific metadata. Maps to an unspecified {@link Object}.\n         */\n        ResultMetadataType[ResultMetadataType[\"OTHER\"] = 0] = \"OTHER\";\n        /**\n         * Denotes the likely approximate orientation of the barcode in the image. This value\n         * is given as degrees rotated clockwise from the normal, upright orientation.\n         * For example a 1D barcode which was found by reading top-to-bottom would be\n         * said to have orientation \"90\". This key maps to an {@link Integer} whose\n         * value is in the range [0,360).\n         */\n        ResultMetadataType[ResultMetadataType[\"ORIENTATION\"] = 1] = \"ORIENTATION\";\n        /**\n         * <p>2D barcode formats typically encode text, but allow for a sort of 'byte mode'\n         * which is sometimes used to encode binary data. While {@link Result} makes available\n         * the complete raw bytes in the barcode for these formats, it does not offer the bytes\n         * from the byte segments alone.</p>\n         *\n         * <p>This maps to a {@link java.util.List} of byte arrays corresponding to the\n         * raw bytes in the byte segments in the barcode, in order.</p>\n         */\n        ResultMetadataType[ResultMetadataType[\"BYTE_SEGMENTS\"] = 2] = \"BYTE_SEGMENTS\";\n        /**\n         * Error correction level used, if applicable. The value type depends on the\n         * format, but is typically a String.\n         */\n        ResultMetadataType[ResultMetadataType[\"ERROR_CORRECTION_LEVEL\"] = 3] = \"ERROR_CORRECTION_LEVEL\";\n        /**\n         * For some periodicals, indicates the issue number as an {@link Integer}.\n         */\n        ResultMetadataType[ResultMetadataType[\"ISSUE_NUMBER\"] = 4] = \"ISSUE_NUMBER\";\n        /**\n         * For some products, indicates the suggested retail price in the barcode as a\n         * formatted {@link String}.\n         */\n        ResultMetadataType[ResultMetadataType[\"SUGGESTED_PRICE\"] = 5] = \"SUGGESTED_PRICE\";\n        /**\n         * For some products, the possible country of manufacture as a {@link String} denoting the\n         * ISO country code. Some map to multiple possible countries, like \"US/CA\".\n         */\n        ResultMetadataType[ResultMetadataType[\"POSSIBLE_COUNTRY\"] = 6] = \"POSSIBLE_COUNTRY\";\n        /**\n         * For some products, the extension text\n         */\n        ResultMetadataType[ResultMetadataType[\"UPC_EAN_EXTENSION\"] = 7] = \"UPC_EAN_EXTENSION\";\n        /**\n         * PDF417-specific metadata\n         */\n        ResultMetadataType[ResultMetadataType[\"PDF417_EXTRA_METADATA\"] = 8] = \"PDF417_EXTRA_METADATA\";\n        /**\n         * If the code format supports structured append and the current scanned code is part of one then the\n         * sequence number is given with it.\n         */\n        ResultMetadataType[ResultMetadataType[\"STRUCTURED_APPEND_SEQUENCE\"] = 9] = \"STRUCTURED_APPEND_SEQUENCE\";\n        /**\n         * If the code format supports structured append and the current scanned code is part of one then the\n         * parity is given with it.\n         */\n        ResultMetadataType[ResultMetadataType[\"STRUCTURED_APPEND_PARITY\"] = 10] = \"STRUCTURED_APPEND_PARITY\";\n    })(ResultMetadataType || (ResultMetadataType = {}));\n    var ResultMetadataType$1 = ResultMetadataType;\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing.common {*/\n    /*import java.util.List;*/\n    /**\n     * <p>Encapsulates the result of decoding a matrix of bits. This typically\n     * applies to 2D barcode formats. For now it contains the raw bytes obtained,\n     * as well as a String interpretation of those bytes, if applicable.</p>\n     *\n     * @author Sean Owen\n     */\n    class DecoderResult {\n        // public constructor(rawBytes: Uint8Array,\n        //                      text: string,\n        //                      List<Uint8Array> byteSegments,\n        //                      String ecLevel) {\n        //   this(rawBytes, text, byteSegments, ecLevel, -1, -1)\n        // }\n        constructor(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber = -1, structuredAppendParity = -1) {\n            this.rawBytes = rawBytes;\n            this.text = text;\n            this.byteSegments = byteSegments;\n            this.ecLevel = ecLevel;\n            this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;\n            this.structuredAppendParity = structuredAppendParity;\n            this.numBits = (rawBytes === undefined || rawBytes === null) ? 0 : 8 * rawBytes.length;\n        }\n        /**\n         * @return raw bytes representing the result, or {@code null} if not applicable\n         */\n        getRawBytes() {\n            return this.rawBytes;\n        }\n        /**\n         * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length\n         * @since 3.3.0\n         */\n        getNumBits() {\n            return this.numBits;\n        }\n        /**\n         * @param numBits overrides the number of bits that are valid in {@link #getRawBytes()}\n         * @since 3.3.0\n         */\n        setNumBits(numBits /*int*/) {\n            this.numBits = numBits;\n        }\n        /**\n         * @return text representation of the result\n         */\n        getText() {\n            return this.text;\n        }\n        /**\n         * @return list of byte segments in the result, or {@code null} if not applicable\n         */\n        getByteSegments() {\n            return this.byteSegments;\n        }\n        /**\n         * @return name of error correction level used, or {@code null} if not applicable\n         */\n        getECLevel() {\n            return this.ecLevel;\n        }\n        /**\n         * @return number of errors corrected, or {@code null} if not applicable\n         */\n        getErrorsCorrected() {\n            return this.errorsCorrected;\n        }\n        setErrorsCorrected(errorsCorrected /*Integer*/) {\n            this.errorsCorrected = errorsCorrected;\n        }\n        /**\n         * @return number of erasures corrected, or {@code null} if not applicable\n         */\n        getErasures() {\n            return this.erasures;\n        }\n        setErasures(erasures /*Integer*/) {\n            this.erasures = erasures;\n        }\n        /**\n         * @return arbitrary additional metadata\n         */\n        getOther() {\n            return this.other;\n        }\n        setOther(other) {\n            this.other = other;\n        }\n        hasStructuredAppend() {\n            return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;\n        }\n        getStructuredAppendParity() {\n            return this.structuredAppendParity;\n        }\n        getStructuredAppendSequenceNumber() {\n            return this.structuredAppendSequenceNumber;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>This class contains utility methods for performing mathematical operations over\n     * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>\n     *\n     * <p>Throughout this package, elements of the GF are represented as an {@code int}\n     * for convenience and speed (but at the cost of memory).\n     * </p>\n     *\n     * @author Sean Owen\n     * @author David Olivier\n     */\n    class AbstractGenericGF {\n        /**\n         * @return 2 to the power of a in GF(size)\n         */\n        exp(a) {\n            return this.expTable[a];\n        }\n        /**\n         * @return base 2 log of a in GF(size)\n         */\n        log(a /*int*/) {\n            if (a === 0) {\n                throw new IllegalArgumentException();\n            }\n            return this.logTable[a];\n        }\n        /**\n         * Implements both addition and subtraction -- they are the same in GF(size).\n         *\n         * @return sum/difference of a and b\n         */\n        static addOrSubtract(a /*int*/, b /*int*/) {\n            return a ^ b;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Represents a polynomial whose coefficients are elements of a GF.\n     * Instances of this class are immutable.</p>\n     *\n     * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\n     * port of his C++ Reed-Solomon implementation.</p>\n     *\n     * @author Sean Owen\n     */\n    class GenericGFPoly {\n        /**\n         * @param field the {@link GenericGF} instance representing the field to use\n         * to perform computations\n         * @param coefficients coefficients as ints representing elements of GF(size), arranged\n         * from most significant (highest-power term) coefficient to least significant\n         * @throws IllegalArgumentException if argument is null or empty,\n         * or if leading coefficient is 0 and this is not a\n         * constant polynomial (that is, it is not the monomial \"0\")\n         */\n        constructor(field, coefficients) {\n            if (coefficients.length === 0) {\n                throw new IllegalArgumentException();\n            }\n            this.field = field;\n            const coefficientsLength = coefficients.length;\n            if (coefficientsLength > 1 && coefficients[0] === 0) {\n                // Leading term must be non-zero for anything except the constant polynomial \"0\"\n                let firstNonZero = 1;\n                while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {\n                    firstNonZero++;\n                }\n                if (firstNonZero === coefficientsLength) {\n                    this.coefficients = Int32Array.from([0]);\n                }\n                else {\n                    this.coefficients = new Int32Array(coefficientsLength - firstNonZero);\n                    System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);\n                }\n            }\n            else {\n                this.coefficients = coefficients;\n            }\n        }\n        getCoefficients() {\n            return this.coefficients;\n        }\n        /**\n         * @return degree of this polynomial\n         */\n        getDegree() {\n            return this.coefficients.length - 1;\n        }\n        /**\n         * @return true iff this polynomial is the monomial \"0\"\n         */\n        isZero() {\n            return this.coefficients[0] === 0;\n        }\n        /**\n         * @return coefficient of x^degree term in this polynomial\n         */\n        getCoefficient(degree /*int*/) {\n            return this.coefficients[this.coefficients.length - 1 - degree];\n        }\n        /**\n         * @return evaluation of this polynomial at a given point\n         */\n        evaluateAt(a /*int*/) {\n            if (a === 0) {\n                // Just return the x^0 coefficient\n                return this.getCoefficient(0);\n            }\n            const coefficients = this.coefficients;\n            let result;\n            if (a === 1) {\n                // Just the sum of the coefficients\n                result = 0;\n                for (let i = 0, length = coefficients.length; i !== length; i++) {\n                    const coefficient = coefficients[i];\n                    result = AbstractGenericGF.addOrSubtract(result, coefficient);\n                }\n                return result;\n            }\n            result = coefficients[0];\n            const size = coefficients.length;\n            const field = this.field;\n            for (let i = 1; i < size; i++) {\n                result = AbstractGenericGF.addOrSubtract(field.multiply(a, result), coefficients[i]);\n            }\n            return result;\n        }\n        addOrSubtract(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException('GenericGFPolys do not have same GenericGF field');\n            }\n            if (this.isZero()) {\n                return other;\n            }\n            if (other.isZero()) {\n                return this;\n            }\n            let smallerCoefficients = this.coefficients;\n            let largerCoefficients = other.coefficients;\n            if (smallerCoefficients.length > largerCoefficients.length) {\n                const temp = smallerCoefficients;\n                smallerCoefficients = largerCoefficients;\n                largerCoefficients = temp;\n            }\n            let sumDiff = new Int32Array(largerCoefficients.length);\n            const lengthDiff = largerCoefficients.length - smallerCoefficients.length;\n            // Copy high-order terms only found in higher-degree polynomial's coefficients\n            System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);\n            for (let i = lengthDiff; i < largerCoefficients.length; i++) {\n                sumDiff[i] = AbstractGenericGF.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);\n            }\n            return new GenericGFPoly(this.field, sumDiff);\n        }\n        multiply(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException('GenericGFPolys do not have same GenericGF field');\n            }\n            if (this.isZero() || other.isZero()) {\n                return this.field.getZero();\n            }\n            const aCoefficients = this.coefficients;\n            const aLength = aCoefficients.length;\n            const bCoefficients = other.coefficients;\n            const bLength = bCoefficients.length;\n            const product = new Int32Array(aLength + bLength - 1);\n            const field = this.field;\n            for (let i = 0; i < aLength; i++) {\n                const aCoeff = aCoefficients[i];\n                for (let j = 0; j < bLength; j++) {\n                    product[i + j] = AbstractGenericGF.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));\n                }\n            }\n            return new GenericGFPoly(field, product);\n        }\n        multiplyScalar(scalar /*int*/) {\n            if (scalar === 0) {\n                return this.field.getZero();\n            }\n            if (scalar === 1) {\n                return this;\n            }\n            const size = this.coefficients.length;\n            const field = this.field;\n            const product = new Int32Array(size);\n            const coefficients = this.coefficients;\n            for (let i = 0; i < size; i++) {\n                product[i] = field.multiply(coefficients[i], scalar);\n            }\n            return new GenericGFPoly(field, product);\n        }\n        multiplyByMonomial(degree /*int*/, coefficient /*int*/) {\n            if (degree < 0) {\n                throw new IllegalArgumentException();\n            }\n            if (coefficient === 0) {\n                return this.field.getZero();\n            }\n            const coefficients = this.coefficients;\n            const size = coefficients.length;\n            const product = new Int32Array(size + degree);\n            const field = this.field;\n            for (let i = 0; i < size; i++) {\n                product[i] = field.multiply(coefficients[i], coefficient);\n            }\n            return new GenericGFPoly(field, product);\n        }\n        divide(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException('GenericGFPolys do not have same GenericGF field');\n            }\n            if (other.isZero()) {\n                throw new IllegalArgumentException('Divide by 0');\n            }\n            const field = this.field;\n            let quotient = field.getZero();\n            let remainder = this;\n            const denominatorLeadingTerm = other.getCoefficient(other.getDegree());\n            const inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);\n            while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {\n                const degreeDifference = remainder.getDegree() - other.getDegree();\n                const scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);\n                const term = other.multiplyByMonomial(degreeDifference, scale);\n                const iterationQuotient = field.buildMonomial(degreeDifference, scale);\n                quotient = quotient.addOrSubtract(iterationQuotient);\n                remainder = remainder.addOrSubtract(term);\n            }\n            return [quotient, remainder];\n        }\n        /*@Override*/\n        toString() {\n            let result = '';\n            for (let degree = this.getDegree(); degree >= 0; degree--) {\n                let coefficient = this.getCoefficient(degree);\n                if (coefficient !== 0) {\n                    if (coefficient < 0) {\n                        result += ' - ';\n                        coefficient = -coefficient;\n                    }\n                    else {\n                        if (result.length > 0) {\n                            result += ' + ';\n                        }\n                    }\n                    if (degree === 0 || coefficient !== 1) {\n                        const alphaPower = this.field.log(coefficient);\n                        if (alphaPower === 0) {\n                            result += '1';\n                        }\n                        else if (alphaPower === 1) {\n                            result += 'a';\n                        }\n                        else {\n                            result += 'a^';\n                            result += alphaPower;\n                        }\n                    }\n                    if (degree !== 0) {\n                        if (degree === 1) {\n                            result += 'x';\n                        }\n                        else {\n                            result += 'x^';\n                            result += degree;\n                        }\n                    }\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class ArithmeticException extends Exception {\n    }\n    ArithmeticException.kind = 'ArithmeticException';\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>This class contains utility methods for performing mathematical operations over\n     * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>\n     *\n     * <p>Throughout this package, elements of the GF are represented as an {@code int}\n     * for convenience and speed (but at the cost of memory).\n     * </p>\n     *\n     * @author Sean Owen\n     * @author David Olivier\n     */\n    class GenericGF extends AbstractGenericGF {\n        /**\n         * Create a representation of GF(size) using the given primitive polynomial.\n         *\n         * @param primitive irreducible polynomial whose coefficients are represented by\n         *  the bits of an int, where the least-significant bit represents the constant\n         *  coefficient\n         * @param size the size of the field\n         * @param b the factor b in the generator polynomial can be 0- or 1-based\n         *  (g(x) = (x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).\n         *  In most cases it should be 1, but for QR code it is 0.\n         */\n        constructor(primitive /*int*/, size /*int*/, generatorBase /*int*/) {\n            super();\n            this.primitive = primitive;\n            this.size = size;\n            this.generatorBase = generatorBase;\n            const expTable = new Int32Array(size);\n            let x = 1;\n            for (let i = 0; i < size; i++) {\n                expTable[i] = x;\n                x *= 2; // we're assuming the generator alpha is 2\n                if (x >= size) {\n                    x ^= primitive;\n                    x &= size - 1;\n                }\n            }\n            this.expTable = expTable;\n            const logTable = new Int32Array(size);\n            for (let i = 0; i < size - 1; i++) {\n                logTable[expTable[i]] = i;\n            }\n            this.logTable = logTable;\n            // logTable[0] == 0 but this should never be used\n            this.zero = new GenericGFPoly(this, Int32Array.from([0]));\n            this.one = new GenericGFPoly(this, Int32Array.from([1]));\n        }\n        getZero() {\n            return this.zero;\n        }\n        getOne() {\n            return this.one;\n        }\n        /**\n         * @return the monomial representing coefficient * x^degree\n         */\n        buildMonomial(degree /*int*/, coefficient /*int*/) {\n            if (degree < 0) {\n                throw new IllegalArgumentException();\n            }\n            if (coefficient === 0) {\n                return this.zero;\n            }\n            const coefficients = new Int32Array(degree + 1);\n            coefficients[0] = coefficient;\n            return new GenericGFPoly(this, coefficients);\n        }\n        /**\n         * @return multiplicative inverse of a\n         */\n        inverse(a /*int*/) {\n            if (a === 0) {\n                throw new ArithmeticException();\n            }\n            return this.expTable[this.size - this.logTable[a] - 1];\n        }\n        /**\n         * @return product of a and b in GF(size)\n         */\n        multiply(a /*int*/, b /*int*/) {\n            if (a === 0 || b === 0) {\n                return 0;\n            }\n            return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];\n        }\n        getSize() {\n            return this.size;\n        }\n        getGeneratorBase() {\n            return this.generatorBase;\n        }\n        /*@Override*/\n        toString() {\n            return ('GF(0x' + Integer.toHexString(this.primitive) + ',' + this.size + ')');\n        }\n        equals(o) {\n            return o === this;\n        }\n    }\n    GenericGF.AZTEC_DATA_12 = new GenericGF(0x1069, 4096, 1); // x^12 + x^6 + x^5 + x^3 + 1\n    GenericGF.AZTEC_DATA_10 = new GenericGF(0x409, 1024, 1); // x^10 + x^3 + 1\n    GenericGF.AZTEC_DATA_6 = new GenericGF(0x43, 64, 1); // x^6 + x + 1\n    GenericGF.AZTEC_PARAM = new GenericGF(0x13, 16, 1); // x^4 + x + 1\n    GenericGF.QR_CODE_FIELD_256 = new GenericGF(0x011d, 256, 0); // x^8 + x^4 + x^3 + x^2 + 1\n    GenericGF.DATA_MATRIX_FIELD_256 = new GenericGF(0x012d, 256, 1); // x^8 + x^5 + x^3 + x^2 + 1\n    GenericGF.AZTEC_DATA_8 = GenericGF.DATA_MATRIX_FIELD_256;\n    GenericGF.MAXICODE_FIELD_64 = GenericGF.AZTEC_DATA_6;\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class ReedSolomonException extends Exception {\n    }\n    ReedSolomonException.kind = 'ReedSolomonException';\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class IllegalStateException extends Exception {\n    }\n    IllegalStateException.kind = 'IllegalStateException';\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Implements Reed-Solomon decoding, as the name implies.</p>\n     *\n     * <p>The algorithm will not be explained here, but the following references were helpful\n     * in creating this implementation:</p>\n     *\n     * <ul>\n     * <li>Bruce Maggs.\n     * <a href=\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps\">\n     * \"Decoding Reed-Solomon Codes\"</a> (see discussion of Forney's Formula)</li>\n     * <li>J.I. Hall. <a href=\"www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf\">\n     * \"Chapter 5. Generalized Reed-Solomon Codes\"</a>\n     * (see discussion of Euclidean algorithm)</li>\n     * </ul>\n     *\n     * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\n     * port of his C++ Reed-Solomon implementation.</p>\n     *\n     * @author Sean Owen\n     * @author William Rucklidge\n     * @author sanfordsquires\n     */\n    class ReedSolomonDecoder {\n        constructor(field) {\n            this.field = field;\n        }\n        /**\n         * <p>Decodes given set of received codewords, which include both data and error-correction\n         * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,\n         * in the input.</p>\n         *\n         * @param received data and error-correction codewords\n         * @param twoS number of error-correction codewords available\n         * @throws ReedSolomonException if decoding fails for any reason\n         */\n        decode(received, twoS /*int*/) {\n            const field = this.field;\n            const poly = new GenericGFPoly(field, received);\n            const syndromeCoefficients = new Int32Array(twoS);\n            let noError = true;\n            for (let i = 0; i < twoS; i++) {\n                const evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));\n                syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;\n                if (evalResult !== 0) {\n                    noError = false;\n                }\n            }\n            if (noError) {\n                return;\n            }\n            const syndrome = new GenericGFPoly(field, syndromeCoefficients);\n            const sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);\n            const sigma = sigmaOmega[0];\n            const omega = sigmaOmega[1];\n            const errorLocations = this.findErrorLocations(sigma);\n            const errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);\n            for (let i = 0; i < errorLocations.length; i++) {\n                const position = received.length - 1 - field.log(errorLocations[i]);\n                if (position < 0) {\n                    throw new ReedSolomonException('Bad error location');\n                }\n                received[position] = GenericGF.addOrSubtract(received[position], errorMagnitudes[i]);\n            }\n        }\n        runEuclideanAlgorithm(a, b, R /*int*/) {\n            // Assume a's degree is >= b's\n            if (a.getDegree() < b.getDegree()) {\n                const temp = a;\n                a = b;\n                b = temp;\n            }\n            const field = this.field;\n            let rLast = a;\n            let r = b;\n            let tLast = field.getZero();\n            let t = field.getOne();\n            // Run Euclidean algorithm until r's degree is less than R/2\n            while (r.getDegree() >= (R / 2 | 0)) {\n                let rLastLast = rLast;\n                let tLastLast = tLast;\n                rLast = r;\n                tLast = t;\n                // Divide rLastLast by rLast, with quotient in q and remainder in r\n                if (rLast.isZero()) {\n                    // Oops, Euclidean algorithm already terminated?\n                    throw new ReedSolomonException('r_{i-1} was zero');\n                }\n                r = rLastLast;\n                let q = field.getZero();\n                const denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n                const dltInverse = field.inverse(denominatorLeadingTerm);\n                while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n                    const degreeDiff = r.getDegree() - rLast.getDegree();\n                    const scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n                    q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));\n                    r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));\n                }\n                t = q.multiply(tLast).addOrSubtract(tLastLast);\n                if (r.getDegree() >= rLast.getDegree()) {\n                    throw new IllegalStateException('Division algorithm failed to reduce polynomial?');\n                }\n            }\n            const sigmaTildeAtZero = t.getCoefficient(0);\n            if (sigmaTildeAtZero === 0) {\n                throw new ReedSolomonException('sigmaTilde(0) was zero');\n            }\n            const inverse = field.inverse(sigmaTildeAtZero);\n            const sigma = t.multiplyScalar(inverse);\n            const omega = r.multiplyScalar(inverse);\n            return [sigma, omega];\n        }\n        findErrorLocations(errorLocator) {\n            // This is a direct application of Chien's search\n            const numErrors = errorLocator.getDegree();\n            if (numErrors === 1) { // shortcut\n                return Int32Array.from([errorLocator.getCoefficient(1)]);\n            }\n            const result = new Int32Array(numErrors);\n            let e = 0;\n            const field = this.field;\n            for (let i = 1; i < field.getSize() && e < numErrors; i++) {\n                if (errorLocator.evaluateAt(i) === 0) {\n                    result[e] = field.inverse(i);\n                    e++;\n                }\n            }\n            if (e !== numErrors) {\n                throw new ReedSolomonException('Error locator degree does not match number of roots');\n            }\n            return result;\n        }\n        findErrorMagnitudes(errorEvaluator, errorLocations) {\n            // This is directly applying Forney's Formula\n            const s = errorLocations.length;\n            const result = new Int32Array(s);\n            const field = this.field;\n            for (let i = 0; i < s; i++) {\n                const xiInverse = field.inverse(errorLocations[i]);\n                let denominator = 1;\n                for (let j = 0; j < s; j++) {\n                    if (i !== j) {\n                        // denominator = field.multiply(denominator,\n                        //    GenericGF.addOrSubtract(1, field.multiply(errorLocations[j], xiInverse)))\n                        // Above should work but fails on some Apple and Linux JDKs due to a Hotspot bug.\n                        // Below is a funny-looking workaround from Steven Parkes\n                        const term = field.multiply(errorLocations[j], xiInverse);\n                        const termPlus1 = (term & 0x1) === 0 ? term | 1 : term & ~1;\n                        denominator = field.multiply(denominator, termPlus1);\n                    }\n                }\n                result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));\n                if (field.getGeneratorBase() !== 0) {\n                    result[i] = field.multiply(result[i], xiInverse);\n                }\n            }\n            return result;\n        }\n    }\n\n    /*\n     * Copyright 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // import java.util.Arrays;\n    var Table;\n    (function (Table) {\n        Table[Table[\"UPPER\"] = 0] = \"UPPER\";\n        Table[Table[\"LOWER\"] = 1] = \"LOWER\";\n        Table[Table[\"MIXED\"] = 2] = \"MIXED\";\n        Table[Table[\"DIGIT\"] = 3] = \"DIGIT\";\n        Table[Table[\"PUNCT\"] = 4] = \"PUNCT\";\n        Table[Table[\"BINARY\"] = 5] = \"BINARY\";\n    })(Table || (Table = {}));\n    /**\n     * <p>The main class which implements Aztec Code decoding -- as opposed to locating and extracting\n     * the Aztec Code from an image.</p>\n     *\n     * @author David Olivier\n     */\n    class Decoder {\n        decode(detectorResult) {\n            this.ddata = detectorResult;\n            let matrix = detectorResult.getBits();\n            let rawbits = this.extractBits(matrix);\n            let correctedBits = this.correctBits(rawbits);\n            let rawBytes = Decoder.convertBoolArrayToByteArray(correctedBits);\n            let result = Decoder.getEncodedData(correctedBits);\n            let decoderResult = new DecoderResult(rawBytes, result, null, null);\n            decoderResult.setNumBits(correctedBits.length);\n            return decoderResult;\n        }\n        // This method is used for testing the high-level encoder\n        static highLevelDecode(correctedBits) {\n            return this.getEncodedData(correctedBits);\n        }\n        /**\n         * Gets the string encoded in the aztec code bits\n         *\n         * @return the decoded string\n         */\n        static getEncodedData(correctedBits) {\n            let endIndex = correctedBits.length;\n            let latchTable = Table.UPPER; // table most recently latched to\n            let shiftTable = Table.UPPER; // table to use for the next read\n            let result = '';\n            let index = 0;\n            while (index < endIndex) {\n                if (shiftTable === Table.BINARY) {\n                    if (endIndex - index < 5) {\n                        break;\n                    }\n                    let length = Decoder.readCode(correctedBits, index, 5);\n                    index += 5;\n                    if (length === 0) {\n                        if (endIndex - index < 11) {\n                            break;\n                        }\n                        length = Decoder.readCode(correctedBits, index, 11) + 31;\n                        index += 11;\n                    }\n                    for (let charCount = 0; charCount < length; charCount++) {\n                        if (endIndex - index < 8) {\n                            index = endIndex; // Force outer loop to exit\n                            break;\n                        }\n                        const code = Decoder.readCode(correctedBits, index, 8);\n                        result += /*(char)*/ StringUtils.castAsNonUtf8Char(code);\n                        index += 8;\n                    }\n                    // Go back to whatever mode we had been in\n                    shiftTable = latchTable;\n                }\n                else {\n                    let size = shiftTable === Table.DIGIT ? 4 : 5;\n                    if (endIndex - index < size) {\n                        break;\n                    }\n                    let code = Decoder.readCode(correctedBits, index, size);\n                    index += size;\n                    let str = Decoder.getCharacter(shiftTable, code);\n                    if (str.startsWith('CTRL_')) {\n                        // Table changes\n                        // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n                        // That's including when that mode is a shift.\n                        // Our test case dlusbs.png for issue #642 exercises that.\n                        latchTable = shiftTable; // Latch the current mode, so as to return to Upper after U/S B/S\n                        shiftTable = Decoder.getTable(str.charAt(5));\n                        if (str.charAt(6) === 'L') {\n                            latchTable = shiftTable;\n                        }\n                    }\n                    else {\n                        result += str;\n                        // Go back to whatever mode we had been in\n                        shiftTable = latchTable;\n                    }\n                }\n            }\n            return result;\n        }\n        /**\n         * gets the table corresponding to the char passed\n         */\n        static getTable(t) {\n            switch (t) {\n                case 'L':\n                    return Table.LOWER;\n                case 'P':\n                    return Table.PUNCT;\n                case 'M':\n                    return Table.MIXED;\n                case 'D':\n                    return Table.DIGIT;\n                case 'B':\n                    return Table.BINARY;\n                case 'U':\n                default:\n                    return Table.UPPER;\n            }\n        }\n        /**\n         * Gets the character (or string) corresponding to the passed code in the given table\n         *\n         * @param table the table used\n         * @param code the code of the character\n         */\n        static getCharacter(table, code) {\n            switch (table) {\n                case Table.UPPER:\n                    return Decoder.UPPER_TABLE[code];\n                case Table.LOWER:\n                    return Decoder.LOWER_TABLE[code];\n                case Table.MIXED:\n                    return Decoder.MIXED_TABLE[code];\n                case Table.PUNCT:\n                    return Decoder.PUNCT_TABLE[code];\n                case Table.DIGIT:\n                    return Decoder.DIGIT_TABLE[code];\n                default:\n                    // Should not reach here.\n                    throw new IllegalStateException('Bad table');\n            }\n        }\n        /**\n         * <p>Performs RS error correction on an array of bits.</p>\n         *\n         * @return the corrected array\n         * @throws FormatException if the input contains too many errors\n         */\n        correctBits(rawbits) {\n            let gf;\n            let codewordSize;\n            if (this.ddata.getNbLayers() <= 2) {\n                codewordSize = 6;\n                gf = GenericGF.AZTEC_DATA_6;\n            }\n            else if (this.ddata.getNbLayers() <= 8) {\n                codewordSize = 8;\n                gf = GenericGF.AZTEC_DATA_8;\n            }\n            else if (this.ddata.getNbLayers() <= 22) {\n                codewordSize = 10;\n                gf = GenericGF.AZTEC_DATA_10;\n            }\n            else {\n                codewordSize = 12;\n                gf = GenericGF.AZTEC_DATA_12;\n            }\n            let numDataCodewords = this.ddata.getNbDatablocks();\n            let numCodewords = rawbits.length / codewordSize;\n            if (numCodewords < numDataCodewords) {\n                throw new FormatException();\n            }\n            let offset = rawbits.length % codewordSize;\n            let dataWords = new Int32Array(numCodewords);\n            for (let i = 0; i < numCodewords; i++, offset += codewordSize) {\n                dataWords[i] = Decoder.readCode(rawbits, offset, codewordSize);\n            }\n            try {\n                let rsDecoder = new ReedSolomonDecoder(gf);\n                rsDecoder.decode(dataWords, numCodewords - numDataCodewords);\n            }\n            catch (ex) {\n                throw new FormatException(ex);\n            }\n            // Now perform the unstuffing operation.\n            // First, count how many bits are going to be thrown out as stuffing\n            let mask = (1 << codewordSize) - 1;\n            let stuffedBits = 0;\n            for (let i = 0; i < numDataCodewords; i++) {\n                let dataWord = dataWords[i];\n                if (dataWord === 0 || dataWord === mask) {\n                    throw new FormatException();\n                }\n                else if (dataWord === 1 || dataWord === mask - 1) {\n                    stuffedBits++;\n                }\n            }\n            // Now, actually unpack the bits and remove the stuffing\n            let correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);\n            let index = 0;\n            for (let i = 0; i < numDataCodewords; i++) {\n                let dataWord = dataWords[i];\n                if (dataWord === 1 || dataWord === mask - 1) {\n                    // next codewordSize-1 bits are all zeros or all ones\n                    correctedBits.fill(dataWord > 1, index, index + codewordSize - 1);\n                    // Arrays.fill(correctedBits, index, index + codewordSize - 1, dataWord > 1);\n                    index += codewordSize - 1;\n                }\n                else {\n                    for (let bit = codewordSize - 1; bit >= 0; --bit) {\n                        correctedBits[index++] = (dataWord & (1 << bit)) !== 0;\n                    }\n                }\n            }\n            return correctedBits;\n        }\n        /**\n         * Gets the array of bits from an Aztec Code matrix\n         *\n         * @return the array of bits\n         */\n        extractBits(matrix) {\n            let compact = this.ddata.isCompact();\n            let layers = this.ddata.getNbLayers();\n            let baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n            let alignmentMap = new Int32Array(baseMatrixSize);\n            let rawbits = new Array(this.totalBitsInLayer(layers, compact));\n            if (compact) {\n                for (let i = 0; i < alignmentMap.length; i++) {\n                    alignmentMap[i] = i;\n                }\n            }\n            else {\n                let matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision((Integer.truncDivision(baseMatrixSize, 2) - 1), 15);\n                let origCenter = baseMatrixSize / 2;\n                let center = Integer.truncDivision(matrixSize, 2);\n                for (let i = 0; i < origCenter; i++) {\n                    let newOffset = i + Integer.truncDivision(i, 15);\n                    alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n                    alignmentMap[origCenter + i] = center + newOffset + 1;\n                }\n            }\n            for (let i = 0, rowOffset = 0; i < layers; i++) {\n                let rowSize = (layers - i) * 4 + (compact ? 9 : 12);\n                // The top-left most point of this layer is <low, low> (not including alignment lines)\n                let low = i * 2;\n                // The bottom-right most point of this layer is <high, high> (not including alignment lines)\n                let high = baseMatrixSize - 1 - low;\n                // We pull bits from the two 2 x rowSize columns and two rowSize x 2 rows\n                for (let j = 0; j < rowSize; j++) {\n                    let columnOffset = j * 2;\n                    for (let k = 0; k < 2; k++) {\n                        // left column\n                        rawbits[rowOffset + columnOffset + k] =\n                            matrix.get(alignmentMap[low + k], alignmentMap[low + j]);\n                        // bottom row\n                        rawbits[rowOffset + 2 * rowSize + columnOffset + k] =\n                            matrix.get(alignmentMap[low + j], alignmentMap[high - k]);\n                        // right column\n                        rawbits[rowOffset + 4 * rowSize + columnOffset + k] =\n                            matrix.get(alignmentMap[high - k], alignmentMap[high - j]);\n                        // top row\n                        rawbits[rowOffset + 6 * rowSize + columnOffset + k] =\n                            matrix.get(alignmentMap[high - j], alignmentMap[low + k]);\n                    }\n                }\n                rowOffset += rowSize * 8;\n            }\n            return rawbits;\n        }\n        /**\n         * Reads a code of given length and at given index in an array of bits\n         */\n        static readCode(rawbits, startIndex, length) {\n            let res = 0;\n            for (let i = startIndex; i < startIndex + length; i++) {\n                res <<= 1;\n                if (rawbits[i]) {\n                    res |= 0x01;\n                }\n            }\n            return res;\n        }\n        /**\n         * Reads a code of length 8 in an array of bits, padding with zeros\n         */\n        static readByte(rawbits, startIndex) {\n            let n = rawbits.length - startIndex;\n            if (n >= 8) {\n                return Decoder.readCode(rawbits, startIndex, 8);\n            }\n            return Decoder.readCode(rawbits, startIndex, n) << (8 - n);\n        }\n        /**\n         * Packs a bit array into bytes, most significant bit first\n         */\n        static convertBoolArrayToByteArray(boolArr) {\n            let byteArr = new Uint8Array((boolArr.length + 7) / 8);\n            for (let i = 0; i < byteArr.length; i++) {\n                byteArr[i] = Decoder.readByte(boolArr, 8 * i);\n            }\n            return byteArr;\n        }\n        totalBitsInLayer(layers, compact) {\n            return ((compact ? 88 : 112) + 16 * layers) * layers;\n        }\n    }\n    Decoder.UPPER_TABLE = [\n        'CTRL_PS', ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\n        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'CTRL_LL', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'\n    ];\n    Decoder.LOWER_TABLE = [\n        'CTRL_PS', ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',\n        'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'CTRL_US', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'\n    ];\n    Decoder.MIXED_TABLE = [\n        // Module parse failed: Octal literal in strict mode (50:29)\n        // so number string were scaped\n        'CTRL_PS', ' ', '\\\\1', '\\\\2', '\\\\3', '\\\\4', '\\\\5', '\\\\6', '\\\\7', '\\b', '\\t', '\\n',\n        '\\\\13', '\\f', '\\r', '\\\\33', '\\\\34', '\\\\35', '\\\\36', '\\\\37', '@', '\\\\', '^', '_',\n        '`', '|', '~', '\\\\177', 'CTRL_LL', 'CTRL_UL', 'CTRL_PL', 'CTRL_BS'\n    ];\n    Decoder.PUNCT_TABLE = [\n        '', '\\r', '\\r\\n', '. ', ', ', ': ', '!', '\"', '#', '$', '%', '&', '\\'', '(', ')',\n        '*', '+', ',', '-', '.', '/', ':', ';', '<', '=', '>', '?', '[', ']', '{', '}', 'CTRL_UL'\n    ];\n    Decoder.DIGIT_TABLE = [\n        'CTRL_PS', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', '.', 'CTRL_UL', 'CTRL_US'\n    ];\n\n    /*\n     * Copyright 2012 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing.common.detector {*/\n    /**\n     * General math-related and numeric utility functions.\n     */\n    class MathUtils {\n        constructor() { }\n        /**\n         * Ends up being a bit faster than {@link Math#round(float)}. This merely rounds its\n         * argument to the nearest int, where x.5 rounds up to x+1. Semantics of this shortcut\n         * differ slightly from {@link Math#round(float)} in that half rounds down for negative\n         * values. -2.5 rounds to -3, not -2. For purposes here it makes no difference.\n         *\n         * @param d real value to round\n         * @return nearest {@code int}\n         */\n        static round(d /*float*/) {\n            if (NaN === d)\n                return 0;\n            if (d <= Number.MIN_SAFE_INTEGER)\n                return Number.MIN_SAFE_INTEGER;\n            if (d >= Number.MAX_SAFE_INTEGER)\n                return Number.MAX_SAFE_INTEGER;\n            return /*(int) */ (d + (d < 0.0 ? -0.5 : 0.5)) | 0;\n        }\n        // TYPESCRIPTPORT: maybe remove round method and call directly Math.round, it looks like it doesn't make sense for js\n        /**\n         * @param aX point A x coordinate\n         * @param aY point A y coordinate\n         * @param bX point B x coordinate\n         * @param bY point B y coordinate\n         * @return Euclidean distance between points A and B\n         */\n        static distance(aX /*float|int*/, aY /*float|int*/, bX /*float|int*/, bY /*float|int*/) {\n            const xDiff = aX - bX;\n            const yDiff = aY - bY;\n            return /*(float) */ Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n        }\n        /**\n         * @param aX point A x coordinate\n         * @param aY point A y coordinate\n         * @param bX point B x coordinate\n         * @param bY point B y coordinate\n         * @return Euclidean distance between points A and B\n         */\n        // public static distance(aX: number /*int*/, aY: number /*int*/, bX: number /*int*/, bY: number /*int*/): float {\n        //   const xDiff = aX - bX\n        //   const yDiff = aY - bY\n        //   return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n        // }\n        /**\n         * @param array values to sum\n         * @return sum of values in array\n         */\n        static sum(array) {\n            let count = 0;\n            for (let i = 0, length = array.length; i !== length; i++) {\n                const a = array[i];\n                count += a;\n            }\n            return count;\n        }\n    }\n\n    /**\n     * Ponyfill for Java's Float class.\n     */\n    class Float {\n        /**\n         * SincTS has no difference between int and float, there's all numbers,\n         * this is used only to polyfill Java code.\n         */\n        static floatToIntBits(f) {\n            return f;\n        }\n    }\n    /**\n     * The float max value in JS is the number max value.\n     */\n    Float.MAX_VALUE = Number.MAX_SAFE_INTEGER;\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this\n     * would be the location of a finder pattern or the corner of the barcode, for example.</p>\n     *\n     * @author Sean Owen\n     */\n    class ResultPoint {\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n        getX() {\n            return this.x;\n        }\n        getY() {\n            return this.y;\n        }\n        /*@Override*/\n        equals(other) {\n            if (other instanceof ResultPoint) {\n                const otherPoint = other;\n                return this.x === otherPoint.x && this.y === otherPoint.y;\n            }\n            return false;\n        }\n        /*@Override*/\n        hashCode() {\n            return 31 * Float.floatToIntBits(this.x) + Float.floatToIntBits(this.y);\n        }\n        /*@Override*/\n        toString() {\n            return '(' + this.x + ',' + this.y + ')';\n        }\n        /**\n         * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC\n         * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.\n         *\n         * @param patterns array of three {@code ResultPoint} to order\n         */\n        static orderBestPatterns(patterns) {\n            // Find distances between pattern centers\n            const zeroOneDistance = this.distance(patterns[0], patterns[1]);\n            const oneTwoDistance = this.distance(patterns[1], patterns[2]);\n            const zeroTwoDistance = this.distance(patterns[0], patterns[2]);\n            let pointA;\n            let pointB;\n            let pointC;\n            // Assume one closest to other two is B; A and C will just be guesses at first\n            if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {\n                pointB = patterns[0];\n                pointA = patterns[1];\n                pointC = patterns[2];\n            }\n            else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {\n                pointB = patterns[1];\n                pointA = patterns[0];\n                pointC = patterns[2];\n            }\n            else {\n                pointB = patterns[2];\n                pointA = patterns[0];\n                pointC = patterns[1];\n            }\n            // Use cross product to figure out whether A and C are correct or flipped.\n            // This asks whether BC x BA has a positive z component, which is the arrangement\n            // we want for A, B, C. If it's negative, then we've got it flipped around and\n            // should swap A and C.\n            if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {\n                const temp = pointA;\n                pointA = pointC;\n                pointC = temp;\n            }\n            patterns[0] = pointA;\n            patterns[1] = pointB;\n            patterns[2] = pointC;\n        }\n        /**\n         * @param pattern1 first pattern\n         * @param pattern2 second pattern\n         * @return distance between two points\n         */\n        static distance(pattern1, pattern2) {\n            return MathUtils.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);\n        }\n        /**\n         * Returns the z component of the cross product between vectors BC and BA.\n         */\n        static crossProductZ(pointA, pointB, pointC) {\n            const bX = pointB.x;\n            const bY = pointB.y;\n            return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates the result of detecting a barcode in an image. This includes the raw\n     * matrix of black/white pixels corresponding to the barcode, and possibly points of interest\n     * in the image, like the location of finder patterns or corners of the barcode in the image.</p>\n     *\n     * @author Sean Owen\n     */\n    class DetectorResult {\n        constructor(bits, points) {\n            this.bits = bits;\n            this.points = points;\n        }\n        getBits() {\n            return this.bits;\n        }\n        getPoints() {\n            return this.points;\n        }\n    }\n\n    /*\n     * Copyright 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Extends {@link DetectorResult} with more information specific to the Aztec format,\n     * like the number of layers and whether it's compact.</p>\n     *\n     * @author Sean Owen\n     */\n    class AztecDetectorResult extends DetectorResult {\n        constructor(bits, points, compact, nbDatablocks, nbLayers) {\n            super(bits, points);\n            this.compact = compact;\n            this.nbDatablocks = nbDatablocks;\n            this.nbLayers = nbLayers;\n        }\n        getNbLayers() {\n            return this.nbLayers;\n        }\n        getNbDatablocks() {\n            return this.nbDatablocks;\n        }\n        isCompact() {\n            return this.compact;\n        }\n    }\n\n    /*\n     * Copyright 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>\n     * Detects a candidate barcode-like rectangular region within an image. It\n     * starts around the center of the image, increases the size of the candidate\n     * region until it finds a white rectangular region. By keeping track of the\n     * last black points it encountered, it determines the corners of the barcode.\n     * </p>\n     *\n     * @author David Olivier\n     */\n    class WhiteRectangleDetector {\n        // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {\n        //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)\n        // }\n        /**\n         * @param image barcode image to find a rectangle in\n         * @param initSize initial size of search area around center\n         * @param x x position of search center\n         * @param y y position of search center\n         * @throws NotFoundException if image is too small to accommodate {@code initSize}\n         */\n        constructor(image, initSize /*int*/, x /*int*/, y /*int*/) {\n            this.image = image;\n            this.height = image.getHeight();\n            this.width = image.getWidth();\n            if (undefined === initSize || null === initSize) {\n                initSize = WhiteRectangleDetector.INIT_SIZE;\n            }\n            if (undefined === x || null === x) {\n                x = image.getWidth() / 2 | 0;\n            }\n            if (undefined === y || null === y) {\n                y = image.getHeight() / 2 | 0;\n            }\n            const halfsize = initSize / 2 | 0;\n            this.leftInit = x - halfsize;\n            this.rightInit = x + halfsize;\n            this.upInit = y - halfsize;\n            this.downInit = y + halfsize;\n            if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {\n                throw new NotFoundException();\n            }\n        }\n        /**\n         * <p>\n         * Detects a candidate barcode-like rectangular region within an image. It\n         * starts around the center of the image, increases the size of the candidate\n         * region until it finds a white rectangular region.\n         * </p>\n         *\n         * @return {@link ResultPoint}[] describing the corners of the rectangular\n         *         region. The first and last points are opposed on the diagonal, as\n         *         are the second and third. The first point will be the topmost\n         *         point and the last, the bottommost. The second point will be\n         *         leftmost and the third, the rightmost\n         * @throws NotFoundException if no Data Matrix Code can be found\n         */\n        detect() {\n            let left = this.leftInit;\n            let right = this.rightInit;\n            let up = this.upInit;\n            let down = this.downInit;\n            let sizeExceeded = false;\n            let aBlackPointFoundOnBorder = true;\n            let atLeastOneBlackPointFoundOnBorder = false;\n            let atLeastOneBlackPointFoundOnRight = false;\n            let atLeastOneBlackPointFoundOnBottom = false;\n            let atLeastOneBlackPointFoundOnLeft = false;\n            let atLeastOneBlackPointFoundOnTop = false;\n            const width = this.width;\n            const height = this.height;\n            while (aBlackPointFoundOnBorder) {\n                aBlackPointFoundOnBorder = false;\n                // .....\n                // .   |\n                // .....\n                let rightBorderNotWhite = true;\n                while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\n                    rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);\n                    if (rightBorderNotWhite) {\n                        right++;\n                        aBlackPointFoundOnBorder = true;\n                        atLeastOneBlackPointFoundOnRight = true;\n                    }\n                    else if (!atLeastOneBlackPointFoundOnRight) {\n                        right++;\n                    }\n                }\n                if (right >= width) {\n                    sizeExceeded = true;\n                    break;\n                }\n                // .....\n                // .   .\n                // .___.\n                let bottomBorderNotWhite = true;\n                while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\n                    bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);\n                    if (bottomBorderNotWhite) {\n                        down++;\n                        aBlackPointFoundOnBorder = true;\n                        atLeastOneBlackPointFoundOnBottom = true;\n                    }\n                    else if (!atLeastOneBlackPointFoundOnBottom) {\n                        down++;\n                    }\n                }\n                if (down >= height) {\n                    sizeExceeded = true;\n                    break;\n                }\n                // .....\n                // |   .\n                // .....\n                let leftBorderNotWhite = true;\n                while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\n                    leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);\n                    if (leftBorderNotWhite) {\n                        left--;\n                        aBlackPointFoundOnBorder = true;\n                        atLeastOneBlackPointFoundOnLeft = true;\n                    }\n                    else if (!atLeastOneBlackPointFoundOnLeft) {\n                        left--;\n                    }\n                }\n                if (left < 0) {\n                    sizeExceeded = true;\n                    break;\n                }\n                // .___.\n                // .   .\n                // .....\n                let topBorderNotWhite = true;\n                while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\n                    topBorderNotWhite = this.containsBlackPoint(left, right, up, true);\n                    if (topBorderNotWhite) {\n                        up--;\n                        aBlackPointFoundOnBorder = true;\n                        atLeastOneBlackPointFoundOnTop = true;\n                    }\n                    else if (!atLeastOneBlackPointFoundOnTop) {\n                        up--;\n                    }\n                }\n                if (up < 0) {\n                    sizeExceeded = true;\n                    break;\n                }\n                if (aBlackPointFoundOnBorder) {\n                    atLeastOneBlackPointFoundOnBorder = true;\n                }\n            }\n            if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {\n                const maxSize = right - left;\n                let z = null;\n                for (let i = 1; z === null && i < maxSize; i++) {\n                    z = this.getBlackPointOnSegment(left, down - i, left + i, down);\n                }\n                if (z == null) {\n                    throw new NotFoundException();\n                }\n                let t = null;\n                // go down right\n                for (let i = 1; t === null && i < maxSize; i++) {\n                    t = this.getBlackPointOnSegment(left, up + i, left + i, up);\n                }\n                if (t == null) {\n                    throw new NotFoundException();\n                }\n                let x = null;\n                // go down left\n                for (let i = 1; x === null && i < maxSize; i++) {\n                    x = this.getBlackPointOnSegment(right, up + i, right - i, up);\n                }\n                if (x == null) {\n                    throw new NotFoundException();\n                }\n                let y = null;\n                // go up left\n                for (let i = 1; y === null && i < maxSize; i++) {\n                    y = this.getBlackPointOnSegment(right, down - i, right - i, down);\n                }\n                if (y == null) {\n                    throw new NotFoundException();\n                }\n                return this.centerEdges(y, z, x, t);\n            }\n            else {\n                throw new NotFoundException();\n            }\n        }\n        getBlackPointOnSegment(aX /*float*/, aY /*float*/, bX /*float*/, bY /*float*/) {\n            const dist = MathUtils.round(MathUtils.distance(aX, aY, bX, bY));\n            const xStep = (bX - aX) / dist;\n            const yStep = (bY - aY) / dist;\n            const image = this.image;\n            for (let i = 0; i < dist; i++) {\n                const x = MathUtils.round(aX + i * xStep);\n                const y = MathUtils.round(aY + i * yStep);\n                if (image.get(x, y)) {\n                    return new ResultPoint(x, y);\n                }\n            }\n            return null;\n        }\n        /**\n         * recenters the points of a constant distance towards the center\n         *\n         * @param y bottom most point\n         * @param z left most point\n         * @param x right most point\n         * @param t top most point\n         * @return {@link ResultPoint}[] describing the corners of the rectangular\n         *         region. The first and last points are opposed on the diagonal, as\n         *         are the second and third. The first point will be the topmost\n         *         point and the last, the bottommost. The second point will be\n         *         leftmost and the third, the rightmost\n         */\n        centerEdges(y, z, x, t) {\n            //\n            //       t            t\n            //  z                      x\n            //        x    OR    z\n            //   y                    y\n            //\n            const yi = y.getX();\n            const yj = y.getY();\n            const zi = z.getX();\n            const zj = z.getY();\n            const xi = x.getX();\n            const xj = x.getY();\n            const ti = t.getX();\n            const tj = t.getY();\n            const CORR = WhiteRectangleDetector.CORR;\n            if (yi < this.width / 2.0) {\n                return [\n                    new ResultPoint(ti - CORR, tj + CORR),\n                    new ResultPoint(zi + CORR, zj + CORR),\n                    new ResultPoint(xi - CORR, xj - CORR),\n                    new ResultPoint(yi + CORR, yj - CORR)\n                ];\n            }\n            else {\n                return [\n                    new ResultPoint(ti + CORR, tj + CORR),\n                    new ResultPoint(zi + CORR, zj - CORR),\n                    new ResultPoint(xi - CORR, xj + CORR),\n                    new ResultPoint(yi - CORR, yj - CORR)\n                ];\n            }\n        }\n        /**\n         * Determines whether a segment contains a black point\n         *\n         * @param a          min value of the scanned coordinate\n         * @param b          max value of the scanned coordinate\n         * @param fixed      value of fixed coordinate\n         * @param horizontal set to true if scan must be horizontal, false if vertical\n         * @return true if a black point has been found, else false.\n         */\n        containsBlackPoint(a /*int*/, b /*int*/, fixed /*int*/, horizontal) {\n            const image = this.image;\n            if (horizontal) {\n                for (let x = a; x <= b; x++) {\n                    if (image.get(x, fixed)) {\n                        return true;\n                    }\n                }\n            }\n            else {\n                for (let y = a; y <= b; y++) {\n                    if (image.get(fixed, y)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n    WhiteRectangleDetector.INIT_SIZE = 10;\n    WhiteRectangleDetector.CORR = 1;\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * Implementations of this class can, given locations of finder patterns for a QR code in an\n     * image, sample the right points in the image to reconstruct the QR code, accounting for\n     * perspective distortion. It is abstracted since it is relatively expensive and should be allowed\n     * to take advantage of platform-specific optimized implementations, like Sun's Java Advanced\n     * Imaging library, but which may not be available in other environments such as J2ME, and vice\n     * versa.\n     *\n     * The implementation used can be controlled by calling {@link #setGridSampler(GridSampler)}\n     * with an instance of a class which implements this interface.\n     *\n     * @author Sean Owen\n     */\n    class GridSampler {\n        /**\n         * <p>Checks a set of points that have been transformed to sample points on an image against\n         * the image's dimensions to see if the point are even within the image.</p>\n         *\n         * <p>This method will actually \"nudge\" the endpoints back onto the image if they are found to be\n         * barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder\n         * patterns in an image where the QR Code runs all the way to the image border.</p>\n         *\n         * <p>For efficiency, the method will check points from either end of the line until one is found\n         * to be within the image. Because the set of points are assumed to be linear, this is valid.</p>\n         *\n         * @param image image into which the points should map\n         * @param points actual points in x1,y1,...,xn,yn form\n         * @throws NotFoundException if an endpoint is lies outside the image boundaries\n         */\n        static checkAndNudgePoints(image, points) {\n            const width = image.getWidth();\n            const height = image.getHeight();\n            // Check and nudge points from start until we see some that are OK:\n            let nudged = true;\n            for (let offset = 0; offset < points.length && nudged; offset += 2) {\n                const x = Math.floor(points[offset]);\n                const y = Math.floor(points[offset + 1]);\n                if (x < -1 || x > width || y < -1 || y > height) {\n                    throw new NotFoundException();\n                }\n                nudged = false;\n                if (x === -1) {\n                    points[offset] = 0.0;\n                    nudged = true;\n                }\n                else if (x === width) {\n                    points[offset] = width - 1;\n                    nudged = true;\n                }\n                if (y === -1) {\n                    points[offset + 1] = 0.0;\n                    nudged = true;\n                }\n                else if (y === height) {\n                    points[offset + 1] = height - 1;\n                    nudged = true;\n                }\n            }\n            // Check and nudge points from end:\n            nudged = true;\n            for (let offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {\n                const x = Math.floor(points[offset]);\n                const y = Math.floor(points[offset + 1]);\n                if (x < -1 || x > width || y < -1 || y > height) {\n                    throw new NotFoundException();\n                }\n                nudged = false;\n                if (x === -1) {\n                    points[offset] = 0.0;\n                    nudged = true;\n                }\n                else if (x === width) {\n                    points[offset] = width - 1;\n                    nudged = true;\n                }\n                if (y === -1) {\n                    points[offset + 1] = 0.0;\n                    nudged = true;\n                }\n                else if (y === height) {\n                    points[offset + 1] = height - 1;\n                    nudged = true;\n                }\n            }\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing.common {*/\n    /**\n     * <p>This class implements a perspective transform in two dimensions. Given four source and four\n     * destination points, it will compute the transformation implied between them. The code is based\n     * directly upon section 3.4.2 of George Wolberg's \"Digital Image Warping\"; see pages 54-56.</p>\n     *\n     * @author Sean Owen\n     */\n    class PerspectiveTransform {\n        constructor(a11 /*float*/, a21 /*float*/, a31 /*float*/, a12 /*float*/, a22 /*float*/, a32 /*float*/, a13 /*float*/, a23 /*float*/, a33 /*float*/) {\n            this.a11 = a11;\n            this.a21 = a21;\n            this.a31 = a31;\n            this.a12 = a12;\n            this.a22 = a22;\n            this.a32 = a32;\n            this.a13 = a13;\n            this.a23 = a23;\n            this.a33 = a33;\n        }\n        static quadrilateralToQuadrilateral(x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/, x0p /*float*/, y0p /*float*/, x1p /*float*/, y1p /*float*/, x2p /*float*/, y2p /*float*/, x3p /*float*/, y3p /*float*/) {\n            const qToS = PerspectiveTransform.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);\n            const sToQ = PerspectiveTransform.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);\n            return sToQ.times(qToS);\n        }\n        transformPoints(points) {\n            const max = points.length;\n            const a11 = this.a11;\n            const a12 = this.a12;\n            const a13 = this.a13;\n            const a21 = this.a21;\n            const a22 = this.a22;\n            const a23 = this.a23;\n            const a31 = this.a31;\n            const a32 = this.a32;\n            const a33 = this.a33;\n            for (let i = 0; i < max; i += 2) {\n                const x = points[i];\n                const y = points[i + 1];\n                const denominator = a13 * x + a23 * y + a33;\n                points[i] = (a11 * x + a21 * y + a31) / denominator;\n                points[i + 1] = (a12 * x + a22 * y + a32) / denominator;\n            }\n        }\n        transformPointsWithValues(xValues, yValues) {\n            const a11 = this.a11;\n            const a12 = this.a12;\n            const a13 = this.a13;\n            const a21 = this.a21;\n            const a22 = this.a22;\n            const a23 = this.a23;\n            const a31 = this.a31;\n            const a32 = this.a32;\n            const a33 = this.a33;\n            const n = xValues.length;\n            for (let i = 0; i < n; i++) {\n                const x = xValues[i];\n                const y = yValues[i];\n                const denominator = a13 * x + a23 * y + a33;\n                xValues[i] = (a11 * x + a21 * y + a31) / denominator;\n                yValues[i] = (a12 * x + a22 * y + a32) / denominator;\n            }\n        }\n        static squareToQuadrilateral(x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {\n            const dx3 = x0 - x1 + x2 - x3;\n            const dy3 = y0 - y1 + y2 - y3;\n            if (dx3 === 0.0 && dy3 === 0.0) {\n                // Affine\n                return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0.0, 0.0, 1.0);\n            }\n            else {\n                const dx1 = x1 - x2;\n                const dx2 = x3 - x2;\n                const dy1 = y1 - y2;\n                const dy2 = y3 - y2;\n                const denominator = dx1 * dy2 - dx2 * dy1;\n                const a13 = (dx3 * dy2 - dx2 * dy3) / denominator;\n                const a23 = (dx1 * dy3 - dx3 * dy1) / denominator;\n                return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1.0);\n            }\n        }\n        static quadrilateralToSquare(x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {\n            // Here, the adjoint serves as the inverse:\n            return PerspectiveTransform.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();\n        }\n        buildAdjoint() {\n            // Adjoint is the transpose of the cofactor matrix:\n            return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);\n        }\n        times(other) {\n            return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * @author Sean Owen\n     */\n    class DefaultGridSampler extends GridSampler {\n        /*@Override*/\n        sampleGrid(image, dimensionX /*int*/, dimensionY /*int*/, p1ToX /*float*/, p1ToY /*float*/, p2ToX /*float*/, p2ToY /*float*/, p3ToX /*float*/, p3ToY /*float*/, p4ToX /*float*/, p4ToY /*float*/, p1FromX /*float*/, p1FromY /*float*/, p2FromX /*float*/, p2FromY /*float*/, p3FromX /*float*/, p3FromY /*float*/, p4FromX /*float*/, p4FromY /*float*/) {\n            const transform = PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);\n            return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);\n        }\n        /*@Override*/\n        sampleGridWithTransform(image, dimensionX /*int*/, dimensionY /*int*/, transform) {\n            if (dimensionX <= 0 || dimensionY <= 0) {\n                throw new NotFoundException();\n            }\n            const bits = new BitMatrix(dimensionX, dimensionY);\n            const points = new Float32Array(2 * dimensionX);\n            for (let y = 0; y < dimensionY; y++) {\n                const max = points.length;\n                const iValue = y + 0.5;\n                for (let x = 0; x < max; x += 2) {\n                    points[x] = (x / 2) + 0.5;\n                    points[x + 1] = iValue;\n                }\n                transform.transformPoints(points);\n                // Quick check to see if points transformed to something inside the image\n                // sufficient to check the endpoints\n                GridSampler.checkAndNudgePoints(image, points);\n                try {\n                    for (let x = 0; x < max; x += 2) {\n                        if (image.get(Math.floor(points[x]), Math.floor(points[x + 1]))) {\n                            // Black(-ish) pixel\n                            bits.set(x / 2, y);\n                        }\n                    }\n                }\n                catch (aioobe /*: ArrayIndexOutOfBoundsException*/) {\n                    // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting\n                    // transform gets \"twisted\" such that it maps a straight line of points to a set of points\n                    // whose endpoints are in bounds, but others are not. There is probably some mathematical\n                    // way to detect this about the transformation that I don't know yet.\n                    // This results in an ugly runtime exception despite our clever checks above -- can't have\n                    // that. We could check each point's coordinates but that feels duplicative. We settle for\n                    // catching and wrapping ArrayIndexOutOfBoundsException.\n                    throw new NotFoundException();\n                }\n            }\n            return bits;\n        }\n    }\n\n    class GridSamplerInstance {\n        /**\n         * Sets the implementation of GridSampler used by the library. One global\n         * instance is stored, which may sound problematic. But, the implementation provided\n         * ought to be appropriate for the entire platform, and all uses of this library\n         * in the whole lifetime of the JVM. For instance, an Android activity can swap in\n         * an implementation that takes advantage of native platform libraries.\n         *\n         * @param newGridSampler The platform-specific object to install.\n         */\n        static setGridSampler(newGridSampler) {\n            GridSamplerInstance.gridSampler = newGridSampler;\n        }\n        /**\n         * @return the current implementation of GridSampler\n         */\n        static getInstance() {\n            return GridSamplerInstance.gridSampler;\n        }\n    }\n    GridSamplerInstance.gridSampler = new DefaultGridSampler();\n\n    /*\n     * Copyright 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    class Point {\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n        toResultPoint() {\n            return new ResultPoint(this.getX(), this.getY());\n        }\n        getX() {\n            return this.x;\n        }\n        getY() {\n            return this.y;\n        }\n    }\n    /**\n     * Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code\n     * is rotated or skewed, or partially obscured.\n     *\n     * @author David Olivier\n     * @author Frank Yellin\n     */\n    class Detector {\n        constructor(image) {\n            this.EXPECTED_CORNER_BITS = new Int32Array([\n                0xee0,\n                0x1dc,\n                0x83b,\n                0x707,\n            ]);\n            this.image = image;\n        }\n        detect() {\n            return this.detectMirror(false);\n        }\n        /**\n         * Detects an Aztec Code in an image.\n         *\n         * @param isMirror if true, image is a mirror-image of original\n         * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code\n         * @throws NotFoundException if no Aztec Code can be found\n         */\n        detectMirror(isMirror) {\n            // 1. Get the center of the aztec matrix\n            let pCenter = this.getMatrixCenter();\n            // 2. Get the center points of the four diagonal points just outside the bull's eye\n            //  [topRight, bottomRight, bottomLeft, topLeft]\n            let bullsEyeCorners = this.getBullsEyeCorners(pCenter);\n            if (isMirror) {\n                let temp = bullsEyeCorners[0];\n                bullsEyeCorners[0] = bullsEyeCorners[2];\n                bullsEyeCorners[2] = temp;\n            }\n            // 3. Get the size of the matrix and other parameters from the bull's eye\n            this.extractParameters(bullsEyeCorners);\n            // 4. Sample the grid\n            let bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);\n            // 5. Get the corners of the matrix.\n            let corners = this.getMatrixCornerPoints(bullsEyeCorners);\n            return new AztecDetectorResult(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);\n        }\n        /**\n         * Extracts the number of data layers and data blocks from the layer around the bull's eye.\n         *\n         * @param bullsEyeCorners the array of bull's eye corners\n         * @throws NotFoundException in case of too many errors or invalid parameters\n         */\n        extractParameters(bullsEyeCorners) {\n            if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) ||\n                !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {\n                throw new NotFoundException();\n            }\n            let length = 2 * this.nbCenterLayers;\n            // Get the bits around the bull's eye\n            let sides = new Int32Array([\n                this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),\n                this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),\n                this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),\n                this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) // Top\n            ]);\n            // bullsEyeCorners[shift] is the corner of the bulls'eye that has three\n            // orientation marks.\n            // sides[shift] is the row/column that goes from the corner with three\n            // orientation marks to the corner with two.\n            this.shift = this.getRotation(sides, length);\n            // Flatten the parameter bits into a single 28- or 40-bit long\n            let parameterData = 0;\n            for (let i = 0; i < 4; i++) {\n                let side = sides[(this.shift + i) % 4];\n                if (this.compact) {\n                    // Each side of the form ..XXXXXXX. where Xs are parameter data\n                    parameterData <<= 7;\n                    parameterData += (side >> 1) & 0x7F;\n                }\n                else {\n                    // Each side of the form ..XXXXX.XXXXX. where Xs are parameter data\n                    parameterData <<= 10;\n                    parameterData += ((side >> 2) & (0x1f << 5)) + ((side >> 1) & 0x1F);\n                }\n            }\n            // Corrects parameter data using RS.  Returns just the data portion\n            // without the error correction.\n            let correctedData = this.getCorrectedParameterData(parameterData, this.compact);\n            if (this.compact) {\n                // 8 bits:  2 bits layers and 6 bits data blocks\n                this.nbLayers = (correctedData >> 6) + 1;\n                this.nbDataBlocks = (correctedData & 0x3F) + 1;\n            }\n            else {\n                // 16 bits:  5 bits layers and 11 bits data blocks\n                this.nbLayers = (correctedData >> 11) + 1;\n                this.nbDataBlocks = (correctedData & 0x7FF) + 1;\n            }\n        }\n        getRotation(sides, length) {\n            // In a normal pattern, we expect to See\n            //   **    .*             D       A\n            //   *      *\n            //\n            //   .      *\n            //   ..    ..             C       B\n            //\n            // Grab the 3 bits from each of the sides the form the locator pattern and concatenate\n            // into a 12-bit integer.  Start with the bit at A\n            let cornerBits = 0;\n            sides.forEach((side, idx, arr) => {\n                // XX......X where X's are orientation marks\n                let t = ((side >> (length - 2)) << 1) + (side & 1);\n                cornerBits = (cornerBits << 3) + t;\n            });\n            // for (var side in sides) {\n            //     // XX......X where X's are orientation marks\n            //     var t = ((side >> (length - 2)) << 1) + (side & 1);\n            //     cornerBits = (cornerBits << 3) + t;\n            // }\n            // Mov the bottom bit to the top, so that the three bits of the locator pattern at A are\n            // together.  cornerBits is now:\n            //  3 orientation bits at A || 3 orientation bits at B || ... || 3 orientation bits at D\n            cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);\n            // The result shift indicates which element of BullsEyeCorners[] goes into the top-left\n            // corner. Since the four rotation values have a Hamming distance of 8, we\n            // can easily tolerate two errors.\n            for (let shift = 0; shift < 4; shift++) {\n                if (Integer.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {\n                    return shift;\n                }\n            }\n            throw new NotFoundException();\n        }\n        /**\n         * Corrects the parameter bits using Reed-Solomon algorithm.\n         *\n         * @param parameterData parameter bits\n         * @param compact true if this is a compact Aztec code\n         * @throws NotFoundException if the array contains too many errors\n         */\n        getCorrectedParameterData(parameterData, compact) {\n            let numCodewords;\n            let numDataCodewords;\n            if (compact) {\n                numCodewords = 7;\n                numDataCodewords = 2;\n            }\n            else {\n                numCodewords = 10;\n                numDataCodewords = 4;\n            }\n            let numECCodewords = numCodewords - numDataCodewords;\n            let parameterWords = new Int32Array(numCodewords);\n            for (let i = numCodewords - 1; i >= 0; --i) {\n                parameterWords[i] = parameterData & 0xF;\n                parameterData >>= 4;\n            }\n            try {\n                let rsDecoder = new ReedSolomonDecoder(GenericGF.AZTEC_PARAM);\n                rsDecoder.decode(parameterWords, numECCodewords);\n            }\n            catch (ignored) {\n                throw new NotFoundException();\n            }\n            // Toss the error correction.  Just return the data as an integer\n            let result = 0;\n            for (let i = 0; i < numDataCodewords; i++) {\n                result = (result << 4) + parameterWords[i];\n            }\n            return result;\n        }\n        /**\n         * Finds the corners of a bull-eye centered on the passed point.\n         * This returns the centers of the diagonal points just outside the bull's eye\n         * Returns [topRight, bottomRight, bottomLeft, topLeft]\n         *\n         * @param pCenter Center point\n         * @return The corners of the bull-eye\n         * @throws NotFoundException If no valid bull-eye can be found\n         */\n        getBullsEyeCorners(pCenter) {\n            let pina = pCenter;\n            let pinb = pCenter;\n            let pinc = pCenter;\n            let pind = pCenter;\n            let color = true;\n            for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {\n                let pouta = this.getFirstDifferent(pina, color, 1, -1);\n                let poutb = this.getFirstDifferent(pinb, color, 1, 1);\n                let poutc = this.getFirstDifferent(pinc, color, -1, 1);\n                let poutd = this.getFirstDifferent(pind, color, -1, -1);\n                // d      a\n                //\n                // c      b\n                if (this.nbCenterLayers > 2) {\n                    let q = (this.distancePoint(poutd, pouta) * this.nbCenterLayers) / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));\n                    if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {\n                        break;\n                    }\n                }\n                pina = pouta;\n                pinb = poutb;\n                pinc = poutc;\n                pind = poutd;\n                color = !color;\n            }\n            if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {\n                throw new NotFoundException();\n            }\n            this.compact = this.nbCenterLayers === 5;\n            // Expand the square by .5 pixel in each direction so that we're on the border\n            // between the white square and the black square\n            let pinax = new ResultPoint(pina.getX() + 0.5, pina.getY() - 0.5);\n            let pinbx = new ResultPoint(pinb.getX() + 0.5, pinb.getY() + 0.5);\n            let pincx = new ResultPoint(pinc.getX() - 0.5, pinc.getY() + 0.5);\n            let pindx = new ResultPoint(pind.getX() - 0.5, pind.getY() - 0.5);\n            // Expand the square so that its corners are the centers of the points\n            // just outside the bull's eye.\n            return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);\n        }\n        /**\n         * Finds a candidate center point of an Aztec code from an image\n         *\n         * @return the center point\n         */\n        getMatrixCenter() {\n            let pointA;\n            let pointB;\n            let pointC;\n            let pointD;\n            // Get a white rectangle that can be the border of the matrix in center bull's eye or\n            try {\n                let cornerPoints = new WhiteRectangleDetector(this.image).detect();\n                pointA = cornerPoints[0];\n                pointB = cornerPoints[1];\n                pointC = cornerPoints[2];\n                pointD = cornerPoints[3];\n            }\n            catch (e) {\n                // This exception can be in case the initial rectangle is white\n                // In that case, surely in the bull's eye, we try to expand the rectangle.\n                let cx = this.image.getWidth() / 2;\n                let cy = this.image.getHeight() / 2;\n                pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n                pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n                pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n                pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n            }\n            // Compute the center of the rectangle\n            let cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n            let cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n            // Redetermine the white rectangle starting from previously computed center.\n            // This will ensure that we end up with a white rectangle in center bull's eye\n            // in order to compute a more accurate center.\n            try {\n                let cornerPoints = new WhiteRectangleDetector(this.image, 15, cx, cy).detect();\n                pointA = cornerPoints[0];\n                pointB = cornerPoints[1];\n                pointC = cornerPoints[2];\n                pointD = cornerPoints[3];\n            }\n            catch (e) {\n                // This exception can be in case the initial rectangle is white\n                // In that case we try to expand the rectangle.\n                pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n                pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n                pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n                pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n            }\n            // Recompute the center of the rectangle\n            cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n            cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n            return new Point(cx, cy);\n        }\n        /**\n         * Gets the Aztec code corners from the bull's eye corners and the parameters.\n         *\n         * @param bullsEyeCorners the array of bull's eye corners\n         * @return the array of aztec code corners\n         */\n        getMatrixCornerPoints(bullsEyeCorners) {\n            return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());\n        }\n        /**\n         * Creates a BitMatrix by sampling the provided image.\n         * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the\n         * diagonal just outside the bull's eye.\n         */\n        sampleGrid(image, topLeft, topRight, bottomRight, bottomLeft) {\n            let sampler = GridSamplerInstance.getInstance();\n            let dimension = this.getDimension();\n            let low = dimension / 2 - this.nbCenterLayers;\n            let high = dimension / 2 + this.nbCenterLayers;\n            return sampler.sampleGrid(image, dimension, dimension, low, low, // topleft\n            high, low, // topright\n            high, high, // bottomright\n            low, high, // bottomleft\n            topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n        }\n        /**\n         * Samples a line.\n         *\n         * @param p1   start point (inclusive)\n         * @param p2   end point (exclusive)\n         * @param size number of bits\n         * @return the array of bits as an int (first bit is high-order bit of result)\n         */\n        sampleLine(p1, p2, size) {\n            let result = 0;\n            let d = this.distanceResultPoint(p1, p2);\n            let moduleSize = d / size;\n            let px = p1.getX();\n            let py = p1.getY();\n            let dx = moduleSize * (p2.getX() - p1.getX()) / d;\n            let dy = moduleSize * (p2.getY() - p1.getY()) / d;\n            for (let i = 0; i < size; i++) {\n                if (this.image.get(MathUtils.round(px + i * dx), MathUtils.round(py + i * dy))) {\n                    result |= 1 << (size - i - 1);\n                }\n            }\n            return result;\n        }\n        /**\n         * @return true if the border of the rectangle passed in parameter is compound of white points only\n         *         or black points only\n         */\n        isWhiteOrBlackRectangle(p1, p2, p3, p4) {\n            let corr = 3;\n            p1 = new Point(p1.getX() - corr, p1.getY() + corr);\n            p2 = new Point(p2.getX() - corr, p2.getY() - corr);\n            p3 = new Point(p3.getX() + corr, p3.getY() - corr);\n            p4 = new Point(p4.getX() + corr, p4.getY() + corr);\n            let cInit = this.getColor(p4, p1);\n            if (cInit === 0) {\n                return false;\n            }\n            let c = this.getColor(p1, p2);\n            if (c !== cInit) {\n                return false;\n            }\n            c = this.getColor(p2, p3);\n            if (c !== cInit) {\n                return false;\n            }\n            c = this.getColor(p3, p4);\n            return c === cInit;\n        }\n        /**\n         * Gets the color of a segment\n         *\n         * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else\n         */\n        getColor(p1, p2) {\n            let d = this.distancePoint(p1, p2);\n            let dx = (p2.getX() - p1.getX()) / d;\n            let dy = (p2.getY() - p1.getY()) / d;\n            let error = 0;\n            let px = p1.getX();\n            let py = p1.getY();\n            let colorModel = this.image.get(p1.getX(), p1.getY());\n            let iMax = Math.ceil(d);\n            for (let i = 0; i < iMax; i++) {\n                px += dx;\n                py += dy;\n                if (this.image.get(MathUtils.round(px), MathUtils.round(py)) !== colorModel) {\n                    error++;\n                }\n            }\n            let errRatio = error / d;\n            if (errRatio > 0.1 && errRatio < 0.9) {\n                return 0;\n            }\n            return (errRatio <= 0.1) === colorModel ? 1 : -1;\n        }\n        /**\n         * Gets the coordinate of the first point with a different color in the given direction\n         */\n        getFirstDifferent(init, color, dx, dy) {\n            let x = init.getX() + dx;\n            let y = init.getY() + dy;\n            while (this.isValid(x, y) && this.image.get(x, y) === color) {\n                x += dx;\n                y += dy;\n            }\n            x -= dx;\n            y -= dy;\n            while (this.isValid(x, y) && this.image.get(x, y) === color) {\n                x += dx;\n            }\n            x -= dx;\n            while (this.isValid(x, y) && this.image.get(x, y) === color) {\n                y += dy;\n            }\n            y -= dy;\n            return new Point(x, y);\n        }\n        /**\n         * Expand the square represented by the corner points by pushing out equally in all directions\n         *\n         * @param cornerPoints the corners of the square, which has the bull's eye at its center\n         * @param oldSide the original length of the side of the square in the target bit matrix\n         * @param newSide the new length of the size of the square in the target bit matrix\n         * @return the corners of the expanded square\n         */\n        expandSquare(cornerPoints, oldSide, newSide) {\n            let ratio = newSide / (2.0 * oldSide);\n            let dx = cornerPoints[0].getX() - cornerPoints[2].getX();\n            let dy = cornerPoints[0].getY() - cornerPoints[2].getY();\n            let centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0;\n            let centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0;\n            let result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);\n            let result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);\n            dx = cornerPoints[1].getX() - cornerPoints[3].getX();\n            dy = cornerPoints[1].getY() - cornerPoints[3].getY();\n            centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0;\n            centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0;\n            let result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);\n            let result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);\n            let results = [result0, result1, result2, result3];\n            return results;\n        }\n        isValid(x, y) {\n            return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();\n        }\n        isValidPoint(point) {\n            let x = MathUtils.round(point.getX());\n            let y = MathUtils.round(point.getY());\n            return this.isValid(x, y);\n        }\n        distancePoint(a, b) {\n            return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());\n        }\n        distanceResultPoint(a, b) {\n            return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());\n        }\n        getDimension() {\n            if (this.compact) {\n                return 4 * this.nbLayers + 11;\n            }\n            if (this.nbLayers <= 4) {\n                return 4 * this.nbLayers + 15;\n            }\n            return 4 * this.nbLayers + 2 * (Integer.truncDivision((this.nbLayers - 4), 8) + 1) + 15;\n        }\n    }\n\n    /*\n     * Copyright 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // import java.util.List;\n    // import java.util.Map;\n    /**\n     * This implementation can detect and decode Aztec codes in an image.\n     *\n     * @author David Olivier\n     */\n    class AztecReader {\n        /**\n         * Locates and decodes a Data Matrix code in an image.\n         *\n         * @return a String representing the content encoded by the Data Matrix code\n         * @throws NotFoundException if a Data Matrix code cannot be found\n         * @throws FormatException if a Data Matrix code cannot be decoded\n         */\n        decode(image, hints = null) {\n            let exception = null;\n            let detector = new Detector(image.getBlackMatrix());\n            let points = null;\n            let decoderResult = null;\n            try {\n                let detectorResult = detector.detectMirror(false);\n                points = detectorResult.getPoints();\n                this.reportFoundResultPoints(hints, points);\n                decoderResult = new Decoder().decode(detectorResult);\n            }\n            catch (e) {\n                exception = e;\n            }\n            if (decoderResult == null) {\n                try {\n                    let detectorResult = detector.detectMirror(true);\n                    points = detectorResult.getPoints();\n                    this.reportFoundResultPoints(hints, points);\n                    decoderResult = new Decoder().decode(detectorResult);\n                }\n                catch (e) {\n                    if (exception != null) {\n                        throw exception;\n                    }\n                    throw e;\n                }\n            }\n            let result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), decoderResult.getNumBits(), points, BarcodeFormat$1.AZTEC, System.currentTimeMillis());\n            let byteSegments = decoderResult.getByteSegments();\n            if (byteSegments != null) {\n                result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);\n            }\n            let ecLevel = decoderResult.getECLevel();\n            if (ecLevel != null) {\n                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);\n            }\n            return result;\n        }\n        reportFoundResultPoints(hints, points) {\n            if (hints != null) {\n                let rpcb = hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);\n                if (rpcb != null) {\n                    points.forEach((point, idx, arr) => {\n                        rpcb.foundPossibleResultPoint(point);\n                    });\n                }\n            }\n        }\n        // @Override\n        reset() {\n            // do nothing\n        }\n    }\n\n    /**\n     * Aztec Code reader to use from browser.\n     *\n     * @class BrowserAztecCodeReader\n     * @extends {BrowserCodeReader}\n     */\n    class BrowserAztecCodeReader extends BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserAztecCodeReader.\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n         *\n         * @memberOf BrowserAztecCodeReader\n         */\n        constructor(timeBetweenScansMillis = 500) {\n            super(new AztecReader(), timeBetweenScansMillis);\n        }\n    }\n\n    /**\n     * Encapsulates functionality and implementation that is common to all families\n     * of one-dimensional barcodes.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     */\n    class OneDReader {\n        /*\n        @Override\n        public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {\n          return decode(image, null);\n        }\n        */\n        // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n        // @Override\n        decode(image, hints) {\n            try {\n                return this.doDecode(image, hints);\n            }\n            catch (nfe) {\n                const tryHarder = hints && (hints.get(DecodeHintType$1.TRY_HARDER) === true);\n                if (tryHarder && image.isRotateSupported()) {\n                    const rotatedImage = image.rotateCounterClockwise();\n                    const result = this.doDecode(rotatedImage, hints);\n                    // Record that we found it rotated 90 degrees CCW / 270 degrees CW\n                    const metadata = result.getResultMetadata();\n                    let orientation = 270;\n                    if (metadata !== null && (metadata.get(ResultMetadataType$1.ORIENTATION) === true)) {\n                        // But if we found it reversed in doDecode(), add in that result here:\n                        orientation = (orientation + metadata.get(ResultMetadataType$1.ORIENTATION) % 360);\n                    }\n                    result.putMetadata(ResultMetadataType$1.ORIENTATION, orientation);\n                    // Update result points\n                    const points = result.getResultPoints();\n                    if (points !== null) {\n                        const height = rotatedImage.getHeight();\n                        for (let i = 0; i < points.length; i++) {\n                            points[i] = new ResultPoint(height - points[i].getY() - 1, points[i].getX());\n                        }\n                    }\n                    return result;\n                }\n                else {\n                    throw new NotFoundException();\n                }\n            }\n        }\n        // @Override\n        reset() {\n            // do nothing\n        }\n        /**\n         * We're going to examine rows from the middle outward, searching alternately above and below the\n         * middle, and farther out each time. rowStep is the number of rows between each successive\n         * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then\n         * middle + rowStep, then middle - (2 * rowStep), etc.\n         * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily\n         * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the\n         * image if \"trying harder\".\n         *\n         * @param image The image to decode\n         * @param hints Any hints that were requested\n         * @return The contents of the decoded barcode\n         * @throws NotFoundException Any spontaneous errors which occur\n         */\n        doDecode(image, hints) {\n            const width = image.getWidth();\n            const height = image.getHeight();\n            let row = new BitArray(width);\n            const tryHarder = hints && (hints.get(DecodeHintType$1.TRY_HARDER) === true);\n            const rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));\n            let maxLines;\n            if (tryHarder) {\n                maxLines = height; // Look at the whole image, not just the center\n            }\n            else {\n                maxLines = 15; // 15 rows spaced 1/32 apart is roughly the middle half of the image\n            }\n            const middle = Math.trunc(height / 2);\n            for (let x = 0; x < maxLines; x++) {\n                // Scanning from the middle out. Determine which row we're looking at next:\n                const rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);\n                const isAbove = (x & 0x01) === 0; // i.e. is x even?\n                const rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);\n                if (rowNumber < 0 || rowNumber >= height) {\n                    // Oops, if we run off the top or bottom, stop\n                    break;\n                }\n                // Estimate black point for this row and load it:\n                try {\n                    row = image.getBlackRow(rowNumber, row);\n                }\n                catch (ignored) {\n                    continue;\n                }\n                // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to\n                // handle decoding upside down barcodes.\n                for (let attempt = 0; attempt < 2; attempt++) {\n                    if (attempt === 1) { // trying again?\n                        row.reverse(); // reverse the row and continue\n                        // This means we will only ever draw result points *once* in the life of this method\n                        // since we want to avoid drawing the wrong points after flipping the row, and,\n                        // don't want to clutter with noise from every single row scan -- just the scans\n                        // that start on the center line.\n                        if (hints && (hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK) === true)) {\n                            const newHints = new Map();\n                            hints.forEach((hint, key) => newHints.set(key, hint));\n                            newHints.delete(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);\n                            hints = newHints;\n                        }\n                    }\n                    try {\n                        // Look for a barcode\n                        const result = this.decodeRow(rowNumber, row, hints);\n                        // We found our barcode\n                        if (attempt === 1) {\n                            // But it was upside down, so note that\n                            result.putMetadata(ResultMetadataType$1.ORIENTATION, 180);\n                            // And remember to flip the result points horizontally.\n                            const points = result.getResultPoints();\n                            if (points !== null) {\n                                points[0] = new ResultPoint(width - points[0].getX() - 1, points[0].getY());\n                                points[1] = new ResultPoint(width - points[1].getX() - 1, points[1].getY());\n                            }\n                        }\n                        return result;\n                    }\n                    catch (re) {\n                        // continue -- just couldn't decode this row\n                    }\n                }\n            }\n            throw new NotFoundException();\n        }\n        /**\n         * Records the size of successive runs of white and black pixels in a row, starting at a given point.\n         * The values are recorded in the given array, and the number of runs recorded is equal to the size\n         * of the array. If the row starts on a white pixel at the given start point, then the first count\n         * recorded is the run of white pixels starting from that point; likewise it is the count of a run\n         * of black pixels if the row begin on a black pixels at that point.\n         *\n         * @param row row to count from\n         * @param start offset into row to start at\n         * @param counters array into which to record counts\n         * @throws NotFoundException if counters cannot be filled entirely from row before running out\n         *  of pixels\n         */\n        static recordPattern(row, start, counters) {\n            const numCounters = counters.length;\n            for (let index = 0; index < numCounters; index++)\n                counters[index] = 0;\n            const end = row.getSize();\n            if (start >= end) {\n                throw new NotFoundException();\n            }\n            let isWhite = !row.get(start);\n            let counterPosition = 0;\n            let i = start;\n            while (i < end) {\n                if (row.get(i) !== isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (++counterPosition === numCounters) {\n                        break;\n                    }\n                    else {\n                        counters[counterPosition] = 1;\n                        isWhite = !isWhite;\n                    }\n                }\n                i++;\n            }\n            // If we read fully the last section of pixels and filled up our counters -- or filled\n            // the last counter but ran off the side of the image, OK. Otherwise, a problem.\n            if (!(counterPosition === numCounters || (counterPosition === numCounters - 1 && i === end))) {\n                throw new NotFoundException();\n            }\n        }\n        static recordPatternInReverse(row, start, counters) {\n            // This could be more efficient I guess\n            let numTransitionsLeft = counters.length;\n            let last = row.get(start);\n            while (start > 0 && numTransitionsLeft >= 0) {\n                if (row.get(--start) !== last) {\n                    numTransitionsLeft--;\n                    last = !last;\n                }\n            }\n            if (numTransitionsLeft >= 0) {\n                throw new NotFoundException();\n            }\n            OneDReader.recordPattern(row, start + 1, counters);\n        }\n        /**\n         * Determines how closely a set of observed counts of runs of black/white values matches a given\n         * target pattern. This is reported as the ratio of the total variance from the expected pattern\n         * proportions across all pattern elements, to the length of the pattern.\n         *\n         * @param counters observed counters\n         * @param pattern expected pattern\n         * @param maxIndividualVariance The most any counter can differ before we give up\n         * @return ratio of total variance between counters and pattern compared to total pattern size\n         */\n        static patternMatchVariance(counters, pattern, maxIndividualVariance) {\n            const numCounters = counters.length;\n            let total = 0;\n            let patternLength = 0;\n            for (let i = 0; i < numCounters; i++) {\n                total += counters[i];\n                patternLength += pattern[i];\n            }\n            if (total < patternLength) {\n                // If we don't even have one pixel per unit of bar width, assume this is too small\n                // to reliably match, so fail:\n                return Number.POSITIVE_INFINITY;\n            }\n            const unitBarWidth = total / patternLength;\n            maxIndividualVariance *= unitBarWidth;\n            let totalVariance = 0.0;\n            for (let x = 0; x < numCounters; x++) {\n                const counter = counters[x];\n                const scaledPattern = pattern[x] * unitBarWidth;\n                const variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n                if (variance > maxIndividualVariance) {\n                    return Number.POSITIVE_INFINITY;\n                }\n                totalVariance += variance;\n            }\n            return totalVariance / total;\n        }\n    }\n\n    /**\n     * <p>Decodes Code 128 barcodes.</p>\n     *\n     * @author Sean Owen\n     */\n    class Code128Reader extends OneDReader {\n        static findStartPattern(row) {\n            const width = row.getSize();\n            const rowOffset = row.getNextSet(0);\n            let counterPosition = 0;\n            let counters = Int32Array.from([0, 0, 0, 0, 0, 0]);\n            let patternStart = rowOffset;\n            let isWhite = false;\n            const patternLength = 6;\n            for (let i = rowOffset; i < width; i++) {\n                if (row.get(i) !== isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (counterPosition === (patternLength - 1)) {\n                        let bestVariance = Code128Reader.MAX_AVG_VARIANCE;\n                        let bestMatch = -1;\n                        for (let startCode = Code128Reader.CODE_START_A; startCode <= Code128Reader.CODE_START_C; startCode++) {\n                            const variance = OneDReader.patternMatchVariance(counters, Code128Reader.CODE_PATTERNS[startCode], Code128Reader.MAX_INDIVIDUAL_VARIANCE);\n                            if (variance < bestVariance) {\n                                bestVariance = variance;\n                                bestMatch = startCode;\n                            }\n                        }\n                        // Look for whitespace before start pattern, >= 50% of width of start pattern\n                        if (bestMatch >= 0 &&\n                            row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {\n                            return Int32Array.from([patternStart, i, bestMatch]);\n                        }\n                        patternStart += counters[0] + counters[1];\n                        counters = counters.slice(2, counters.length - 1);\n                        counters[counterPosition - 1] = 0;\n                        counters[counterPosition] = 0;\n                        counterPosition--;\n                    }\n                    else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        static decodeCode(row, counters, rowOffset) {\n            OneDReader.recordPattern(row, rowOffset, counters);\n            let bestVariance = Code128Reader.MAX_AVG_VARIANCE; // worst variance we'll accept\n            let bestMatch = -1;\n            for (let d = 0; d < Code128Reader.CODE_PATTERNS.length; d++) {\n                const pattern = Code128Reader.CODE_PATTERNS[d];\n                const variance = this.patternMatchVariance(counters, pattern, Code128Reader.MAX_INDIVIDUAL_VARIANCE);\n                if (variance < bestVariance) {\n                    bestVariance = variance;\n                    bestMatch = d;\n                }\n            }\n            // TODO We're overlooking the fact that the STOP pattern has 7 values, not 6.\n            if (bestMatch >= 0) {\n                return bestMatch;\n            }\n            else {\n                throw new NotFoundException();\n            }\n        }\n        decodeRow(rowNumber, row, hints) {\n            const convertFNC1 = hints && (hints.get(DecodeHintType$1.ASSUME_GS1) === true);\n            const startPatternInfo = Code128Reader.findStartPattern(row);\n            const startCode = startPatternInfo[2];\n            let currentRawCodesIndex = 0;\n            const rawCodes = new Uint8Array(20);\n            rawCodes[currentRawCodesIndex++] = startCode;\n            let codeSet;\n            switch (startCode) {\n                case Code128Reader.CODE_START_A:\n                    codeSet = Code128Reader.CODE_CODE_A;\n                    break;\n                case Code128Reader.CODE_START_B:\n                    codeSet = Code128Reader.CODE_CODE_B;\n                    break;\n                case Code128Reader.CODE_START_C:\n                    codeSet = Code128Reader.CODE_CODE_C;\n                    break;\n                default:\n                    throw new FormatException();\n            }\n            let done = false;\n            let isNextShifted = false;\n            let result = '';\n            let lastStart = startPatternInfo[0];\n            let nextStart = startPatternInfo[1];\n            const counters = Int32Array.from([0, 0, 0, 0, 0, 0]);\n            let lastCode = 0;\n            let code = 0;\n            let checksumTotal = startCode;\n            let multiplier = 0;\n            let lastCharacterWasPrintable = true;\n            let upperMode = false;\n            let shiftUpperMode = false;\n            while (!done) {\n                const unshift = isNextShifted;\n                isNextShifted = false;\n                // Save off last code\n                lastCode = code;\n                // Decode another code from image\n                code = Code128Reader.decodeCode(row, counters, nextStart);\n                rawCodes[currentRawCodesIndex++] = code;\n                // Remember whether the last code was printable or not (excluding CODE_STOP)\n                if (code !== Code128Reader.CODE_STOP) {\n                    lastCharacterWasPrintable = true;\n                }\n                // Add to checksum computation (if not CODE_STOP of course)\n                if (code !== Code128Reader.CODE_STOP) {\n                    multiplier++;\n                    checksumTotal += multiplier * code;\n                }\n                // Advance to where the next code will to start\n                lastStart = nextStart;\n                nextStart += counters.reduce((previous, current) => previous + current, 0);\n                // Take care of illegal start codes\n                switch (code) {\n                    case Code128Reader.CODE_START_A:\n                    case Code128Reader.CODE_START_B:\n                    case Code128Reader.CODE_START_C:\n                        throw new FormatException();\n                }\n                switch (codeSet) {\n                    case Code128Reader.CODE_CODE_A:\n                        if (code < 64) {\n                            if (shiftUpperMode === upperMode) {\n                                result += String.fromCharCode((' '.charCodeAt(0) + code));\n                            }\n                            else {\n                                result += String.fromCharCode((' '.charCodeAt(0) + code + 128));\n                            }\n                            shiftUpperMode = false;\n                        }\n                        else if (code < 96) {\n                            if (shiftUpperMode === upperMode) {\n                                result += String.fromCharCode((code - 64));\n                            }\n                            else {\n                                result += String.fromCharCode((code + 64));\n                            }\n                            shiftUpperMode = false;\n                        }\n                        else {\n                            // Don't let CODE_STOP, which always appears, affect whether whether we think the last\n                            // code was printable or not.\n                            if (code !== Code128Reader.CODE_STOP) {\n                                lastCharacterWasPrintable = false;\n                            }\n                            switch (code) {\n                                case Code128Reader.CODE_FNC_1:\n                                    if (convertFNC1) {\n                                        if (result.length === 0) {\n                                            // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                                            // is FNC1 then this is GS1-128. We add the symbology identifier.\n                                            result += ']C1';\n                                        }\n                                        else {\n                                            // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                                            result += String.fromCharCode(29);\n                                        }\n                                    }\n                                    break;\n                                case Code128Reader.CODE_FNC_2:\n                                case Code128Reader.CODE_FNC_3:\n                                    // do nothing?\n                                    break;\n                                case Code128Reader.CODE_FNC_4_A:\n                                    if (!upperMode && shiftUpperMode) {\n                                        upperMode = true;\n                                        shiftUpperMode = false;\n                                    }\n                                    else if (upperMode && shiftUpperMode) {\n                                        upperMode = false;\n                                        shiftUpperMode = false;\n                                    }\n                                    else {\n                                        shiftUpperMode = true;\n                                    }\n                                    break;\n                                case Code128Reader.CODE_SHIFT:\n                                    isNextShifted = true;\n                                    codeSet = Code128Reader.CODE_CODE_B;\n                                    break;\n                                case Code128Reader.CODE_CODE_B:\n                                    codeSet = Code128Reader.CODE_CODE_B;\n                                    break;\n                                case Code128Reader.CODE_CODE_C:\n                                    codeSet = Code128Reader.CODE_CODE_C;\n                                    break;\n                                case Code128Reader.CODE_STOP:\n                                    done = true;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Code128Reader.CODE_CODE_B:\n                        if (code < 96) {\n                            if (shiftUpperMode === upperMode) {\n                                result += String.fromCharCode((' '.charCodeAt(0) + code));\n                            }\n                            else {\n                                result += String.fromCharCode((' '.charCodeAt(0) + code + 128));\n                            }\n                            shiftUpperMode = false;\n                        }\n                        else {\n                            if (code !== Code128Reader.CODE_STOP) {\n                                lastCharacterWasPrintable = false;\n                            }\n                            switch (code) {\n                                case Code128Reader.CODE_FNC_1:\n                                    if (convertFNC1) {\n                                        if (result.length === 0) {\n                                            // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                                            // is FNC1 then this is GS1-128. We add the symbology identifier.\n                                            result += ']C1';\n                                        }\n                                        else {\n                                            // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                                            result += String.fromCharCode(29);\n                                        }\n                                    }\n                                    break;\n                                case Code128Reader.CODE_FNC_2:\n                                case Code128Reader.CODE_FNC_3:\n                                    // do nothing?\n                                    break;\n                                case Code128Reader.CODE_FNC_4_B:\n                                    if (!upperMode && shiftUpperMode) {\n                                        upperMode = true;\n                                        shiftUpperMode = false;\n                                    }\n                                    else if (upperMode && shiftUpperMode) {\n                                        upperMode = false;\n                                        shiftUpperMode = false;\n                                    }\n                                    else {\n                                        shiftUpperMode = true;\n                                    }\n                                    break;\n                                case Code128Reader.CODE_SHIFT:\n                                    isNextShifted = true;\n                                    codeSet = Code128Reader.CODE_CODE_A;\n                                    break;\n                                case Code128Reader.CODE_CODE_A:\n                                    codeSet = Code128Reader.CODE_CODE_A;\n                                    break;\n                                case Code128Reader.CODE_CODE_C:\n                                    codeSet = Code128Reader.CODE_CODE_C;\n                                    break;\n                                case Code128Reader.CODE_STOP:\n                                    done = true;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Code128Reader.CODE_CODE_C:\n                        if (code < 100) {\n                            if (code < 10) {\n                                result += '0';\n                            }\n                            result += code;\n                        }\n                        else {\n                            if (code !== Code128Reader.CODE_STOP) {\n                                lastCharacterWasPrintable = false;\n                            }\n                            switch (code) {\n                                case Code128Reader.CODE_FNC_1:\n                                    if (convertFNC1) {\n                                        if (result.length === 0) {\n                                            // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                                            // is FNC1 then this is GS1-128. We add the symbology identifier.\n                                            result += ']C1';\n                                        }\n                                        else {\n                                            // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                                            result += String.fromCharCode(29);\n                                        }\n                                    }\n                                    break;\n                                case Code128Reader.CODE_CODE_A:\n                                    codeSet = Code128Reader.CODE_CODE_A;\n                                    break;\n                                case Code128Reader.CODE_CODE_B:\n                                    codeSet = Code128Reader.CODE_CODE_B;\n                                    break;\n                                case Code128Reader.CODE_STOP:\n                                    done = true;\n                                    break;\n                            }\n                        }\n                        break;\n                }\n                // Unshift back to another code set if we were shifted\n                if (unshift) {\n                    codeSet = codeSet === Code128Reader.CODE_CODE_A ? Code128Reader.CODE_CODE_B : Code128Reader.CODE_CODE_A;\n                }\n            }\n            const lastPatternSize = nextStart - lastStart;\n            // Check for ample whitespace following pattern, but, to do this we first need to remember that\n            // we fudged decoding CODE_STOP since it actually has 7 bars, not 6. There is a black bar left\n            // to read off. Would be slightly better to properly read. Here we just skip it:\n            nextStart = row.getNextUnset(nextStart);\n            if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {\n                throw new NotFoundException();\n            }\n            // Pull out from sum the value of the penultimate check code\n            checksumTotal -= multiplier * lastCode;\n            // lastCode is the checksum then:\n            if (checksumTotal % 103 !== lastCode) {\n                throw new ChecksumException();\n            }\n            // Need to pull out the check digits from string\n            const resultLength = result.length;\n            if (resultLength === 0) {\n                // false positive\n                throw new NotFoundException();\n            }\n            // Only bother if the result had at least one character, and if the checksum digit happened to\n            // be a printable character. If it was just interpreted as a control code, nothing to remove.\n            if (resultLength > 0 && lastCharacterWasPrintable) {\n                if (codeSet === Code128Reader.CODE_CODE_C) {\n                    result = result.substring(0, resultLength - 2);\n                }\n                else {\n                    result = result.substring(0, resultLength - 1);\n                }\n            }\n            const left = (startPatternInfo[1] + startPatternInfo[0]) / 2.0;\n            const right = lastStart + lastPatternSize / 2.0;\n            const rawCodesSize = rawCodes.length;\n            const rawBytes = new Uint8Array(rawCodesSize);\n            for (let i = 0; i < rawCodesSize; i++) {\n                rawBytes[i] = rawCodes[i];\n            }\n            const points = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];\n            return new Result(result, rawBytes, 0, points, BarcodeFormat$1.CODE_128, new Date().getTime());\n        }\n    }\n    Code128Reader.CODE_PATTERNS = [\n        Int32Array.from([2, 1, 2, 2, 2, 2]),\n        Int32Array.from([2, 2, 2, 1, 2, 2]),\n        Int32Array.from([2, 2, 2, 2, 2, 1]),\n        Int32Array.from([1, 2, 1, 2, 2, 3]),\n        Int32Array.from([1, 2, 1, 3, 2, 2]),\n        Int32Array.from([1, 3, 1, 2, 2, 2]),\n        Int32Array.from([1, 2, 2, 2, 1, 3]),\n        Int32Array.from([1, 2, 2, 3, 1, 2]),\n        Int32Array.from([1, 3, 2, 2, 1, 2]),\n        Int32Array.from([2, 2, 1, 2, 1, 3]),\n        Int32Array.from([2, 2, 1, 3, 1, 2]),\n        Int32Array.from([2, 3, 1, 2, 1, 2]),\n        Int32Array.from([1, 1, 2, 2, 3, 2]),\n        Int32Array.from([1, 2, 2, 1, 3, 2]),\n        Int32Array.from([1, 2, 2, 2, 3, 1]),\n        Int32Array.from([1, 1, 3, 2, 2, 2]),\n        Int32Array.from([1, 2, 3, 1, 2, 2]),\n        Int32Array.from([1, 2, 3, 2, 2, 1]),\n        Int32Array.from([2, 2, 3, 2, 1, 1]),\n        Int32Array.from([2, 2, 1, 1, 3, 2]),\n        Int32Array.from([2, 2, 1, 2, 3, 1]),\n        Int32Array.from([2, 1, 3, 2, 1, 2]),\n        Int32Array.from([2, 2, 3, 1, 1, 2]),\n        Int32Array.from([3, 1, 2, 1, 3, 1]),\n        Int32Array.from([3, 1, 1, 2, 2, 2]),\n        Int32Array.from([3, 2, 1, 1, 2, 2]),\n        Int32Array.from([3, 2, 1, 2, 2, 1]),\n        Int32Array.from([3, 1, 2, 2, 1, 2]),\n        Int32Array.from([3, 2, 2, 1, 1, 2]),\n        Int32Array.from([3, 2, 2, 2, 1, 1]),\n        Int32Array.from([2, 1, 2, 1, 2, 3]),\n        Int32Array.from([2, 1, 2, 3, 2, 1]),\n        Int32Array.from([2, 3, 2, 1, 2, 1]),\n        Int32Array.from([1, 1, 1, 3, 2, 3]),\n        Int32Array.from([1, 3, 1, 1, 2, 3]),\n        Int32Array.from([1, 3, 1, 3, 2, 1]),\n        Int32Array.from([1, 1, 2, 3, 1, 3]),\n        Int32Array.from([1, 3, 2, 1, 1, 3]),\n        Int32Array.from([1, 3, 2, 3, 1, 1]),\n        Int32Array.from([2, 1, 1, 3, 1, 3]),\n        Int32Array.from([2, 3, 1, 1, 1, 3]),\n        Int32Array.from([2, 3, 1, 3, 1, 1]),\n        Int32Array.from([1, 1, 2, 1, 3, 3]),\n        Int32Array.from([1, 1, 2, 3, 3, 1]),\n        Int32Array.from([1, 3, 2, 1, 3, 1]),\n        Int32Array.from([1, 1, 3, 1, 2, 3]),\n        Int32Array.from([1, 1, 3, 3, 2, 1]),\n        Int32Array.from([1, 3, 3, 1, 2, 1]),\n        Int32Array.from([3, 1, 3, 1, 2, 1]),\n        Int32Array.from([2, 1, 1, 3, 3, 1]),\n        Int32Array.from([2, 3, 1, 1, 3, 1]),\n        Int32Array.from([2, 1, 3, 1, 1, 3]),\n        Int32Array.from([2, 1, 3, 3, 1, 1]),\n        Int32Array.from([2, 1, 3, 1, 3, 1]),\n        Int32Array.from([3, 1, 1, 1, 2, 3]),\n        Int32Array.from([3, 1, 1, 3, 2, 1]),\n        Int32Array.from([3, 3, 1, 1, 2, 1]),\n        Int32Array.from([3, 1, 2, 1, 1, 3]),\n        Int32Array.from([3, 1, 2, 3, 1, 1]),\n        Int32Array.from([3, 3, 2, 1, 1, 1]),\n        Int32Array.from([3, 1, 4, 1, 1, 1]),\n        Int32Array.from([2, 2, 1, 4, 1, 1]),\n        Int32Array.from([4, 3, 1, 1, 1, 1]),\n        Int32Array.from([1, 1, 1, 2, 2, 4]),\n        Int32Array.from([1, 1, 1, 4, 2, 2]),\n        Int32Array.from([1, 2, 1, 1, 2, 4]),\n        Int32Array.from([1, 2, 1, 4, 2, 1]),\n        Int32Array.from([1, 4, 1, 1, 2, 2]),\n        Int32Array.from([1, 4, 1, 2, 2, 1]),\n        Int32Array.from([1, 1, 2, 2, 1, 4]),\n        Int32Array.from([1, 1, 2, 4, 1, 2]),\n        Int32Array.from([1, 2, 2, 1, 1, 4]),\n        Int32Array.from([1, 2, 2, 4, 1, 1]),\n        Int32Array.from([1, 4, 2, 1, 1, 2]),\n        Int32Array.from([1, 4, 2, 2, 1, 1]),\n        Int32Array.from([2, 4, 1, 2, 1, 1]),\n        Int32Array.from([2, 2, 1, 1, 1, 4]),\n        Int32Array.from([4, 1, 3, 1, 1, 1]),\n        Int32Array.from([2, 4, 1, 1, 1, 2]),\n        Int32Array.from([1, 3, 4, 1, 1, 1]),\n        Int32Array.from([1, 1, 1, 2, 4, 2]),\n        Int32Array.from([1, 2, 1, 1, 4, 2]),\n        Int32Array.from([1, 2, 1, 2, 4, 1]),\n        Int32Array.from([1, 1, 4, 2, 1, 2]),\n        Int32Array.from([1, 2, 4, 1, 1, 2]),\n        Int32Array.from([1, 2, 4, 2, 1, 1]),\n        Int32Array.from([4, 1, 1, 2, 1, 2]),\n        Int32Array.from([4, 2, 1, 1, 1, 2]),\n        Int32Array.from([4, 2, 1, 2, 1, 1]),\n        Int32Array.from([2, 1, 2, 1, 4, 1]),\n        Int32Array.from([2, 1, 4, 1, 2, 1]),\n        Int32Array.from([4, 1, 2, 1, 2, 1]),\n        Int32Array.from([1, 1, 1, 1, 4, 3]),\n        Int32Array.from([1, 1, 1, 3, 4, 1]),\n        Int32Array.from([1, 3, 1, 1, 4, 1]),\n        Int32Array.from([1, 1, 4, 1, 1, 3]),\n        Int32Array.from([1, 1, 4, 3, 1, 1]),\n        Int32Array.from([4, 1, 1, 1, 1, 3]),\n        Int32Array.from([4, 1, 1, 3, 1, 1]),\n        Int32Array.from([1, 1, 3, 1, 4, 1]),\n        Int32Array.from([1, 1, 4, 1, 3, 1]),\n        Int32Array.from([3, 1, 1, 1, 4, 1]),\n        Int32Array.from([4, 1, 1, 1, 3, 1]),\n        Int32Array.from([2, 1, 1, 4, 1, 2]),\n        Int32Array.from([2, 1, 1, 2, 1, 4]),\n        Int32Array.from([2, 1, 1, 2, 3, 2]),\n        Int32Array.from([2, 3, 3, 1, 1, 1, 2]),\n    ];\n    Code128Reader.MAX_AVG_VARIANCE = 0.25;\n    Code128Reader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n    Code128Reader.CODE_SHIFT = 98;\n    Code128Reader.CODE_CODE_C = 99;\n    Code128Reader.CODE_CODE_B = 100;\n    Code128Reader.CODE_CODE_A = 101;\n    Code128Reader.CODE_FNC_1 = 102;\n    Code128Reader.CODE_FNC_2 = 97;\n    Code128Reader.CODE_FNC_3 = 96;\n    Code128Reader.CODE_FNC_4_A = 101;\n    Code128Reader.CODE_FNC_4_B = 100;\n    Code128Reader.CODE_START_A = 103;\n    Code128Reader.CODE_START_B = 104;\n    Code128Reader.CODE_START_C = 105;\n    Code128Reader.CODE_STOP = 106;\n\n    /**\n     * <p>Decodes Code 39 barcodes. Supports \"Full ASCII Code 39\" if USE_CODE_39_EXTENDED_MODE is set.</p>\n     *\n     * @author Sean Owen\n     * @see Code93Reader\n     */\n    class Code39Reader extends OneDReader {\n        /**\n         * Creates a reader that assumes all encoded data is data, and does not treat the final\n         * character as a check digit. It will not decoded \"extended Code 39\" sequences.\n         */\n        // public Code39Reader() {\n        //   this(false);\n        // }\n        /**\n         * Creates a reader that can be configured to check the last character as a check digit.\n         * It will not decoded \"extended Code 39\" sequences.\n         *\n         * @param usingCheckDigit if true, treat the last data character as a check digit, not\n         * data, and verify that the checksum passes.\n         */\n        // public Code39Reader(boolean usingCheckDigit) {\n        //   this(usingCheckDigit, false);\n        // }\n        /**\n         * Creates a reader that can be configured to check the last character as a check digit,\n         * or optionally attempt to decode \"extended Code 39\" sequences that are used to encode\n         * the full ASCII character set.\n         *\n         * @param usingCheckDigit if true, treat the last data character as a check digit, not\n         * data, and verify that the checksum passes.\n         * @param extendedMode if true, will attempt to decode extended Code 39 sequences in the\n         * text.\n         */\n        constructor(usingCheckDigit = false, extendedMode = false) {\n            super();\n            this.usingCheckDigit = usingCheckDigit;\n            this.extendedMode = extendedMode;\n            this.decodeRowResult = '';\n            this.counters = new Int32Array(9);\n        }\n        decodeRow(rowNumber, row, hints) {\n            let theCounters = this.counters;\n            theCounters.fill(0);\n            this.decodeRowResult = '';\n            let start = Code39Reader.findAsteriskPattern(row, theCounters);\n            // Read off white space\n            let nextStart = row.getNextSet(start[1]);\n            let end = row.getSize();\n            let decodedChar;\n            let lastStart;\n            do {\n                Code39Reader.recordPattern(row, nextStart, theCounters);\n                let pattern = Code39Reader.toNarrowWidePattern(theCounters);\n                if (pattern < 0) {\n                    throw new NotFoundException();\n                }\n                decodedChar = Code39Reader.patternToChar(pattern);\n                this.decodeRowResult += decodedChar;\n                lastStart = nextStart;\n                for (let counter of theCounters) {\n                    nextStart += counter;\n                }\n                // Read off white space\n                nextStart = row.getNextSet(nextStart);\n            } while (decodedChar !== '*');\n            this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1); // remove asterisk\n            // Look for whitespace after pattern:\n            let lastPatternSize = 0;\n            for (let counter of theCounters) {\n                lastPatternSize += counter;\n            }\n            let whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;\n            // If 50% of last pattern size, following last pattern, is not whitespace, fail\n            // (but if it's whitespace to the very end of the image, that's OK)\n            if (nextStart !== end && (whiteSpaceAfterEnd * 2) < lastPatternSize) {\n                throw new NotFoundException();\n            }\n            if (this.usingCheckDigit) {\n                let max = this.decodeRowResult.length - 1;\n                let total = 0;\n                for (let i = 0; i < max; i++) {\n                    total += Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i));\n                }\n                if (this.decodeRowResult.charAt(max) !== Code39Reader.ALPHABET_STRING.charAt(total % 43)) {\n                    throw new ChecksumException();\n                }\n                this.decodeRowResult = this.decodeRowResult.substring(0, max);\n            }\n            if (this.decodeRowResult.length === 0) {\n                // false positive\n                throw new NotFoundException();\n            }\n            let resultString;\n            if (this.extendedMode) {\n                resultString = Code39Reader.decodeExtended(this.decodeRowResult);\n            }\n            else {\n                resultString = this.decodeRowResult;\n            }\n            let left = (start[1] + start[0]) / 2.0;\n            let right = lastStart + lastPatternSize / 2.0;\n            return new Result(resultString, null, 0, [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)], BarcodeFormat$1.CODE_39, new Date().getTime());\n        }\n        static findAsteriskPattern(row, counters) {\n            let width = row.getSize();\n            let rowOffset = row.getNextSet(0);\n            let counterPosition = 0;\n            let patternStart = rowOffset;\n            let isWhite = false;\n            let patternLength = counters.length;\n            for (let i = rowOffset; i < width; i++) {\n                if (row.get(i) !== isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (counterPosition === patternLength - 1) {\n                        // Look for whitespace before start pattern, >= 50% of width of start pattern\n                        if (this.toNarrowWidePattern(counters) === Code39Reader.ASTERISK_ENCODING &&\n                            row.isRange(Math.max(0, patternStart - Math.floor((i - patternStart) / 2)), patternStart, false)) {\n                            return [patternStart, i];\n                        }\n                        patternStart += counters[0] + counters[1];\n                        counters.copyWithin(0, 2, 2 + counterPosition - 1);\n                        counters[counterPosition - 1] = 0;\n                        counters[counterPosition] = 0;\n                        counterPosition--;\n                    }\n                    else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        // For efficiency, returns -1 on failure. Not throwing here saved as many as 700 exceptions\n        // per image when using some of our blackbox images.\n        static toNarrowWidePattern(counters) {\n            let numCounters = counters.length;\n            let maxNarrowCounter = 0;\n            let wideCounters;\n            do {\n                let minCounter = 0x7fffffff;\n                for (let counter of counters) {\n                    if (counter < minCounter && counter > maxNarrowCounter) {\n                        minCounter = counter;\n                    }\n                }\n                maxNarrowCounter = minCounter;\n                wideCounters = 0;\n                let totalWideCountersWidth = 0;\n                let pattern = 0;\n                for (let i = 0; i < numCounters; i++) {\n                    let counter = counters[i];\n                    if (counter > maxNarrowCounter) {\n                        pattern |= 1 << (numCounters - 1 - i);\n                        wideCounters++;\n                        totalWideCountersWidth += counter;\n                    }\n                }\n                if (wideCounters === 3) {\n                    // Found 3 wide counters, but are they close enough in width?\n                    // We can perform a cheap, conservative check to see if any individual\n                    // counter is more than 1.5 times the average:\n                    for (let i = 0; i < numCounters && wideCounters > 0; i++) {\n                        let counter = counters[i];\n                        if (counter > maxNarrowCounter) {\n                            wideCounters--;\n                            // totalWideCountersWidth = 3 * average, so this checks if counter >= 3/2 * average\n                            if ((counter * 2) >= totalWideCountersWidth) {\n                                return -1;\n                            }\n                        }\n                    }\n                    return pattern;\n                }\n            } while (wideCounters > 3);\n            return -1;\n        }\n        static patternToChar(pattern) {\n            for (let i = 0; i < Code39Reader.CHARACTER_ENCODINGS.length; i++) {\n                if (Code39Reader.CHARACTER_ENCODINGS[i] === pattern) {\n                    return Code39Reader.ALPHABET_STRING.charAt(i);\n                }\n            }\n            if (pattern === Code39Reader.ASTERISK_ENCODING) {\n                return '*';\n            }\n            throw new NotFoundException();\n        }\n        static decodeExtended(encoded) {\n            let length = encoded.length;\n            let decoded = '';\n            for (let i = 0; i < length; i++) {\n                let c = encoded.charAt(i);\n                if (c === '+' || c === '$' || c === '%' || c === '/') {\n                    let next = encoded.charAt(i + 1);\n                    let decodedChar = '\\0';\n                    switch (c) {\n                        case '+':\n                            // +A to +Z map to a to z\n                            if (next >= 'A' && next <= 'Z') {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                        case '$':\n                            // $A to $Z map to control codes SH to SB\n                            if (next >= 'A' && next <= 'Z') {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                        case '%':\n                            // %A to %E map to control codes ESC to US\n                            if (next >= 'A' && next <= 'E') {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);\n                            }\n                            else if (next >= 'F' && next <= 'J') {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);\n                            }\n                            else if (next >= 'K' && next <= 'O') {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);\n                            }\n                            else if (next >= 'P' && next <= 'T') {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);\n                            }\n                            else if (next === 'U') {\n                                decodedChar = '\\0';\n                            }\n                            else if (next === 'V') {\n                                decodedChar = '@';\n                            }\n                            else if (next === 'W') {\n                                decodedChar = '`';\n                            }\n                            else if (next === 'X' || next === 'Y' || next === 'Z') {\n                                decodedChar = '\\x7f';\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                        case '/':\n                            // /A to /O map to ! to , and /Z maps to :\n                            if (next >= 'A' && next <= 'O') {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);\n                            }\n                            else if (next === 'Z') {\n                                decodedChar = ':';\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                    }\n                    decoded += decodedChar;\n                    // bump up i again since we read two characters\n                    i++;\n                }\n                else {\n                    decoded += c;\n                }\n            }\n            return decoded;\n        }\n    }\n    Code39Reader.ALPHABET_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%';\n    /**\n     * These represent the encodings of characters, as patterns of wide and narrow bars.\n     * The 9 least-significant bits of each int correspond to the pattern of wide and narrow,\n     * with 1s representing \"wide\" and 0s representing narrow.\n     */\n    Code39Reader.CHARACTER_ENCODINGS = [\n        0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064,\n        0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C,\n        0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016,\n        0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x0A8,\n        0x0A2, 0x08A, 0x02A // /-%\n    ];\n    Code39Reader.ASTERISK_ENCODING = 0x094;\n\n    /**\n     * <p>Decodes ITF barcodes.</p>\n     *\n     * @author Tjieco\n     */\n    class ITFReader extends OneDReader {\n        constructor() {\n            // private static W = 3; // Pixel width of a 3x wide line\n            // private static w = 2; // Pixel width of a 2x wide line\n            // private static N = 1; // Pixed width of a narrow line\n            super(...arguments);\n            // Stores the actual narrow line width of the image being decoded.\n            this.narrowLineWidth = -1;\n        }\n        // See ITFWriter.PATTERNS\n        /*\n      \n        /!**\n         * Patterns of Wide / Narrow lines to indicate each digit\n         *!/\n        */\n        decodeRow(rowNumber, row, hints) {\n            // Find out where the Middle section (payload) starts & ends\n            let startRange = this.decodeStart(row);\n            let endRange = this.decodeEnd(row);\n            let result = new StringBuilder();\n            ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);\n            let resultString = result.toString();\n            let allowedLengths = null;\n            if (hints != null) {\n                allowedLengths = hints.get(DecodeHintType$1.ALLOWED_LENGTHS);\n            }\n            if (allowedLengths == null) {\n                allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;\n            }\n            // To avoid false positives with 2D barcodes (and other patterns), make\n            // an assumption that the decoded string must be a 'standard' length if it's short\n            let length = resultString.length;\n            let lengthOK = false;\n            let maxAllowedLength = 0;\n            for (let value of allowedLengths) {\n                if (length === value) {\n                    lengthOK = true;\n                    break;\n                }\n                if (value > maxAllowedLength) {\n                    maxAllowedLength = value;\n                }\n            }\n            if (!lengthOK && length > maxAllowedLength) {\n                lengthOK = true;\n            }\n            if (!lengthOK) {\n                throw new FormatException();\n            }\n            const points = [new ResultPoint(startRange[1], rowNumber), new ResultPoint(endRange[0], rowNumber)];\n            let resultReturn = new Result(resultString, null, // no natural byte representation for these barcodes\n            0, points, BarcodeFormat$1.ITF, new Date().getTime());\n            return resultReturn;\n        }\n        /*\n        /!**\n         * @param row          row of black/white values to search\n         * @param payloadStart offset of start pattern\n         * @param resultString {@link StringBuilder} to append decoded chars to\n         * @throws NotFoundException if decoding could not complete successfully\n         *!/*/\n        static decodeMiddle(row, payloadStart, payloadEnd, resultString) {\n            // Digits are interleaved in pairs - 5 black lines for one digit, and the\n            // 5\n            // interleaved white lines for the second digit.\n            // Therefore, need to scan 10 lines and then\n            // split these into two arrays\n            let counterDigitPair = new Int32Array(10); // 10\n            let counterBlack = new Int32Array(5); // 5\n            let counterWhite = new Int32Array(5); // 5\n            counterDigitPair.fill(0);\n            counterBlack.fill(0);\n            counterWhite.fill(0);\n            while (payloadStart < payloadEnd) {\n                // Get 10 runs of black/white.\n                OneDReader.recordPattern(row, payloadStart, counterDigitPair);\n                // Split them into each array\n                for (let k = 0; k < 5; k++) {\n                    let twoK = 2 * k;\n                    counterBlack[k] = counterDigitPair[twoK];\n                    counterWhite[k] = counterDigitPair[twoK + 1];\n                }\n                let bestMatch = ITFReader.decodeDigit(counterBlack);\n                resultString.append(bestMatch.toString());\n                bestMatch = this.decodeDigit(counterWhite);\n                resultString.append(bestMatch.toString());\n                counterDigitPair.forEach(function (counterDigit) {\n                    payloadStart += counterDigit;\n                });\n            }\n        }\n        /*/!**\n         * Identify where the start of the middle / payload section starts.\n         *\n         * @param row row of black/white values to search\n         * @return Array, containing index of start of 'start block' and end of\n         *         'start block'\n         *!/*/\n        decodeStart(row) {\n            let endStart = ITFReader.skipWhiteSpace(row);\n            let startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN);\n            // Determine the width of a narrow line in pixels. We can do this by\n            // getting the width of the start pattern and dividing by 4 because its\n            // made up of 4 narrow lines.\n            this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;\n            this.validateQuietZone(row, startPattern[0]);\n            return startPattern;\n        }\n        /*/!**\n         * The start & end patterns must be pre/post fixed by a quiet zone. This\n         * zone must be at least 10 times the width of a narrow line.  Scan back until\n         * we either get to the start of the barcode or match the necessary number of\n         * quiet zone pixels.\n         *\n         * Note: Its assumed the row is reversed when using this method to find\n         * quiet zone after the end pattern.\n         *\n         * ref: http://www.barcode-1.net/i25code.html\n         *\n         * @param row bit array representing the scanned barcode.\n         * @param startPattern index into row of the start or end pattern.\n         * @throws NotFoundException if the quiet zone cannot be found\n         *!/*/\n        validateQuietZone(row, startPattern) {\n            let quietCount = this.narrowLineWidth * 10; // expect to find this many pixels of quiet zone\n            // if there are not so many pixel at all let's try as many as possible\n            quietCount = quietCount < startPattern ? quietCount : startPattern;\n            for (let i = startPattern - 1; quietCount > 0 && i >= 0; i--) {\n                if (row.get(i)) {\n                    break;\n                }\n                quietCount--;\n            }\n            if (quietCount !== 0) {\n                // Unable to find the necessary number of quiet zone pixels.\n                throw new NotFoundException();\n            }\n        }\n        /*\n        /!**\n         * Skip all whitespace until we get to the first black line.\n         *\n         * @param row row of black/white values to search\n         * @return index of the first black line.\n         * @throws NotFoundException Throws exception if no black lines are found in the row\n         *!/*/\n        static skipWhiteSpace(row) {\n            const width = row.getSize();\n            const endStart = row.getNextSet(0);\n            if (endStart === width) {\n                throw new NotFoundException();\n            }\n            return endStart;\n        }\n        /*/!**\n         * Identify where the end of the middle / payload section ends.\n         *\n         * @param row row of black/white values to search\n         * @return Array, containing index of start of 'end block' and end of 'end\n         *         block'\n         *!/*/\n        decodeEnd(row) {\n            // For convenience, reverse the row and then\n            // search from 'the start' for the end block\n            row.reverse();\n            try {\n                let endStart = ITFReader.skipWhiteSpace(row);\n                let endPattern;\n                try {\n                    endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);\n                }\n                catch (error) {\n                    if (error instanceof NotFoundException) {\n                        endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);\n                    }\n                }\n                // The start & end patterns must be pre/post fixed by a quiet zone. This\n                // zone must be at least 10 times the width of a narrow line.\n                // ref: http://www.barcode-1.net/i25code.html\n                this.validateQuietZone(row, endPattern[0]);\n                // Now recalculate the indices of where the 'endblock' starts & stops to\n                // accommodate\n                // the reversed nature of the search\n                let temp = endPattern[0];\n                endPattern[0] = row.getSize() - endPattern[1];\n                endPattern[1] = row.getSize() - temp;\n                return endPattern;\n            }\n            finally {\n                // Put the row back the right way.\n                row.reverse();\n            }\n        }\n        /*\n        /!**\n         * @param row       row of black/white values to search\n         * @param rowOffset position to start search\n         * @param pattern   pattern of counts of number of black and white pixels that are\n         *                  being searched for as a pattern\n         * @return start/end horizontal offset of guard pattern, as an array of two\n         *         ints\n         * @throws NotFoundException if pattern is not found\n         *!/*/\n        static findGuardPattern(row, rowOffset, pattern) {\n            let patternLength = pattern.length;\n            let counters = new Int32Array(patternLength);\n            let width = row.getSize();\n            let isWhite = false;\n            let counterPosition = 0;\n            let patternStart = rowOffset;\n            counters.fill(0);\n            for (let x = rowOffset; x < width; x++) {\n                if (row.get(x) !== isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (counterPosition === patternLength - 1) {\n                        if (OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {\n                            return [patternStart, x];\n                        }\n                        patternStart += counters[0] + counters[1];\n                        System.arraycopy(counters, 2, counters, 0, counterPosition - 1);\n                        counters[counterPosition - 1] = 0;\n                        counters[counterPosition] = 0;\n                        counterPosition--;\n                    }\n                    else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        /*/!**\n         * Attempts to decode a sequence of ITF black/white lines into single\n         * digit.\n         *\n         * @param counters the counts of runs of observed black/white/black/... values\n         * @return The decoded digit\n         * @throws NotFoundException if digit cannot be decoded\n         *!/*/\n        static decodeDigit(counters) {\n            let bestVariance = ITFReader.MAX_AVG_VARIANCE; // worst variance we'll accept\n            let bestMatch = -1;\n            let max = ITFReader.PATTERNS.length;\n            for (let i = 0; i < max; i++) {\n                let pattern = ITFReader.PATTERNS[i];\n                let variance = OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);\n                if (variance < bestVariance) {\n                    bestVariance = variance;\n                    bestMatch = i;\n                }\n                else if (variance === bestVariance) {\n                    // if we find a second 'best match' with the same variance, we can not reliably report to have a suitable match\n                    bestMatch = -1;\n                }\n            }\n            if (bestMatch >= 0) {\n                return bestMatch % 10;\n            }\n            else {\n                throw new NotFoundException();\n            }\n        }\n    }\n    ITFReader.PATTERNS = [\n        Int32Array.from([1, 1, 2, 2, 1]),\n        Int32Array.from([2, 1, 1, 1, 2]),\n        Int32Array.from([1, 2, 1, 1, 2]),\n        Int32Array.from([2, 2, 1, 1, 1]),\n        Int32Array.from([1, 1, 2, 1, 2]),\n        Int32Array.from([2, 1, 2, 1, 1]),\n        Int32Array.from([1, 2, 2, 1, 1]),\n        Int32Array.from([1, 1, 1, 2, 2]),\n        Int32Array.from([2, 1, 1, 2, 1]),\n        Int32Array.from([1, 2, 1, 2, 1]),\n        Int32Array.from([1, 1, 3, 3, 1]),\n        Int32Array.from([3, 1, 1, 1, 3]),\n        Int32Array.from([1, 3, 1, 1, 3]),\n        Int32Array.from([3, 3, 1, 1, 1]),\n        Int32Array.from([1, 1, 3, 1, 3]),\n        Int32Array.from([3, 1, 3, 1, 1]),\n        Int32Array.from([1, 3, 3, 1, 1]),\n        Int32Array.from([1, 1, 1, 3, 3]),\n        Int32Array.from([3, 1, 1, 3, 1]),\n        Int32Array.from([1, 3, 1, 3, 1]) // 9\n    ];\n    ITFReader.MAX_AVG_VARIANCE = 0.38;\n    ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;\n    /* /!** Valid ITF lengths. Anything longer than the largest value is also allowed. *!/*/\n    ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];\n    /*/!**\n     * Start/end guard pattern.\n     *\n     * Note: The end pattern is reversed because the row is reversed before\n     * searching for the END_PATTERN\n     *!/*/\n    ITFReader.START_PATTERN = Int32Array.from([1, 1, 1, 1]);\n    ITFReader.END_PATTERN_REVERSED = [\n        Int32Array.from([1, 1, 2]),\n        Int32Array.from([1, 1, 3]) // 3x\n    ];\n\n    /**\n     * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n     * of one-dimensional barcodes.</p>\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     * @author alasdair@google.com (Alasdair Mackintosh)\n     */\n    class AbstractUPCEANReader extends OneDReader {\n        constructor() {\n            super(...arguments);\n            this.decodeRowStringBuffer = '';\n        }\n\n        static findStartGuardPattern(row) {\n            let foundStart = false;\n            let startRange;\n            let nextStart = 0;\n            let counters = Int32Array.from([0, 0, 0]);\n            while (!foundStart) {\n                counters = Int32Array.from([0, 0, 0]);\n                startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);\n                let start = startRange[0];\n                nextStart = startRange[1];\n                let quietStart = start - (nextStart - start);\n                if (quietStart >= 0) {\n                    foundStart = row.isRange(quietStart, start, false);\n                }\n            }\n            return startRange;\n        }\n        static checkChecksum(s) {\n            return AbstractUPCEANReader.checkStandardUPCEANChecksum(s);\n        }\n        static checkStandardUPCEANChecksum(s) {\n            let length = s.length;\n            if (length === 0)\n                return false;\n            let check = parseInt(s.charAt(length - 1), 10);\n            return AbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n        }\n        static getStandardUPCEANChecksum(s) {\n            let length = s.length;\n            let sum = 0;\n            for (let i = length - 1; i >= 0; i -= 2) {\n                let digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n                if (digit < 0 || digit > 9) {\n                    throw new FormatException();\n                }\n                sum += digit;\n            }\n            sum *= 3;\n            for (let i = length - 2; i >= 0; i -= 2) {\n                let digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n                if (digit < 0 || digit > 9) {\n                    throw new FormatException();\n                }\n                sum += digit;\n            }\n            return (1000 - sum) % 10;\n        }\n        static decodeEnd(row, endStart) {\n            return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Int32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));\n        }\n        /**\n         * @throws NotFoundException\n         */\n        static findGuardPatternWithoutCounters(row, rowOffset, whiteFirst, pattern) {\n            return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));\n        }\n        /**\n         * @param row row of black/white values to search\n         * @param rowOffset position to start search\n         * @param whiteFirst if true, indicates that the pattern specifies white/black/white/...\n         * pixel counts, otherwise, it is interpreted as black/white/black/...\n         * @param pattern pattern of counts of number of black and white pixels that are being\n         * searched for as a pattern\n         * @param counters array of counters, as long as pattern, to re-use\n         * @return start/end horizontal offset of guard pattern, as an array of two ints\n         * @throws NotFoundException if pattern is not found\n         */\n        static findGuardPattern(row, rowOffset, whiteFirst, pattern, counters) {\n            let width = row.getSize();\n            rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);\n            let counterPosition = 0;\n            let patternStart = rowOffset;\n            let patternLength = pattern.length;\n            let isWhite = whiteFirst;\n            for (let x = rowOffset; x < width; x++) {\n                if (row.get(x) !== isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (counterPosition === patternLength - 1) {\n                        if (OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {\n                            return Int32Array.from([patternStart, x]);\n                        }\n                        patternStart += counters[0] + counters[1];\n                        let slice = counters.slice(2, counters.length - 1);\n                        for (let i = 0; i < counterPosition - 1; i++) {\n                            counters[i] = slice[i];\n                        }\n                        counters[counterPosition - 1] = 0;\n                        counters[counterPosition] = 0;\n                        counterPosition--;\n                    }\n                    else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        static decodeDigit(row, counters, rowOffset, patterns) {\n            this.recordPattern(row, rowOffset, counters);\n            let bestVariance = this.MAX_AVG_VARIANCE;\n            let bestMatch = -1;\n            let max = patterns.length;\n            for (let i = 0; i < max; i++) {\n                let pattern = patterns[i];\n                let variance = OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);\n                if (variance < bestVariance) {\n                    bestVariance = variance;\n                    bestMatch = i;\n                }\n            }\n            if (bestMatch >= 0) {\n                return bestMatch;\n            }\n            else {\n                throw new NotFoundException();\n            }\n        }\n    }\n    // These two values are critical for determining how permissive the decoding will be.\n    // We've arrived at these values through a lot of trial and error. Setting them any higher\n    // lets false positives creep in quickly.\n    AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;\n    AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n    /**\n     * Start/end guard pattern.\n     */\n    AbstractUPCEANReader.START_END_PATTERN = Int32Array.from([1, 1, 1]);\n    /**\n     * Pattern marking the middle of a UPC/EAN pattern, separating the two halves.\n     */\n    AbstractUPCEANReader.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);\n    /**\n     * end guard pattern.\n     */\n    AbstractUPCEANReader.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);\n    /**\n     * \"Odd\", or \"L\" patterns used to encode UPC/EAN digits.\n     */\n    AbstractUPCEANReader.L_PATTERNS = [\n        Int32Array.from([3, 2, 1, 1]),\n        Int32Array.from([2, 2, 2, 1]),\n        Int32Array.from([2, 1, 2, 2]),\n        Int32Array.from([1, 4, 1, 1]),\n        Int32Array.from([1, 1, 3, 2]),\n        Int32Array.from([1, 2, 3, 1]),\n        Int32Array.from([1, 1, 1, 4]),\n        Int32Array.from([1, 3, 1, 2]),\n        Int32Array.from([1, 2, 1, 3]),\n        Int32Array.from([3, 1, 1, 2]),\n    ];\n\n    /**\n     * @see UPCEANExtension2Support\n     */\n    class UPCEANExtension5Support {\n        constructor() {\n            this.CHECK_DIGIT_ENCODINGS = [0x18, 0x14, 0x12, 0x11, 0x0C, 0x06, 0x03, 0x0A, 0x09, 0x05];\n            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);\n            this.decodeRowStringBuffer = '';\n        }\n        decodeRow(rowNumber, row, extensionStartRange) {\n            let result = this.decodeRowStringBuffer;\n            let end = this.decodeMiddle(row, extensionStartRange, result);\n            let resultString = result.toString();\n            let extensionData = UPCEANExtension5Support.parseExtensionString(resultString);\n            let resultPoints = [\n                new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2.0, rowNumber),\n                new ResultPoint(end, rowNumber)\n            ];\n            let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, new Date().getTime());\n            if (extensionData != null) {\n                extensionResult.putAllMetadata(extensionData);\n            }\n            return extensionResult;\n        }\n        decodeMiddle(row, startRange, resultString) {\n            let counters = this.decodeMiddleCounters;\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let end = row.getSize();\n            let rowOffset = startRange[1];\n            let lgPatternFound = 0;\n            for (let x = 0; x < 5 && rowOffset < end; x++) {\n                let bestMatch = AbstractUPCEANReader.decodeDigit(\n                    row,\n                    counters,\n                    rowOffset,\n                    AbstractUPCEANReader.L_AND_G_PATTERNS);\n                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));\n                for (let counter of counters) {\n                    rowOffset += counter;\n                }\n                if (bestMatch >= 10) {\n                    lgPatternFound |= 1 << (4 - x);\n                }\n                if (x !== 4) {\n                    // Read off separator if not last\n                    rowOffset = row.getNextSet(rowOffset);\n                    rowOffset = row.getNextUnset(rowOffset);\n                }\n            }\n            if (resultString.length !== 5) {\n                throw new NotFoundException();\n            }\n            let checkDigit = this.determineCheckDigit(lgPatternFound);\n            if (UPCEANExtension5Support.extensionChecksum(resultString.toString()) !== checkDigit) {\n                throw new NotFoundException();\n            }\n            return rowOffset;\n        }\n        static extensionChecksum(s) {\n            let length = s.length;\n            let sum = 0;\n            for (let i = length - 2; i >= 0; i -= 2) {\n                sum += s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            }\n            sum *= 3;\n            for (let i = length - 1; i >= 0; i -= 2) {\n                sum += s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            }\n            sum *= 3;\n            return sum % 10;\n        }\n        determineCheckDigit(lgPatternFound) {\n            for (let d = 0; d < 10; d++) {\n                if (lgPatternFound === this.CHECK_DIGIT_ENCODINGS[d]) {\n                    return d;\n                }\n            }\n            throw new NotFoundException();\n        }\n        static parseExtensionString(raw) {\n            if (raw.length !== 5) {\n                return null;\n            }\n            let value = UPCEANExtension5Support.parseExtension5String(raw);\n            if (value == null) {\n                return null;\n            }\n            return new Map([[ResultMetadataType$1.SUGGESTED_PRICE, value]]);\n        }\n        static parseExtension5String(raw) {\n            let currency;\n            switch (raw.charAt(0)) {\n                case '0':\n                    currency = '£';\n                    break;\n                case '5':\n                    currency = '$';\n                    break;\n                case '9':\n                    // Reference: http://www.jollytech.com\n                    switch (raw) {\n                        case '90000':\n                            // No suggested retail price\n                            return null;\n                        case '99991':\n                            // Complementary\n                            return '0.00';\n                        case '99990':\n                            return 'Used';\n                    }\n                    // Otherwise... unknown currency?\n                    currency = '';\n                    break;\n                default:\n                    currency = '';\n                    break;\n            }\n            let rawAmount = parseInt(raw.substring(1));\n            let unitsString = (rawAmount / 100).toString();\n            let hundredths = rawAmount % 100;\n            let hundredthsString = hundredths < 10 ? '0' + hundredths : hundredths.toString(); // fixme\n            return currency + unitsString + '.' + hundredthsString;\n        }\n    }\n\n    /**\n     * @see UPCEANExtension5Support\n     */\n    class UPCEANExtension2Support {\n        constructor() {\n            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);\n            this.decodeRowStringBuffer = '';\n        }\n        decodeRow(rowNumber, row, extensionStartRange) {\n            let result = this.decodeRowStringBuffer;\n            let end = this.decodeMiddle(row, extensionStartRange, result);\n            let resultString = result.toString();\n            let extensionData = UPCEANExtension2Support.parseExtensionString(resultString);\n            let resultPoints = [\n                new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2.0, rowNumber),\n                new ResultPoint(end, rowNumber)\n            ];\n            let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, new Date().getTime());\n            if (extensionData != null) {\n                extensionResult.putAllMetadata(extensionData);\n            }\n            return extensionResult;\n        }\n        decodeMiddle(row, startRange, resultString) {\n            let counters = this.decodeMiddleCounters;\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let end = row.getSize();\n            let rowOffset = startRange[1];\n            let checkParity = 0;\n            for (let x = 0; x < 2 && rowOffset < end; x++) {\n                let bestMatch = AbstractUPCEANReader.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader.L_AND_G_PATTERNS);\n                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));\n                for (let counter of counters) {\n                    rowOffset += counter;\n                }\n                if (bestMatch >= 10) {\n                    checkParity |= 1 << (1 - x);\n                }\n                if (x !== 1) {\n                    // Read off separator if not last\n                    rowOffset = row.getNextSet(rowOffset);\n                    rowOffset = row.getNextUnset(rowOffset);\n                }\n            }\n            if (resultString.length !== 2) {\n                throw new NotFoundException();\n            }\n            if (parseInt(resultString.toString()) % 4 !== checkParity) {\n                throw new NotFoundException();\n            }\n            return rowOffset;\n        }\n        static parseExtensionString(raw) {\n            if (raw.length !== 2) {\n                return null;\n            }\n            return new Map([[ResultMetadataType$1.ISSUE_NUMBER, parseInt(raw)]]);\n        }\n    }\n\n    class UPCEANExtensionSupport {\n        static decodeRow(rowNumber, row, rowOffset) {\n            let extensionStartRange = AbstractUPCEANReader.findGuardPattern(\n                row,\n                rowOffset,\n                false,\n                this.EXTENSION_START_PATTERN,\n                new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0));\n            try {\n                // return null;\n                let fiveSupport = new UPCEANExtension5Support();\n                return fiveSupport.decodeRow(rowNumber, row, extensionStartRange);\n            }\n            catch (err) {\n                // return null;\n                let twoSupport = new UPCEANExtension2Support();\n                return twoSupport.decodeRow(rowNumber, row, extensionStartRange);\n            }\n        }\n    }\n    UPCEANExtensionSupport.EXTENSION_START_PATTERN = Int32Array.from([1, 1, 2]);\n\n    /**\n     * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n     * of one-dimensional barcodes.</p>\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     * @author alasdair@google.com (Alasdair Mackintosh)\n     */\n    class UPCEANReader extends AbstractUPCEANReader {\n        constructor() {\n            super();\n            this.decodeRowStringBuffer = '';\n            UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map(arr => Int32Array.from(arr));\n            for (let i = 10; i < 20; i++) {\n                let widths = UPCEANReader.L_PATTERNS[i - 10];\n                let reversedWidths = new Int32Array(widths.length);\n                for (let j = 0; j < widths.length; j++) {\n                    reversedWidths[j] = widths[widths.length - j - 1];\n                }\n                UPCEANReader.L_AND_G_PATTERNS[i] = reversedWidths;\n            }\n        }\n        decodeRow(rowNumber, row, hints) {\n            let startGuardRange = UPCEANReader.findStartGuardPattern(row);\n            let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);\n            if (resultPointCallback != null) {\n                const resultPoint = new ResultPoint((startGuardRange[0] + startGuardRange[1]) / 2.0, rowNumber);\n                resultPointCallback.foundPossibleResultPoint(resultPoint);\n            }\n            let budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);\n            let endStart = budello.rowOffset;\n            let result = budello.resultString;\n            if (resultPointCallback != null) {\n                const resultPoint = new ResultPoint(endStart, rowNumber);\n                resultPointCallback.foundPossibleResultPoint(resultPoint);\n            }\n            let endRange = this.decodeEnd(row, endStart);\n            if (resultPointCallback != null) {\n                const resultPoint = new ResultPoint((endRange[0] + endRange[1]) / 2.0, rowNumber);\n                resultPointCallback.foundPossibleResultPoint(resultPoint);\n            }\n            // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The\n            // spec might want more whitespace, but in practice this is the maximum we can count on.\n            let end = endRange[1];\n            let quietEnd = end + (end - endRange[0]);\n            if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {\n                throw new NotFoundException();\n            }\n            let resultString = result.toString();\n            // UPC/EAN should never be less than 8 chars anyway\n            if (resultString.length < 8) {\n                throw new FormatException();\n            }\n            if (!UPCEANReader.checkChecksum(resultString)) {\n                throw new ChecksumException();\n            }\n            let left = (startGuardRange[1] + startGuardRange[0]) / 2.0;\n            let right = (endRange[1] + endRange[0]) / 2.0;\n            let format = this.getBarcodeFormat();\n            let resultPoint = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];\n            let decodeResult = new Result(resultString, null, 0, resultPoint, format, new Date().getTime());\n            let extensionLength = 0;\n            try {\n                let extensionResult = UPCEANExtensionSupport.decodeRow(rowNumber, row, endRange[1]);\n                decodeResult.putMetadata(ResultMetadataType$1.UPC_EAN_EXTENSION, extensionResult.getText());\n                decodeResult.putAllMetadata(extensionResult.getResultMetadata());\n                decodeResult.addResultPoints(extensionResult.getResultPoints());\n                extensionLength = extensionResult.getText().length;\n            }\n            catch (ignoreError) {}\n            let allowedExtensions = hints == null ? null : hints.get(DecodeHintType$1.ALLOWED_EAN_EXTENSIONS);\n            if (allowedExtensions != null) {\n                let valid = false;\n                for (let length in allowedExtensions) {\n                    if (extensionLength.toString() === length) { // check me\n                        valid = true;\n                        break;\n                    }\n                }\n                if (!valid) {\n                    throw new NotFoundException();\n                }\n            }\n            return decodeResult;\n        }\n        decodeEnd(row, endStart) {\n            return UPCEANReader.findGuardPattern(\n                row, endStart, false, UPCEANReader.START_END_PATTERN,\n                new Int32Array(UPCEANReader.START_END_PATTERN.length).fill(0));\n        }\n        static checkChecksum(s) {\n            return UPCEANReader.checkStandardUPCEANChecksum(s);\n        }\n        static checkStandardUPCEANChecksum(s) {\n            let length = s.length;\n            if (length === 0)\n                return false;\n            let check = parseInt(s.charAt(length - 1), 10);\n            return UPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n        }\n        static getStandardUPCEANChecksum(s) {\n            let length = s.length;\n            let sum = 0;\n            for (let i = length - 1; i >= 0; i -= 2) {\n                let digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n                if (digit < 0 || digit > 9) {\n                    throw new FormatException();\n                }\n                sum += digit;\n            }\n            sum *= 3;\n            for (let i = length - 2; i >= 0; i -= 2) {\n                let digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n                if (digit < 0 || digit > 9) {\n                    throw new FormatException();\n                }\n                sum += digit;\n            }\n            return (1000 - sum) % 10;\n        }\n    }\n\n    /**\n     * <p>Implements decoding of the EAN-13 format.</p>\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     * @author alasdair@google.com (Alasdair Mackintosh)\n     */\n    class EAN13Reader extends UPCEANReader {\n        constructor() {\n            super();\n            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);\n        }\n        decodeMiddle(row, startRange, resultString) {\n            let counters = this.decodeMiddleCounters;\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let end = row.getSize();\n            let rowOffset = startRange[1];\n            let lgPatternFound = 0;\n            for (let x = 0; x < 6 && rowOffset < end; x++) {\n                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_AND_G_PATTERNS);\n                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));\n                for (let counter of counters) {\n                    rowOffset += counter;\n                }\n                if (bestMatch >= 10) {\n                    lgPatternFound |= 1 << (5 - x);\n                }\n            }\n            resultString = EAN13Reader.determineFirstDigit(resultString, lgPatternFound);\n            let middleRange = UPCEANReader.findGuardPattern(\n                row,\n                rowOffset,\n                true,\n                UPCEANReader.MIDDLE_PATTERN,\n                new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));\n            rowOffset = middleRange[1];\n            for (let x = 0; x < 6 && rowOffset < end; x++) {\n                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);\n                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));\n                for (let counter of counters) {\n                    rowOffset += counter;\n                }\n            }\n            return { rowOffset, resultString };\n        }\n        getBarcodeFormat() {\n            return BarcodeFormat$1.EAN_13;\n        }\n        static determineFirstDigit(resultString, lgPatternFound) {\n            for (let d = 0; d < 10; d++) {\n                if (lgPatternFound === this.FIRST_DIGIT_ENCODINGS[d]) {\n                    resultString = String.fromCharCode(('0'.charCodeAt(0) + d)) + resultString;\n                    return resultString;\n                }\n            }\n            throw new NotFoundException();\n        }\n    }\n    EAN13Reader.FIRST_DIGIT_ENCODINGS = [0x00, 0x0B, 0x0D, 0xE, 0x13, 0x19, 0x1C, 0x15, 0x16, 0x1A];\n\n    /**\n     * <p>Implements decoding of the EAN-8 format.</p>\n     *\n     * @author Sean Owen\n     */\n    class EAN8Reader extends UPCEANReader {\n        constructor() {\n            super();\n            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);\n        }\n        decodeMiddle(row, startRange, resultString) {\n            const counters = this.decodeMiddleCounters;\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let end = row.getSize();\n            let rowOffset = startRange[1];\n            for (let x = 0; x < 4 && rowOffset < end; x++) {\n                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);\n                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));\n                for (let counter of counters) {\n                    rowOffset += counter;\n                }\n            }\n            let middleRange = UPCEANReader.findGuardPattern(row, rowOffset, true, UPCEANReader.MIDDLE_PATTERN, new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));\n            rowOffset = middleRange[1];\n            for (let x = 0; x < 4 && rowOffset < end; x++) {\n                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);\n                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));\n                for (let counter of counters) {\n                    rowOffset += counter;\n                }\n            }\n            return { rowOffset, resultString };\n        }\n        getBarcodeFormat() {\n            return BarcodeFormat$1.EAN_8;\n        }\n    }\n\n    /**\n     * Encapsulates functionality and implementation that is common to all families\n     * of one-dimensional barcodes.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     * @author sam2332 (Sam Rudloff)\n     *\n     * @source https://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCAReader.java\n     *\n     * @experimental\n     */\n    class UPCAReader extends UPCEANReader {\n        constructor() {\n            super(...arguments);\n            this.ean13Reader = new EAN13Reader();\n        }\n        // @Override\n        getBarcodeFormat() {\n            return BarcodeFormat$1.UPC_A;\n        }\n        // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n        // @Override\n        decode(image, hints) {\n            return this.maybeReturnResult(this.ean13Reader.decode(image));\n        }\n        // @Override\n        decodeRow(rowNumber, row, hints) {\n            return this.maybeReturnResult(this.ean13Reader.decodeRow(rowNumber, row, hints));\n        }\n        // @Override\n        decodeMiddle(row, startRange, resultString) {\n            return this.ean13Reader.decodeMiddle(row, startRange, resultString);\n        }\n        maybeReturnResult(result) {\n            let text = result.getText();\n            if (text.charAt(0) === '0') {\n                let upcaResult = new Result(text.substring(1), null, null, result.getResultPoints(), BarcodeFormat$1.UPC_A);\n                if (result.getResultMetadata() != null) {\n                    upcaResult.putAllMetadata(result.getResultMetadata());\n                }\n                return upcaResult;\n            }\n            else {\n                throw new NotFoundException();\n            }\n        }\n        reset() {\n            this.ean13Reader.reset();\n        }\n    }\n\n    /**\n     * <p>Implements decoding of the UPC-E format.</p>\n     * <p><a href=\"http://www.barcodeisland.com/upce.phtml\">This</a> is a great reference for\n     * UPC-E information.</p>\n     *\n     * @author Sean Owen\n     *\n     * @source https://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCEReader.java\n     *\n     * @experimental\n     */\n    /* final */ class UPCEReader extends UPCEANReader {\n        constructor() {\n            super();\n            this.decodeMiddleCounters = new Int32Array(4);\n        }\n        /**\n         * @throws NotFoundException\n         */\n        // @Override\n        decodeMiddle(row, startRange, result) {\n            const counters = this.decodeMiddleCounters.map(x => x);\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            const end = row.getSize();\n            let rowOffset = startRange[1];\n            let lgPatternFound = 0;\n            for (let x = 0; x < 6 && rowOffset < end; x++) {\n                const bestMatch = UPCEReader.decodeDigit(\n                    row, counters, rowOffset, UPCEReader.L_AND_G_PATTERNS);\n                result += String.fromCharCode(('0'.charCodeAt(0) + (bestMatch % 10)));\n                for (let counter of counters) {\n                    rowOffset += counter;\n                }\n                if (bestMatch >= 10) {\n                    lgPatternFound |= (1 << (5 - x));\n                }\n            }\n            let resultString = UPCEReader.determineNumSysAndCheckDigit(\n                result, lgPatternFound);\n            return {rowOffset, resultString};\n        }\n        /**\n         * @throws NotFoundException\n         */\n        // @Override\n        decodeEnd(row, endStart) {\n            return UPCEReader.findGuardPatternWithoutCounters(\n                row, endStart, true, UPCEReader.MIDDLE_END_PATTERN);\n        }\n        /**\n         * @throws FormatException\n         */\n        // @Override\n        checkChecksum(s) {\n            return UPCEANReader.checkChecksum(UPCEReader.convertUPCEtoUPCA(s));\n        }\n        /**\n         * @throws NotFoundException\n         */\n        static determineNumSysAndCheckDigit(resultString, lgPatternFound) {\n            for (let numSys = 0; numSys <= 1; numSys++) {\n                for (let d = 0; d < 10; d++) {\n                    if (lgPatternFound === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[numSys][d]) {\n                        let prefix = String.fromCharCode('0'.charCodeAt(0) + numSys);\n                        let suffix = String.fromCharCode('0'.charCodeAt(0) + d);\n                        return prefix + resultString + suffix;\n                    }\n                }\n            }\n            throw NotFoundException.getNotFoundInstance();\n        }\n        // @Override\n        getBarcodeFormat() {\n            return BarcodeFormat$1.UPC_E;\n        }\n        /**\n         * Expands a UPC-E value back into its full, equivalent UPC-A code value.\n         *\n         * @param upce UPC-E code as string of digits\n         * @return equivalent UPC-A code as string of digits\n         */\n        static convertUPCEtoUPCA(upce) {\n            // the following line is equivalent to upce.getChars(1, 7, upceChars, 0);\n            const upceChars = upce.slice(1, 7).split('').map(x => x.charCodeAt(0));\n            const result = new StringBuilder( /*12*/);\n            result.append(upce.charAt(0));\n            let lastChar = upceChars[5];\n            switch (lastChar) {\n                case 0:\n                case 1:\n                case 2:\n                    result.appendChars(upceChars, 0, 2);\n                    result.append(lastChar);\n                    result.append('0000');\n                    result.appendChars(upceChars, 2, 3);\n                    break;\n                case 3:\n                    result.appendChars(upceChars, 0, 3);\n                    result.append('00000');\n                    result.appendChars(upceChars, 3, 2);\n                    break;\n                case 4:\n                    result.appendChars(upceChars, 0, 4);\n                    result.append('00000');\n                    result.append(upceChars[4]);\n                    break;\n                default:\n                    result.appendChars(upceChars, 0, 5);\n                    result.append('0000');\n                    result.append(lastChar);\n                    break;\n            }\n            // Only append check digit in conversion if supplied\n            if (upce.length >= 8) {\n                result.append(upce.charAt(7));\n            }\n            return result.toString();\n        }\n    }\n    /**\n     * The pattern that marks the middle, and end, of a UPC-E pattern.\n     * There is no \"second half\" to a UPC-E barcode.\n     */\n    UPCEReader.MIDDLE_END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);\n    // For an UPC-E barcode, the final digit is represented by the parities used\n    // to encode the middle six digits, according to the table below.\n    //\n    //                Parity of next 6 digits\n    //    Digit   0     1     2     3     4     5\n    //       0    Even   Even  Even Odd  Odd   Odd\n    //       1    Even   Even  Odd  Even Odd   Odd\n    //       2    Even   Even  Odd  Odd  Even  Odd\n    //       3    Even   Even  Odd  Odd  Odd   Even\n    //       4    Even   Odd   Even Even Odd   Odd\n    //       5    Even   Odd   Odd  Even Even  Odd\n    //       6    Even   Odd   Odd  Odd  Even  Even\n    //       7    Even   Odd   Even Odd  Even  Odd\n    //       8    Even   Odd   Even Odd  Odd   Even\n    //       9    Even   Odd   Odd  Even Odd   Even\n    //\n    // The encoding is represented by the following array, which is a bit pattern\n    // using Odd = 0 and Even = 1. For example, 5 is represented by:\n    //\n    //              Odd Even Even Odd Odd Even\n    // in binary:\n    //                0    1    1   0   0    1   == 0x19\n    //\n    /**\n     * See {@link #L_AND_G_PATTERNS}; these values similarly represent patterns of\n     * even-odd parity encodings of digits that imply both the number system (0 or 1)\n     * used, and the check digit.\n     */\n    UPCEReader.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [\n        Int32Array.from([0x38, 0x34, 0x32, 0x31, 0x2C, 0x26, 0x23, 0x2A, 0x29, 0x25]),\n        Int32Array.from([0x07, 0x0B, 0x0D, 0x0E, 0x13, 0x19, 0x1C, 0x15, 0x16, 0x1A]),\n    ];\n\n    /**\n     * <p>A reader that can read all available UPC/EAN formats. If a caller wants to try to\n     * read all such formats, it is most efficient to use this implementation rather than invoke\n     * individual readers.</p>\n     *\n     * @author Sean Owen\n     */\n    class MultiFormatUPCEANReader extends OneDReader {\n        constructor(hints) {\n            super();\n            let possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);\n            let readers = [];\n            if (!isNullOrUndefined(possibleFormats)) {\n                if (possibleFormats.indexOf(BarcodeFormat$1.EAN_13) > -1) {\n                    readers.push(new EAN13Reader());\n                }\n                if (possibleFormats.indexOf(BarcodeFormat$1.UPC_A) > -1) {\n                    readers.push(new UPCAReader());\n                }\n                if (possibleFormats.indexOf(BarcodeFormat$1.EAN_8) > -1) {\n                    readers.push(new EAN8Reader());\n                }\n                if (possibleFormats.indexOf(BarcodeFormat$1.UPC_E) > -1) {\n                    readers.push(new UPCEReader());\n                }\n            } else {\n                // No hints provided.\n                readers.push(new EAN13Reader());\n                readers.push(new UPCAReader());\n                readers.push(new EAN8Reader());\n                readers.push(new UPCEReader());\n            }\n            this.readers = readers;\n        }\n        decodeRow(rowNumber, row, hints) {\n            for (let reader of this.readers) {\n                try {\n                    // const result: Result = reader.decodeRow(rowNumber, row, startGuardPattern, hints);\n                    const result = reader.decodeRow(rowNumber, row, hints);\n                    // Special case: a 12-digit code encoded in UPC-A is identical to a \"0\"\n                    // followed by those 12 digits encoded as EAN-13. Each will recognize such a code,\n                    // UPC-A as a 12-digit string and EAN-13 as a 13-digit string starting with \"0\".\n                    // Individually these are correct and their readers will both read such a code\n                    // and correctly call it EAN-13, or UPC-A, respectively.\n                    //\n                    // In this case, if we've been looking for both types, we'd like to call it\n                    // a UPC-A code. But for efficiency we only run the EAN-13 decoder to also read\n                    // UPC-A. So we special case it here, and convert an EAN-13 result to a UPC-A\n                    // result if appropriate.\n                    //\n                    // But, don't return UPC-A if UPC-A was not a requested format!\n                    const ean13MayBeUPCA = result.getBarcodeFormat() === BarcodeFormat$1.EAN_13 &&\n                        result.getText().charAt(0) === '0';\n                    // @SuppressWarnings(\"unchecked\")\n                    const possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);\n                    const canReturnUPCA = possibleFormats == null || possibleFormats.includes(BarcodeFormat$1.UPC_A);\n                    if (ean13MayBeUPCA && canReturnUPCA) {\n                        const rawBytes = result.getRawBytes();\n                        // Transfer the metadata across\n                        const resultUPCA = new Result(\n                            result.getText().substring(1),\n                            rawBytes,\n                            (rawBytes ? rawBytes.length : null),\n                            result.getResultPoints(),\n                            BarcodeFormat$1.UPC_A);\n                        resultUPCA.putAllMetadata(result.getResultMetadata());\n                        return resultUPCA;\n                    }\n                    return result;\n                }\n                catch (err) {\n                    // continue;\n                }\n            }\n            throw new NotFoundException();\n        }\n        reset() {\n            for (let reader of this.readers) {\n                reader.reset();\n            }\n        }\n    }\n\n    // import Integer from '../../util/Integer';\n    // import Float from '../../util/Float';\n    class AbstractRSSReader extends OneDReader {\n        constructor() {\n            super();\n            this.decodeFinderCounters = new Int32Array(4);\n            this.dataCharacterCounters = new Int32Array(8);\n            this.oddRoundingErrors = new Array(4);\n            this.evenRoundingErrors = new Array(4);\n            this.oddCounts = new Array(this.dataCharacterCounters.length / 2);\n            this.evenCounts = new Array(this.dataCharacterCounters.length / 2);\n        }\n        getDecodeFinderCounters() {\n            return this.decodeFinderCounters;\n        }\n        getDataCharacterCounters() {\n            return this.dataCharacterCounters;\n        }\n        getOddRoundingErrors() {\n            return this.oddRoundingErrors;\n        }\n        getEvenRoundingErrors() {\n            return this.evenRoundingErrors;\n        }\n        getOddCounts() {\n            return this.oddCounts;\n        }\n        getEvenCounts() {\n            return this.evenCounts;\n        }\n        parseFinderValue(counters, finderPatterns) {\n            for (let value = 0; value < finderPatterns.length; value++) {\n                if (OneDReader.patternMatchVariance(counters, finderPatterns[value], AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE) < AbstractRSSReader.MAX_AVG_VARIANCE) {\n                    return value;\n                }\n            }\n            throw new NotFoundException();\n        }\n        /**\n         * @param array values to sum\n         * @return sum of values\n         * @deprecated call {@link MathUtils#sum(int[])}\n         */\n        static count(array) {\n            return MathUtils.sum(new Int32Array(array));\n        }\n        static increment(array, errors) {\n            let index = 0;\n            let biggestError = errors[0];\n            for (let i = 1; i < array.length; i++) {\n                if (errors[i] > biggestError) {\n                    biggestError = errors[i];\n                    index = i;\n                }\n            }\n            array[index]++;\n        }\n        static decrement(array, errors) {\n            let index = 0;\n            let biggestError = errors[0];\n            for (let i = 1; i < array.length; i++) {\n                if (errors[i] < biggestError) {\n                    biggestError = errors[i];\n                    index = i;\n                }\n            }\n            array[index]--;\n        }\n        static isFinderPattern(counters) {\n            let firstTwoSum = counters[0] + counters[1];\n            let sum = firstTwoSum + counters[2] + counters[3];\n            let ratio = firstTwoSum / sum;\n            if (ratio >= AbstractRSSReader.MIN_FINDER_PATTERN_RATIO && ratio <= AbstractRSSReader.MAX_FINDER_PATTERN_RATIO) {\n                // passes ratio test in spec, but see if the counts are unreasonable\n                let minCounter = Number.MAX_SAFE_INTEGER;\n                let maxCounter = Number.MIN_SAFE_INTEGER;\n                for (let counter of counters) {\n                    if (counter > maxCounter) {\n                        maxCounter = counter;\n                    }\n                    if (counter < minCounter) {\n                        minCounter = counter;\n                    }\n                }\n                return maxCounter < 10 * minCounter;\n            }\n            return false;\n        }\n    }\n    AbstractRSSReader.MAX_AVG_VARIANCE = 0.2;\n    AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE = 0.45;\n    AbstractRSSReader.MIN_FINDER_PATTERN_RATIO = 9.5 / 12.0;\n    AbstractRSSReader.MAX_FINDER_PATTERN_RATIO = 12.5 / 14.0;\n\n    class DataCharacter {\n        constructor(value, checksumPortion) {\n            this.value = value;\n            this.checksumPortion = checksumPortion;\n        }\n        getValue() {\n            return this.value;\n        }\n        getChecksumPortion() {\n            return this.checksumPortion;\n        }\n        toString() {\n            return this.value + '(' + this.checksumPortion + ')';\n        }\n        equals(o) {\n            if (!(o instanceof DataCharacter)) {\n                return false;\n            }\n            const that = o;\n            return this.value === that.value && this.checksumPortion === that.checksumPortion;\n        }\n        hashCode() {\n            return this.value ^ this.checksumPortion;\n        }\n    }\n\n    class FinderPattern {\n        constructor(value, startEnd, start, end, rowNumber) {\n            this.value = value;\n            this.startEnd = startEnd;\n            this.value = value;\n            this.startEnd = startEnd;\n            this.resultPoints = new Array();\n            this.resultPoints.push(new ResultPoint(start, rowNumber));\n            this.resultPoints.push(new ResultPoint(end, rowNumber));\n        }\n        getValue() {\n            return this.value;\n        }\n        getStartEnd() {\n            return this.startEnd;\n        }\n        getResultPoints() {\n            return this.resultPoints;\n        }\n        equals(o) {\n            if (!(o instanceof FinderPattern)) {\n                return false;\n            }\n            const that = o;\n            return this.value === that.value;\n        }\n        hashCode() {\n            return this.value;\n        }\n    }\n\n    /**\n     * RSS util functions.\n     */\n    class RSSUtils {\n        constructor() { }\n        static getRSSvalue(widths, maxWidth, noNarrow) {\n            let n = 0;\n            for (let width of widths) {\n                n += width;\n            }\n            let val = 0;\n            let narrowMask = 0;\n            let elements = widths.length;\n            for (let bar = 0; bar < elements - 1; bar++) {\n                let elmWidth;\n                for (elmWidth = 1, narrowMask |= 1 << bar; elmWidth < widths[bar]; elmWidth++, narrowMask &= ~(1 << bar)) {\n                    let subVal = RSSUtils.combins(n - elmWidth - 1, elements - bar - 2);\n                    if (noNarrow && (narrowMask === 0) && (n - elmWidth - (elements - bar - 1) >= elements - bar - 1)) {\n                        subVal -= RSSUtils.combins(n - elmWidth - (elements - bar), elements - bar - 2);\n                    }\n                    if (elements - bar - 1 > 1) {\n                        let lessVal = 0;\n                        for (let mxwElement = n - elmWidth - (elements - bar - 2); mxwElement > maxWidth; mxwElement--) {\n                            lessVal += RSSUtils.combins(n - elmWidth - mxwElement - 1, elements - bar - 3);\n                        }\n                        subVal -= lessVal * (elements - 1 - bar);\n                    }\n                    else if (n - elmWidth > maxWidth) {\n                        subVal--;\n                    }\n                    val += subVal;\n                }\n                n -= elmWidth;\n            }\n            return val;\n        }\n        static combins(n, r) {\n            let maxDenom;\n            let minDenom;\n            if (n - r > r) {\n                minDenom = r;\n                maxDenom = n - r;\n            }\n            else {\n                minDenom = n - r;\n                maxDenom = r;\n            }\n            let val = 1;\n            let j = 1;\n            for (let i = n; i > maxDenom; i--) {\n                val *= i;\n                if (j <= minDenom) {\n                    val /= j;\n                    j++;\n                }\n            }\n            while ((j <= minDenom)) {\n                val /= j;\n                j++;\n            }\n            return val;\n        }\n    }\n\n    class BitArrayBuilder {\n        static buildBitArray(pairs) {\n            let charNumber = (pairs.length * 2) - 1;\n            if (pairs[pairs.length - 1].getRightChar() == null) {\n                charNumber -= 1;\n            }\n            let size = 12 * charNumber;\n            let binary = new BitArray(size);\n            let accPos = 0;\n            let firstPair = pairs[0];\n            let firstValue = firstPair.getRightChar().getValue();\n            for (let i = 11; i >= 0; --i) {\n                if ((firstValue & (1 << i)) != 0) {\n                    binary.set(accPos);\n                }\n                accPos++;\n            }\n            for (let i = 1; i < pairs.length; ++i) {\n                let currentPair = pairs[i];\n                let leftValue = currentPair.getLeftChar().getValue();\n                for (let j = 11; j >= 0; --j) {\n                    if ((leftValue & (1 << j)) != 0) {\n                        binary.set(accPos);\n                    }\n                    accPos++;\n                }\n                if (currentPair.getRightChar() != null) {\n                    let rightValue = currentPair.getRightChar().getValue();\n                    for (let j = 11; j >= 0; --j) {\n                        if ((rightValue & (1 << j)) != 0) {\n                            binary.set(accPos);\n                        }\n                        accPos++;\n                    }\n                }\n            }\n            return binary;\n        }\n    }\n\n    class BlockParsedResult {\n        constructor(finished, decodedInformation) {\n            if (decodedInformation) {\n                this.decodedInformation = null;\n            }\n            else {\n                this.finished = finished;\n                this.decodedInformation = decodedInformation;\n            }\n        }\n        getDecodedInformation() {\n            return this.decodedInformation;\n        }\n        isFinished() {\n            return this.finished;\n        }\n    }\n\n    class DecodedObject {\n        constructor(newPosition) {\n            this.newPosition = newPosition;\n        }\n        getNewPosition() {\n            return this.newPosition;\n        }\n    }\n\n    class DecodedChar extends DecodedObject {\n        constructor(newPosition, value) {\n            super(newPosition);\n            this.value = value;\n        }\n        getValue() {\n            return this.value;\n        }\n        isFNC1() {\n            return this.value === DecodedChar.FNC1;\n        }\n    }\n    DecodedChar.FNC1 = '$';\n\n    class DecodedInformation extends DecodedObject {\n        constructor(newPosition, newString, remainingValue) {\n            super(newPosition);\n            if (remainingValue) {\n                this.remaining = true;\n                this.remainingValue = this.remainingValue;\n            }\n            else {\n                this.remaining = false;\n                this.remainingValue = 0;\n            }\n            this.newString = newString;\n        }\n        getNewString() {\n            return this.newString;\n        }\n        isRemaining() {\n            return this.remaining;\n        }\n        getRemainingValue() {\n            return this.remainingValue;\n        }\n    }\n\n    class DecodedNumeric extends DecodedObject {\n        constructor(newPosition, firstDigit, secondDigit) {\n            super(newPosition);\n            if (firstDigit < 0 || firstDigit > 10 || secondDigit < 0 || secondDigit > 10) {\n                throw new FormatException();\n            }\n            this.firstDigit = firstDigit;\n            this.secondDigit = secondDigit;\n        }\n        getFirstDigit() {\n            return this.firstDigit;\n        }\n        getSecondDigit() {\n            return this.secondDigit;\n        }\n        getValue() {\n            return this.firstDigit * 10 + this.secondDigit;\n        }\n        isFirstDigitFNC1() {\n            return this.firstDigit === DecodedNumeric.FNC1;\n        }\n        isSecondDigitFNC1() {\n            return this.secondDigit === DecodedNumeric.FNC1;\n        }\n        isAnyFNC1() {\n            return this.firstDigit === DecodedNumeric.FNC1 || this.secondDigit === DecodedNumeric.FNC1;\n        }\n    }\n    DecodedNumeric.FNC1 = 10;\n\n    class FieldParser {\n        constructor() {\n        }\n        static parseFieldsInGeneralPurpose(rawInformation) {\n            if (!rawInformation) {\n                return null;\n            }\n            // Processing 2-digit AIs\n            if (rawInformation.length < 2) {\n                throw new NotFoundException();\n            }\n            let firstTwoDigits = rawInformation.substring(0, 2);\n            for (let dataLength of FieldParser.TWO_DIGIT_DATA_LENGTH) {\n                if (dataLength[0] === firstTwoDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(2, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(2, dataLength[1], rawInformation);\n                }\n            }\n            if (rawInformation.length < 3) {\n                throw new NotFoundException();\n            }\n            let firstThreeDigits = rawInformation.substring(0, 3);\n            for (let dataLength of FieldParser.THREE_DIGIT_DATA_LENGTH) {\n                if (dataLength[0] === firstThreeDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(3, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(3, dataLength[1], rawInformation);\n                }\n            }\n            for (let dataLength of FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH) {\n                if (dataLength[0] === firstThreeDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(4, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(4, dataLength[1], rawInformation);\n                }\n            }\n            if (rawInformation.length < 4) {\n                throw new NotFoundException();\n            }\n            let firstFourDigits = rawInformation.substring(0, 4);\n            for (let dataLength of FieldParser.FOUR_DIGIT_DATA_LENGTH) {\n                if (dataLength[0] === firstFourDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(4, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(4, dataLength[1], rawInformation);\n                }\n            }\n            throw new NotFoundException();\n        }\n        static processFixedAI(aiSize, fieldSize, rawInformation) {\n            if (rawInformation.length < aiSize) {\n                throw new NotFoundException();\n            }\n            let ai = rawInformation.substring(0, aiSize);\n            if (rawInformation.length < aiSize + fieldSize) {\n                throw new NotFoundException();\n            }\n            let field = rawInformation.substring(aiSize, aiSize + fieldSize);\n            let remaining = rawInformation.substring(aiSize + fieldSize);\n            let result = '(' + ai + ')' + field;\n            let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);\n            return parsedAI == null ? result : result + parsedAI;\n        }\n        static processVariableAI(aiSize, variableFieldSize, rawInformation) {\n            let ai = rawInformation.substring(0, aiSize);\n            let maxSize;\n            if (rawInformation.length < aiSize + variableFieldSize) {\n                maxSize = rawInformation.length;\n            }\n            else {\n                maxSize = aiSize + variableFieldSize;\n            }\n            let field = rawInformation.substring(aiSize, maxSize);\n            let remaining = rawInformation.substring(maxSize);\n            let result = '(' + ai + ')' + field;\n            let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);\n            return parsedAI == null ? result : result + parsedAI;\n        }\n    }\n    FieldParser.VARIABLE_LENGTH = [];\n    FieldParser.TWO_DIGIT_DATA_LENGTH = [\n        ['00', 18],\n        ['01', 14],\n        ['02', 14],\n        ['10', FieldParser.VARIABLE_LENGTH, 20],\n        ['11', 6],\n        ['12', 6],\n        ['13', 6],\n        ['15', 6],\n        ['17', 6],\n        ['20', 2],\n        ['21', FieldParser.VARIABLE_LENGTH, 20],\n        ['22', FieldParser.VARIABLE_LENGTH, 29],\n        ['30', FieldParser.VARIABLE_LENGTH, 8],\n        ['37', FieldParser.VARIABLE_LENGTH, 8],\n        // internal company codes\n        ['90', FieldParser.VARIABLE_LENGTH, 30],\n        ['91', FieldParser.VARIABLE_LENGTH, 30],\n        ['92', FieldParser.VARIABLE_LENGTH, 30],\n        ['93', FieldParser.VARIABLE_LENGTH, 30],\n        ['94', FieldParser.VARIABLE_LENGTH, 30],\n        ['95', FieldParser.VARIABLE_LENGTH, 30],\n        ['96', FieldParser.VARIABLE_LENGTH, 30],\n        ['97', FieldParser.VARIABLE_LENGTH, 3],\n        ['98', FieldParser.VARIABLE_LENGTH, 30],\n        ['99', FieldParser.VARIABLE_LENGTH, 30],\n    ];\n    FieldParser.THREE_DIGIT_DATA_LENGTH = [\n        // Same format as above\n        ['240', FieldParser.VARIABLE_LENGTH, 30],\n        ['241', FieldParser.VARIABLE_LENGTH, 30],\n        ['242', FieldParser.VARIABLE_LENGTH, 6],\n        ['250', FieldParser.VARIABLE_LENGTH, 30],\n        ['251', FieldParser.VARIABLE_LENGTH, 30],\n        ['253', FieldParser.VARIABLE_LENGTH, 17],\n        ['254', FieldParser.VARIABLE_LENGTH, 20],\n        ['400', FieldParser.VARIABLE_LENGTH, 30],\n        ['401', FieldParser.VARIABLE_LENGTH, 30],\n        ['402', 17],\n        ['403', FieldParser.VARIABLE_LENGTH, 30],\n        ['410', 13],\n        ['411', 13],\n        ['412', 13],\n        ['413', 13],\n        ['414', 13],\n        ['420', FieldParser.VARIABLE_LENGTH, 20],\n        ['421', FieldParser.VARIABLE_LENGTH, 15],\n        ['422', 3],\n        ['423', FieldParser.VARIABLE_LENGTH, 15],\n        ['424', 3],\n        ['425', 3],\n        ['426', 3],\n    ];\n    FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [\n        // Same format as above\n        ['310', 6],\n        ['311', 6],\n        ['312', 6],\n        ['313', 6],\n        ['314', 6],\n        ['315', 6],\n        ['316', 6],\n        ['320', 6],\n        ['321', 6],\n        ['322', 6],\n        ['323', 6],\n        ['324', 6],\n        ['325', 6],\n        ['326', 6],\n        ['327', 6],\n        ['328', 6],\n        ['329', 6],\n        ['330', 6],\n        ['331', 6],\n        ['332', 6],\n        ['333', 6],\n        ['334', 6],\n        ['335', 6],\n        ['336', 6],\n        ['340', 6],\n        ['341', 6],\n        ['342', 6],\n        ['343', 6],\n        ['344', 6],\n        ['345', 6],\n        ['346', 6],\n        ['347', 6],\n        ['348', 6],\n        ['349', 6],\n        ['350', 6],\n        ['351', 6],\n        ['352', 6],\n        ['353', 6],\n        ['354', 6],\n        ['355', 6],\n        ['356', 6],\n        ['357', 6],\n        ['360', 6],\n        ['361', 6],\n        ['362', 6],\n        ['363', 6],\n        ['364', 6],\n        ['365', 6],\n        ['366', 6],\n        ['367', 6],\n        ['368', 6],\n        ['369', 6],\n        ['390', FieldParser.VARIABLE_LENGTH, 15],\n        ['391', FieldParser.VARIABLE_LENGTH, 18],\n        ['392', FieldParser.VARIABLE_LENGTH, 15],\n        ['393', FieldParser.VARIABLE_LENGTH, 18],\n        ['703', FieldParser.VARIABLE_LENGTH, 30],\n    ];\n    FieldParser.FOUR_DIGIT_DATA_LENGTH = [\n        // Same format as above\n        ['7001', 13],\n        ['7002', FieldParser.VARIABLE_LENGTH, 30],\n        ['7003', 10],\n        ['8001', 14],\n        ['8002', FieldParser.VARIABLE_LENGTH, 20],\n        ['8003', FieldParser.VARIABLE_LENGTH, 30],\n        ['8004', FieldParser.VARIABLE_LENGTH, 30],\n        ['8005', 6],\n        ['8006', 18],\n        ['8007', FieldParser.VARIABLE_LENGTH, 30],\n        ['8008', FieldParser.VARIABLE_LENGTH, 12],\n        ['8018', 18],\n        ['8020', FieldParser.VARIABLE_LENGTH, 25],\n        ['8100', 6],\n        ['8101', 10],\n        ['8102', 2],\n        ['8110', FieldParser.VARIABLE_LENGTH, 70],\n        ['8200', FieldParser.VARIABLE_LENGTH, 70],\n    ];\n\n    class GeneralAppIdDecoder {\n        constructor(information) {\n            this.buffer = new StringBuilder();\n            this.information = information;\n        }\n        decodeAllCodes(buff, initialPosition) {\n            let currentPosition = initialPosition;\n            let remaining = null;\n            do {\n                let info = this.decodeGeneralPurposeField(currentPosition, remaining);\n                let parsedFields = FieldParser.parseFieldsInGeneralPurpose(info.getNewString());\n                if (parsedFields != null) {\n                    buff.append(parsedFields);\n                }\n                if (info.isRemaining()) {\n                    remaining = '' + info.getRemainingValue();\n                }\n                else {\n                    remaining = null;\n                }\n                if (currentPosition === info.getNewPosition()) { // No step forward!\n                    break;\n                }\n                currentPosition = info.getNewPosition();\n            } while (true);\n            return buff.toString();\n        }\n        isStillNumeric(pos) {\n            // It's numeric if it still has 7 positions\n            // and one of the first 4 bits is \"1\".\n            if (pos + 7 > this.information.getSize()) {\n                return pos + 4 <= this.information.getSize();\n            }\n            for (let i = pos; i < pos + 3; ++i) {\n                if (this.information.get(i)) {\n                    return true;\n                }\n            }\n            return this.information.get(pos + 3);\n        }\n        decodeNumeric(pos) {\n            if (pos + 7 > this.information.getSize()) {\n                let numeric = this.extractNumericValueFromBitArray(pos, 4);\n                if (numeric === 0) {\n                    return new DecodedNumeric(this.information.getSize(), DecodedNumeric.FNC1, DecodedNumeric.FNC1);\n                }\n                return new DecodedNumeric(this.information.getSize(), numeric - 1, DecodedNumeric.FNC1);\n            }\n            let numeric = this.extractNumericValueFromBitArray(pos, 7);\n            let digit1 = (numeric - 8) / 11;\n            let digit2 = (numeric - 8) % 11;\n            return new DecodedNumeric(pos + 7, digit1, digit2);\n        }\n        extractNumericValueFromBitArray(pos, bits) {\n            return GeneralAppIdDecoder.extractNumericValueFromBitArray(this.information, pos, bits);\n        }\n        static extractNumericValueFromBitArray(information, pos, bits) {\n            let value = 0;\n            for (let i = 0; i < bits; ++i) {\n                if (information.get(pos + i)) {\n                    value |= 1 << (bits - i - 1);\n                }\n            }\n            return value;\n        }\n        decodeGeneralPurposeField(pos, remaining) {\n            // this.buffer.setLength(0);\n            this.buffer.setLengthToZero();\n            if (remaining != null) {\n                this.buffer.append(remaining);\n            }\n            this.current.setPosition(pos);\n            let lastDecoded = this.parseBlocks();\n            if (lastDecoded != null && lastDecoded.isRemaining()) {\n                return new DecodedInformation(this.current.getPosition(), this.buffer.toString(), lastDecoded.getRemainingValue());\n            }\n            return new DecodedInformation(this.current.getPosition(), this.buffer.toString());\n        }\n        parseBlocks() {\n            let isFinished;\n            let result;\n            do {\n                let initialPosition = this.current.getPosition();\n                if (this.current.isAlpha()) {\n                    result = this.parseAlphaBlock();\n                    isFinished = result.isFinished();\n                }\n                else if (this.current.isIsoIec646()) {\n                    result = this.parseIsoIec646Block();\n                    isFinished = result.isFinished();\n                }\n                else { // it must be numeric\n                    result = this.parseNumericBlock();\n                    isFinished = result.isFinished();\n                }\n                let positionChanged = initialPosition !== this.current.getPosition();\n                if (!positionChanged && !isFinished) {\n                    break;\n                }\n            } while (!isFinished);\n            return result.getDecodedInformation();\n        }\n        parseNumericBlock() {\n            while (this.isStillNumeric(this.current.getPosition())) {\n                let numeric = this.decodeNumeric(this.current.getPosition());\n                this.current.setPosition(numeric.getNewPosition());\n                if (numeric.isFirstDigitFNC1()) {\n                    let information;\n                    if (numeric.isSecondDigitFNC1()) {\n                        information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());\n                    }\n                    else {\n                        information = new DecodedInformation(this.current.getPosition(), this.buffer.toString(), numeric.getSecondDigit());\n                    }\n                    return new BlockParsedResult(true, information);\n                }\n                this.buffer.append(numeric.getFirstDigit());\n                if (numeric.isSecondDigitFNC1()) {\n                    let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());\n                    return new BlockParsedResult(true, information);\n                }\n                this.buffer.append(numeric.getSecondDigit());\n            }\n            if (this.isNumericToAlphaNumericLatch(this.current.getPosition())) {\n                this.current.setAlpha();\n                this.current.incrementPosition(4);\n            }\n            return new BlockParsedResult(false);\n        }\n        parseIsoIec646Block() {\n            while (this.isStillIsoIec646(this.current.getPosition())) {\n                let iso = this.decodeIsoIec646(this.current.getPosition());\n                this.current.setPosition(iso.getNewPosition());\n                if (iso.isFNC1()) {\n                    let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());\n                    return new BlockParsedResult(true, information);\n                }\n                this.buffer.append(iso.getValue());\n            }\n            if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {\n                this.current.incrementPosition(3);\n                this.current.setNumeric();\n            }\n            else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {\n                if (this.current.getPosition() + 5 < this.information.getSize()) {\n                    this.current.incrementPosition(5);\n                }\n                else {\n                    this.current.setPosition(this.information.getSize());\n                }\n                this.current.setAlpha();\n            }\n            return new BlockParsedResult(false);\n        }\n        parseAlphaBlock() {\n            while (this.isStillAlpha(this.current.getPosition())) {\n                let alpha = this.decodeAlphanumeric(this.current.getPosition());\n                this.current.setPosition(alpha.getNewPosition());\n                if (alpha.isFNC1()) {\n                    let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());\n                    return new BlockParsedResult(true, information); // end of the char block\n                }\n                this.buffer.append(alpha.getValue());\n            }\n            if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {\n                this.current.incrementPosition(3);\n                this.current.setNumeric();\n            }\n            else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {\n                if (this.current.getPosition() + 5 < this.information.getSize()) {\n                    this.current.incrementPosition(5);\n                }\n                else {\n                    this.current.setPosition(this.information.getSize());\n                }\n                this.current.setIsoIec646();\n            }\n            return new BlockParsedResult(false);\n        }\n        isStillIsoIec646(pos) {\n            if (pos + 5 > this.information.getSize()) {\n                return false;\n            }\n            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n            if (fiveBitValue >= 5 && fiveBitValue < 16) {\n                return true;\n            }\n            if (pos + 7 > this.information.getSize()) {\n                return false;\n            }\n            let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);\n            if (sevenBitValue >= 64 && sevenBitValue < 116) {\n                return true;\n            }\n            if (pos + 8 > this.information.getSize()) {\n                return false;\n            }\n            let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);\n            return eightBitValue >= 232 && eightBitValue < 253;\n        }\n        decodeIsoIec646(pos) {\n            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n            if (fiveBitValue === 15) {\n                return new DecodedChar(pos + 5, DecodedChar.FNC1);\n            }\n            if (fiveBitValue >= 5 && fiveBitValue < 15) {\n                return new DecodedChar(pos + 5, ('0' + (fiveBitValue - 5)));\n            }\n            let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);\n            if (sevenBitValue >= 64 && sevenBitValue < 90) {\n                return new DecodedChar(pos + 7, ('' + (sevenBitValue + 1)));\n            }\n            if (sevenBitValue >= 90 && sevenBitValue < 116) {\n                return new DecodedChar(pos + 7, ('' + (sevenBitValue + 7)));\n            }\n            let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);\n            let c;\n            switch (eightBitValue) {\n                case 232:\n                    c = '!';\n                    break;\n                case 233:\n                    c = '\"';\n                    break;\n                case 234:\n                    c = '%';\n                    break;\n                case 235:\n                    c = '&';\n                    break;\n                case 236:\n                    c = '\\'';\n                    break;\n                case 237:\n                    c = '(';\n                    break;\n                case 238:\n                    c = ')';\n                    break;\n                case 239:\n                    c = '*';\n                    break;\n                case 240:\n                    c = '+';\n                    break;\n                case 241:\n                    c = ',';\n                    break;\n                case 242:\n                    c = '-';\n                    break;\n                case 243:\n                    c = '.';\n                    break;\n                case 244:\n                    c = '/';\n                    break;\n                case 245:\n                    c = ':';\n                    break;\n                case 246:\n                    c = ';';\n                    break;\n                case 247:\n                    c = '<';\n                    break;\n                case 248:\n                    c = '=';\n                    break;\n                case 249:\n                    c = '>';\n                    break;\n                case 250:\n                    c = '?';\n                    break;\n                case 251:\n                    c = '_';\n                    break;\n                case 252:\n                    c = ' ';\n                    break;\n                default:\n                    throw new FormatException();\n            }\n            return new DecodedChar(pos + 8, c);\n        }\n        isStillAlpha(pos) {\n            if (pos + 5 > this.information.getSize()) {\n                return false;\n            }\n            // We now check if it's a valid 5-bit value (0..9 and FNC1)\n            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n            if (fiveBitValue >= 5 && fiveBitValue < 16) {\n                return true;\n            }\n            if (pos + 6 > this.information.getSize()) {\n                return false;\n            }\n            let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);\n            return sixBitValue >= 16 && sixBitValue < 63; // 63 not included\n        }\n        decodeAlphanumeric(pos) {\n            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n            if (fiveBitValue === 15) {\n                return new DecodedChar(pos + 5, DecodedChar.FNC1);\n            }\n            if (fiveBitValue >= 5 && fiveBitValue < 15) {\n                return new DecodedChar(pos + 5, ('0' + (fiveBitValue - 5)));\n            }\n            let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);\n            if (sixBitValue >= 32 && sixBitValue < 58) {\n                return new DecodedChar(pos + 6, ('' + (sixBitValue + 33)));\n            }\n            let c;\n            switch (sixBitValue) {\n                case 58:\n                    c = '*';\n                    break;\n                case 59:\n                    c = ',';\n                    break;\n                case 60:\n                    c = '-';\n                    break;\n                case 61:\n                    c = '.';\n                    break;\n                case 62:\n                    c = '/';\n                    break;\n                default:\n                    throw new IllegalStateException('Decoding invalid alphanumeric value: ' + sixBitValue);\n            }\n            return new DecodedChar(pos + 6, c);\n        }\n        isAlphaTo646ToAlphaLatch(pos) {\n            if (pos + 1 > this.information.getSize()) {\n                return false;\n            }\n            for (let i = 0; i < 5 && i + pos < this.information.getSize(); ++i) {\n                if (i === 2) {\n                    if (!this.information.get(pos + 2)) {\n                        return false;\n                    }\n                }\n                else if (this.information.get(pos + i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        isAlphaOr646ToNumericLatch(pos) {\n            // Next is alphanumeric if there are 3 positions and they are all zeros\n            if (pos + 3 > this.information.getSize()) {\n                return false;\n            }\n            for (let i = pos; i < pos + 3; ++i) {\n                if (this.information.get(i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        isNumericToAlphaNumericLatch(pos) {\n            // Next is alphanumeric if there are 4 positions and they are all zeros, or\n            // if there is a subset of this just before the end of the symbol\n            if (pos + 1 > this.information.getSize()) {\n                return false;\n            }\n            for (let i = 0; i < 4 && i + pos < this.information.getSize(); ++i) {\n                if (this.information.get(pos + i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    class AbstractExpandedDecoder {\n        constructor(information) {\n            this.information = information;\n            this.generalDecoder = new GeneralAppIdDecoder(information);\n        }\n        getInformation() {\n            return this.information;\n        }\n        getGeneralDecoder() {\n            return this.generalDecoder;\n        }\n    }\n\n    class AI01decoder extends AbstractExpandedDecoder {\n        constructor(information) {\n            super(information);\n        }\n        encodeCompressedGtin(buf, currentPos) {\n            buf.append('(01)');\n            let initialPosition = buf.length();\n            buf.append('9');\n            this.encodeCompressedGtinWithoutAI(buf, currentPos, initialPosition);\n        }\n        encodeCompressedGtinWithoutAI(buf, currentPos, initialBufferPosition) {\n            for (let i = 0; i < 4; ++i) {\n                let currentBlock = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos + 10 * i, 10);\n                if (currentBlock / 100 === 0) {\n                    buf.append('0');\n                }\n                if (currentBlock / 10 === 0) {\n                    buf.append('0');\n                }\n                buf.append(currentBlock);\n            }\n            AI01decoder.appendCheckDigit(buf, initialBufferPosition);\n        }\n        static appendCheckDigit(buf, currentPos) {\n            let checkDigit = 0;\n            for (let i = 0; i < 13; i++) {\n                // let digit = buf.charAt(i + currentPos) - '0';\n                // To be checked\n                let digit = buf.charAt(i + currentPos).charCodeAt(0) - '0'.charCodeAt(0);\n                checkDigit += (i & 0x01) === 0 ? 3 * digit : digit;\n            }\n            checkDigit = 10 - (checkDigit % 10);\n            if (checkDigit === 10) {\n                checkDigit = 0;\n            }\n            buf.append(checkDigit);\n        }\n    }\n    AI01decoder.GTIN_SIZE = 40;\n\n    class AI01AndOtherAIs extends AI01decoder {\n        // the second one is the encodation method, and the other two are for the variable length\n        constructor(information) {\n            super(information);\n        }\n        parseInformation() {\n            let buff = new StringBuilder();\n            buff.append('(01)');\n            let initialGtinPosition = buff.length();\n            let firstGtinDigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01AndOtherAIs.HEADER_SIZE, 4);\n            buff.append(firstGtinDigit);\n            this.encodeCompressedGtinWithoutAI(buff, AI01AndOtherAIs.HEADER_SIZE + 4, initialGtinPosition);\n            return this.getGeneralDecoder().decodeAllCodes(buff, AI01AndOtherAIs.HEADER_SIZE + 44);\n        }\n    }\n    AI01AndOtherAIs.HEADER_SIZE = 1 + 1 + 2; // first bit encodes the linkage flag,\n\n    class AnyAIDecoder extends AbstractExpandedDecoder {\n        constructor(information) {\n            super(information);\n        }\n        parseInformation() {\n            let buf = new StringBuilder();\n            return this.getGeneralDecoder().decodeAllCodes(buf, AnyAIDecoder.HEADER_SIZE);\n        }\n    }\n    AnyAIDecoder.HEADER_SIZE = 2 + 1 + 2;\n\n    class AI01weightDecoder extends AI01decoder {\n        constructor(information) {\n            super(information);\n        }\n        encodeCompressedWeight(buf, currentPos, weightSize) {\n            let originalWeightNumeric = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, weightSize);\n            this.addWeightCode(buf, originalWeightNumeric);\n            let weightNumeric = this.checkWeight(originalWeightNumeric);\n            let currentDivisor = 100000;\n            for (let i = 0; i < 5; ++i) {\n                if (weightNumeric / currentDivisor === 0) {\n                    buf.append('0');\n                }\n                currentDivisor /= 10;\n            }\n            buf.append(weightNumeric);\n        }\n    }\n\n    class AI013x0xDecoder extends AI01weightDecoder {\n        constructor(information) {\n            super(information);\n        }\n        parseInformation() {\n            if (this.getInformation().getSize() != AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE + AI013x0xDecoder.WEIGHT_SIZE) {\n                throw new NotFoundException();\n            }\n            let buf = new StringBuilder();\n            this.encodeCompressedGtin(buf, AI013x0xDecoder.HEADER_SIZE);\n            this.encodeCompressedWeight(buf, AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE, AI013x0xDecoder.WEIGHT_SIZE);\n            return buf.toString();\n        }\n    }\n    AI013x0xDecoder.HEADER_SIZE = 4 + 1;\n    AI013x0xDecoder.WEIGHT_SIZE = 15;\n\n    class AI013103decoder extends AI013x0xDecoder {\n        constructor(information) {\n            super(information);\n        }\n        addWeightCode(buf, weight) {\n            buf.append('(3103)');\n        }\n        checkWeight(weight) {\n            return weight;\n        }\n    }\n\n    class AI01320xDecoder extends AI013x0xDecoder {\n        constructor(information) {\n            super(information);\n        }\n        addWeightCode(buf, weight) {\n            if (weight < 10000) {\n                buf.append('(3202)');\n            }\n            else {\n                buf.append('(3203)');\n            }\n        }\n        checkWeight(weight) {\n            if (weight < 10000) {\n                return weight;\n            }\n            return weight - 10000;\n        }\n    }\n\n    class AI01392xDecoder extends AI01decoder {\n        constructor(information) {\n            super(information);\n        }\n        parseInformation() {\n            if (this.getInformation().getSize() < AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {\n                throw new NotFoundException();\n            }\n            let buf = new StringBuilder();\n            this.encodeCompressedGtin(buf, AI01392xDecoder.HEADER_SIZE);\n            let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01392xDecoder.LAST_DIGIT_SIZE);\n            buf.append('(392');\n            buf.append(lastAIdigit);\n            buf.append(')');\n            let decodedInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01392xDecoder.LAST_DIGIT_SIZE, null);\n            buf.append(decodedInformation.getNewString());\n            return buf.toString();\n        }\n    }\n    AI01392xDecoder.HEADER_SIZE = 5 + 1 + 2;\n    AI01392xDecoder.LAST_DIGIT_SIZE = 2;\n\n    class AI01393xDecoder extends AI01decoder {\n        constructor(information) {\n            super(information);\n        }\n        parseInformation() {\n            if (this.getInformation().getSize() < AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {\n                throw new NotFoundException();\n            }\n            let buf = new StringBuilder();\n            this.encodeCompressedGtin(buf, AI01393xDecoder.HEADER_SIZE);\n            let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01393xDecoder.LAST_DIGIT_SIZE);\n            buf.append('(393');\n            buf.append(lastAIdigit);\n            buf.append(')');\n            let firstThreeDigits = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE, AI01393xDecoder.FIRST_THREE_DIGITS_SIZE);\n            if (firstThreeDigits / 100 == 0) {\n                buf.append('0');\n            }\n            if (firstThreeDigits / 10 == 0) {\n                buf.append('0');\n            }\n            buf.append(firstThreeDigits);\n            let generalInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE + AI01393xDecoder.FIRST_THREE_DIGITS_SIZE, null);\n            buf.append(generalInformation.getNewString());\n            return buf.toString();\n        }\n    }\n    AI01393xDecoder.HEADER_SIZE = 5 + 1 + 2;\n    AI01393xDecoder.LAST_DIGIT_SIZE = 2;\n    AI01393xDecoder.FIRST_THREE_DIGITS_SIZE = 10;\n\n    class AI013x0x1xDecoder extends AI01weightDecoder {\n        constructor(information, firstAIdigits, dateCode) {\n            super(information);\n            this.dateCode = dateCode;\n            this.firstAIdigits = firstAIdigits;\n        }\n        parseInformation() {\n            if (this.getInformation().getSize() != AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE + AI013x0x1xDecoder.DATE_SIZE) {\n                throw new NotFoundException();\n            }\n            let buf = new StringBuilder();\n            this.encodeCompressedGtin(buf, AI013x0x1xDecoder.HEADER_SIZE);\n            this.encodeCompressedWeight(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE, AI013x0x1xDecoder.WEIGHT_SIZE);\n            this.encodeCompressedDate(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE);\n            return buf.toString();\n        }\n        encodeCompressedDate(buf, currentPos) {\n            let numericDate = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, AI013x0x1xDecoder.DATE_SIZE);\n            if (numericDate == 38400) {\n                return;\n            }\n            buf.append('(');\n            buf.append(this.dateCode);\n            buf.append(')');\n            let day = numericDate % 32;\n            numericDate /= 32;\n            let month = numericDate % 12 + 1;\n            numericDate /= 12;\n            let year = numericDate;\n            if (year / 10 == 0) {\n                buf.append('0');\n            }\n            buf.append(year);\n            if (month / 10 == 0) {\n                buf.append('0');\n            }\n            buf.append(month);\n            if (day / 10 == 0) {\n                buf.append('0');\n            }\n            buf.append(day);\n        }\n        addWeightCode(buf, weight) {\n            buf.append('(');\n            buf.append(this.firstAIdigits);\n            buf.append(weight / 100000);\n            buf.append(')');\n        }\n        checkWeight(weight) {\n            return weight % 100000;\n        }\n    }\n    AI013x0x1xDecoder.HEADER_SIZE = 7 + 1;\n    AI013x0x1xDecoder.WEIGHT_SIZE = 20;\n    AI013x0x1xDecoder.DATE_SIZE = 16;\n\n    function createDecoder(information) {\n        try {\n            if (information.get(1)) {\n                return new AI01AndOtherAIs(information);\n            }\n            if (!information.get(2)) {\n                return new AnyAIDecoder(information);\n            }\n            let fourBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 4);\n            switch (fourBitEncodationMethod) {\n                case 4: return new AI013103decoder(information);\n                case 5: return new AI01320xDecoder(information);\n            }\n            let fiveBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 5);\n            switch (fiveBitEncodationMethod) {\n                case 12: return new AI01392xDecoder(information);\n                case 13: return new AI01393xDecoder(information);\n            }\n            let sevenBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 7);\n            switch (sevenBitEncodationMethod) {\n                case 56: return new AI013x0x1xDecoder(information, '310', '11');\n                case 57: return new AI013x0x1xDecoder(information, '320', '11');\n                case 58: return new AI013x0x1xDecoder(information, '310', '13');\n                case 59: return new AI013x0x1xDecoder(information, '320', '13');\n                case 60: return new AI013x0x1xDecoder(information, '310', '15');\n                case 61: return new AI013x0x1xDecoder(information, '320', '15');\n                case 62: return new AI013x0x1xDecoder(information, '310', '17');\n                case 63: return new AI013x0x1xDecoder(information, '320', '17');\n            }\n        }\n        catch (e) {\n            console.log(e);\n            throw new IllegalStateException('unknown decoder: ' + information);\n        }\n    }\n\n    class ExpandedPair {\n        constructor(leftChar, rightChar, finderPatter, mayBeLast) {\n            this.leftchar = leftChar;\n            this.rightchar = rightChar;\n            this.finderpattern = finderPatter;\n            this.maybeLast = mayBeLast;\n        }\n        mayBeLast() {\n            return this.maybeLast;\n        }\n        getLeftChar() {\n            return this.leftchar;\n        }\n        getRightChar() {\n            return this.rightchar;\n        }\n        getFinderPattern() {\n            return this.finderpattern;\n        }\n        mustBeLast() {\n            return this.rightchar == null;\n        }\n        toString() {\n            return '[ ' + this.leftchar + ', ' + this.rightchar + ' : ' + (this.finderpattern == null ? 'null' : this.finderpattern.getValue()) + ' ]';\n        }\n        static equals(o1, o2) {\n            if (!(o1 instanceof ExpandedPair)) {\n                return false;\n            }\n            return ExpandedPair.equalsOrNull(o1.leftchar, o2.leftchar) &&\n                ExpandedPair.equalsOrNull(o1.rightchar, o2.rightchar) &&\n                ExpandedPair.equalsOrNull(o1.finderpattern, o2.finderpattern);\n        }\n        static equalsOrNull(o1, o2) {\n            return o1 === null ? o2 === null : ExpandedPair.equals(o1, o2);\n        }\n        hashCode() {\n            // return ExpandedPair.hashNotNull(leftChar) ^ hashNotNull(rightChar) ^ hashNotNull(finderPattern);\n            let value = this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue();\n            return value;\n        }\n    }\n\n    class ExpandedRow {\n        constructor(pairs, rowNumber, wasReversed) {\n            this.pairs = pairs;\n            this.rowNumber = rowNumber;\n            this.wasReversed = wasReversed;\n        }\n        getPairs() {\n            return this.pairs;\n        }\n        getRowNumber() {\n            return this.rowNumber;\n        }\n        isReversed() {\n            return this.wasReversed;\n        }\n        // check implementation\n        isEquivalent(otherPairs) {\n            return this.checkEqualitity(this, otherPairs);\n        }\n        // @Override\n        toString() {\n            return '{ ' + this.pairs + ' }';\n        }\n        /**\n         * Two rows are equal if they contain the same pairs in the same order.\n         */\n        // @Override\n        // check implementation\n        equals(o1, o2) {\n            if (!(o1 instanceof ExpandedRow)) {\n                return false;\n            }\n            return this.checkEqualitity(o1, o2) && o1.wasReversed === o2.wasReversed;\n        }\n        checkEqualitity(pair1, pair2) {\n            if (!pair1 || !pair2)\n                return;\n            let result;\n            pair1.forEach((e1, i) => {\n                pair2.forEach(e2 => {\n                    if (e1.getLeftChar().getValue() === e2.getLeftChar().getValue() && e1.getRightChar().getValue() === e2.getRightChar().getValue() && e1.getFinderPatter().getValue() === e2.getFinderPatter().getValue()) {\n                        result = true;\n                    }\n                });\n            });\n            return result;\n        }\n    }\n\n    // import java.util.ArrayList;\n    // import java.util.Iterator;\n    // import java.util.List;\n    // import java.util.Map;\n    // import java.util.Collections;\n    class RSSExpandedReader extends AbstractRSSReader {\n        constructor(verbose) {\n            super(...arguments);\n            this.pairs = new Array(RSSExpandedReader.MAX_PAIRS);\n            this.rows = new Array();\n            this.startEnd = [2];\n            this.verbose = (verbose === true);\n        }\n        decodeRow(rowNumber, row, hints) {\n            // Rows can start with even pattern in case in prev rows there where odd number of patters.\n            // So lets try twice\n            // this.pairs.clear();\n            this.pairs.length = 0;\n            this.startFromEven = false;\n            try {\n                return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));\n            }\n            catch (e) {\n                // OK\n                if (this.verbose) {\n                    console.log(e);\n                }\n            }\n            this.pairs.length = 0;\n            this.startFromEven = true;\n            return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));\n        }\n        reset() {\n            this.pairs.length = 0;\n            this.rows.length = 0;\n        }\n        // Not private for testing\n        decodeRow2pairs(rowNumber, row) {\n            let done = false;\n            while (!done) {\n                try {\n                    this.pairs.push(this.retrieveNextPair(row, this.pairs, rowNumber));\n                }\n                catch (error) {\n                    if (error instanceof NotFoundException) {\n                        if (!this.pairs.length) {\n                            throw new NotFoundException();\n                        }\n                        // exit this loop when retrieveNextPair() fails and throws\n                        done = true;\n                    }\n                }\n            }\n            // TODO: verify sequence of finder patterns as in checkPairSequence()\n            if (this.checkChecksum()) {\n                return this.pairs;\n            }\n            let tryStackedDecode;\n            if (this.rows.length) {\n                tryStackedDecode = true;\n            }\n            else {\n                tryStackedDecode = false;\n            }\n            // let tryStackedDecode = !this.rows.isEmpty();\n            this.storeRow(rowNumber, false); // TODO: deal with reversed rows\n            if (tryStackedDecode) {\n                // When the image is 180-rotated, then rows are sorted in wrong direction.\n                // Try twice with both the directions.\n                let ps = this.checkRowsBoolean(false);\n                if (ps != null) {\n                    return ps;\n                }\n                ps = this.checkRowsBoolean(true);\n                if (ps != null) {\n                    return ps;\n                }\n            }\n            throw new NotFoundException();\n        }\n        // Need to Verify\n        checkRowsBoolean(reverse) {\n            // Limit number of rows we are checking\n            // We use recursive algorithm with pure complexity and don't want it to take forever\n            // Stacked barcode can have up to 11 rows, so 25 seems reasonable enough\n            if (this.rows.length > 25) {\n                this.rows.length = 0; // We will never have a chance to get result, so clear it\n                return null;\n            }\n            this.pairs.length = 0;\n            if (reverse) {\n                this.rows = this.rows.reverse();\n                // Collections.reverse(this.rows);\n            }\n            let ps = null;\n            try {\n                ps = this.checkRows(new Array(), 0);\n            }\n            catch (e) {\n                // OK\n                if (this.verbose) {\n                    console.log(e);\n                }\n            }\n            if (reverse) {\n                this.rows = this.rows.reverse();\n                // Collections.reverse(this.rows);\n            }\n            return ps;\n        }\n        // Try to construct a valid rows sequence\n        // Recursion is used to implement backtracking\n        checkRows(collectedRows, currentRow) {\n            for (let i = currentRow; i < this.rows.length; i++) {\n                let row = this.rows[i];\n                this.pairs.length = 0;\n                for (let collectedRow of collectedRows) {\n                    this.pairs.push(collectedRow.getPairs());\n                }\n                this.pairs.push(row.getPairs());\n                if (!RSSExpandedReader.isValidSequence(this.pairs)) {\n                    continue;\n                }\n                if (this.checkChecksum()) {\n                    return this.pairs;\n                }\n                let rs = new Array(collectedRows);\n                rs.push(row);\n                try {\n                    // Recursion: try to add more rows\n                    return this.checkRows(rs, i + 1);\n                }\n                catch (e) {\n                    // We failed, try the next candidate\n                    if (this.verbose) {\n                        console.log(e);\n                    }\n                }\n            }\n            throw new NotFoundException();\n        }\n        // Whether the pairs form a valid find pattern sequence,\n        // either complete or a prefix\n        static isValidSequence(pairs) {\n            for (let sequence of RSSExpandedReader.FINDER_PATTERN_SEQUENCES) {\n                if (pairs.length > sequence.length) {\n                    continue;\n                }\n                let stop = true;\n                for (let j = 0; j < pairs.length; j++) {\n                    if (pairs[j].getFinderPattern().getValue() != sequence[j]) {\n                        stop = false;\n                        break;\n                    }\n                }\n                if (stop) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        storeRow(rowNumber, wasReversed) {\n            // Discard if duplicate above or below; otherwise insert in order by row number.\n            let insertPos = 0;\n            let prevIsSame = false;\n            let nextIsSame = false;\n            while (insertPos < this.rows.length) {\n                let erow = this.rows[insertPos];\n                if (erow.getRowNumber() > rowNumber) {\n                    nextIsSame = erow.isEquivalent(this.pairs);\n                    break;\n                }\n                prevIsSame = erow.isEquivalent(this.pairs);\n                insertPos++;\n            }\n            if (nextIsSame || prevIsSame) {\n                return;\n            }\n            // When the row was partially decoded (e.g. 2 pairs found instead of 3),\n            // it will prevent us from detecting the barcode.\n            // Try to merge partial rows\n            // Check whether the row is part of an allready detected row\n            if (RSSExpandedReader.isPartialRow(this.pairs, this.rows)) {\n                return;\n            }\n            this.rows.push(insertPos, new ExpandedRow(this.pairs, rowNumber, wasReversed));\n            this.removePartialRows(this.pairs, this.rows);\n        }\n        // Remove all the rows that contains only specified pairs\n        removePartialRows(pairs, rows) {\n            // for (Iterator<ExpandedRow> iterator = rows.iterator(); iterator.hasNext();) {\n            //   ExpandedRow r = iterator.next();\n            //   if (r.getPairs().size() == pairs.size()) {\n            //     continue;\n            //   }\n            //   boolean allFound = true;\n            //   for (ExpandedPair p : r.getPairs()) {\n            //     boolean found = false;\n            //     for (ExpandedPair pp : pairs) {\n            //       if (p.equals(pp)) {\n            //         found = true;\n            //         break;\n            //       }\n            //     }\n            //     if (!found) {\n            //       allFound = false;\n            //       break;\n            //     }\n            //   }\n            //   if (allFound) {\n            //     // 'pairs' contains all the pairs from the row 'r'\n            //     iterator.remove();\n            //   }\n            // }\n            for (let row of rows) {\n                if (row.getPairs().length === pairs.length) {\n                    continue;\n                }\n                for (let p of row.getPairs()) {\n                    for (let pp of pairs) {\n                        if (ExpandedPair.equals(p, pp)) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        // Returns true when one of the rows already contains all the pairs\n        static isPartialRow(pairs, rows) {\n            for (let r of rows) {\n                let allFound = true;\n                for (let p of pairs) {\n                    let found = false;\n                    for (let pp of r.getPairs()) {\n                        if (p.equals(pp)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        allFound = false;\n                        break;\n                    }\n                }\n                if (allFound) {\n                    // the row 'r' contain all the pairs from 'pairs'\n                    return true;\n                }\n            }\n            return false;\n        }\n        // Only used for unit testing\n        getRows() {\n            return this.rows;\n        }\n        // Not private for unit testing\n        static constructResult(pairs) {\n            let binary = BitArrayBuilder.buildBitArray(pairs);\n            let decoder = createDecoder(binary);\n            let resultingString = decoder.parseInformation();\n            let firstPoints = pairs[0].getFinderPattern().getResultPoints();\n            let lastPoints = pairs[pairs.length - 1].getFinderPattern().getResultPoints();\n            let points = [firstPoints[0], firstPoints[1], lastPoints[0], lastPoints[1]];\n            return new Result(resultingString, null, null, points, BarcodeFormat$1.RSS_EXPANDED, null);\n        }\n        checkChecksum() {\n            let firstPair = this.pairs.get(0);\n            let checkCharacter = firstPair.getLeftChar();\n            let firstCharacter = firstPair.getRightChar();\n            if (firstCharacter == null) {\n                return false;\n            }\n            let checksum = firstCharacter.getChecksumPortion();\n            let s = 2;\n            for (let i = 1; i < this.pairs.size(); ++i) {\n                let currentPair = this.pairs.get(i);\n                checksum += currentPair.getLeftChar().getChecksumPortion();\n                s++;\n                let currentRightChar = currentPair.getRightChar();\n                if (currentRightChar != null) {\n                    checksum += currentRightChar.getChecksumPortion();\n                    s++;\n                }\n            }\n            checksum %= 211;\n            let checkCharacterValue = 211 * (s - 4) + checksum;\n            return checkCharacterValue == checkCharacter.getValue();\n        }\n        static getNextSecondBar(row, initialPos) {\n            let currentPos;\n            if (row.get(initialPos)) {\n                currentPos = row.getNextUnset(initialPos);\n                currentPos = row.getNextSet(currentPos);\n            }\n            else {\n                currentPos = row.getNextSet(initialPos);\n                currentPos = row.getNextUnset(currentPos);\n            }\n            return currentPos;\n        }\n        // not private for testing\n        retrieveNextPair(row, previousPairs, rowNumber) {\n            let isOddPattern = previousPairs.length % 2 == 0;\n            if (this.startFromEven) {\n                isOddPattern = !isOddPattern;\n            }\n            let pattern;\n            let keepFinding = true;\n            let forcedOffset = -1;\n            do {\n                this.findNextPair(row, previousPairs, forcedOffset);\n                pattern = this.parseFoundFinderPattern(row, rowNumber, isOddPattern);\n                if (pattern == null) {\n                    forcedOffset = RSSExpandedReader.getNextSecondBar(row, this.startEnd[0]);\n                }\n                else {\n                    keepFinding = false;\n                }\n            } while (keepFinding);\n            // When stacked symbol is split over multiple rows, there's no way to guess if this pair can be last or not.\n            // boolean mayBeLast = checkPairSequence(previousPairs, pattern);\n            let leftChar = this.decodeDataCharacter(row, pattern, isOddPattern, true);\n            if (!this.isEmptyPair(previousPairs) && previousPairs[previousPairs.length - 1].mustBeLast()) {\n                throw new NotFoundException();\n            }\n            let rightChar;\n            try {\n                rightChar = this.decodeDataCharacter(row, pattern, isOddPattern, false);\n            }\n            catch (e) {\n                rightChar = null;\n                if (this.verbose) {\n                    console.log(e);\n                }\n            }\n            return new ExpandedPair(leftChar, rightChar, pattern, true);\n        }\n        isEmptyPair(pairs) {\n            if (pairs.length === 0) {\n                return true;\n            }\n            return false;\n        }\n        findNextPair(row, previousPairs, forcedOffset) {\n            let counters = this.getDecodeFinderCounters();\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let width = row.getSize();\n            let rowOffset;\n            if (forcedOffset >= 0) {\n                rowOffset = forcedOffset;\n            }\n            else if (this.isEmptyPair(previousPairs)) {\n                rowOffset = 0;\n            }\n            else {\n                let lastPair = previousPairs[previousPairs.length - 1];\n                rowOffset = lastPair.getFinderPattern().getStartEnd()[1];\n            }\n            let searchingEvenPair = previousPairs.length % 2 != 0;\n            if (this.startFromEven) {\n                searchingEvenPair = !searchingEvenPair;\n            }\n            let isWhite = false;\n            while (rowOffset < width) {\n                isWhite = !row.get(rowOffset);\n                if (!isWhite) {\n                    break;\n                }\n                rowOffset++;\n            }\n            let counterPosition = 0;\n            let patternStart = rowOffset;\n            for (let x = rowOffset; x < width; x++) {\n                if (row.get(x) != isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (counterPosition == 3) {\n                        if (searchingEvenPair) {\n                            RSSExpandedReader.reverseCounters(counters);\n                        }\n                        if (RSSExpandedReader.isFinderPattern(counters)) {\n                            this.startEnd[0] = patternStart;\n                            this.startEnd[1] = x;\n                            return;\n                        }\n                        if (searchingEvenPair) {\n                            RSSExpandedReader.reverseCounters(counters);\n                        }\n                        patternStart += counters[0] + counters[1];\n                        counters[0] = counters[2];\n                        counters[1] = counters[3];\n                        counters[2] = 0;\n                        counters[3] = 0;\n                        counterPosition--;\n                    }\n                    else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        static reverseCounters(counters) {\n            let length = counters.length;\n            for (let i = 0; i < length / 2; ++i) {\n                let tmp = counters[i];\n                counters[i] = counters[length - i - 1];\n                counters[length - i - 1] = tmp;\n            }\n        }\n        parseFoundFinderPattern(row, rowNumber, oddPattern) {\n            // Actually we found elements 2-5.\n            let firstCounter;\n            let start;\n            let end;\n            if (oddPattern) {\n                // If pattern number is odd, we need to locate element 1 *before* the current block.\n                let firstElementStart = this.startEnd[0] - 1;\n                // Locate element 1\n                while (firstElementStart >= 0 && !row.get(firstElementStart)) {\n                    firstElementStart--;\n                }\n                firstElementStart++;\n                firstCounter = this.startEnd[0] - firstElementStart;\n                start = firstElementStart;\n                end = this.startEnd[1];\n            }\n            else {\n                // If pattern number is even, the pattern is reversed, so we need to locate element 1 *after* the current block.\n                start = this.startEnd[0];\n                end = row.getNextUnset(this.startEnd[1] + 1);\n                firstCounter = end - this.startEnd[1];\n            }\n            // Make 'counters' hold 1-4\n            let counters = this.getDecodeFinderCounters();\n            System.arraycopy(counters, 0, counters, 1, counters.length - 1);\n            counters[0] = firstCounter;\n            let value;\n            try {\n                value = this.parseFinderValue(counters, RSSExpandedReader.FINDER_PATTERNS);\n            }\n            catch (e) {\n                return null;\n            }\n            // return new FinderPattern(value, new int[] { start, end }, start, end, rowNumber});\n            return new FinderPattern(value, [start, end], start, end, rowNumber);\n        }\n        decodeDataCharacter(row, pattern, isOddPattern, leftChar) {\n            let counters = this.getDataCharacterCounters();\n            for (let x = 0; x < counters.length; x++) {\n                counters[x] = 0;\n            }\n            if (leftChar) {\n                RSSExpandedReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);\n            }\n            else {\n                RSSExpandedReader.recordPattern(row, pattern.getStartEnd()[1], counters);\n                // reverse it\n                for (let i = 0, j = counters.length - 1; i < j; i++, j--) {\n                    let temp = counters[i];\n                    counters[i] = counters[j];\n                    counters[j] = temp;\n                }\n            } // counters[] has the pixels of the module\n            let numModules = 17; // left and right data characters have all the same length\n            let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;\n            // Sanity check: element width for pattern and the character should match\n            let expectedElementWidth = (pattern.getStartEnd()[1] - pattern.getStartEnd()[0]) / 15.0;\n            if (Math.abs(elementWidth - expectedElementWidth) / expectedElementWidth > 0.3) {\n                throw new NotFoundException();\n            }\n            let oddCounts = this.getOddCounts();\n            let evenCounts = this.getEvenCounts();\n            let oddRoundingErrors = this.getOddRoundingErrors();\n            let evenRoundingErrors = this.getEvenRoundingErrors();\n            for (let i = 0; i < counters.length; i++) {\n                let value = 1.0 * counters[i] / elementWidth;\n                let count = value + 0.5; // Round\n                if (count < 1) {\n                    if (value < 0.3) {\n                        throw new NotFoundException();\n                    }\n                    count = 1;\n                }\n                else if (count > 8) {\n                    if (value > 8.7) {\n                        throw new NotFoundException();\n                    }\n                    count = 8;\n                }\n                let offset = i / 2;\n                if ((i & 0x01) == 0) {\n                    oddCounts[offset] = count;\n                    oddRoundingErrors[offset] = value - count;\n                }\n                else {\n                    evenCounts[offset] = count;\n                    evenRoundingErrors[offset] = value - count;\n                }\n            }\n            this.adjustOddEvenCounts(numModules);\n            let weightRowNumber = 4 * pattern.getValue() + (isOddPattern ? 0 : 2) + (leftChar ? 0 : 1) - 1;\n            let oddSum = 0;\n            let oddChecksumPortion = 0;\n            for (let i = oddCounts.length - 1; i >= 0; i--) {\n                if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {\n                    let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i];\n                    oddChecksumPortion += oddCounts[i] * weight;\n                }\n                oddSum += oddCounts[i];\n            }\n            let evenChecksumPortion = 0;\n            // int evenSum = 0;\n            for (let i = evenCounts.length - 1; i >= 0; i--) {\n                if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {\n                    let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i + 1];\n                    evenChecksumPortion += evenCounts[i] * weight;\n                }\n                // evenSum += evenCounts[i];\n            }\n            let checksumPortion = oddChecksumPortion + evenChecksumPortion;\n            if ((oddSum & 0x01) != 0 || oddSum > 13 || oddSum < 4) {\n                throw new NotFoundException();\n            }\n            let group = (13 - oddSum) / 2;\n            let oddWidest = RSSExpandedReader.SYMBOL_WIDEST[group];\n            let evenWidest = 9 - oddWidest;\n            let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);\n            let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);\n            let tEven = RSSExpandedReader.EVEN_TOTAL_SUBSET[group];\n            let gSum = RSSExpandedReader.GSUM[group];\n            let value = vOdd * tEven + vEven + gSum;\n            return new DataCharacter(value, checksumPortion);\n        }\n        static isNotA1left(pattern, isOddPattern, leftChar) {\n            // A1: pattern.getValue is 0 (A), and it's an oddPattern, and it is a left char\n            return !(pattern.getValue() == 0 && isOddPattern && leftChar);\n        }\n        adjustOddEvenCounts(numModules) {\n            let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));\n            let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));\n            let incrementOdd = false;\n            let decrementOdd = false;\n            if (oddSum > 13) {\n                decrementOdd = true;\n            }\n            else if (oddSum < 4) {\n                incrementOdd = true;\n            }\n            let incrementEven = false;\n            let decrementEven = false;\n            if (evenSum > 13) {\n                decrementEven = true;\n            }\n            else if (evenSum < 4) {\n                incrementEven = true;\n            }\n            let mismatch = oddSum + evenSum - numModules;\n            let oddParityBad = (oddSum & 0x01) == 1;\n            let evenParityBad = (evenSum & 0x01) == 0;\n            if (mismatch == 1) {\n                if (oddParityBad) {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    decrementOdd = true;\n                }\n                else {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    decrementEven = true;\n                }\n            }\n            else if (mismatch == -1) {\n                if (oddParityBad) {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    incrementOdd = true;\n                }\n                else {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    incrementEven = true;\n                }\n            }\n            else if (mismatch == 0) {\n                if (oddParityBad) {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    // Both bad\n                    if (oddSum < evenSum) {\n                        incrementOdd = true;\n                        decrementEven = true;\n                    }\n                    else {\n                        decrementOdd = true;\n                        incrementEven = true;\n                    }\n                }\n                else {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    // Nothing to do!\n                }\n            }\n            else {\n                throw new NotFoundException();\n            }\n            if (incrementOdd) {\n                if (decrementOdd) {\n                    throw new NotFoundException();\n                }\n                RSSExpandedReader.increment(this.getOddCounts(), this.getOddRoundingErrors());\n            }\n            if (decrementOdd) {\n                RSSExpandedReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());\n            }\n            if (incrementEven) {\n                if (decrementEven) {\n                    throw new NotFoundException();\n                }\n                RSSExpandedReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());\n            }\n            if (decrementEven) {\n                RSSExpandedReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());\n            }\n        }\n    }\n    RSSExpandedReader.SYMBOL_WIDEST = [7, 5, 4, 3, 1];\n    RSSExpandedReader.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204];\n    RSSExpandedReader.GSUM = [0, 348, 1388, 2948, 3988];\n    RSSExpandedReader.FINDER_PATTERNS = [\n        Int32Array.from([1, 8, 4, 1]),\n        Int32Array.from([3, 6, 4, 1]),\n        Int32Array.from([3, 4, 6, 1]),\n        Int32Array.from([3, 2, 8, 1]),\n        Int32Array.from([2, 6, 5, 1]),\n        Int32Array.from([2, 2, 9, 1]) // F\n    ];\n    RSSExpandedReader.WEIGHTS = [\n        [1, 3, 9, 27, 81, 32, 96, 77],\n        [20, 60, 180, 118, 143, 7, 21, 63],\n        [189, 145, 13, 39, 117, 140, 209, 205],\n        [193, 157, 49, 147, 19, 57, 171, 91],\n        [62, 186, 136, 197, 169, 85, 44, 132],\n        [185, 133, 188, 142, 4, 12, 36, 108],\n        [113, 128, 173, 97, 80, 29, 87, 50],\n        [150, 28, 84, 41, 123, 158, 52, 156],\n        [46, 138, 203, 187, 139, 206, 196, 166],\n        [76, 17, 51, 153, 37, 111, 122, 155],\n        [43, 129, 176, 106, 107, 110, 119, 146],\n        [16, 48, 144, 10, 30, 90, 59, 177],\n        [109, 116, 137, 200, 178, 112, 125, 164],\n        [70, 210, 208, 202, 184, 130, 179, 115],\n        [134, 191, 151, 31, 93, 68, 204, 190],\n        [148, 22, 66, 198, 172, 94, 71, 2],\n        [6, 18, 54, 162, 64, 192, 154, 40],\n        [120, 149, 25, 75, 14, 42, 126, 167],\n        [79, 26, 78, 23, 69, 207, 199, 175],\n        [103, 98, 83, 38, 114, 131, 182, 124],\n        [161, 61, 183, 127, 170, 88, 53, 159],\n        [55, 165, 73, 8, 24, 72, 5, 15],\n        [45, 135, 194, 160, 58, 174, 100, 89]\n    ];\n    RSSExpandedReader.FINDER_PAT_A = 0;\n    RSSExpandedReader.FINDER_PAT_B = 1;\n    RSSExpandedReader.FINDER_PAT_C = 2;\n    RSSExpandedReader.FINDER_PAT_D = 3;\n    RSSExpandedReader.FINDER_PAT_E = 4;\n    RSSExpandedReader.FINDER_PAT_F = 5;\n    RSSExpandedReader.FINDER_PATTERN_SEQUENCES = [\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_C],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_F],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],\n    ];\n    RSSExpandedReader.MAX_PAIRS = 11;\n\n    class Pair extends DataCharacter {\n        constructor(value, checksumPortion, finderPattern) {\n            super(value, checksumPortion);\n            this.count = 0;\n            this.finderPattern = finderPattern;\n        }\n        getFinderPattern() {\n            return this.finderPattern;\n        }\n        getCount() {\n            return this.count;\n        }\n        incrementCount() {\n            this.count++;\n        }\n    }\n\n    class RSS14Reader extends AbstractRSSReader {\n        constructor() {\n            super(...arguments);\n            this.possibleLeftPairs = [];\n            this.possibleRightPairs = [];\n        }\n        decodeRow(rowNumber, row, hints) {\n            const leftPair = this.decodePair(row, false, rowNumber, hints);\n            RSS14Reader.addOrTally(this.possibleLeftPairs, leftPair);\n            row.reverse();\n            let rightPair = this.decodePair(row, true, rowNumber, hints);\n            RSS14Reader.addOrTally(this.possibleRightPairs, rightPair);\n            row.reverse();\n            for (let left of this.possibleLeftPairs) {\n                if (left.getCount() > 1) {\n                    for (let right of this.possibleRightPairs) {\n                        if (right.getCount() > 1 && RSS14Reader.checkChecksum(left, right)) {\n                            return RSS14Reader.constructResult(left, right);\n                        }\n                    }\n                }\n            }\n            throw new NotFoundException();\n        }\n        static addOrTally(possiblePairs, pair) {\n            if (pair == null) {\n                return;\n            }\n            let found = false;\n            for (let other of possiblePairs) {\n                if (other.getValue() === pair.getValue()) {\n                    other.incrementCount();\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                possiblePairs.push(pair);\n            }\n        }\n        reset() {\n            this.possibleLeftPairs.length = 0;\n            this.possibleRightPairs.length = 0;\n        }\n        static constructResult(leftPair, rightPair) {\n            let symbolValue = 4537077 * leftPair.getValue() + rightPair.getValue();\n            let text = new String(symbolValue).toString();\n            let buffer = new StringBuilder();\n            for (let i = 13 - text.length; i > 0; i--) {\n                buffer.append('0');\n            }\n            buffer.append(text);\n            let checkDigit = 0;\n            for (let i = 0; i < 13; i++) {\n                let digit = buffer.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n                checkDigit += ((i & 0x01) === 0) ? 3 * digit : digit;\n            }\n            checkDigit = 10 - (checkDigit % 10);\n            if (checkDigit === 10) {\n                checkDigit = 0;\n            }\n            buffer.append(checkDigit.toString());\n            let leftPoints = leftPair.getFinderPattern().getResultPoints();\n            let rightPoints = rightPair.getFinderPattern().getResultPoints();\n            return new Result(buffer.toString(), null, 0, [leftPoints[0], leftPoints[1], rightPoints[0], rightPoints[1]], BarcodeFormat$1.RSS_14, new Date().getTime());\n        }\n        static checkChecksum(leftPair, rightPair) {\n            let checkValue = (leftPair.getChecksumPortion() + 16 * rightPair.getChecksumPortion()) % 79;\n            let targetCheckValue = 9 * leftPair.getFinderPattern().getValue() + rightPair.getFinderPattern().getValue();\n            if (targetCheckValue > 72) {\n                targetCheckValue--;\n            }\n            if (targetCheckValue > 8) {\n                targetCheckValue--;\n            }\n            return checkValue === targetCheckValue;\n        }\n        decodePair(row, right, rowNumber, hints) {\n            try {\n                let startEnd = this.findFinderPattern(row, right);\n                let pattern = this.parseFoundFinderPattern(row, rowNumber, right, startEnd);\n                let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);\n                if (resultPointCallback != null) {\n                    let center = (startEnd[0] + startEnd[1]) / 2.0;\n                    if (right) {\n                        // row is actually reversed\n                        center = row.getSize() - 1 - center;\n                    }\n                    resultPointCallback.foundPossibleResultPoint(new ResultPoint(center, rowNumber));\n                }\n                let outside = this.decodeDataCharacter(row, pattern, true);\n                let inside = this.decodeDataCharacter(row, pattern, false);\n                return new Pair(1597 * outside.getValue() + inside.getValue(), outside.getChecksumPortion() + 4 * inside.getChecksumPortion(), pattern);\n            }\n            catch (err) {\n                return null;\n            }\n        }\n        decodeDataCharacter(row, pattern, outsideChar) {\n            let counters = this.getDataCharacterCounters();\n            for (let x = 0; x < counters.length; x++) {\n                counters[x] = 0;\n            }\n            if (outsideChar) {\n                OneDReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);\n            }\n            else {\n                OneDReader.recordPattern(row, pattern.getStartEnd()[1] + 1, counters);\n                // reverse it\n                for (let i = 0, j = counters.length - 1; i < j; i++, j--) {\n                    let temp = counters[i];\n                    counters[i] = counters[j];\n                    counters[j] = temp;\n                }\n            }\n            let numModules = outsideChar ? 16 : 15;\n            let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;\n            let oddCounts = this.getOddCounts();\n            let evenCounts = this.getEvenCounts();\n            let oddRoundingErrors = this.getOddRoundingErrors();\n            let evenRoundingErrors = this.getEvenRoundingErrors();\n            for (let i = 0; i < counters.length; i++) {\n                let value = counters[i] / elementWidth;\n                let count = Math.floor(value + 0.5);\n                if (count < 1) {\n                    count = 1;\n                }\n                else if (count > 8) {\n                    count = 8;\n                }\n                let offset = Math.floor(i / 2);\n                if ((i & 0x01) === 0) {\n                    oddCounts[offset] = count;\n                    oddRoundingErrors[offset] = value - count;\n                }\n                else {\n                    evenCounts[offset] = count;\n                    evenRoundingErrors[offset] = value - count;\n                }\n            }\n            this.adjustOddEvenCounts(outsideChar, numModules);\n            let oddSum = 0;\n            let oddChecksumPortion = 0;\n            for (let i = oddCounts.length - 1; i >= 0; i--) {\n                oddChecksumPortion *= 9;\n                oddChecksumPortion += oddCounts[i];\n                oddSum += oddCounts[i];\n            }\n            let evenChecksumPortion = 0;\n            let evenSum = 0;\n            for (let i = evenCounts.length - 1; i >= 0; i--) {\n                evenChecksumPortion *= 9;\n                evenChecksumPortion += evenCounts[i];\n                evenSum += evenCounts[i];\n            }\n            let checksumPortion = oddChecksumPortion + 3 * evenChecksumPortion;\n            if (outsideChar) {\n                if ((oddSum & 0x01) !== 0 || oddSum > 12 || oddSum < 4) {\n                    throw new NotFoundException();\n                }\n                let group = (12 - oddSum) / 2;\n                let oddWidest = RSS14Reader.OUTSIDE_ODD_WIDEST[group];\n                let evenWidest = 9 - oddWidest;\n                let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, false);\n                let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, true);\n                let tEven = RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET[group];\n                let gSum = RSS14Reader.OUTSIDE_GSUM[group];\n                return new DataCharacter(vOdd * tEven + vEven + gSum, checksumPortion);\n            }\n            else {\n                if ((evenSum & 0x01) !== 0 || evenSum > 10 || evenSum < 4) {\n                    throw new NotFoundException();\n                }\n                let group = (10 - evenSum) / 2;\n                let oddWidest = RSS14Reader.INSIDE_ODD_WIDEST[group];\n                let evenWidest = 9 - oddWidest;\n                let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);\n                let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);\n                let tOdd = RSS14Reader.INSIDE_ODD_TOTAL_SUBSET[group];\n                let gSum = RSS14Reader.INSIDE_GSUM[group];\n                return new DataCharacter(vEven * tOdd + vOdd + gSum, checksumPortion);\n            }\n        }\n        findFinderPattern(row, rightFinderPattern) {\n            let counters = this.getDecodeFinderCounters();\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let width = row.getSize();\n            let isWhite = false;\n            let rowOffset = 0;\n            while (rowOffset < width) {\n                isWhite = !row.get(rowOffset);\n                if (rightFinderPattern === isWhite) {\n                    // Will encounter white first when searching for right finder pattern\n                    break;\n                }\n                rowOffset++;\n            }\n            let counterPosition = 0;\n            let patternStart = rowOffset;\n            for (let x = rowOffset; x < width; x++) {\n                if (row.get(x) !== isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (counterPosition === 3) {\n                        if (AbstractRSSReader.isFinderPattern(counters)) {\n                            return [patternStart, x];\n                        }\n                        patternStart += counters[0] + counters[1];\n                        counters[0] = counters[2];\n                        counters[1] = counters[3];\n                        counters[2] = 0;\n                        counters[3] = 0;\n                        counterPosition--;\n                    }\n                    else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        parseFoundFinderPattern(row, rowNumber, right, startEnd) {\n            // Actually we found elements 2-5\n            let firstIsBlack = row.get(startEnd[0]);\n            let firstElementStart = startEnd[0] - 1;\n            // Locate element 1\n            while (firstElementStart >= 0 && firstIsBlack !== row.get(firstElementStart)) {\n                firstElementStart--;\n            }\n            firstElementStart++;\n            const firstCounter = startEnd[0] - firstElementStart;\n            // Make 'counters' hold 1-4\n            const counters = this.getDecodeFinderCounters();\n            const copy = new Int32Array(counters.length);\n            System.arraycopy(counters, 0, copy, 1, counters.length - 1);\n            copy[0] = firstCounter;\n            const value = this.parseFinderValue(copy, RSS14Reader.FINDER_PATTERNS);\n            let start = firstElementStart;\n            let end = startEnd[1];\n            if (right) {\n                // row is actually reversed\n                start = row.getSize() - 1 - start;\n                end = row.getSize() - 1 - end;\n            }\n            return new FinderPattern(value, [firstElementStart, startEnd[1]], start, end, rowNumber);\n        }\n        adjustOddEvenCounts(outsideChar, numModules) {\n            let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));\n            let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));\n            let incrementOdd = false;\n            let decrementOdd = false;\n            let incrementEven = false;\n            let decrementEven = false;\n            if (outsideChar) {\n                if (oddSum > 12) {\n                    decrementOdd = true;\n                }\n                else if (oddSum < 4) {\n                    incrementOdd = true;\n                }\n                if (evenSum > 12) {\n                    decrementEven = true;\n                }\n                else if (evenSum < 4) {\n                    incrementEven = true;\n                }\n            }\n            else {\n                if (oddSum > 11) {\n                    decrementOdd = true;\n                }\n                else if (oddSum < 5) {\n                    incrementOdd = true;\n                }\n                if (evenSum > 10) {\n                    decrementEven = true;\n                }\n                else if (evenSum < 4) {\n                    incrementEven = true;\n                }\n            }\n            let mismatch = oddSum + evenSum - numModules;\n            let oddParityBad = (oddSum & 0x01) === (outsideChar ? 1 : 0);\n            let evenParityBad = (evenSum & 0x01) === 1;\n            if (mismatch === 1) {\n                if (oddParityBad) {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    decrementOdd = true;\n                }\n                else {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    decrementEven = true;\n                }\n            }\n            else if (mismatch === -1) {\n                if (oddParityBad) {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    incrementOdd = true;\n                }\n                else {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    incrementEven = true;\n                }\n            }\n            else if (mismatch === 0) {\n                if (oddParityBad) {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    // Both bad\n                    if (oddSum < evenSum) {\n                        incrementOdd = true;\n                        decrementEven = true;\n                    }\n                    else {\n                        decrementOdd = true;\n                        incrementEven = true;\n                    }\n                }\n                else {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    // Nothing to do!\n                }\n            }\n            else {\n                throw new NotFoundException();\n            }\n            if (incrementOdd) {\n                if (decrementOdd) {\n                    throw new NotFoundException();\n                }\n                AbstractRSSReader.increment(this.getOddCounts(), this.getOddRoundingErrors());\n            }\n            if (decrementOdd) {\n                AbstractRSSReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());\n            }\n            if (incrementEven) {\n                if (decrementEven) {\n                    throw new NotFoundException();\n                }\n                AbstractRSSReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());\n            }\n            if (decrementEven) {\n                AbstractRSSReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());\n            }\n        }\n    }\n    RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126];\n    RSS14Reader.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81];\n    RSS14Reader.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715];\n    RSS14Reader.INSIDE_GSUM = [0, 336, 1036, 1516];\n    RSS14Reader.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1];\n    RSS14Reader.INSIDE_ODD_WIDEST = [2, 4, 6, 8];\n    RSS14Reader.FINDER_PATTERNS = [\n        Int32Array.from([3, 8, 2, 1]),\n        Int32Array.from([3, 5, 5, 1]),\n        Int32Array.from([3, 3, 7, 1]),\n        Int32Array.from([3, 1, 9, 1]),\n        Int32Array.from([2, 7, 4, 1]),\n        Int32Array.from([2, 5, 6, 1]),\n        Int32Array.from([2, 3, 8, 1]),\n        Int32Array.from([1, 5, 7, 1]),\n        Int32Array.from([1, 3, 9, 1]),\n    ];\n\n    /**\n     * @author Daniel Switkin <dswitkin@google.com>\n     * @author Sean Owen\n     */\n    class MultiFormatOneDReader extends OneDReader {\n        constructor(hints, verbose) {\n            super();\n            this.readers = [];\n            this.verbose = (verbose === true);\n            const possibleFormats = !hints ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);\n            const useCode39CheckDigit = hints && hints.get(DecodeHintType$1.ASSUME_CODE_39_CHECK_DIGIT) !== undefined;\n            if (possibleFormats) {\n                if (possibleFormats.includes(BarcodeFormat$1.EAN_13) ||\n                    possibleFormats.includes(BarcodeFormat$1.UPC_A) ||\n                    possibleFormats.includes(BarcodeFormat$1.EAN_8) ||\n                    possibleFormats.includes(BarcodeFormat$1.UPC_E)) {\n                    this.readers.push(new MultiFormatUPCEANReader(hints));\n                }\n                if (possibleFormats.includes(BarcodeFormat$1.CODE_39)) {\n                    this.readers.push(new Code39Reader(useCode39CheckDigit));\n                }\n                // if (possibleFormats.includes(BarcodeFormat.CODE_93)) {\n                //    this.readers.push(new Code93Reader());\n                // }\n                if (possibleFormats.includes(BarcodeFormat$1.CODE_128)) {\n                    this.readers.push(new Code128Reader());\n                }\n                if (possibleFormats.includes(BarcodeFormat$1.ITF)) {\n                    this.readers.push(new ITFReader());\n                }\n                // if (possibleFormats.includes(BarcodeFormat.CODABAR)) {\n                //    this.readers.push(new CodaBarReader());\n                // }\n                if (possibleFormats.includes(BarcodeFormat$1.RSS_14)) {\n                    this.readers.push(new RSS14Reader());\n                }\n                if (possibleFormats.includes(BarcodeFormat$1.RSS_EXPANDED)) {\n                    this.readers.push(new RSSExpandedReader(this.verbose));\n                }\n            } else {\n                // Case when no hints were provided -> add all.\n                this.readers.push(new MultiFormatUPCEANReader(hints));\n                this.readers.push(new Code39Reader());\n                // this.readers.push(new CodaBarReader());\n                // this.readers.push(new Code93Reader());\n                this.readers.push(new MultiFormatUPCEANReader(hints));\n                this.readers.push(new Code128Reader());\n                this.readers.push(new ITFReader());\n                this.readers.push(new RSS14Reader());\n                this.readers.push(new RSSExpandedReader(this.verbose));\n            }\n        }\n        // @Override\n        decodeRow(rowNumber, row, hints) {\n            for (let i = 0; i < this.readers.length; i++) {\n                try {\n                    return this.readers[i].decodeRow(rowNumber, row, hints);\n                }\n                catch (re) {\n                    // continue\n                }\n            }\n            throw new NotFoundException();\n        }\n        // @Override\n        reset() {\n            this.readers.forEach(reader => reader.reset());\n        }\n    }\n\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * Barcode reader reader to use from browser.\n     */\n    class BrowserBarcodeReader extends BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserBarcodeReader.\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n         * @param {Map<DecodeHintType, any>} hints\n         */\n        constructor(timeBetweenScansMillis = 500, hints) {\n            super(new MultiFormatOneDReader(hints), timeBetweenScansMillis, hints);\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will\n     * use blocks of differing sizes within one version, so, this encapsulates the parameters for\n     * each set of blocks. It also holds the number of error-correction codewords per block since it\n     * will be the same across all blocks within one version.</p>\n     */\n    class ECBlocks {\n        constructor(ecCodewords, ecBlocks1, ecBlocks2) {\n            this.ecCodewords = ecCodewords;\n            this.ecBlocks = [ecBlocks1];\n            ecBlocks2 && this.ecBlocks.push(ecBlocks2);\n        }\n        getECCodewords() {\n            return this.ecCodewords;\n        }\n        getECBlocks() {\n            return this.ecBlocks;\n        }\n    }\n    /**\n     * <p>Encapsulates the parameters for one error-correction block in one symbol version.\n     * This includes the number of data codewords, and the number of times a block with these\n     * parameters is used consecutively in the Data Matrix code version's format.</p>\n     */\n    class ECB {\n        constructor(count, dataCodewords) {\n            this.count = count;\n            this.dataCodewords = dataCodewords;\n        }\n        getCount() {\n            return this.count;\n        }\n        getDataCodewords() {\n            return this.dataCodewords;\n        }\n    }\n    /**\n     * The Version object encapsulates attributes about a particular\n     * size Data Matrix Code.\n     *\n     * @author bbrown@google.com (Brian Brown)\n     */\n    class Version {\n        constructor(versionNumber, symbolSizeRows, symbolSizeColumns, dataRegionSizeRows, dataRegionSizeColumns, ecBlocks) {\n            this.versionNumber = versionNumber;\n            this.symbolSizeRows = symbolSizeRows;\n            this.symbolSizeColumns = symbolSizeColumns;\n            this.dataRegionSizeRows = dataRegionSizeRows;\n            this.dataRegionSizeColumns = dataRegionSizeColumns;\n            this.ecBlocks = ecBlocks;\n            // Calculate the total number of codewords\n            let total = 0;\n            const ecCodewords = ecBlocks.getECCodewords();\n            const ecbArray = ecBlocks.getECBlocks();\n            for (let ecBlock of ecbArray) {\n                total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);\n            }\n            this.totalCodewords = total;\n        }\n        getVersionNumber() {\n            return this.versionNumber;\n        }\n        getSymbolSizeRows() {\n            return this.symbolSizeRows;\n        }\n        getSymbolSizeColumns() {\n            return this.symbolSizeColumns;\n        }\n        getDataRegionSizeRows() {\n            return this.dataRegionSizeRows;\n        }\n        getDataRegionSizeColumns() {\n            return this.dataRegionSizeColumns;\n        }\n        getTotalCodewords() {\n            return this.totalCodewords;\n        }\n        getECBlocks() {\n            return this.ecBlocks;\n        }\n        /**\n         * <p>Deduces version information from Data Matrix dimensions.</p>\n         *\n         * @param numRows Number of rows in modules\n         * @param numColumns Number of columns in modules\n         * @return Version for a Data Matrix Code of those dimensions\n         * @throws FormatException if dimensions do correspond to a valid Data Matrix size\n         */\n        static getVersionForDimensions(numRows, numColumns) {\n            if ((numRows & 0x01) !== 0 || (numColumns & 0x01) !== 0) {\n                throw new FormatException();\n            }\n            for (let version of Version.VERSIONS) {\n                if (version.symbolSizeRows === numRows && version.symbolSizeColumns === numColumns) {\n                    return version;\n                }\n            }\n            throw new FormatException();\n        }\n        //  @Override\n        toString() {\n            return '' + this.versionNumber;\n        }\n        /**\n         * See ISO 16022:2006 5.5.1 Table 7\n         */\n        static buildVersions() {\n            return [\n                new Version(1, 10, 10, 8, 8, new ECBlocks(5, new ECB(1, 3))),\n                new Version(2, 12, 12, 10, 10, new ECBlocks(7, new ECB(1, 5))),\n                new Version(3, 14, 14, 12, 12, new ECBlocks(10, new ECB(1, 8))),\n                new Version(4, 16, 16, 14, 14, new ECBlocks(12, new ECB(1, 12))),\n                new Version(5, 18, 18, 16, 16, new ECBlocks(14, new ECB(1, 18))),\n                new Version(6, 20, 20, 18, 18, new ECBlocks(18, new ECB(1, 22))),\n                new Version(7, 22, 22, 20, 20, new ECBlocks(20, new ECB(1, 30))),\n                new Version(8, 24, 24, 22, 22, new ECBlocks(24, new ECB(1, 36))),\n                new Version(9, 26, 26, 24, 24, new ECBlocks(28, new ECB(1, 44))),\n                new Version(10, 32, 32, 14, 14, new ECBlocks(36, new ECB(1, 62))),\n                new Version(11, 36, 36, 16, 16, new ECBlocks(42, new ECB(1, 86))),\n                new Version(12, 40, 40, 18, 18, new ECBlocks(48, new ECB(1, 114))),\n                new Version(13, 44, 44, 20, 20, new ECBlocks(56, new ECB(1, 144))),\n                new Version(14, 48, 48, 22, 22, new ECBlocks(68, new ECB(1, 174))),\n                new Version(15, 52, 52, 24, 24, new ECBlocks(42, new ECB(2, 102))),\n                new Version(16, 64, 64, 14, 14, new ECBlocks(56, new ECB(2, 140))),\n                new Version(17, 72, 72, 16, 16, new ECBlocks(36, new ECB(4, 92))),\n                new Version(18, 80, 80, 18, 18, new ECBlocks(48, new ECB(4, 114))),\n                new Version(19, 88, 88, 20, 20, new ECBlocks(56, new ECB(4, 144))),\n                new Version(20, 96, 96, 22, 22, new ECBlocks(68, new ECB(4, 174))),\n                new Version(21, 104, 104, 24, 24, new ECBlocks(56, new ECB(6, 136))),\n                new Version(22, 120, 120, 18, 18, new ECBlocks(68, new ECB(6, 175))),\n                new Version(23, 132, 132, 20, 20, new ECBlocks(62, new ECB(8, 163))),\n                new Version(24, 144, 144, 22, 22, new ECBlocks(62, new ECB(8, 156), new ECB(2, 155))),\n                new Version(25, 8, 18, 6, 16, new ECBlocks(7, new ECB(1, 5))),\n                new Version(26, 8, 32, 6, 14, new ECBlocks(11, new ECB(1, 10))),\n                new Version(27, 12, 26, 10, 24, new ECBlocks(14, new ECB(1, 16))),\n                new Version(28, 12, 36, 10, 16, new ECBlocks(18, new ECB(1, 22))),\n                new Version(29, 16, 36, 14, 16, new ECBlocks(24, new ECB(1, 32))),\n                new Version(30, 16, 48, 14, 22, new ECBlocks(28, new ECB(1, 49)))\n            ];\n        }\n    }\n    Version.VERSIONS = Version.buildVersions();\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * @author bbrown@google.com (Brian Brown)\n     */\n    class BitMatrixParser {\n        /**\n         * @param bitMatrix {@link BitMatrix} to parse\n         * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2\n         */\n        constructor(bitMatrix) {\n            const dimension = bitMatrix.getHeight();\n            if (dimension < 8 || dimension > 144 || (dimension & 0x01) !== 0) {\n                throw new FormatException();\n            }\n            this.version = BitMatrixParser.readVersion(bitMatrix);\n            this.mappingBitMatrix = this.extractDataRegion(bitMatrix);\n            this.readMappingMatrix = new BitMatrix(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());\n        }\n        getVersion() {\n            return this.version;\n        }\n        /**\n         * <p>Creates the version object based on the dimension of the original bit matrix from\n         * the datamatrix code.</p>\n         *\n         * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>\n         *\n         * @param bitMatrix Original {@link BitMatrix} including alignment patterns\n         * @return {@link Version} encapsulating the Data Matrix Code's \"version\"\n         * @throws FormatException if the dimensions of the mapping matrix are not valid\n         * Data Matrix dimensions.\n         */\n        static readVersion(bitMatrix) {\n            const numRows = bitMatrix.getHeight();\n            const numColumns = bitMatrix.getWidth();\n            return Version.getVersionForDimensions(numRows, numColumns);\n        }\n        /**\n         * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)\n         * in the correct order in order to reconstitute the codewords bytes contained within the\n         * Data Matrix Code.</p>\n         *\n         * @return bytes encoded within the Data Matrix Code\n         * @throws FormatException if the exact number of bytes expected is not read\n         */\n        readCodewords() {\n            const result = new Int8Array(this.version.getTotalCodewords());\n            let resultOffset = 0;\n            let row = 4;\n            let column = 0;\n            const numRows = this.mappingBitMatrix.getHeight();\n            const numColumns = this.mappingBitMatrix.getWidth();\n            let corner1Read = false;\n            let corner2Read = false;\n            let corner3Read = false;\n            let corner4Read = false;\n            // Read all of the codewords\n            do {\n                // Check the four corner cases\n                if ((row === numRows) && (column === 0) && !corner1Read) {\n                    result[resultOffset++] = this.readCorner1(numRows, numColumns) & 0xff;\n                    row -= 2;\n                    column += 2;\n                    corner1Read = true;\n                }\n                else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x03) !== 0) && !corner2Read) {\n                    result[resultOffset++] = this.readCorner2(numRows, numColumns) & 0xff;\n                    row -= 2;\n                    column += 2;\n                    corner2Read = true;\n                }\n                else if ((row === numRows + 4) && (column === 2) && ((numColumns & 0x07) === 0) && !corner3Read) {\n                    result[resultOffset++] = this.readCorner3(numRows, numColumns) & 0xff;\n                    row -= 2;\n                    column += 2;\n                    corner3Read = true;\n                }\n                else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x07) === 4) && !corner4Read) {\n                    result[resultOffset++] = this.readCorner4(numRows, numColumns) & 0xff;\n                    row -= 2;\n                    column += 2;\n                    corner4Read = true;\n                }\n                else {\n                    // Sweep upward diagonally to the right\n                    do {\n                        if ((row < numRows) && (column >= 0) && !this.readMappingMatrix.get(column, row)) {\n                            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n                        }\n                        row -= 2;\n                        column += 2;\n                    } while ((row >= 0) && (column < numColumns));\n                    row += 1;\n                    column += 3;\n                    // Sweep downward diagonally to the left\n                    do {\n                        if ((row >= 0) && (column < numColumns) && !this.readMappingMatrix.get(column, row)) {\n                            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n                        }\n                        row += 2;\n                        column -= 2;\n                    } while ((row < numRows) && (column >= 0));\n                    row += 3;\n                    column += 1;\n                }\n            } while ((row < numRows) || (column < numColumns));\n            if (resultOffset !== this.version.getTotalCodewords()) {\n                throw new FormatException();\n            }\n            return result;\n        }\n        /**\n         * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>\n         *\n         * @param row Row to read in the mapping matrix\n         * @param column Column to read in the mapping matrix\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return value of the given bit in the mapping matrix\n         */\n        readModule(row, column, numRows, numColumns) {\n            // Adjust the row and column indices based on boundary wrapping\n            if (row < 0) {\n                row += numRows;\n                column += 4 - ((numRows + 4) & 0x07);\n            }\n            if (column < 0) {\n                column += numColumns;\n                row += 4 - ((numColumns + 4) & 0x07);\n            }\n            this.readMappingMatrix.set(column, row);\n            return this.mappingBitMatrix.get(column, row);\n        }\n        /**\n         * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>\n         *\n         * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>\n         *\n         * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\n         * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return byte from the utah shape\n         */\n        readUtah(row, column, numRows, numColumns) {\n            let currentByte = 0;\n            if (this.readModule(row - 2, column - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row - 2, column - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row - 1, column - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row - 1, column - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row - 1, column, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row, column - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row, column - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row, column, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            return currentByte;\n        }\n        /**\n         * <p>Reads the 8 bits of the special corner condition 1.</p>\n         *\n         * <p>See ISO 16022:2006, Figure F.3</p>\n         *\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return byte from the Corner condition 1\n         */\n        readCorner1(numRows, numColumns) {\n            let currentByte = 0;\n            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 1, 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 1, 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            return currentByte;\n        }\n        /**\n         * <p>Reads the 8 bits of the special corner condition 2.</p>\n         *\n         * <p>See ISO 16022:2006, Figure F.4</p>\n         *\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return byte from the Corner condition 2\n         */\n        readCorner2(numRows, numColumns) {\n            let currentByte = 0;\n            if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 4, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            return currentByte;\n        }\n        /**\n         * <p>Reads the 8 bits of the special corner condition 3.</p>\n         *\n         * <p>See ISO 16022:2006, Figure F.5</p>\n         *\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return byte from the Corner condition 3\n         */\n        readCorner3(numRows, numColumns) {\n            let currentByte = 0;\n            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 3, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            return currentByte;\n        }\n        /**\n         * <p>Reads the 8 bits of the special corner condition 4.</p>\n         *\n         * <p>See ISO 16022:2006, Figure F.6</p>\n         *\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return byte from the Corner condition 4\n         */\n        readCorner4(numRows, numColumns) {\n            let currentByte = 0;\n            if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            return currentByte;\n        }\n        /**\n         * <p>Extracts the data region from a {@link BitMatrix} that contains\n         * alignment patterns.</p>\n         *\n         * @param bitMatrix Original {@link BitMatrix} with alignment patterns\n         * @return BitMatrix that has the alignment patterns removed\n         */\n        extractDataRegion(bitMatrix) {\n            const symbolSizeRows = this.version.getSymbolSizeRows();\n            const symbolSizeColumns = this.version.getSymbolSizeColumns();\n            if (bitMatrix.getHeight() !== symbolSizeRows) {\n                throw new IllegalArgumentException('Dimension of bitMatrix must match the version size');\n            }\n            const dataRegionSizeRows = this.version.getDataRegionSizeRows();\n            const dataRegionSizeColumns = this.version.getDataRegionSizeColumns();\n            const numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;\n            const numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;\n            const sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;\n            const sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;\n            const bitMatrixWithoutAlignment = new BitMatrix(sizeDataRegionColumn, sizeDataRegionRow);\n            for (let dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {\n                const dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;\n                for (let dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {\n                    const dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;\n                    for (let i = 0; i < dataRegionSizeRows; ++i) {\n                        const readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;\n                        const writeRowOffset = dataRegionRowOffset + i;\n                        for (let j = 0; j < dataRegionSizeColumns; ++j) {\n                            const readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;\n                            if (bitMatrix.get(readColumnOffset, readRowOffset)) {\n                                const writeColumnOffset = dataRegionColumnOffset + j;\n                                bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);\n                            }\n                        }\n                    }\n                }\n            }\n            return bitMatrixWithoutAlignment;\n        }\n    }\n\n    /**\n     * <p>Encapsulates a block of data within a Data Matrix Code. Data Matrix Codes may split their data into\n     * multiple blocks, each of which is a unit of data and error-correction codewords. Each\n     * is represented by an instance of this class.</p>\n     *\n     * @author bbrown@google.com (Brian Brown)\n     */\n    class DataBlock {\n        constructor(numDataCodewords, codewords) {\n            this.numDataCodewords = numDataCodewords;\n            this.codewords = codewords;\n        }\n        /**\n         * <p>When Data Matrix Codes use multiple data blocks, they actually interleave the bytes of each of them.\n         * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This\n         * method will separate the data into original blocks.</p>\n         *\n         * @param rawCodewords bytes as read directly from the Data Matrix Code\n         * @param version version of the Data Matrix Code\n         * @return DataBlocks containing original bytes, \"de-interleaved\" from representation in the\n         *         Data Matrix Code\n         */\n        static getDataBlocks(rawCodewords, version) {\n            // Figure out the number and size of data blocks used by this version\n            const ecBlocks = version.getECBlocks();\n            // First count the total number of data blocks\n            let totalBlocks = 0;\n            const ecBlockArray = ecBlocks.getECBlocks();\n            for (let ecBlock of ecBlockArray) {\n                totalBlocks += ecBlock.getCount();\n            }\n            // Now establish DataBlocks of the appropriate size and number of data codewords\n            const result = new Array(totalBlocks);\n            let numResultBlocks = 0;\n            for (let ecBlock of ecBlockArray) {\n                for (let i = 0; i < ecBlock.getCount(); i++) {\n                    const numDataCodewords = ecBlock.getDataCodewords();\n                    const numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;\n                    result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));\n                }\n            }\n            // All blocks have the same amount of data, except that the last n\n            // (where n may be 0) have 1 less byte. Figure out where these start.\n            // TODO(bbrown): There is only one case where there is a difference for Data Matrix for size 144\n            const longerBlocksTotalCodewords = result[0].codewords.length;\n            // int shorterBlocksTotalCodewords = longerBlocksTotalCodewords - 1;\n            const longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();\n            const shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1;\n            // The last elements of result may be 1 element shorter for 144 matrix\n            // first fill out as many elements as all of them have minus 1\n            let rawCodewordsOffset = 0;\n            for (let i = 0; i < shorterBlocksNumDataCodewords; i++) {\n                for (let j = 0; j < numResultBlocks; j++) {\n                    result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];\n                }\n            }\n            // Fill out the last data block in the longer ones\n            const specialVersion = version.getVersionNumber() === 24;\n            const numLongerBlocks = specialVersion ? 8 : numResultBlocks;\n            for (let j = 0; j < numLongerBlocks; j++) {\n                result[j].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];\n            }\n            // Now add in error correction blocks\n            const max = result[0].codewords.length;\n            for (let i = longerBlocksNumDataCodewords; i < max; i++) {\n                for (let j = 0; j < numResultBlocks; j++) {\n                    const jOffset = specialVersion ? (j + 8) % numResultBlocks : j;\n                    const iOffset = specialVersion && jOffset > 7 ? i - 1 : i;\n                    result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];\n                }\n            }\n            if (rawCodewordsOffset !== rawCodewords.length) {\n                throw new IllegalArgumentException();\n            }\n            return result;\n        }\n        getNumDataCodewords() {\n            return this.numDataCodewords;\n        }\n        getCodewords() {\n            return this.codewords;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the\n     * number of bits read is not often a multiple of 8.</p>\n     *\n     * <p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array\n     * it passed in, in which case all bets are off.</p>\n     *\n     * @author Sean Owen\n     */\n    class BitSource {\n        /**\n         * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.\n         * Bits are read within a byte from most-significant to least-significant bit.\n         */\n        constructor(bytes) {\n            this.bytes = bytes;\n            this.byteOffset = 0;\n            this.bitOffset = 0;\n        }\n        /**\n         * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.\n         */\n        getBitOffset() {\n            return this.bitOffset;\n        }\n        /**\n         * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.\n         */\n        getByteOffset() {\n            return this.byteOffset;\n        }\n        /**\n         * @param numBits number of bits to read\n         * @return int representing the bits read. The bits will appear as the least-significant\n         *         bits of the int\n         * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available\n         */\n        readBits(numBits /*int*/) {\n            if (numBits < 1 || numBits > 32 || numBits > this.available()) {\n                throw new IllegalArgumentException('' + numBits);\n            }\n            let result = 0;\n            let bitOffset = this.bitOffset;\n            let byteOffset = this.byteOffset;\n            const bytes = this.bytes;\n            // First, read remainder from current byte\n            if (bitOffset > 0) {\n                const bitsLeft = 8 - bitOffset;\n                const toRead = numBits < bitsLeft ? numBits : bitsLeft;\n                const bitsToNotRead = bitsLeft - toRead;\n                const mask = (0xFF >> (8 - toRead)) << bitsToNotRead;\n                result = (bytes[byteOffset] & mask) >> bitsToNotRead;\n                numBits -= toRead;\n                bitOffset += toRead;\n                if (bitOffset === 8) {\n                    bitOffset = 0;\n                    byteOffset++;\n                }\n            }\n            // Next read whole bytes\n            if (numBits > 0) {\n                while (numBits >= 8) {\n                    result = (result << 8) | (bytes[byteOffset] & 0xFF);\n                    byteOffset++;\n                    numBits -= 8;\n                }\n                // Finally read a partial byte\n                if (numBits > 0) {\n                    const bitsToNotRead = 8 - numBits;\n                    const mask = (0xFF >> bitsToNotRead) << bitsToNotRead;\n                    result = (result << numBits) | ((bytes[byteOffset] & mask) >> bitsToNotRead);\n                    bitOffset += numBits;\n                }\n            }\n            this.bitOffset = bitOffset;\n            this.byteOffset = byteOffset;\n            return result;\n        }\n        /**\n         * @return number of bits that can be read successfully\n         */\n        available() {\n            return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;\n        }\n    }\n\n    var Mode;\n    (function (Mode) {\n        Mode[Mode[\"PAD_ENCODE\"] = 0] = \"PAD_ENCODE\";\n        Mode[Mode[\"ASCII_ENCODE\"] = 1] = \"ASCII_ENCODE\";\n        Mode[Mode[\"C40_ENCODE\"] = 2] = \"C40_ENCODE\";\n        Mode[Mode[\"TEXT_ENCODE\"] = 3] = \"TEXT_ENCODE\";\n        Mode[Mode[\"ANSIX12_ENCODE\"] = 4] = \"ANSIX12_ENCODE\";\n        Mode[Mode[\"EDIFACT_ENCODE\"] = 5] = \"EDIFACT_ENCODE\";\n        Mode[Mode[\"BASE256_ENCODE\"] = 6] = \"BASE256_ENCODE\";\n    })(Mode || (Mode = {}));\n    /**\n     * <p>Data Matrix Codes can encode text as bits in one of several modes, and can use multiple modes\n     * in one Data Matrix Code. This class decodes the bits back into text.</p>\n     *\n     * <p>See ISO 16022:2006, 5.2.1 - 5.2.9.2</p>\n     *\n     * @author bbrown@google.com (Brian Brown)\n     * @author Sean Owen\n     */\n    class DecodedBitStreamParser {\n        static decode(bytes) {\n            const bits = new BitSource(bytes);\n            const result = new StringBuilder();\n            const resultTrailer = new StringBuilder();\n            const byteSegments = new Array();\n            let mode = Mode.ASCII_ENCODE;\n            do {\n                if (mode === Mode.ASCII_ENCODE) {\n                    mode = this.decodeAsciiSegment(bits, result, resultTrailer);\n                }\n                else {\n                    switch (mode) {\n                        case Mode.C40_ENCODE:\n                            this.decodeC40Segment(bits, result);\n                            break;\n                        case Mode.TEXT_ENCODE:\n                            this.decodeTextSegment(bits, result);\n                            break;\n                        case Mode.ANSIX12_ENCODE:\n                            this.decodeAnsiX12Segment(bits, result);\n                            break;\n                        case Mode.EDIFACT_ENCODE:\n                            this.decodeEdifactSegment(bits, result);\n                            break;\n                        case Mode.BASE256_ENCODE:\n                            this.decodeBase256Segment(bits, result, byteSegments);\n                            break;\n                        default:\n                            throw new FormatException();\n                    }\n                    mode = Mode.ASCII_ENCODE;\n                }\n            } while (mode !== Mode.PAD_ENCODE && bits.available() > 0);\n            if (resultTrailer.length() > 0) {\n                result.append(resultTrailer.toString());\n            }\n            return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, null);\n        }\n        /**\n         * See ISO 16022:2006, 5.2.3 and Annex C, Table C.2\n         */\n        static decodeAsciiSegment(bits, result, resultTrailer) {\n            let upperShift = false;\n            do {\n                let oneByte = bits.readBits(8);\n                if (oneByte === 0) {\n                    throw new FormatException();\n                }\n                else if (oneByte <= 128) { // ASCII data (ASCII value + 1)\n                    if (upperShift) {\n                        oneByte += 128;\n                        // upperShift = false;\n                    }\n                    result.append(String.fromCharCode(oneByte - 1));\n                    return Mode.ASCII_ENCODE;\n                }\n                else if (oneByte === 129) { // Pad\n                    return Mode.PAD_ENCODE;\n                }\n                else if (oneByte <= 229) { // 2-digit data 00-99 (Numeric Value + 130)\n                    const value = oneByte - 130;\n                    if (value < 10) { // pad with '0' for single digit values\n                        result.append('0');\n                    }\n                    result.append('' + value);\n                }\n                else {\n                    switch (oneByte) {\n                        case 230: // Latch to C40 encodation\n                            return Mode.C40_ENCODE;\n                        case 231: // Latch to Base 256 encodation\n                            return Mode.BASE256_ENCODE;\n                        case 232: // FNC1\n                            result.append(String.fromCharCode(29)); // translate as ASCII 29\n                            break;\n                        case 233: // Structured Append\n                        case 234: // Reader Programming\n                            // Ignore these symbols for now\n                            // throw ReaderException.getInstance();\n                            break;\n                        case 235: // Upper Shift (shift to Extended ASCII)\n                            upperShift = true;\n                            break;\n                        case 236: // 05 Macro\n                            result.append('[)>\\u001E05\\u001D');\n                            resultTrailer.insert(0, '\\u001E\\u0004');\n                            break;\n                        case 237: // 06 Macro\n                            result.append('[)>\\u001E06\\u001D');\n                            resultTrailer.insert(0, '\\u001E\\u0004');\n                            break;\n                        case 238: // Latch to ANSI X12 encodation\n                            return Mode.ANSIX12_ENCODE;\n                        case 239: // Latch to Text encodation\n                            return Mode.TEXT_ENCODE;\n                        case 240: // Latch to EDIFACT encodation\n                            return Mode.EDIFACT_ENCODE;\n                        case 241: // ECI Character\n                            // TODO(bbrown): I think we need to support ECI\n                            // throw ReaderException.getInstance();\n                            // Ignore this symbol for now\n                            break;\n                        default:\n                            // Not to be used in ASCII encodation\n                            // but work around encoders that end with 254, latch back to ASCII\n                            if (oneByte !== 254 || bits.available() !== 0) {\n                                throw new FormatException();\n                            }\n                            break;\n                    }\n                }\n            } while (bits.available() > 0);\n            return Mode.ASCII_ENCODE;\n        }\n        /**\n         * See ISO 16022:2006, 5.2.5 and Annex C, Table C.1\n         */\n        static decodeC40Segment(bits, result) {\n            // Three C40 values are encoded in a 16-bit value as\n            // (1600 * C1) + (40 * C2) + C3 + 1\n            // TODO(bbrown): The Upper Shift with C40 doesn't work in the 4 value scenario all the time\n            let upperShift = false;\n            const cValues = [];\n            let shift = 0;\n            do {\n                // If there is only one byte left then it will be encoded as ASCII\n                if (bits.available() === 8) {\n                    return;\n                }\n                const firstByte = bits.readBits(8);\n                if (firstByte === 254) { // Unlatch codeword\n                    return;\n                }\n                this.parseTwoBytes(firstByte, bits.readBits(8), cValues);\n                for (let i = 0; i < 3; i++) {\n                    const cValue = cValues[i];\n                    switch (shift) {\n                        case 0:\n                            if (cValue < 3) {\n                                shift = cValue + 1;\n                            }\n                            else if (cValue < this.C40_BASIC_SET_CHARS.length) {\n                                const c40char = this.C40_BASIC_SET_CHARS[cValue];\n                                if (upperShift) {\n                                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));\n                                    upperShift = false;\n                                }\n                                else {\n                                    result.append(c40char);\n                                }\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                        case 1:\n                            if (upperShift) {\n                                result.append(String.fromCharCode(cValue + 128));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(String.fromCharCode(cValue));\n                            }\n                            shift = 0;\n                            break;\n                        case 2:\n                            if (cValue < this.C40_SHIFT2_SET_CHARS.length) {\n                                const c40char = this.C40_SHIFT2_SET_CHARS[cValue];\n                                if (upperShift) {\n                                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));\n                                    upperShift = false;\n                                }\n                                else {\n                                    result.append(c40char);\n                                }\n                            }\n                            else {\n                                switch (cValue) {\n                                    case 27: // FNC1\n                                        result.append(String.fromCharCode(29)); // translate as ASCII 29\n                                        break;\n                                    case 30: // Upper Shift\n                                        upperShift = true;\n                                        break;\n                                    default:\n                                        throw new FormatException();\n                                }\n                            }\n                            shift = 0;\n                            break;\n                        case 3:\n                            if (upperShift) {\n                                result.append(String.fromCharCode(cValue + 224));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(String.fromCharCode(cValue + 96));\n                            }\n                            shift = 0;\n                            break;\n                        default:\n                            throw new FormatException();\n                    }\n                }\n            } while (bits.available() > 0);\n        }\n        /**\n         * See ISO 16022:2006, 5.2.6 and Annex C, Table C.2\n         */\n        static decodeTextSegment(bits, result) {\n            // Three Text values are encoded in a 16-bit value as\n            // (1600 * C1) + (40 * C2) + C3 + 1\n            // TODO(bbrown): The Upper Shift with Text doesn't work in the 4 value scenario all the time\n            let upperShift = false;\n            let cValues = [];\n            let shift = 0;\n            do {\n                // If there is only one byte left then it will be encoded as ASCII\n                if (bits.available() === 8) {\n                    return;\n                }\n                const firstByte = bits.readBits(8);\n                if (firstByte === 254) { // Unlatch codeword\n                    return;\n                }\n                this.parseTwoBytes(firstByte, bits.readBits(8), cValues);\n                for (let i = 0; i < 3; i++) {\n                    const cValue = cValues[i];\n                    switch (shift) {\n                        case 0:\n                            if (cValue < 3) {\n                                shift = cValue + 1;\n                            }\n                            else if (cValue < this.TEXT_BASIC_SET_CHARS.length) {\n                                const textChar = this.TEXT_BASIC_SET_CHARS[cValue];\n                                if (upperShift) {\n                                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));\n                                    upperShift = false;\n                                }\n                                else {\n                                    result.append(textChar);\n                                }\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                        case 1:\n                            if (upperShift) {\n                                result.append(String.fromCharCode(cValue + 128));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(String.fromCharCode(cValue));\n                            }\n                            shift = 0;\n                            break;\n                        case 2:\n                            // Shift 2 for Text is the same encoding as C40\n                            if (cValue < this.TEXT_SHIFT2_SET_CHARS.length) {\n                                const textChar = this.TEXT_SHIFT2_SET_CHARS[cValue];\n                                if (upperShift) {\n                                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));\n                                    upperShift = false;\n                                }\n                                else {\n                                    result.append(textChar);\n                                }\n                            }\n                            else {\n                                switch (cValue) {\n                                    case 27: // FNC1\n                                        result.append(String.fromCharCode(29)); // translate as ASCII 29\n                                        break;\n                                    case 30: // Upper Shift\n                                        upperShift = true;\n                                        break;\n                                    default:\n                                        throw new FormatException();\n                                }\n                            }\n                            shift = 0;\n                            break;\n                        case 3:\n                            if (cValue < this.TEXT_SHIFT3_SET_CHARS.length) {\n                                const textChar = this.TEXT_SHIFT3_SET_CHARS[cValue];\n                                if (upperShift) {\n                                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));\n                                    upperShift = false;\n                                }\n                                else {\n                                    result.append(textChar);\n                                }\n                                shift = 0;\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                        default:\n                            throw new FormatException();\n                    }\n                }\n            } while (bits.available() > 0);\n        }\n        /**\n         * See ISO 16022:2006, 5.2.7\n         */\n        static decodeAnsiX12Segment(bits, result) {\n            // Three ANSI X12 values are encoded in a 16-bit value as\n            // (1600 * C1) + (40 * C2) + C3 + 1\n            const cValues = [];\n            do {\n                // If there is only one byte left then it will be encoded as ASCII\n                if (bits.available() === 8) {\n                    return;\n                }\n                const firstByte = bits.readBits(8);\n                if (firstByte === 254) { // Unlatch codeword\n                    return;\n                }\n                this.parseTwoBytes(firstByte, bits.readBits(8), cValues);\n                for (let i = 0; i < 3; i++) {\n                    const cValue = cValues[i];\n                    switch (cValue) {\n                        case 0: // X12 segment terminator <CR>\n                            result.append('\\r');\n                            break;\n                        case 1: // X12 segment separator *\n                            result.append('*');\n                            break;\n                        case 2: // X12 sub-element separator >\n                            result.append('>');\n                            break;\n                        case 3: // space\n                            result.append(' ');\n                            break;\n                        default:\n                            if (cValue < 14) { // 0 - 9\n                                result.append(String.fromCharCode(cValue + 44));\n                            }\n                            else if (cValue < 40) { // A - Z\n                                result.append(String.fromCharCode(cValue + 51));\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                    }\n                }\n            } while (bits.available() > 0);\n        }\n        static parseTwoBytes(firstByte, secondByte, result) {\n            let fullBitValue = (firstByte << 8) + secondByte - 1;\n            let temp = Math.floor(fullBitValue / 1600);\n            result[0] = temp;\n            fullBitValue -= temp * 1600;\n            temp = Math.floor(fullBitValue / 40);\n            result[1] = temp;\n            result[2] = fullBitValue - temp * 40;\n        }\n        /**\n         * See ISO 16022:2006, 5.2.8 and Annex C Table C.3\n         */\n        static decodeEdifactSegment(bits, result) {\n            do {\n                // If there is only two or less bytes left then it will be encoded as ASCII\n                if (bits.available() <= 16) {\n                    return;\n                }\n                for (let i = 0; i < 4; i++) {\n                    let edifactValue = bits.readBits(6);\n                    // Check for the unlatch character\n                    if (edifactValue === 0x1F) { // 011111\n                        // Read rest of byte, which should be 0, and stop\n                        const bitsLeft = 8 - bits.getBitOffset();\n                        if (bitsLeft !== 8) {\n                            bits.readBits(bitsLeft);\n                        }\n                        return;\n                    }\n                    if ((edifactValue & 0x20) === 0) { // no 1 in the leading (6th) bit\n                        edifactValue |= 0x40; // Add a leading 01 to the 6 bit binary value\n                    }\n                    result.append(String.fromCharCode(edifactValue));\n                }\n            } while (bits.available() > 0);\n        }\n        /**\n         * See ISO 16022:2006, 5.2.9 and Annex B, B.2\n         */\n        static decodeBase256Segment(bits, result, byteSegments) {\n            // Figure out how long the Base 256 Segment is.\n            let codewordPosition = 1 + bits.getByteOffset(); // position is 1-indexed\n            const d1 = this.unrandomize255State(bits.readBits(8), codewordPosition++);\n            let count;\n            if (d1 === 0) { // Read the remainder of the symbol\n                count = bits.available() / 8 | 0;\n            }\n            else if (d1 < 250) {\n                count = d1;\n            }\n            else {\n                count = 250 * (d1 - 249) + this.unrandomize255State(bits.readBits(8), codewordPosition++);\n            }\n            // We're seeing NegativeArraySizeException errors from users.\n            if (count < 0) {\n                throw new FormatException();\n            }\n            const bytes = new Uint8Array(count);\n            for (let i = 0; i < count; i++) {\n                // Have seen this particular error in the wild, such as at\n                // http://www.bcgen.com/demo/IDAutomationStreamingDataMatrix.aspx?MODE=3&D=Fred&PFMT=3&PT=F&X=0.3&O=0&LM=0.2\n                if (bits.available() < 8) {\n                    throw new FormatException();\n                }\n                bytes[i] = this.unrandomize255State(bits.readBits(8), codewordPosition++);\n            }\n            byteSegments.push(bytes);\n            try {\n                result.append(StringEncoding.decode(bytes, StringUtils.ISO88591));\n            }\n            catch (uee) {\n                throw new IllegalStateException('Platform does not support required encoding: ' + uee.message);\n            }\n        }\n        /**\n         * See ISO 16022:2006, Annex B, B.2\n         */\n        static unrandomize255State(randomizedBase256Codeword, base256CodewordPosition) {\n            const pseudoRandomNumber = ((149 * base256CodewordPosition) % 255) + 1;\n            const tempVariable = randomizedBase256Codeword - pseudoRandomNumber;\n            return tempVariable >= 0 ? tempVariable : tempVariable + 256;\n        }\n    }\n    /**\n     * See ISO 16022:2006, Annex C Table C.1\n     * The C40 Basic Character Set (*'s used for placeholders for the shift values)\n     */\n    DecodedBitStreamParser.C40_BASIC_SET_CHARS = [\n        '*', '*', '*', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\n    ];\n    DecodedBitStreamParser.C40_SHIFT2_SET_CHARS = [\n        '!', '\"', '#', '$', '%', '&', '\\'', '(', ')', '*', '+', ',', '-', '.',\n        '/', ':', ';', '<', '=', '>', '?', '@', '[', '\\\\', ']', '^', '_'\n    ];\n    /**\n     * See ISO 16022:2006, Annex C Table C.2\n     * The Text Basic Character Set (*'s used for placeholders for the shift values)\n     */\n    DecodedBitStreamParser.TEXT_BASIC_SET_CHARS = [\n        '*', '*', '*', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n    ];\n    // Shift 2 for Text is the same encoding as C40\n    DecodedBitStreamParser.TEXT_SHIFT2_SET_CHARS = DecodedBitStreamParser.C40_SHIFT2_SET_CHARS;\n    DecodedBitStreamParser.TEXT_SHIFT3_SET_CHARS = [\n        '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~', String.fromCharCode(127)\n    ];\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>The main class which implements Data Matrix Code decoding -- as opposed to locating and extracting\n     * the Data Matrix Code from an image.</p>\n     *\n     * @author bbrown@google.com (Brian Brown)\n     */\n    class Decoder$1 {\n        constructor() {\n            this.rsDecoder = new ReedSolomonDecoder(GenericGF.DATA_MATRIX_FIELD_256);\n        }\n        /**\n         * <p>Decodes a Data Matrix Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken\n         * to mean a black module.</p>\n         *\n         * @param bits booleans representing white/black Data Matrix Code modules\n         * @return text and bytes encoded within the Data Matrix Code\n         * @throws FormatException if the Data Matrix Code cannot be decoded\n         * @throws ChecksumException if error correction fails\n         */\n        decode(bits) {\n            // Construct a parser and read version, error-correction level\n            const parser = new BitMatrixParser(bits);\n            const version = parser.getVersion();\n            // Read codewords\n            const codewords = parser.readCodewords();\n            // Separate into data blocks\n            const dataBlocks = DataBlock.getDataBlocks(codewords, version);\n            // Count total number of data bytes\n            let totalBytes = 0;\n            for (let db of dataBlocks) {\n                totalBytes += db.getNumDataCodewords();\n            }\n            const resultBytes = new Uint8Array(totalBytes);\n            const dataBlocksCount = dataBlocks.length;\n            // Error-correct and copy data blocks together into a stream of bytes\n            for (let j = 0; j < dataBlocksCount; j++) {\n                const dataBlock = dataBlocks[j];\n                const codewordBytes = dataBlock.getCodewords();\n                const numDataCodewords = dataBlock.getNumDataCodewords();\n                this.correctErrors(codewordBytes, numDataCodewords);\n                for (let i = 0; i < numDataCodewords; i++) {\n                    // De-interlace data blocks.\n                    resultBytes[i * dataBlocksCount + j] = codewordBytes[i];\n                }\n            }\n            // Decode the contents of that stream of bytes\n            return DecodedBitStreamParser.decode(resultBytes);\n        }\n        /**\n         * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n         * correct the errors in-place using Reed-Solomon error correction.</p>\n         *\n         * @param codewordBytes data and error correction codewords\n         * @param numDataCodewords number of codewords that are data bytes\n         * @throws ChecksumException if error correction fails\n         */\n        correctErrors(codewordBytes, numDataCodewords) {\n            // const numCodewords = codewordBytes.length;\n            // First read into an array of ints\n            const codewordsInts = new Int32Array(codewordBytes);\n            // for (let i = 0; i < numCodewords; i++) {\n            //   codewordsInts[i] = codewordBytes[i] & 0xFF;\n            // }\n            try {\n                this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n            }\n            catch (ignored /* ReedSolomonException */) {\n                throw new ChecksumException();\n            }\n            // Copy back into array of bytes -- only need to worry about the bytes that were data\n            // We don't care about errors in the error-correction codewords\n            for (let i = 0; i < numDataCodewords; i++) {\n                codewordBytes[i] = codewordsInts[i];\n            }\n        }\n    }\n\n    /**\n     * <p>Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code\n     * is rotated or skewed, or partially obscured.</p>\n     *\n     * @author Sean Owen\n     */\n    class Detector$1 {\n        constructor(image) {\n            this.image = image;\n            this.rectangleDetector = new WhiteRectangleDetector(this.image);\n        }\n        /**\n         * <p>Detects a Data Matrix Code in an image.</p>\n         *\n         * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code\n         * @throws NotFoundException if no Data Matrix Code can be found\n         */\n        detect() {\n            const cornerPoints = this.rectangleDetector.detect();\n            let points = this.detectSolid1(cornerPoints);\n            points = this.detectSolid2(points);\n            points[3] = this.correctTopRight(points);\n            if (!points[3]) {\n                throw new NotFoundException();\n            }\n            points = this.shiftToModuleCenter(points);\n            const topLeft = points[0];\n            const bottomLeft = points[1];\n            const bottomRight = points[2];\n            const topRight = points[3];\n            let dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;\n            let dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;\n            if ((dimensionTop & 0x01) === 1) {\n                dimensionTop += 1;\n            }\n            if ((dimensionRight & 0x01) === 1) {\n                dimensionRight += 1;\n            }\n            if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {\n                // The matrix is square\n                dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);\n            }\n            let bits = Detector$1.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);\n            return new DetectorResult(bits, [topLeft, bottomLeft, bottomRight, topRight]);\n        }\n        static shiftPoint(point, to, div) {\n            let x = (to.getX() - point.getX()) / (div + 1);\n            let y = (to.getY() - point.getY()) / (div + 1);\n            return new ResultPoint(point.getX() + x, point.getY() + y);\n        }\n        static moveAway(point, fromX, fromY) {\n            let x = point.getX();\n            let y = point.getY();\n            if (x < fromX) {\n                x -= 1;\n            }\n            else {\n                x += 1;\n            }\n            if (y < fromY) {\n                y -= 1;\n            }\n            else {\n                y += 1;\n            }\n            return new ResultPoint(x, y);\n        }\n        /**\n         * Detect a solid side which has minimum transition.\n         */\n        detectSolid1(cornerPoints) {\n            // 0  2\n            // 1  3\n            let pointA = cornerPoints[0];\n            let pointB = cornerPoints[1];\n            let pointC = cornerPoints[3];\n            let pointD = cornerPoints[2];\n            let trAB = this.transitionsBetween(pointA, pointB);\n            let trBC = this.transitionsBetween(pointB, pointC);\n            let trCD = this.transitionsBetween(pointC, pointD);\n            let trDA = this.transitionsBetween(pointD, pointA);\n            // 0..3\n            // :  :\n            // 1--2\n            let min = trAB;\n            let points = [pointD, pointA, pointB, pointC];\n            if (min > trBC) {\n                min = trBC;\n                points[0] = pointA;\n                points[1] = pointB;\n                points[2] = pointC;\n                points[3] = pointD;\n            }\n            if (min > trCD) {\n                min = trCD;\n                points[0] = pointB;\n                points[1] = pointC;\n                points[2] = pointD;\n                points[3] = pointA;\n            }\n            if (min > trDA) {\n                points[0] = pointC;\n                points[1] = pointD;\n                points[2] = pointA;\n                points[3] = pointB;\n            }\n            return points;\n        }\n        /**\n         * Detect a second solid side next to first solid side.\n         */\n        detectSolid2(points) {\n            // A..D\n            // :  :\n            // B--C\n            let pointA = points[0];\n            let pointB = points[1];\n            let pointC = points[2];\n            let pointD = points[3];\n            // Transition detection on the edge is not stable.\n            // To safely detect, shift the points to the module center.\n            let tr = this.transitionsBetween(pointA, pointD);\n            let pointBs = Detector$1.shiftPoint(pointB, pointC, (tr + 1) * 4);\n            let pointCs = Detector$1.shiftPoint(pointC, pointB, (tr + 1) * 4);\n            let trBA = this.transitionsBetween(pointBs, pointA);\n            let trCD = this.transitionsBetween(pointCs, pointD);\n            // 0..3\n            // |  :\n            // 1--2\n            if (trBA < trCD) {\n                // solid sides: A-B-C\n                points[0] = pointA;\n                points[1] = pointB;\n                points[2] = pointC;\n                points[3] = pointD;\n            }\n            else {\n                // solid sides: B-C-D\n                points[0] = pointB;\n                points[1] = pointC;\n                points[2] = pointD;\n                points[3] = pointA;\n            }\n            return points;\n        }\n        /**\n         * Calculates the corner position of the white top right module.\n         */\n        correctTopRight(points) {\n            // A..D\n            // |  :\n            // B--C\n            let pointA = points[0];\n            let pointB = points[1];\n            let pointC = points[2];\n            let pointD = points[3];\n            // shift points for safe transition detection.\n            let trTop = this.transitionsBetween(pointA, pointD);\n            let trRight = this.transitionsBetween(pointB, pointD);\n            let pointAs = Detector$1.shiftPoint(pointA, pointB, (trRight + 1) * 4);\n            let pointCs = Detector$1.shiftPoint(pointC, pointB, (trTop + 1) * 4);\n            trTop = this.transitionsBetween(pointAs, pointD);\n            trRight = this.transitionsBetween(pointCs, pointD);\n            let candidate1 = new ResultPoint(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));\n            let candidate2 = new ResultPoint(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));\n            if (!this.isValid(candidate1)) {\n                if (this.isValid(candidate2)) {\n                    return candidate2;\n                }\n                return null;\n            }\n            if (!this.isValid(candidate2)) {\n                return candidate1;\n            }\n            let sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);\n            let sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);\n            if (sumc1 > sumc2) {\n                return candidate1;\n            }\n            else {\n                return candidate2;\n            }\n        }\n        /**\n         * Shift the edge points to the module center.\n         */\n        shiftToModuleCenter(points) {\n            // A..D\n            // |  :\n            // B--C\n            let pointA = points[0];\n            let pointB = points[1];\n            let pointC = points[2];\n            let pointD = points[3];\n            // calculate pseudo dimensions\n            let dimH = this.transitionsBetween(pointA, pointD) + 1;\n            let dimV = this.transitionsBetween(pointC, pointD) + 1;\n            // shift points for safe dimension detection\n            let pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);\n            let pointCs = Detector$1.shiftPoint(pointC, pointB, dimH * 4);\n            //  calculate more precise dimensions\n            dimH = this.transitionsBetween(pointAs, pointD) + 1;\n            dimV = this.transitionsBetween(pointCs, pointD) + 1;\n            if ((dimH & 0x01) === 1) {\n                dimH += 1;\n            }\n            if ((dimV & 0x01) === 1) {\n                dimV += 1;\n            }\n            // WhiteRectangleDetector returns points inside of the rectangle.\n            // I want points on the edges.\n            let centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;\n            let centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;\n            pointA = Detector$1.moveAway(pointA, centerX, centerY);\n            pointB = Detector$1.moveAway(pointB, centerX, centerY);\n            pointC = Detector$1.moveAway(pointC, centerX, centerY);\n            pointD = Detector$1.moveAway(pointD, centerX, centerY);\n            let pointBs;\n            let pointDs;\n            // shift points to the center of each modules\n            pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);\n            pointAs = Detector$1.shiftPoint(pointAs, pointD, dimH * 4);\n            pointBs = Detector$1.shiftPoint(pointB, pointA, dimV * 4);\n            pointBs = Detector$1.shiftPoint(pointBs, pointC, dimH * 4);\n            pointCs = Detector$1.shiftPoint(pointC, pointD, dimV * 4);\n            pointCs = Detector$1.shiftPoint(pointCs, pointB, dimH * 4);\n            pointDs = Detector$1.shiftPoint(pointD, pointC, dimV * 4);\n            pointDs = Detector$1.shiftPoint(pointDs, pointA, dimH * 4);\n            return [pointAs, pointBs, pointCs, pointDs];\n        }\n        isValid(p) {\n            return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();\n        }\n        static sampleGrid(image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {\n            const sampler = GridSamplerInstance.getInstance();\n            return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n        }\n        /**\n         * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.\n         */\n        transitionsBetween(from, to) {\n            // See QR Code Detector, sizeOfBlackWhiteBlackRun()\n            let fromX = Math.trunc(from.getX());\n            let fromY = Math.trunc(from.getY());\n            let toX = Math.trunc(to.getX());\n            let toY = Math.trunc(to.getY());\n            let steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n            if (steep) {\n                let temp = fromX;\n                fromX = fromY;\n                fromY = temp;\n                temp = toX;\n                toX = toY;\n                toY = temp;\n            }\n            let dx = Math.abs(toX - fromX);\n            let dy = Math.abs(toY - fromY);\n            let error = -dx / 2;\n            let ystep = fromY < toY ? 1 : -1;\n            let xstep = fromX < toX ? 1 : -1;\n            let transitions = 0;\n            let inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);\n            for (let x = fromX, y = fromY; x !== toX; x += xstep) {\n                let isBlack = this.image.get(steep ? y : x, steep ? x : y);\n                if (isBlack !== inBlack) {\n                    transitions++;\n                    inBlack = isBlack;\n                }\n                error += dy;\n                if (error > 0) {\n                    if (y === toY) {\n                        break;\n                    }\n                    y += ystep;\n                    error -= dx;\n                }\n            }\n            return transitions;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * This implementation can detect and decode Data Matrix codes in an image.\n     *\n     * @author bbrown@google.com (Brian Brown)\n     */\n    class DataMatrixReader {\n        constructor() {\n            this.decoder = new Decoder$1();\n        }\n        /**\n         * Locates and decodes a Data Matrix code in an image.\n         *\n         * @return a String representing the content encoded by the Data Matrix code\n         * @throws NotFoundException if a Data Matrix code cannot be found\n         * @throws FormatException if a Data Matrix code cannot be decoded\n         * @throws ChecksumException if error correction fails\n         */\n        // @Override\n        // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n        //   return decode(image, null);\n        // }\n        // @Override\n        decode(image, hints = null) {\n            let decoderResult;\n            let points;\n            if (hints != null && hints.has(DecodeHintType$1.PURE_BARCODE)) {\n                const bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());\n                decoderResult = this.decoder.decode(bits);\n                points = DataMatrixReader.NO_POINTS;\n            }\n            else {\n                const detectorResult = new Detector$1(image.getBlackMatrix()).detect();\n                decoderResult = this.decoder.decode(detectorResult.getBits());\n                points = detectorResult.getPoints();\n            }\n            const rawBytes = decoderResult.getRawBytes();\n            const result = new Result(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat$1.DATA_MATRIX, System.currentTimeMillis());\n            const byteSegments = decoderResult.getByteSegments();\n            if (byteSegments != null) {\n                result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);\n            }\n            const ecLevel = decoderResult.getECLevel();\n            if (ecLevel != null) {\n                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);\n            }\n            return result;\n        }\n        // @Override\n        reset() {\n            // do nothing\n        }\n        /**\n         * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n         * which contains only an unrotated, unskewed, image of a code, with some white border\n         * around it. This is a specialized method that works exceptionally fast in this special\n         * case.\n         *\n         * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)\n         */\n        static extractPureBits(image) {\n            const leftTopBlack = image.getTopLeftOnBit();\n            const rightBottomBlack = image.getBottomRightOnBit();\n            if (leftTopBlack == null || rightBottomBlack == null) {\n                throw new NotFoundException();\n            }\n            const moduleSize = this.moduleSize(leftTopBlack, image);\n            let top = leftTopBlack[1];\n            const bottom = rightBottomBlack[1];\n            let left = leftTopBlack[0];\n            const right = rightBottomBlack[0];\n            const matrixWidth = (right - left + 1) / moduleSize;\n            const matrixHeight = (bottom - top + 1) / moduleSize;\n            if (matrixWidth <= 0 || matrixHeight <= 0) {\n                throw new NotFoundException();\n            }\n            // Push in the \"border\" by half the module width so that we start\n            // sampling in the middle of the module. Just in case the image is a\n            // little off, this will help recover.\n            const nudge = moduleSize / 2;\n            top += nudge;\n            left += nudge;\n            // Now just read off the bits\n            const bits = new BitMatrix(matrixWidth, matrixHeight);\n            for (let y = 0; y < matrixHeight; y++) {\n                const iOffset = top + y * moduleSize;\n                for (let x = 0; x < matrixWidth; x++) {\n                    if (image.get(left + x * moduleSize, iOffset)) {\n                        bits.set(x, y);\n                    }\n                }\n            }\n            return bits;\n        }\n        static moduleSize(leftTopBlack, image) {\n            const width = image.getWidth();\n            let x = leftTopBlack[0];\n            const y = leftTopBlack[1];\n            while (x < width && image.get(x, y)) {\n                x++;\n            }\n            if (x === width) {\n                throw new NotFoundException();\n            }\n            const moduleSize = x - leftTopBlack[0];\n            if (moduleSize === 0) {\n                throw new NotFoundException();\n            }\n            return moduleSize;\n        }\n    }\n    DataMatrixReader.NO_POINTS = [];\n\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * QR Code reader to use from browser.\n     */\n    class BrowserDatamatrixCodeReader extends BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserQRCodeReader.\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n         */\n        constructor(timeBetweenScansMillis = 500) {\n            super(new DataMatrixReader(), timeBetweenScansMillis);\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var ErrorCorrectionLevelValues;\n    (function (ErrorCorrectionLevelValues) {\n        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"L\"] = 0] = \"L\";\n        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"M\"] = 1] = \"M\";\n        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"Q\"] = 2] = \"Q\";\n        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"H\"] = 3] = \"H\";\n    })(ErrorCorrectionLevelValues || (ErrorCorrectionLevelValues = {}));\n    /**\n     * <p>See ISO 18004:2006, 6.5.1. This enum encapsulates the four error correction levels\n     * defined by the QR code standard.</p>\n     *\n     * @author Sean Owen\n     */\n    class ErrorCorrectionLevel {\n        constructor(value, stringValue, bits /*int*/) {\n            this.value = value;\n            this.stringValue = stringValue;\n            this.bits = bits;\n            ErrorCorrectionLevel.FOR_BITS.set(bits, this);\n            ErrorCorrectionLevel.FOR_VALUE.set(value, this);\n        }\n        getValue() {\n            return this.value;\n        }\n        getBits() {\n            return this.bits;\n        }\n        static fromString(s) {\n            switch (s) {\n                case 'L': return ErrorCorrectionLevel.L;\n                case 'M': return ErrorCorrectionLevel.M;\n                case 'Q': return ErrorCorrectionLevel.Q;\n                case 'H': return ErrorCorrectionLevel.H;\n                default: throw new ArgumentException(s + 'not available');\n            }\n        }\n        toString() {\n            return this.stringValue;\n        }\n        equals(o) {\n            if (!(o instanceof ErrorCorrectionLevel)) {\n                return false;\n            }\n            const other = o;\n            return this.value === other.value;\n        }\n        /**\n         * @param bits int containing the two bits encoding a QR Code's error correction level\n         * @return ErrorCorrectionLevel representing the encoded error correction level\n         */\n        static forBits(bits /*int*/) {\n            if (bits < 0 || bits >= ErrorCorrectionLevel.FOR_BITS.size) {\n                throw new IllegalArgumentException();\n            }\n            return ErrorCorrectionLevel.FOR_BITS.get(bits);\n        }\n    }\n    ErrorCorrectionLevel.FOR_BITS = new Map();\n    ErrorCorrectionLevel.FOR_VALUE = new Map();\n    /** L = ~7% correction */\n    ErrorCorrectionLevel.L = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.L, 'L', 0x01);\n    /** M = ~15% correction */\n    ErrorCorrectionLevel.M = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.M, 'M', 0x00);\n    /** Q = ~25% correction */\n    ErrorCorrectionLevel.Q = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.Q, 'Q', 0x03);\n    /** H = ~30% correction */\n    ErrorCorrectionLevel.H = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.H, 'H', 0x02);\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates a QR Code's format information, including the data mask used and\n     * error correction level.</p>\n     *\n     * @author Sean Owen\n     * @see DataMask\n     * @see ErrorCorrectionLevel\n     */\n    class FormatInformation {\n        constructor(formatInfo /*int*/) {\n            // Bits 3,4\n            this.errorCorrectionLevel = ErrorCorrectionLevel.forBits((formatInfo >> 3) & 0x03);\n            // Bottom 3 bits\n            this.dataMask = /*(byte) */ (formatInfo & 0x07);\n        }\n        static numBitsDiffering(a /*int*/, b /*int*/) {\n            return Integer.bitCount(a ^ b);\n        }\n        /**\n         * @param maskedFormatInfo1 format info indicator, with mask still applied\n         * @param maskedFormatInfo2 second copy of same info; both are checked at the same time\n         *  to establish best match\n         * @return information about the format it specifies, or {@code null}\n         *  if doesn't seem to match any known pattern\n         */\n        static decodeFormatInformation(maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {\n            const formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);\n            if (formatInfo !== null) {\n                return formatInfo;\n            }\n            // Should return null, but, some QR codes apparently\n            // do not mask this info. Try again by actually masking the pattern\n            // first\n            return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);\n        }\n        static doDecodeFormatInformation(maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {\n            // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing\n            let bestDifference = Number.MAX_SAFE_INTEGER;\n            let bestFormatInfo = 0;\n            for (const decodeInfo of FormatInformation.FORMAT_INFO_DECODE_LOOKUP) {\n                const targetInfo = decodeInfo[0];\n                if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {\n                    // Found an exact match\n                    return new FormatInformation(decodeInfo[1]);\n                }\n                let bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);\n                if (bitsDifference < bestDifference) {\n                    bestFormatInfo = decodeInfo[1];\n                    bestDifference = bitsDifference;\n                }\n                if (maskedFormatInfo1 !== maskedFormatInfo2) {\n                    // also try the other option\n                    bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);\n                    if (bitsDifference < bestDifference) {\n                        bestFormatInfo = decodeInfo[1];\n                        bestDifference = bitsDifference;\n                    }\n                }\n            }\n            // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits\n            // differing means we found a match\n            if (bestDifference <= 3) {\n                return new FormatInformation(bestFormatInfo);\n            }\n            return null;\n        }\n        getErrorCorrectionLevel() {\n            return this.errorCorrectionLevel;\n        }\n        getDataMask() {\n            return this.dataMask;\n        }\n        /*@Override*/\n        hashCode() {\n            return (this.errorCorrectionLevel.getBits() << 3) | this.dataMask;\n        }\n        /*@Override*/\n        equals(o) {\n            if (!(o instanceof FormatInformation)) {\n                return false;\n            }\n            const other = o;\n            return this.errorCorrectionLevel === other.errorCorrectionLevel &&\n                this.dataMask === other.dataMask;\n        }\n    }\n    FormatInformation.FORMAT_INFO_MASK_QR = 0x5412;\n    /**\n     * See ISO 18004:2006, Annex C, Table C.1\n     */\n    FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [\n        Int32Array.from([0x5412, 0x00]),\n        Int32Array.from([0x5125, 0x01]),\n        Int32Array.from([0x5E7C, 0x02]),\n        Int32Array.from([0x5B4B, 0x03]),\n        Int32Array.from([0x45F9, 0x04]),\n        Int32Array.from([0x40CE, 0x05]),\n        Int32Array.from([0x4F97, 0x06]),\n        Int32Array.from([0x4AA0, 0x07]),\n        Int32Array.from([0x77C4, 0x08]),\n        Int32Array.from([0x72F3, 0x09]),\n        Int32Array.from([0x7DAA, 0x0A]),\n        Int32Array.from([0x789D, 0x0B]),\n        Int32Array.from([0x662F, 0x0C]),\n        Int32Array.from([0x6318, 0x0D]),\n        Int32Array.from([0x6C41, 0x0E]),\n        Int32Array.from([0x6976, 0x0F]),\n        Int32Array.from([0x1689, 0x10]),\n        Int32Array.from([0x13BE, 0x11]),\n        Int32Array.from([0x1CE7, 0x12]),\n        Int32Array.from([0x19D0, 0x13]),\n        Int32Array.from([0x0762, 0x14]),\n        Int32Array.from([0x0255, 0x15]),\n        Int32Array.from([0x0D0C, 0x16]),\n        Int32Array.from([0x083B, 0x17]),\n        Int32Array.from([0x355F, 0x18]),\n        Int32Array.from([0x3068, 0x19]),\n        Int32Array.from([0x3F31, 0x1A]),\n        Int32Array.from([0x3A06, 0x1B]),\n        Int32Array.from([0x24B4, 0x1C]),\n        Int32Array.from([0x2183, 0x1D]),\n        Int32Array.from([0x2EDA, 0x1E]),\n        Int32Array.from([0x2BED, 0x1F]),\n    ];\n\n    /**\n     * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will\n     * use blocks of differing sizes within one version, so, this encapsulates the parameters for\n     * each set of blocks. It also holds the number of error-correction codewords per block since it\n     * will be the same across all blocks within one version.</p>\n     */\n    class ECBlocks$1 {\n        constructor(ecCodewordsPerBlock /*int*/, ...ecBlocks) {\n            this.ecCodewordsPerBlock = ecCodewordsPerBlock;\n            this.ecBlocks = ecBlocks;\n        }\n        getECCodewordsPerBlock() {\n            return this.ecCodewordsPerBlock;\n        }\n        getNumBlocks() {\n            let total = 0;\n            const ecBlocks = this.ecBlocks;\n            for (const ecBlock of ecBlocks) {\n                total += ecBlock.getCount();\n            }\n            return total;\n        }\n        getTotalECCodewords() {\n            return this.ecCodewordsPerBlock * this.getNumBlocks();\n        }\n        getECBlocks() {\n            return this.ecBlocks;\n        }\n    }\n\n    /**\n     * <p>Encapsulates the parameters for one error-correction block in one symbol version.\n     * This includes the number of data codewords, and the number of times a block with these\n     * parameters is used consecutively in the QR code version's format.</p>\n     */\n    class ECB$1 {\n        constructor(count /*int*/, dataCodewords /*int*/) {\n            this.count = count;\n            this.dataCodewords = dataCodewords;\n        }\n        getCount() {\n            return this.count;\n        }\n        getDataCodewords() {\n            return this.dataCodewords;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * See ISO 18004:2006 Annex D\n     *\n     * @author Sean Owen\n     */\n    class Version$1 {\n        constructor(versionNumber /*int*/, alignmentPatternCenters, ...ecBlocks) {\n            this.versionNumber = versionNumber;\n            this.alignmentPatternCenters = alignmentPatternCenters;\n            this.ecBlocks = ecBlocks;\n            let total = 0;\n            const ecCodewords = ecBlocks[0].getECCodewordsPerBlock();\n            const ecbArray = ecBlocks[0].getECBlocks();\n            for (const ecBlock of ecbArray) {\n                total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);\n            }\n            this.totalCodewords = total;\n        }\n        getVersionNumber() {\n            return this.versionNumber;\n        }\n        getAlignmentPatternCenters() {\n            return this.alignmentPatternCenters;\n        }\n        getTotalCodewords() {\n            return this.totalCodewords;\n        }\n        getDimensionForVersion() {\n            return 17 + 4 * this.versionNumber;\n        }\n        getECBlocksForLevel(ecLevel) {\n            return this.ecBlocks[ecLevel.getValue()];\n            // TYPESCRIPTPORT: original was using ordinal, and using the order of levels as defined in ErrorCorrectionLevel enum (LMQH)\n            // I will use the direct value from ErrorCorrectionLevelValues enum which in typescript goes to a number\n        }\n        /**\n         * <p>Deduces version information purely from QR Code dimensions.</p>\n         *\n         * @param dimension dimension in modules\n         * @return Version for a QR Code of that dimension\n         * @throws FormatException if dimension is not 1 mod 4\n         */\n        static getProvisionalVersionForDimension(dimension /*int*/) {\n            if (dimension % 4 !== 1) {\n                throw new FormatException();\n            }\n            try {\n                return this.getVersionForNumber((dimension - 17) / 4);\n            }\n            catch (ignored /*: IllegalArgumentException*/) {\n                throw new FormatException();\n            }\n        }\n        static getVersionForNumber(versionNumber /*int*/) {\n            if (versionNumber < 1 || versionNumber > 40) {\n                throw new IllegalArgumentException();\n            }\n            return Version$1.VERSIONS[versionNumber - 1];\n        }\n        static decodeVersionInformation(versionBits /*int*/) {\n            let bestDifference = Number.MAX_SAFE_INTEGER;\n            let bestVersion = 0;\n            for (let i = 0; i < Version$1.VERSION_DECODE_INFO.length; i++) {\n                const targetVersion = Version$1.VERSION_DECODE_INFO[i];\n                // Do the version info bits match exactly? done.\n                if (targetVersion === versionBits) {\n                    return Version$1.getVersionForNumber(i + 7);\n                }\n                // Otherwise see if this is the closest to a real version info bit string\n                // we have seen so far\n                const bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);\n                if (bitsDifference < bestDifference) {\n                    bestVersion = i + 7;\n                    bestDifference = bitsDifference;\n                }\n            }\n            // We can tolerate up to 3 bits of error since no two version info codewords will\n            // differ in less than 8 bits.\n            if (bestDifference <= 3) {\n                return Version$1.getVersionForNumber(bestVersion);\n            }\n            // If we didn't find a close enough match, fail\n            return null;\n        }\n        /**\n         * See ISO 18004:2006 Annex E\n         */\n        buildFunctionPattern() {\n            const dimension = this.getDimensionForVersion();\n            const bitMatrix = new BitMatrix(dimension);\n            // Top left finder pattern + separator + format\n            bitMatrix.setRegion(0, 0, 9, 9);\n            // Top right finder pattern + separator + format\n            bitMatrix.setRegion(dimension - 8, 0, 8, 9);\n            // Bottom left finder pattern + separator + format\n            bitMatrix.setRegion(0, dimension - 8, 9, 8);\n            // Alignment patterns\n            const max = this.alignmentPatternCenters.length;\n            for (let x = 0; x < max; x++) {\n                const i = this.alignmentPatternCenters[x] - 2;\n                for (let y = 0; y < max; y++) {\n                    if ((x === 0 && (y === 0 || y === max - 1)) || (x === max - 1 && y === 0)) {\n                        // No alignment patterns near the three finder patterns\n                        continue;\n                    }\n                    bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);\n                }\n            }\n            // Vertical timing pattern\n            bitMatrix.setRegion(6, 9, 1, dimension - 17);\n            // Horizontal timing pattern\n            bitMatrix.setRegion(9, 6, dimension - 17, 1);\n            if (this.versionNumber > 6) {\n                // Version info, top right\n                bitMatrix.setRegion(dimension - 11, 0, 3, 6);\n                // Version info, bottom left\n                bitMatrix.setRegion(0, dimension - 11, 6, 3);\n            }\n            return bitMatrix;\n        }\n        /*@Override*/\n        toString() {\n            return '' + this.versionNumber;\n        }\n    }\n    /**\n       * See ISO 18004:2006 Annex D.\n       * Element i represents the raw version bits that specify version i + 7\n       */\n    Version$1.VERSION_DECODE_INFO = Int32Array.from([\n        0x07C94, 0x085BC, 0x09A99, 0x0A4D3, 0x0BBF6,\n        0x0C762, 0x0D847, 0x0E60D, 0x0F928, 0x10B78,\n        0x1145D, 0x12A17, 0x13532, 0x149A6, 0x15683,\n        0x168C9, 0x177EC, 0x18EC4, 0x191E1, 0x1AFAB,\n        0x1B08E, 0x1CC1A, 0x1D33F, 0x1ED75, 0x1F250,\n        0x209D5, 0x216F0, 0x228BA, 0x2379F, 0x24B0B,\n        0x2542E, 0x26A64, 0x27541, 0x28C69\n    ]);\n    /**\n       * See ISO 18004:2006 6.5.1 Table 9\n       */\n    Version$1.VERSIONS = [\n        new Version$1(1, new Int32Array(0), new ECBlocks$1(7, new ECB$1(1, 19)), new ECBlocks$1(10, new ECB$1(1, 16)), new ECBlocks$1(13, new ECB$1(1, 13)), new ECBlocks$1(17, new ECB$1(1, 9))),\n        new Version$1(2, Int32Array.from([6, 18]), new ECBlocks$1(10, new ECB$1(1, 34)), new ECBlocks$1(16, new ECB$1(1, 28)), new ECBlocks$1(22, new ECB$1(1, 22)), new ECBlocks$1(28, new ECB$1(1, 16))),\n        new Version$1(3, Int32Array.from([6, 22]), new ECBlocks$1(15, new ECB$1(1, 55)), new ECBlocks$1(26, new ECB$1(1, 44)), new ECBlocks$1(18, new ECB$1(2, 17)), new ECBlocks$1(22, new ECB$1(2, 13))),\n        new Version$1(4, Int32Array.from([6, 26]), new ECBlocks$1(20, new ECB$1(1, 80)), new ECBlocks$1(18, new ECB$1(2, 32)), new ECBlocks$1(26, new ECB$1(2, 24)), new ECBlocks$1(16, new ECB$1(4, 9))),\n        new Version$1(5, Int32Array.from([6, 30]), new ECBlocks$1(26, new ECB$1(1, 108)), new ECBlocks$1(24, new ECB$1(2, 43)), new ECBlocks$1(18, new ECB$1(2, 15), new ECB$1(2, 16)), new ECBlocks$1(22, new ECB$1(2, 11), new ECB$1(2, 12))),\n        new Version$1(6, Int32Array.from([6, 34]), new ECBlocks$1(18, new ECB$1(2, 68)), new ECBlocks$1(16, new ECB$1(4, 27)), new ECBlocks$1(24, new ECB$1(4, 19)), new ECBlocks$1(28, new ECB$1(4, 15))),\n        new Version$1(7, Int32Array.from([6, 22, 38]), new ECBlocks$1(20, new ECB$1(2, 78)), new ECBlocks$1(18, new ECB$1(4, 31)), new ECBlocks$1(18, new ECB$1(2, 14), new ECB$1(4, 15)), new ECBlocks$1(26, new ECB$1(4, 13), new ECB$1(1, 14))),\n        new Version$1(8, Int32Array.from([6, 24, 42]), new ECBlocks$1(24, new ECB$1(2, 97)), new ECBlocks$1(22, new ECB$1(2, 38), new ECB$1(2, 39)), new ECBlocks$1(22, new ECB$1(4, 18), new ECB$1(2, 19)), new ECBlocks$1(26, new ECB$1(4, 14), new ECB$1(2, 15))),\n        new Version$1(9, Int32Array.from([6, 26, 46]), new ECBlocks$1(30, new ECB$1(2, 116)), new ECBlocks$1(22, new ECB$1(3, 36), new ECB$1(2, 37)), new ECBlocks$1(20, new ECB$1(4, 16), new ECB$1(4, 17)), new ECBlocks$1(24, new ECB$1(4, 12), new ECB$1(4, 13))),\n        new Version$1(10, Int32Array.from([6, 28, 50]), new ECBlocks$1(18, new ECB$1(2, 68), new ECB$1(2, 69)), new ECBlocks$1(26, new ECB$1(4, 43), new ECB$1(1, 44)), new ECBlocks$1(24, new ECB$1(6, 19), new ECB$1(2, 20)), new ECBlocks$1(28, new ECB$1(6, 15), new ECB$1(2, 16))),\n        new Version$1(11, Int32Array.from([6, 30, 54]), new ECBlocks$1(20, new ECB$1(4, 81)), new ECBlocks$1(30, new ECB$1(1, 50), new ECB$1(4, 51)), new ECBlocks$1(28, new ECB$1(4, 22), new ECB$1(4, 23)), new ECBlocks$1(24, new ECB$1(3, 12), new ECB$1(8, 13))),\n        new Version$1(12, Int32Array.from([6, 32, 58]), new ECBlocks$1(24, new ECB$1(2, 92), new ECB$1(2, 93)), new ECBlocks$1(22, new ECB$1(6, 36), new ECB$1(2, 37)), new ECBlocks$1(26, new ECB$1(4, 20), new ECB$1(6, 21)), new ECBlocks$1(28, new ECB$1(7, 14), new ECB$1(4, 15))),\n        new Version$1(13, Int32Array.from([6, 34, 62]), new ECBlocks$1(26, new ECB$1(4, 107)), new ECBlocks$1(22, new ECB$1(8, 37), new ECB$1(1, 38)), new ECBlocks$1(24, new ECB$1(8, 20), new ECB$1(4, 21)), new ECBlocks$1(22, new ECB$1(12, 11), new ECB$1(4, 12))),\n        new Version$1(14, Int32Array.from([6, 26, 46, 66]), new ECBlocks$1(30, new ECB$1(3, 115), new ECB$1(1, 116)), new ECBlocks$1(24, new ECB$1(4, 40), new ECB$1(5, 41)), new ECBlocks$1(20, new ECB$1(11, 16), new ECB$1(5, 17)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(5, 13))),\n        new Version$1(15, Int32Array.from([6, 26, 48, 70]), new ECBlocks$1(22, new ECB$1(5, 87), new ECB$1(1, 88)), new ECBlocks$1(24, new ECB$1(5, 41), new ECB$1(5, 42)), new ECBlocks$1(30, new ECB$1(5, 24), new ECB$1(7, 25)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(7, 13))),\n        new Version$1(16, Int32Array.from([6, 26, 50, 74]), new ECBlocks$1(24, new ECB$1(5, 98), new ECB$1(1, 99)), new ECBlocks$1(28, new ECB$1(7, 45), new ECB$1(3, 46)), new ECBlocks$1(24, new ECB$1(15, 19), new ECB$1(2, 20)), new ECBlocks$1(30, new ECB$1(3, 15), new ECB$1(13, 16))),\n        new Version$1(17, Int32Array.from([6, 30, 54, 78]), new ECBlocks$1(28, new ECB$1(1, 107), new ECB$1(5, 108)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(1, 47)), new ECBlocks$1(28, new ECB$1(1, 22), new ECB$1(15, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(17, 15))),\n        new Version$1(18, Int32Array.from([6, 30, 56, 82]), new ECBlocks$1(30, new ECB$1(5, 120), new ECB$1(1, 121)), new ECBlocks$1(26, new ECB$1(9, 43), new ECB$1(4, 44)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(1, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(19, 15))),\n        new Version$1(19, Int32Array.from([6, 30, 58, 86]), new ECBlocks$1(28, new ECB$1(3, 113), new ECB$1(4, 114)), new ECBlocks$1(26, new ECB$1(3, 44), new ECB$1(11, 45)), new ECBlocks$1(26, new ECB$1(17, 21), new ECB$1(4, 22)), new ECBlocks$1(26, new ECB$1(9, 13), new ECB$1(16, 14))),\n        new Version$1(20, Int32Array.from([6, 34, 62, 90]), new ECBlocks$1(28, new ECB$1(3, 107), new ECB$1(5, 108)), new ECBlocks$1(26, new ECB$1(3, 41), new ECB$1(13, 42)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(5, 25)), new ECBlocks$1(28, new ECB$1(15, 15), new ECB$1(10, 16))),\n        new Version$1(21, Int32Array.from([6, 28, 50, 72, 94]), new ECBlocks$1(28, new ECB$1(4, 116), new ECB$1(4, 117)), new ECBlocks$1(26, new ECB$1(17, 42)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(19, 16), new ECB$1(6, 17))),\n        new Version$1(22, Int32Array.from([6, 26, 50, 74, 98]), new ECBlocks$1(28, new ECB$1(2, 111), new ECB$1(7, 112)), new ECBlocks$1(28, new ECB$1(17, 46)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(16, 25)), new ECBlocks$1(24, new ECB$1(34, 13))),\n        new Version$1(23, Int32Array.from([6, 30, 54, 78, 102]), new ECBlocks$1(30, new ECB$1(4, 121), new ECB$1(5, 122)), new ECBlocks$1(28, new ECB$1(4, 47), new ECB$1(14, 48)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(16, 15), new ECB$1(14, 16))),\n        new Version$1(24, Int32Array.from([6, 28, 54, 80, 106]), new ECBlocks$1(30, new ECB$1(6, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(6, 45), new ECB$1(14, 46)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(16, 25)), new ECBlocks$1(30, new ECB$1(30, 16), new ECB$1(2, 17))),\n        new Version$1(25, Int32Array.from([6, 32, 58, 84, 110]), new ECBlocks$1(26, new ECB$1(8, 106), new ECB$1(4, 107)), new ECBlocks$1(28, new ECB$1(8, 47), new ECB$1(13, 48)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(13, 16))),\n        new Version$1(26, Int32Array.from([6, 30, 58, 86, 114]), new ECBlocks$1(28, new ECB$1(10, 114), new ECB$1(2, 115)), new ECBlocks$1(28, new ECB$1(19, 46), new ECB$1(4, 47)), new ECBlocks$1(28, new ECB$1(28, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(33, 16), new ECB$1(4, 17))),\n        new Version$1(27, Int32Array.from([6, 34, 62, 90, 118]), new ECBlocks$1(30, new ECB$1(8, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(22, 45), new ECB$1(3, 46)), new ECBlocks$1(30, new ECB$1(8, 23), new ECB$1(26, 24)), new ECBlocks$1(30, new ECB$1(12, 15), new ECB$1(28, 16))),\n        new Version$1(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new ECBlocks$1(30, new ECB$1(3, 117), new ECB$1(10, 118)), new ECBlocks$1(28, new ECB$1(3, 45), new ECB$1(23, 46)), new ECBlocks$1(30, new ECB$1(4, 24), new ECB$1(31, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(31, 16))),\n        new Version$1(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new ECBlocks$1(30, new ECB$1(7, 116), new ECB$1(7, 117)), new ECBlocks$1(28, new ECB$1(21, 45), new ECB$1(7, 46)), new ECBlocks$1(30, new ECB$1(1, 23), new ECB$1(37, 24)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(26, 16))),\n        new Version$1(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new ECBlocks$1(30, new ECB$1(5, 115), new ECB$1(10, 116)), new ECBlocks$1(28, new ECB$1(19, 47), new ECB$1(10, 48)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(25, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(25, 16))),\n        new Version$1(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(3, 116)), new ECBlocks$1(28, new ECB$1(2, 46), new ECB$1(29, 47)), new ECBlocks$1(30, new ECB$1(42, 24), new ECB$1(1, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(28, 16))),\n        new Version$1(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new ECBlocks$1(30, new ECB$1(17, 115)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(10, 24), new ECB$1(35, 25)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(35, 16))),\n        new Version$1(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new ECBlocks$1(30, new ECB$1(17, 115), new ECB$1(1, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(21, 47)), new ECBlocks$1(30, new ECB$1(29, 24), new ECB$1(19, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(46, 16))),\n        new Version$1(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(6, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(44, 24), new ECB$1(7, 25)), new ECBlocks$1(30, new ECB$1(59, 16), new ECB$1(1, 17))),\n        new Version$1(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new ECBlocks$1(30, new ECB$1(12, 121), new ECB$1(7, 122)), new ECBlocks$1(28, new ECB$1(12, 47), new ECB$1(26, 48)), new ECBlocks$1(30, new ECB$1(39, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(41, 16))),\n        new Version$1(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new ECBlocks$1(30, new ECB$1(6, 121), new ECB$1(14, 122)), new ECBlocks$1(28, new ECB$1(6, 47), new ECB$1(34, 48)), new ECBlocks$1(30, new ECB$1(46, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(2, 15), new ECB$1(64, 16))),\n        new Version$1(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new ECBlocks$1(30, new ECB$1(17, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(29, 46), new ECB$1(14, 47)), new ECBlocks$1(30, new ECB$1(49, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(24, 15), new ECB$1(46, 16))),\n        new Version$1(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new ECBlocks$1(30, new ECB$1(4, 122), new ECB$1(18, 123)), new ECBlocks$1(28, new ECB$1(13, 46), new ECB$1(32, 47)), new ECBlocks$1(30, new ECB$1(48, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(42, 15), new ECB$1(32, 16))),\n        new Version$1(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new ECBlocks$1(30, new ECB$1(20, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(40, 47), new ECB$1(7, 48)), new ECBlocks$1(30, new ECB$1(43, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(10, 15), new ECB$1(67, 16))),\n        new Version$1(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new ECBlocks$1(30, new ECB$1(19, 118), new ECB$1(6, 119)), new ECBlocks$1(28, new ECB$1(18, 47), new ECB$1(31, 48)), new ECBlocks$1(30, new ECB$1(34, 24), new ECB$1(34, 25)), new ECBlocks$1(30, new ECB$1(20, 15), new ECB$1(61, 16)))\n    ];\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var DataMaskValues;\n    (function (DataMaskValues) {\n        DataMaskValues[DataMaskValues[\"DATA_MASK_000\"] = 0] = \"DATA_MASK_000\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_001\"] = 1] = \"DATA_MASK_001\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_010\"] = 2] = \"DATA_MASK_010\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_011\"] = 3] = \"DATA_MASK_011\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_100\"] = 4] = \"DATA_MASK_100\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_101\"] = 5] = \"DATA_MASK_101\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_110\"] = 6] = \"DATA_MASK_110\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_111\"] = 7] = \"DATA_MASK_111\";\n    })(DataMaskValues || (DataMaskValues = {}));\n    /**\n     * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations\n     * of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,\n     * including areas used for finder patterns, timing patterns, etc. These areas should be unused\n     * after the point they are unmasked anyway.</p>\n     *\n     * <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position\n     * and j is row position. In fact, as the text says, i is row position and j is column position.</p>\n     *\n     * @author Sean Owen\n     */\n    class DataMask {\n        // See ISO 18004:2006 6.8.1\n        constructor(value, isMasked) {\n            this.value = value;\n            this.isMasked = isMasked;\n        }\n        // End of enum constants.\n        /**\n         * <p>Implementations of this method reverse the data masking process applied to a QR Code and\n         * make its bits ready to read.</p>\n         *\n         * @param bits representation of QR Code bits\n         * @param dimension dimension of QR Code, represented by bits, being unmasked\n         */\n        unmaskBitMatrix(bits, dimension /*int*/) {\n            for (let i = 0; i < dimension; i++) {\n                for (let j = 0; j < dimension; j++) {\n                    if (this.isMasked(i, j)) {\n                        bits.flip(j, i);\n                    }\n                }\n            }\n        }\n    }\n    DataMask.values = new Map([\n        /**\n         * 000: mask bits for which (x + y) mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, (i /*int*/, j /*int*/) => { return ((i + j) & 0x01) === 0; })],\n        /**\n         * 001: mask bits for which x mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, (i /*int*/, j /*int*/) => { return (i & 0x01) === 0; })],\n        /**\n         * 010: mask bits for which y mod 3 == 0\n         */\n        [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, (i /*int*/, j /*int*/) => { return j % 3 === 0; })],\n        /**\n         * 011: mask bits for which (x + y) mod 3 == 0\n         */\n        [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, (i /*int*/, j /*int*/) => { return (i + j) % 3 === 0; })],\n        /**\n         * 100: mask bits for which (x/2 + y/3) mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, (i /*int*/, j /*int*/) => { return ((Math.floor(i / 2) + Math.floor(j / 3)) & 0x01) === 0; })],\n        /**\n         * 101: mask bits for which xy mod 2 + xy mod 3 == 0\n         * equivalently, such that xy mod 6 == 0\n         */\n        [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, (i /*int*/, j /*int*/) => { return (i * j) % 6 === 0; })],\n        /**\n         * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0\n         * equivalently, such that xy mod 6 < 3\n         */\n        [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, (i /*int*/, j /*int*/) => { return ((i * j) % 6) < 3; })],\n        /**\n         * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0\n         * equivalently, such that (x + y + xy mod 3) mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, (i /*int*/, j /*int*/) => { return ((i + j + ((i * j) % 3)) & 0x01) === 0; })],\n    ]);\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * @author Sean Owen\n     */\n    class BitMatrixParser$1 {\n        /**\n         * @param bitMatrix {@link BitMatrix} to parse\n         * @throws FormatException if dimension is not >= 21 and 1 mod 4\n         */\n        constructor(bitMatrix) {\n            const dimension = bitMatrix.getHeight();\n            if (dimension < 21 || (dimension & 0x03) !== 1) {\n                throw new FormatException();\n            }\n            this.bitMatrix = bitMatrix;\n        }\n        /**\n         * <p>Reads format information from one of its two locations within the QR Code.</p>\n         *\n         * @return {@link FormatInformation} encapsulating the QR Code's format info\n         * @throws FormatException if both format information locations cannot be parsed as\n         * the valid encoding of format information\n         */\n        readFormatInformation() {\n            if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {\n                return this.parsedFormatInfo;\n            }\n            // Read top-left format info bits\n            let formatInfoBits1 = 0;\n            for (let i = 0; i < 6; i++) {\n                formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);\n            }\n            // .. and skip a bit in the timing pattern ...\n            formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);\n            formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);\n            formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);\n            // .. and skip a bit in the timing pattern ...\n            for (let j = 5; j >= 0; j--) {\n                formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);\n            }\n            // Read the top-right/bottom-left pattern too\n            const dimension = this.bitMatrix.getHeight();\n            let formatInfoBits2 = 0;\n            const jMin = dimension - 7;\n            for (let j = dimension - 1; j >= jMin; j--) {\n                formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);\n            }\n            for (let i = dimension - 8; i < dimension; i++) {\n                formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);\n            }\n            this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);\n            if (this.parsedFormatInfo !== null) {\n                return this.parsedFormatInfo;\n            }\n            throw new FormatException();\n        }\n        /**\n         * <p>Reads version information from one of its two locations within the QR Code.</p>\n         *\n         * @return {@link Version} encapsulating the QR Code's version\n         * @throws FormatException if both version information locations cannot be parsed as\n         * the valid encoding of version information\n         */\n        readVersion() {\n            if (this.parsedVersion !== null && this.parsedVersion !== undefined) {\n                return this.parsedVersion;\n            }\n            const dimension = this.bitMatrix.getHeight();\n            const provisionalVersion = Math.floor((dimension - 17) / 4);\n            if (provisionalVersion <= 6) {\n                return Version$1.getVersionForNumber(provisionalVersion);\n            }\n            // Read top-right version info: 3 wide by 6 tall\n            let versionBits = 0;\n            const ijMin = dimension - 11;\n            for (let j = 5; j >= 0; j--) {\n                for (let i = dimension - 9; i >= ijMin; i--) {\n                    versionBits = this.copyBit(i, j, versionBits);\n                }\n            }\n            let theParsedVersion = Version$1.decodeVersionInformation(versionBits);\n            if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n                this.parsedVersion = theParsedVersion;\n                return theParsedVersion;\n            }\n            // Hmm, failed. Try bottom left: 6 wide by 3 tall\n            versionBits = 0;\n            for (let i = 5; i >= 0; i--) {\n                for (let j = dimension - 9; j >= ijMin; j--) {\n                    versionBits = this.copyBit(i, j, versionBits);\n                }\n            }\n            theParsedVersion = Version$1.decodeVersionInformation(versionBits);\n            if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n                this.parsedVersion = theParsedVersion;\n                return theParsedVersion;\n            }\n            throw new FormatException();\n        }\n        copyBit(i /*int*/, j /*int*/, versionBits /*int*/) {\n            const bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);\n            return bit ? (versionBits << 1) | 0x1 : versionBits << 1;\n        }\n        /**\n         * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the\n         * correct order in order to reconstruct the codewords bytes contained within the\n         * QR Code.</p>\n         *\n         * @return bytes encoded within the QR Code\n         * @throws FormatException if the exact number of bytes expected is not read\n         */\n        readCodewords() {\n            const formatInfo = this.readFormatInformation();\n            const version = this.readVersion();\n            // Get the data mask for the format used in this QR Code. This will exclude\n            // some bits from reading as we wind through the bit matrix.\n            const dataMask = DataMask.values.get(formatInfo.getDataMask());\n            const dimension = this.bitMatrix.getHeight();\n            dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n            const functionPattern = version.buildFunctionPattern();\n            let readingUp = true;\n            const result = new Uint8Array(version.getTotalCodewords());\n            let resultOffset = 0;\n            let currentByte = 0;\n            let bitsRead = 0;\n            // Read columns in pairs, from right to left\n            for (let j = dimension - 1; j > 0; j -= 2) {\n                if (j === 6) {\n                    // Skip whole column with vertical alignment pattern\n                    // saves time and makes the other code proceed more cleanly\n                    j--;\n                }\n                // Read alternatingly from bottom to top then top to bottom\n                for (let count = 0; count < dimension; count++) {\n                    const i = readingUp ? dimension - 1 - count : count;\n                    for (let col = 0; col < 2; col++) {\n                        // Ignore bits covered by the function pattern\n                        if (!functionPattern.get(j - col, i)) {\n                            // Read a bit\n                            bitsRead++;\n                            currentByte <<= 1;\n                            if (this.bitMatrix.get(j - col, i)) {\n                                currentByte |= 1;\n                            }\n                            // If we've made a whole byte, save it off\n                            if (bitsRead === 8) {\n                                result[resultOffset++] = /*(byte) */ currentByte;\n                                bitsRead = 0;\n                                currentByte = 0;\n                            }\n                        }\n                    }\n                }\n                readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions\n            }\n            if (resultOffset !== version.getTotalCodewords()) {\n                throw new FormatException();\n            }\n            return result;\n        }\n        /**\n         * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.\n         */\n        remask() {\n            if (this.parsedFormatInfo === null) {\n                return; // We have no format information, and have no data mask\n            }\n            const dataMask = DataMask.values[this.parsedFormatInfo.getDataMask()];\n            const dimension = this.bitMatrix.getHeight();\n            dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n        }\n        /**\n         * Prepare the parser for a mirrored operation.\n         * This flag has effect only on the {@link #readFormatInformation()} and the\n         * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the\n         * {@link #mirror()} method should be called.\n         *\n         * @param mirror Whether to read version and format information mirrored.\n         */\n        setMirror(isMirror) {\n            this.parsedVersion = null;\n            this.parsedFormatInfo = null;\n            this.isMirror = isMirror;\n        }\n        /** Mirror the bit matrix in order to attempt a second reading. */\n        mirror() {\n            const bitMatrix = this.bitMatrix;\n            for (let x = 0, width = bitMatrix.getWidth(); x < width; x++) {\n                for (let y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {\n                    if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {\n                        bitMatrix.flip(y, x);\n                        bitMatrix.flip(x, y);\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates a block of data within a QR Code. QR Codes may split their data into\n     * multiple blocks, each of which is a unit of data and error-correction codewords. Each\n     * is represented by an instance of this class.</p>\n     *\n     * @author Sean Owen\n     */\n    class DataBlock$1 {\n        constructor(numDataCodewords /*int*/, codewords) {\n            this.numDataCodewords = numDataCodewords;\n            this.codewords = codewords;\n        }\n        /**\n         * <p>When QR Codes use multiple data blocks, they are actually interleaved.\n         * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This\n         * method will separate the data into original blocks.</p>\n         *\n         * @param rawCodewords bytes as read directly from the QR Code\n         * @param version version of the QR Code\n         * @param ecLevel error-correction level of the QR Code\n         * @return DataBlocks containing original bytes, \"de-interleaved\" from representation in the\n         *         QR Code\n         */\n        static getDataBlocks(rawCodewords, version, ecLevel) {\n            if (rawCodewords.length !== version.getTotalCodewords()) {\n                throw new IllegalArgumentException();\n            }\n            // Figure out the number and size of data blocks used by this version and\n            // error correction level\n            const ecBlocks = version.getECBlocksForLevel(ecLevel);\n            // First count the total number of data blocks\n            let totalBlocks = 0;\n            const ecBlockArray = ecBlocks.getECBlocks();\n            for (const ecBlock of ecBlockArray) {\n                totalBlocks += ecBlock.getCount();\n            }\n            // Now establish DataBlocks of the appropriate size and number of data codewords\n            const result = new Array(totalBlocks);\n            let numResultBlocks = 0;\n            for (const ecBlock of ecBlockArray) {\n                for (let i = 0; i < ecBlock.getCount(); i++) {\n                    const numDataCodewords = ecBlock.getDataCodewords();\n                    const numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;\n                    result[numResultBlocks++] = new DataBlock$1(numDataCodewords, new Uint8Array(numBlockCodewords));\n                }\n            }\n            // All blocks have the same amount of data, except that the last n\n            // (where n may be 0) have 1 more byte. Figure out where these start.\n            const shorterBlocksTotalCodewords = result[0].codewords.length;\n            let longerBlocksStartAt = result.length - 1;\n            // TYPESCRIPTPORT: check length is correct here\n            while (longerBlocksStartAt >= 0) {\n                const numCodewords = result[longerBlocksStartAt].codewords.length;\n                if (numCodewords === shorterBlocksTotalCodewords) {\n                    break;\n                }\n                longerBlocksStartAt--;\n            }\n            longerBlocksStartAt++;\n            const shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();\n            // The last elements of result may be 1 element longer\n            // first fill out as many elements as all of them have\n            let rawCodewordsOffset = 0;\n            for (let i = 0; i < shorterBlocksNumDataCodewords; i++) {\n                for (let j = 0; j < numResultBlocks; j++) {\n                    result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];\n                }\n            }\n            // Fill out the last data block in the longer ones\n            for (let j = longerBlocksStartAt; j < numResultBlocks; j++) {\n                result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];\n            }\n            // Now add in error correction blocks\n            const max = result[0].codewords.length;\n            for (let i = shorterBlocksNumDataCodewords; i < max; i++) {\n                for (let j = 0; j < numResultBlocks; j++) {\n                    const iOffset = j < longerBlocksStartAt ? i : i + 1;\n                    result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];\n                }\n            }\n            return result;\n        }\n        getNumDataCodewords() {\n            return this.numDataCodewords;\n        }\n        getCodewords() {\n            return this.codewords;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var ModeValues;\n    (function (ModeValues) {\n        ModeValues[ModeValues[\"TERMINATOR\"] = 0] = \"TERMINATOR\";\n        ModeValues[ModeValues[\"NUMERIC\"] = 1] = \"NUMERIC\";\n        ModeValues[ModeValues[\"ALPHANUMERIC\"] = 2] = \"ALPHANUMERIC\";\n        ModeValues[ModeValues[\"STRUCTURED_APPEND\"] = 3] = \"STRUCTURED_APPEND\";\n        ModeValues[ModeValues[\"BYTE\"] = 4] = \"BYTE\";\n        ModeValues[ModeValues[\"ECI\"] = 5] = \"ECI\";\n        ModeValues[ModeValues[\"KANJI\"] = 6] = \"KANJI\";\n        ModeValues[ModeValues[\"FNC1_FIRST_POSITION\"] = 7] = \"FNC1_FIRST_POSITION\";\n        ModeValues[ModeValues[\"FNC1_SECOND_POSITION\"] = 8] = \"FNC1_SECOND_POSITION\";\n        /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\n        ModeValues[ModeValues[\"HANZI\"] = 9] = \"HANZI\";\n    })(ModeValues || (ModeValues = {}));\n    /**\n     * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which\n     * data can be encoded to bits in the QR code standard.</p>\n     *\n     * @author Sean Owen\n     */\n    class Mode$1 {\n        constructor(value, stringValue, characterCountBitsForVersions, bits /*int*/) {\n            this.value = value;\n            this.stringValue = stringValue;\n            this.characterCountBitsForVersions = characterCountBitsForVersions;\n            this.bits = bits;\n            Mode$1.FOR_BITS.set(bits, this);\n            Mode$1.FOR_VALUE.set(value, this);\n        }\n        /**\n         * @param bits four bits encoding a QR Code data mode\n         * @return Mode encoded by these bits\n         * @throws IllegalArgumentException if bits do not correspond to a known mode\n         */\n        static forBits(bits /*int*/) {\n            const mode = Mode$1.FOR_BITS.get(bits);\n            if (undefined === mode) {\n                throw new IllegalArgumentException();\n            }\n            return mode;\n        }\n        /**\n         * @param version version in question\n         * @return number of bits used, in this QR Code symbol {@link Version}, to encode the\n         *         count of characters that will follow encoded in this Mode\n         */\n        getCharacterCountBits(version) {\n            const versionNumber = version.getVersionNumber();\n            let offset;\n            if (versionNumber <= 9) {\n                offset = 0;\n            }\n            else if (versionNumber <= 26) {\n                offset = 1;\n            }\n            else {\n                offset = 2;\n            }\n            return this.characterCountBitsForVersions[offset];\n        }\n        getValue() {\n            return this.value;\n        }\n        getBits() {\n            return this.bits;\n        }\n        equals(o) {\n            if (!(o instanceof Mode$1)) {\n                return false;\n            }\n            const other = o;\n            return this.value === other.value;\n        }\n        toString() {\n            return this.stringValue;\n        }\n    }\n    Mode$1.FOR_BITS = new Map();\n    Mode$1.FOR_VALUE = new Map();\n    Mode$1.TERMINATOR = new Mode$1(ModeValues.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0x00); // Not really a mode...\n    Mode$1.NUMERIC = new Mode$1(ModeValues.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 0x01);\n    Mode$1.ALPHANUMERIC = new Mode$1(ModeValues.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 0x02);\n    Mode$1.STRUCTURED_APPEND = new Mode$1(ModeValues.STRUCTURED_APPEND, 'STRUCTURED_APPEND', Int32Array.from([0, 0, 0]), 0x03); // Not supported\n    Mode$1.BYTE = new Mode$1(ModeValues.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 0x04);\n    Mode$1.ECI = new Mode$1(ModeValues.ECI, 'ECI', Int32Array.from([0, 0, 0]), 0x07); // character counts don't apply\n    Mode$1.KANJI = new Mode$1(ModeValues.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 0x08);\n    Mode$1.FNC1_FIRST_POSITION = new Mode$1(ModeValues.FNC1_FIRST_POSITION, 'FNC1_FIRST_POSITION', Int32Array.from([0, 0, 0]), 0x05);\n    Mode$1.FNC1_SECOND_POSITION = new Mode$1(ModeValues.FNC1_SECOND_POSITION, 'FNC1_SECOND_POSITION', Int32Array.from([0, 0, 0]), 0x09);\n    /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\n    Mode$1.HANZI = new Mode$1(ModeValues.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 0x0D);\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*import java.io.UnsupportedEncodingException;*/\n    /*import java.util.ArrayList;*/\n    /*import java.util.Collection;*/\n    /*import java.util.List;*/\n    /*import java.util.Map;*/\n    /**\n     * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes\n     * in one QR Code. This class decodes the bits back into text.</p>\n     *\n     * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>\n     *\n     * @author Sean Owen\n     */\n    class DecodedBitStreamParser$1 {\n        static decode(bytes, version, ecLevel, hints) {\n            const bits = new BitSource(bytes);\n            let result = new StringBuilder();\n            const byteSegments = new Array(); // 1\n            // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below\n            let symbolSequence = -1;\n            let parityData = -1;\n            try {\n                let currentCharacterSetECI = null;\n                let fc1InEffect = false;\n                let mode;\n                do {\n                    // While still another segment to read...\n                    if (bits.available() < 4) {\n                        // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here\n                        mode = Mode$1.TERMINATOR;\n                    }\n                    else {\n                        const modeBits = bits.readBits(4);\n                        mode = Mode$1.forBits(modeBits); // mode is encoded by 4 bits\n                    }\n                    switch (mode) {\n                        case Mode$1.TERMINATOR:\n                            break;\n                        case Mode$1.FNC1_FIRST_POSITION:\n                        case Mode$1.FNC1_SECOND_POSITION:\n                            // We do little with FNC1 except alter the parsed result a bit according to the spec\n                            fc1InEffect = true;\n                            break;\n                        case Mode$1.STRUCTURED_APPEND:\n                            if (bits.available() < 16) {\n                                throw new FormatException();\n                            }\n                            // sequence number and parity is added later to the result metadata\n                            // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue\n                            symbolSequence = bits.readBits(8);\n                            parityData = bits.readBits(8);\n                            break;\n                        case Mode$1.ECI:\n                            // Count doesn't apply to ECI\n                            const value = DecodedBitStreamParser$1.parseECIValue(bits);\n                            currentCharacterSetECI = CharacterSetECI.getCharacterSetECIByValue(value);\n                            if (currentCharacterSetECI === null) {\n                                throw new FormatException();\n                            }\n                            break;\n                        case Mode$1.HANZI:\n                            // First handle Hanzi mode which does not start with character count\n                            // Chinese mode contains a sub set indicator right after mode indicator\n                            const subset = bits.readBits(4);\n                            const countHanzi = bits.readBits(mode.getCharacterCountBits(version));\n                            if (subset === DecodedBitStreamParser$1.GB2312_SUBSET) {\n                                DecodedBitStreamParser$1.decodeHanziSegment(bits, result, countHanzi);\n                            }\n                            break;\n                        default:\n                            // \"Normal\" QR code modes:\n                            // How many characters will follow, encoded in this mode?\n                            const count = bits.readBits(mode.getCharacterCountBits(version));\n                            switch (mode) {\n                                case Mode$1.NUMERIC:\n                                    DecodedBitStreamParser$1.decodeNumericSegment(bits, result, count);\n                                    break;\n                                case Mode$1.ALPHANUMERIC:\n                                    DecodedBitStreamParser$1.decodeAlphanumericSegment(bits, result, count, fc1InEffect);\n                                    break;\n                                case Mode$1.BYTE:\n                                    DecodedBitStreamParser$1.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);\n                                    break;\n                                case Mode$1.KANJI:\n                                    DecodedBitStreamParser$1.decodeKanjiSegment(bits, result, count);\n                                    break;\n                                default:\n                                    throw new FormatException();\n                            }\n                            break;\n                    }\n                } while (mode !== Mode$1.TERMINATOR);\n            }\n            catch (iae /*: IllegalArgumentException*/) {\n                // from readBits() calls\n                throw new FormatException();\n            }\n            return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);\n        }\n        /**\n         * See specification GBT 18284-2000\n         */\n        static decodeHanziSegment(bits, result, count /*int*/) {\n            // Don't crash trying to read more bits than we have available.\n            if (count * 13 > bits.available()) {\n                throw new FormatException();\n            }\n            // Each character will require 2 bytes. Read the characters as 2-byte pairs\n            // and decode as GB2312 afterwards\n            const buffer = new Uint8Array(2 * count);\n            let offset = 0;\n            while (count > 0) {\n                // Each 13 bits encodes a 2-byte character\n                const twoBytes = bits.readBits(13);\n                let assembledTwoBytes = (((twoBytes / 0x060) << 8) & 0xFFFFFFFF) | (twoBytes % 0x060);\n                if (assembledTwoBytes < 0x003BF) {\n                    // In the 0xA1A1 to 0xAAFE range\n                    assembledTwoBytes += 0x0A1A1;\n                }\n                else {\n                    // In the 0xB0A1 to 0xFAFE range\n                    assembledTwoBytes += 0x0A6A1;\n                }\n                buffer[offset] = /*(byte) */ ((assembledTwoBytes >> 8) & 0xFF);\n                buffer[offset + 1] = /*(byte) */ (assembledTwoBytes & 0xFF);\n                offset += 2;\n                count--;\n            }\n            try {\n                result.append(StringEncoding.decode(buffer, StringUtils.GB2312));\n                // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point\n            }\n            catch (ignored /*: UnsupportedEncodingException*/) {\n                throw new FormatException(ignored);\n            }\n        }\n        static decodeKanjiSegment(bits, result, count /*int*/) {\n            // Don't crash trying to read more bits than we have available.\n            if (count * 13 > bits.available()) {\n                throw new FormatException();\n            }\n            // Each character will require 2 bytes. Read the characters as 2-byte pairs\n            // and decode as Shift_JIS afterwards\n            const buffer = new Uint8Array(2 * count);\n            let offset = 0;\n            while (count > 0) {\n                // Each 13 bits encodes a 2-byte character\n                const twoBytes = bits.readBits(13);\n                let assembledTwoBytes = (((twoBytes / 0x0C0) << 8) & 0xFFFFFFFF) | (twoBytes % 0x0C0);\n                if (assembledTwoBytes < 0x01F00) {\n                    // In the 0x8140 to 0x9FFC range\n                    assembledTwoBytes += 0x08140;\n                }\n                else {\n                    // In the 0xE040 to 0xEBBF range\n                    assembledTwoBytes += 0x0C140;\n                }\n                buffer[offset] = /*(byte) */ (assembledTwoBytes >> 8);\n                buffer[offset + 1] = /*(byte) */ assembledTwoBytes;\n                offset += 2;\n                count--;\n            }\n            // Shift_JIS may not be supported in some environments:\n            try {\n                result.append(StringEncoding.decode(buffer, StringUtils.SHIFT_JIS));\n                // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point\n            }\n            catch (ignored /*: UnsupportedEncodingException*/) {\n                throw new FormatException(ignored);\n            }\n        }\n        static decodeByteSegment(bits, result, count /*int*/, currentCharacterSetECI, byteSegments, hints) {\n            // Don't crash trying to read more bits than we have available.\n            if (8 * count > bits.available()) {\n                throw new FormatException();\n            }\n            const readBytes = new Uint8Array(count);\n            for (let i = 0; i < count; i++) {\n                readBytes[i] = /*(byte) */ bits.readBits(8);\n            }\n            let encoding;\n            if (currentCharacterSetECI === null) {\n                // The spec isn't clear on this mode; see\n                // section 6.4.5: t does not say which encoding to assuming\n                // upon decoding. I have seen ISO-8859-1 used as well as\n                // Shift_JIS -- without anything like an ECI designator to\n                // give a hint.\n                encoding = StringUtils.guessEncoding(readBytes, hints);\n            }\n            else {\n                encoding = currentCharacterSetECI.getName();\n            }\n            try {\n                result.append(StringEncoding.decode(readBytes, encoding));\n            }\n            catch (ignored /*: UnsupportedEncodingException*/) {\n                throw new FormatException(ignored);\n            }\n            byteSegments.push(readBytes);\n        }\n        static toAlphaNumericChar(value /*int*/) {\n            if (value >= DecodedBitStreamParser$1.ALPHANUMERIC_CHARS.length) {\n                throw new FormatException();\n            }\n            return DecodedBitStreamParser$1.ALPHANUMERIC_CHARS[value];\n        }\n        static decodeAlphanumericSegment(bits, result, count /*int*/, fc1InEffect) {\n            // Read two characters at a time\n            const start = result.length();\n            while (count > 1) {\n                if (bits.available() < 11) {\n                    throw new FormatException();\n                }\n                const nextTwoCharsBits = bits.readBits(11);\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(nextTwoCharsBits % 45));\n                count -= 2;\n            }\n            if (count === 1) {\n                // special case: one character left\n                if (bits.available() < 6) {\n                    throw new FormatException();\n                }\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(bits.readBits(6)));\n            }\n            // See section 6.4.8.1, 6.4.8.2\n            if (fc1InEffect) {\n                // We need to massage the result a bit if in an FNC1 mode:\n                for (let i = start; i < result.length(); i++) {\n                    if (result.charAt(i) === '%') {\n                        if (i < result.length() - 1 && result.charAt(i + 1) === '%') {\n                            // %% is rendered as %\n                            result.deleteCharAt(i + 1);\n                        }\n                        else {\n                            // In alpha mode, % should be converted to FNC1 separator 0x1D\n                            result.setCharAt(i, String.fromCharCode(0x1D));\n                        }\n                    }\n                }\n            }\n        }\n        static decodeNumericSegment(bits, result, count /*int*/) {\n            // Read three digits at a time\n            while (count >= 3) {\n                // Each 10 bits encodes three digits\n                if (bits.available() < 10) {\n                    throw new FormatException();\n                }\n                const threeDigitsBits = bits.readBits(10);\n                if (threeDigitsBits >= 1000) {\n                    throw new FormatException();\n                }\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(threeDigitsBits % 10));\n                count -= 3;\n            }\n            if (count === 2) {\n                // Two digits left over to read, encoded in 7 bits\n                if (bits.available() < 7) {\n                    throw new FormatException();\n                }\n                const twoDigitsBits = bits.readBits(7);\n                if (twoDigitsBits >= 100) {\n                    throw new FormatException();\n                }\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(twoDigitsBits % 10));\n            }\n            else if (count === 1) {\n                // One digit left over to read\n                if (bits.available() < 4) {\n                    throw new FormatException();\n                }\n                const digitBits = bits.readBits(4);\n                if (digitBits >= 10) {\n                    throw new FormatException();\n                }\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(digitBits));\n            }\n        }\n        static parseECIValue(bits) {\n            const firstByte = bits.readBits(8);\n            if ((firstByte & 0x80) === 0) {\n                // just one byte\n                return firstByte & 0x7F;\n            }\n            if ((firstByte & 0xC0) === 0x80) {\n                // two bytes\n                const secondByte = bits.readBits(8);\n                return (((firstByte & 0x3F) << 8) & 0xFFFFFFFF) | secondByte;\n            }\n            if ((firstByte & 0xE0) === 0xC0) {\n                // three bytes\n                const secondThirdBytes = bits.readBits(16);\n                return (((firstByte & 0x1F) << 16) & 0xFFFFFFFF) | secondThirdBytes;\n            }\n            throw new FormatException();\n        }\n    }\n    /**\n     * See ISO 18004:2006, 6.4.4 Table 5\n     */\n    DecodedBitStreamParser$1.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';\n    DecodedBitStreamParser$1.GB2312_SUBSET = 1;\n    // function Uint8ArrayToString(a: Uint8Array): string {\n    //     const CHUNK_SZ = 0x8000;\n    //     const c = new StringBuilder();\n    //     for (let i = 0, length = a.length; i < length; i += CHUNK_SZ) {\n    //         c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));\n    //     }\n    //     return c.toString();\n    // }\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * Meta-data container for QR Code decoding. Instances of this class may be used to convey information back to the\n     * decoding caller. Callers are expected to process this.\n     *\n     * @see com.google.zxing.common.DecoderResult#getOther()\n     */\n    class QRCodeDecoderMetaData {\n        constructor(mirrored) {\n            this.mirrored = mirrored;\n        }\n        /**\n         * @return true if the QR Code was mirrored.\n         */\n        isMirrored() {\n            return this.mirrored;\n        }\n        /**\n         * Apply the result points' order correction due to mirroring.\n         *\n         * @param points Array of points to apply mirror correction to.\n         */\n        applyMirroredCorrection(points) {\n            if (!this.mirrored || points === null || points.length < 3) {\n                return;\n            }\n            const bottomLeft = points[0];\n            points[0] = points[2];\n            points[2] = bottomLeft;\n            // No need to 'fix' top-left and alignment pattern.\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*import java.util.Map;*/\n    /**\n     * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting\n     * the QR Code from an image.</p>\n     *\n     * @author Sean Owen\n     */\n    class Decoder$2 {\n        constructor() {\n            this.rsDecoder = new ReedSolomonDecoder(GenericGF.QR_CODE_FIELD_256);\n        }\n        // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {\n        //   return decode(image, null)\n        // }\n        /**\n         * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.\n         * \"true\" is taken to mean a black module.</p>\n         *\n         * @param image booleans representing white/black QR Code modules\n         * @param hints decoding hints that should be used to influence decoding\n         * @return text and bytes encoded within the QR Code\n         * @throws FormatException if the QR Code cannot be decoded\n         * @throws ChecksumException if error correction fails\n         */\n        decodeBooleanArray(image, hints) {\n            return this.decodeBitMatrix(BitMatrix.parseFromBooleanArray(image), hints);\n        }\n        // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {\n        //   return decode(bits, null)\n        // }\n        /**\n         * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken to mean a black module.</p>\n         *\n         * @param bits booleans representing white/black QR Code modules\n         * @param hints decoding hints that should be used to influence decoding\n         * @return text and bytes encoded within the QR Code\n         * @throws FormatException if the QR Code cannot be decoded\n         * @throws ChecksumException if error correction fails\n         */\n        decodeBitMatrix(bits, hints) {\n            // Construct a parser and read version, error-correction level\n            const parser = new BitMatrixParser$1(bits);\n            let ex = null;\n            try {\n                return this.decodeBitMatrixParser(parser, hints);\n            }\n            catch (e /*: FormatException, ChecksumException*/) {\n                ex = e;\n            }\n            try {\n                // Revert the bit matrix\n                parser.remask();\n                // Will be attempting a mirrored reading of the version and format info.\n                parser.setMirror(true);\n                // Preemptively read the version.\n                parser.readVersion();\n                // Preemptively read the format information.\n                parser.readFormatInformation();\n                /*\n                 * Since we're here, this means we have successfully detected some kind\n                 * of version and format information when mirrored. This is a good sign,\n                 * that the QR code may be mirrored, and we should try once more with a\n                 * mirrored content.\n                 */\n                // Prepare for a mirrored reading.\n                parser.mirror();\n                const result = this.decodeBitMatrixParser(parser, hints);\n                // Success! Notify the caller that the code was mirrored.\n                result.setOther(new QRCodeDecoderMetaData(true));\n                return result;\n            }\n            catch (e /*FormatException | ChecksumException*/) {\n                // Throw the exception from the original reading\n                if (ex !== null) {\n                    throw ex;\n                }\n                throw e;\n            }\n        }\n        decodeBitMatrixParser(parser, hints) {\n            const version = parser.readVersion();\n            const ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();\n            // Read codewords\n            const codewords = parser.readCodewords();\n            // Separate into data blocks\n            const dataBlocks = DataBlock$1.getDataBlocks(codewords, version, ecLevel);\n            // Count total number of data bytes\n            let totalBytes = 0;\n            for (const dataBlock of dataBlocks) {\n                totalBytes += dataBlock.getNumDataCodewords();\n            }\n            const resultBytes = new Uint8Array(totalBytes);\n            let resultOffset = 0;\n            // Error-correct and copy data blocks together into a stream of bytes\n            for (const dataBlock of dataBlocks) {\n                const codewordBytes = dataBlock.getCodewords();\n                const numDataCodewords = dataBlock.getNumDataCodewords();\n                this.correctErrors(codewordBytes, numDataCodewords);\n                for (let i = 0; i < numDataCodewords; i++) {\n                    resultBytes[resultOffset++] = codewordBytes[i];\n                }\n            }\n            // Decode the contents of that stream of bytes\n            return DecodedBitStreamParser$1.decode(resultBytes, version, ecLevel, hints);\n        }\n        /**\n         * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n         * correct the errors in-place using Reed-Solomon error correction.</p>\n         *\n         * @param codewordBytes data and error correction codewords\n         * @param numDataCodewords number of codewords that are data bytes\n         * @throws ChecksumException if error correction fails\n         */\n        correctErrors(codewordBytes, numDataCodewords /*int*/) {\n            // const numCodewords = codewordBytes.length;\n            // First read into an array of ints\n            const codewordsInts = new Int32Array(codewordBytes);\n            // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?\n            // const codewordsInts = new Int32Array(numCodewords)\n            // for (let i = 0; i < numCodewords; i++) {\n            //   codewordsInts[i] = codewordBytes[i] & 0xFF\n            // }\n            try {\n                this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n            }\n            catch (ignored /*: ReedSolomonException*/) {\n                throw new ChecksumException();\n            }\n            // Copy back into array of bytes -- only need to worry about the bytes that were data\n            // We don't care about errors in the error-correction codewords\n            for (let i = 0; i < numDataCodewords; i++) {\n                codewordBytes[i] = /*(byte) */ codewordsInts[i];\n            }\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates an alignment pattern, which are the smaller square patterns found in\n     * all but the simplest QR Codes.</p>\n     *\n     * @author Sean Owen\n     */\n    class AlignmentPattern extends ResultPoint {\n        constructor(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/) {\n            super(posX, posY);\n            this.estimatedModuleSize = estimatedModuleSize;\n        }\n        /**\n         * <p>Determines if this alignment pattern \"about equals\" an alignment pattern at the stated\n         * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>\n         */\n        aboutEquals(moduleSize /*float*/, i /*float*/, j /*float*/) {\n            if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {\n                const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\n                return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;\n            }\n            return false;\n        }\n        /**\n         * Combines this object's current estimate of a finder pattern position and module size\n         * with a new estimate. It returns a new {@code FinderPattern} containing an average of the two.\n         */\n        combineEstimate(i /*float*/, j /*float*/, newModuleSize /*float*/) {\n            const combinedX = (this.getX() + j) / 2.0;\n            const combinedY = (this.getY() + i) / 2.0;\n            const combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2.0;\n            return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*import java.util.ArrayList;*/\n    /*import java.util.List;*/\n    /**\n     * <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder\n     * patterns but are smaller and appear at regular intervals throughout the image.</p>\n     *\n     * <p>At the moment this only looks for the bottom-right alignment pattern.</p>\n     *\n     * <p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,\n     * pasted and stripped down here for maximum performance but does unfortunately duplicate\n     * some code.</p>\n     *\n     * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>\n     *\n     * @author Sean Owen\n     */\n    class AlignmentPatternFinder {\n        /**\n         * <p>Creates a finder that will look in a portion of the whole image.</p>\n         *\n         * @param image image to search\n         * @param startX left column from which to start searching\n         * @param startY top row from which to start searching\n         * @param width width of region to search\n         * @param height height of region to search\n         * @param moduleSize estimated module size so far\n         */\n        constructor(image, startX /*int*/, startY /*int*/, width /*int*/, height /*int*/, moduleSize /*float*/, resultPointCallback) {\n            this.image = image;\n            this.startX = startX;\n            this.startY = startY;\n            this.width = width;\n            this.height = height;\n            this.moduleSize = moduleSize;\n            this.resultPointCallback = resultPointCallback;\n            this.possibleCenters = []; // new Array<any>(5))\n            // TYPESCRIPTPORT: array initialization without size as the length is checked below\n            this.crossCheckStateCount = new Int32Array(3);\n        }\n        /**\n         * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since\n         * it's pretty performance-critical and so is written to be fast foremost.</p>\n         *\n         * @return {@link AlignmentPattern} if found\n         * @throws NotFoundException if not found\n         */\n        find() {\n            const startX = this.startX;\n            const height = this.height;\n            const width = this.width;\n            const maxJ = startX + width;\n            const middleI = this.startY + (height / 2);\n            // We are looking for black/white/black modules in 1:1:1 ratio\n            // this tracks the number of black/white/black modules seen so far\n            const stateCount = new Int32Array(3);\n            const image = this.image;\n            for (let iGen = 0; iGen < height; iGen++) {\n                // Search from middle outwards\n                const i = middleI + ((iGen & 0x01) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));\n                stateCount[0] = 0;\n                stateCount[1] = 0;\n                stateCount[2] = 0;\n                let j = startX;\n                // Burn off leading white pixels before anything else; if we start in the middle of\n                // a white run, it doesn't make sense to count its length, since we don't know if the\n                // white run continued to the left of the start point\n                while (j < maxJ && !image.get(j, i)) {\n                    j++;\n                }\n                let currentState = 0;\n                while (j < maxJ) {\n                    if (image.get(j, i)) {\n                        // Black pixel\n                        if (currentState === 1) { // Counting black pixels\n                            stateCount[1]++;\n                        }\n                        else { // Counting white pixels\n                            if (currentState === 2) { // A winner?\n                                if (this.foundPatternCross(stateCount)) { // Yes\n                                    const confirmed = this.handlePossibleCenter(stateCount, i, j);\n                                    if (confirmed !== null) {\n                                        return confirmed;\n                                    }\n                                }\n                                stateCount[0] = stateCount[2];\n                                stateCount[1] = 1;\n                                stateCount[2] = 0;\n                                currentState = 1;\n                            }\n                            else {\n                                stateCount[++currentState]++;\n                            }\n                        }\n                    }\n                    else { // White pixel\n                        if (currentState === 1) { // Counting black pixels\n                            currentState++;\n                        }\n                        stateCount[currentState]++;\n                    }\n                    j++;\n                }\n                if (this.foundPatternCross(stateCount)) {\n                    const confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\n                    if (confirmed !== null) {\n                        return confirmed;\n                    }\n                }\n            }\n            // Hmm, nothing we saw was observed and confirmed twice. If we had\n            // any guess at all, return it.\n            if (this.possibleCenters.length !== 0) {\n                return this.possibleCenters[0];\n            }\n            throw new NotFoundException();\n        }\n        /**\n         * Given a count of black/white/black pixels just seen and an end position,\n         * figures the location of the center of this black/white/black run.\n         */\n        static centerFromEnd(stateCount, end /*int*/) {\n            return (end - stateCount[2]) - stateCount[1] / 2.0;\n        }\n        /**\n         * @param stateCount count of black/white/black pixels just read\n         * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios\n         *         used by alignment patterns to be considered a match\n         */\n        foundPatternCross(stateCount) {\n            const moduleSize = this.moduleSize;\n            const maxVariance = moduleSize / 2.0;\n            for (let i = 0; i < 3; i++) {\n                if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /**\n         * <p>After a horizontal scan finds a potential alignment pattern, this method\n         * \"cross-checks\" by scanning down vertically through the center of the possible\n         * alignment pattern to see if the same proportion is detected.</p>\n         *\n         * @param startI row where an alignment pattern was detected\n         * @param centerJ center of the section that appears to cross an alignment pattern\n         * @param maxCount maximum reasonable number of modules that should be\n         * observed in any reading state, based on the results of the horizontal scan\n         * @return vertical center of alignment pattern, or {@link Float#NaN} if not found\n         */\n        crossCheckVertical(startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n            const image = this.image;\n            const maxI = image.getHeight();\n            const stateCount = this.crossCheckStateCount;\n            stateCount[0] = 0;\n            stateCount[1] = 0;\n            stateCount[2] = 0;\n            // Start counting up from center\n            let i = startI;\n            while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {\n                stateCount[1]++;\n                i--;\n            }\n            // If already too many modules in this state or ran off the edge:\n            if (i < 0 || stateCount[1] > maxCount) {\n                return NaN;\n            }\n            while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {\n                stateCount[0]++;\n                i--;\n            }\n            if (stateCount[0] > maxCount) {\n                return NaN;\n            }\n            // Now also count down from center\n            i = startI + 1;\n            while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {\n                stateCount[1]++;\n                i++;\n            }\n            if (i === maxI || stateCount[1] > maxCount) {\n                return NaN;\n            }\n            while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {\n                stateCount[2]++;\n                i++;\n            }\n            if (stateCount[2] > maxCount) {\n                return NaN;\n            }\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n                return NaN;\n            }\n            return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i) : NaN;\n        }\n        /**\n         * <p>This is called when a horizontal scan finds a possible alignment pattern. It will\n         * cross check with a vertical scan, and if successful, will see if this pattern had been\n         * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have\n         * found the alignment pattern.</p>\n         *\n         * @param stateCount reading state module counts from horizontal scan\n         * @param i row where alignment pattern may be found\n         * @param j end of possible alignment pattern in row\n         * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not\n         */\n        handlePossibleCenter(stateCount, i /*int*/, j /*int*/) {\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n            const centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j);\n            const centerI = this.crossCheckVertical(i, /*(int) */ centerJ, 2 * stateCount[1], stateCountTotal);\n            if (!isNaN(centerI)) {\n                const estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;\n                for (const center of this.possibleCenters) {\n                    // Look for about the same center and module size:\n                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n                        return center.combineEstimate(centerI, centerJ, estimatedModuleSize);\n                    }\n                }\n                // Hadn't found this before; save it\n                const point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);\n                this.possibleCenters.push(point);\n                if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {\n                    this.resultPointCallback.foundPossibleResultPoint(point);\n                }\n            }\n            return null;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates a finder pattern, which are the three square patterns found in\n     * the corners of QR Codes. It also encapsulates a count of similar finder patterns,\n     * as a convenience to the finder's bookkeeping.</p>\n     *\n     * @author Sean Owen\n     */\n    class FinderPattern$1 extends ResultPoint {\n        // FinderPattern(posX: number/*float*/, posY: number/*float*/, estimatedModuleSize: number/*float*/) {\n        //   this(posX, posY, estimatedModuleSize, 1)\n        // }\n        constructor(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/, count /*int*/) {\n            super(posX, posY);\n            this.estimatedModuleSize = estimatedModuleSize;\n            this.count = count;\n            if (undefined === count) {\n                this.count = 1;\n            }\n        }\n        getEstimatedModuleSize() {\n            return this.estimatedModuleSize;\n        }\n        getCount() {\n            return this.count;\n        }\n        /*\n        void incrementCount() {\n          this.count++\n        }\n         */\n        /**\n         * <p>Determines if this finder pattern \"about equals\" a finder pattern at the stated\n         * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>\n         */\n        aboutEquals(moduleSize /*float*/, i /*float*/, j /*float*/) {\n            if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {\n                const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\n                return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;\n            }\n            return false;\n        }\n        /**\n         * Combines this object's current estimate of a finder pattern position and module size\n         * with a new estimate. It returns a new {@code FinderPattern} containing a weighted average\n         * based on count.\n         */\n        combineEstimate(i /*float*/, j /*float*/, newModuleSize /*float*/) {\n            const combinedCount = this.count + 1;\n            const combinedX = (this.count * this.getX() + j) / combinedCount;\n            const combinedY = (this.count * this.getY() + i) / combinedCount;\n            const combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;\n            return new FinderPattern$1(combinedX, combinedY, combinedModuleSize, combinedCount);\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates information about finder patterns in an image, including the location of\n     * the three finder patterns, and their estimated module size.</p>\n     *\n     * @author Sean Owen\n     */\n    class FinderPatternInfo {\n        constructor(patternCenters) {\n            this.bottomLeft = patternCenters[0];\n            this.topLeft = patternCenters[1];\n            this.topRight = patternCenters[2];\n        }\n        getBottomLeft() {\n            return this.bottomLeft;\n        }\n        getTopLeft() {\n            return this.topLeft;\n        }\n        getTopRight() {\n            return this.topRight;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*import java.io.Serializable;*/\n    /*import java.util.ArrayList;*/\n    /*import java.util.Collections;*/\n    /*import java.util.Comparator;*/\n    /*import java.util.List;*/\n    /*import java.util.Map;*/\n    /**\n     * <p>This class attempts to find finder patterns in a QR Code. Finder patterns are the square\n     * markers at three corners of a QR Code.</p>\n     *\n     * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.\n     *\n     * @author Sean Owen\n     */\n    class FinderPatternFinder {\n        /**\n         * <p>Creates a finder that will search the image for three finder patterns.</p>\n         *\n         * @param image image to search\n         */\n        // public constructor(image: BitMatrix) {\n        //   this(image, null)\n        // }\n        constructor(image, resultPointCallback) {\n            this.image = image;\n            this.resultPointCallback = resultPointCallback;\n            this.possibleCenters = [];\n            this.crossCheckStateCount = new Int32Array(5);\n            this.resultPointCallback = resultPointCallback;\n        }\n        getImage() {\n            return this.image;\n        }\n        getPossibleCenters() {\n            return this.possibleCenters;\n        }\n        find(hints) {\n            const tryHarder = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType$1.TRY_HARDER);\n            const pureBarcode = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType$1.PURE_BARCODE);\n            const image = this.image;\n            const maxI = image.getHeight();\n            const maxJ = image.getWidth();\n            // We are looking for black/white/black/white/black modules in\n            // 1:1:3:1:1 ratio; this tracks the number of such modules seen so far\n            // Let's assume that the maximum version QR Code we support takes up 1/4 the height of the\n            // image, and then account for the center being 3 modules in size. This gives the smallest\n            // number of pixels the center could be, so skip this often. When trying harder, look for all\n            // QR versions regardless of how dense they are.\n            let iSkip = Math.floor((3 * maxI) / (4 * FinderPatternFinder.MAX_MODULES));\n            if (iSkip < FinderPatternFinder.MIN_SKIP || tryHarder) {\n                iSkip = FinderPatternFinder.MIN_SKIP;\n            }\n            let done = false;\n            const stateCount = new Int32Array(5);\n            for (let i = iSkip - 1; i < maxI && !done; i += iSkip) {\n                // Get a row of black/white values\n                stateCount[0] = 0;\n                stateCount[1] = 0;\n                stateCount[2] = 0;\n                stateCount[3] = 0;\n                stateCount[4] = 0;\n                let currentState = 0;\n                for (let j = 0; j < maxJ; j++) {\n                    if (image.get(j, i)) {\n                        // Black pixel\n                        if ((currentState & 1) === 1) { // Counting white pixels\n                            currentState++;\n                        }\n                        stateCount[currentState]++;\n                    }\n                    else { // White pixel\n                        if ((currentState & 1) === 0) { // Counting black pixels\n                            if (currentState === 4) { // A winner?\n                                if (FinderPatternFinder.foundPatternCross(stateCount)) { // Yes\n                                    const confirmed = this.handlePossibleCenter(stateCount, i, j, pureBarcode);\n                                    if (confirmed === true) {\n                                        // Start examining every other line. Checking each line turned out to be too\n                                        // expensive and didn't improve performance.\n                                        iSkip = 2;\n                                        if (this.hasSkipped === true) {\n                                            done = this.haveMultiplyConfirmedCenters();\n                                        }\n                                        else {\n                                            const rowSkip = this.findRowSkip();\n                                            if (rowSkip > stateCount[2]) {\n                                                // Skip rows between row of lower confirmed center\n                                                // and top of presumed third confirmed center\n                                                // but back up a bit to get a full chance of detecting\n                                                // it, entire width of center of finder pattern\n                                                // Skip by rowSkip, but back off by stateCount[2] (size of last center\n                                                // of pattern we saw) to be conservative, and also back off by iSkip which\n                                                // is about to be re-added\n                                                i += rowSkip - stateCount[2] - iSkip;\n                                                j = maxJ - 1;\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        stateCount[0] = stateCount[2];\n                                        stateCount[1] = stateCount[3];\n                                        stateCount[2] = stateCount[4];\n                                        stateCount[3] = 1;\n                                        stateCount[4] = 0;\n                                        currentState = 3;\n                                        continue;\n                                    }\n                                    // Clear state to start looking again\n                                    currentState = 0;\n                                    stateCount[0] = 0;\n                                    stateCount[1] = 0;\n                                    stateCount[2] = 0;\n                                    stateCount[3] = 0;\n                                    stateCount[4] = 0;\n                                }\n                                else { // No, shift counts back by two\n                                    stateCount[0] = stateCount[2];\n                                    stateCount[1] = stateCount[3];\n                                    stateCount[2] = stateCount[4];\n                                    stateCount[3] = 1;\n                                    stateCount[4] = 0;\n                                    currentState = 3;\n                                }\n                            }\n                            else {\n                                stateCount[++currentState]++;\n                            }\n                        }\n                        else { // Counting white pixels\n                            stateCount[currentState]++;\n                        }\n                    }\n                }\n                if (FinderPatternFinder.foundPatternCross(stateCount)) {\n                    const confirmed = this.handlePossibleCenter(stateCount, i, maxJ, pureBarcode);\n                    if (confirmed === true) {\n                        iSkip = stateCount[0];\n                        if (this.hasSkipped) {\n                            // Found a third one\n                            done = this.haveMultiplyConfirmedCenters();\n                        }\n                    }\n                }\n            }\n            const patternInfo = this.selectBestPatterns();\n            ResultPoint.orderBestPatterns(patternInfo);\n            return new FinderPatternInfo(patternInfo);\n        }\n        /**\n         * Given a count of black/white/black/white/black pixels just seen and an end position,\n         * figures the location of the center of this run.\n         */\n        static centerFromEnd(stateCount, end /*int*/) {\n            return (end - stateCount[4] - stateCount[3]) - stateCount[2] / 2.0;\n        }\n        /**\n         * @param stateCount count of black/white/black/white/black pixels just read\n         * @return true iff the proportions of the counts is close enough to the 1/1/3/1/1 ratios\n         *         used by finder patterns to be considered a match\n         */\n        static foundPatternCross(stateCount) {\n            let totalModuleSize = 0;\n            for (let i = 0; i < 5; i++) {\n                const count = stateCount[i];\n                if (count === 0) {\n                    return false;\n                }\n                totalModuleSize += count;\n            }\n            if (totalModuleSize < 7) {\n                return false;\n            }\n            const moduleSize = totalModuleSize / 7.0;\n            const maxVariance = moduleSize / 2.0;\n            // Allow less than 50% variance from 1-1-3-1-1 proportions\n            return Math.abs(moduleSize - stateCount[0]) < maxVariance &&\n                Math.abs(moduleSize - stateCount[1]) < maxVariance &&\n                Math.abs(3.0 * moduleSize - stateCount[2]) < 3 * maxVariance &&\n                Math.abs(moduleSize - stateCount[3]) < maxVariance &&\n                Math.abs(moduleSize - stateCount[4]) < maxVariance;\n        }\n        getCrossCheckStateCount() {\n            const crossCheckStateCount = this.crossCheckStateCount;\n            crossCheckStateCount[0] = 0;\n            crossCheckStateCount[1] = 0;\n            crossCheckStateCount[2] = 0;\n            crossCheckStateCount[3] = 0;\n            crossCheckStateCount[4] = 0;\n            return crossCheckStateCount;\n        }\n        /**\n         * After a vertical and horizontal scan finds a potential finder pattern, this method\n         * \"cross-cross-cross-checks\" by scanning down diagonally through the center of the possible\n         * finder pattern to see if the same proportion is detected.\n         *\n         * @param startI row where a finder pattern was detected\n         * @param centerJ center of the section that appears to cross a finder pattern\n         * @param maxCount maximum reasonable number of modules that should be\n         *  observed in any reading state, based on the results of the horizontal scan\n         * @param originalStateCountTotal The original state count total.\n         * @return true if proportions are withing expected limits\n         */\n        crossCheckDiagonal(startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n            const stateCount = this.getCrossCheckStateCount();\n            // Start counting up, left from center finding black center mass\n            let i = 0;\n            const image = this.image;\n            while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i)) {\n                stateCount[2]++;\n                i++;\n            }\n            if (startI < i || centerJ < i) {\n                return false;\n            }\n            // Continue up, left finding white space\n            while (startI >= i && centerJ >= i && !image.get(centerJ - i, startI - i) &&\n                stateCount[1] <= maxCount) {\n                stateCount[1]++;\n                i++;\n            }\n            // If already too many modules in this state or ran off the edge:\n            if (startI < i || centerJ < i || stateCount[1] > maxCount) {\n                return false;\n            }\n            // Continue up, left finding black border\n            while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i) &&\n                stateCount[0] <= maxCount) {\n                stateCount[0]++;\n                i++;\n            }\n            if (stateCount[0] > maxCount) {\n                return false;\n            }\n            const maxI = image.getHeight();\n            const maxJ = image.getWidth();\n            // Now also count down, right from center\n            i = 1;\n            while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i)) {\n                stateCount[2]++;\n                i++;\n            }\n            // Ran off the edge?\n            if (startI + i >= maxI || centerJ + i >= maxJ) {\n                return false;\n            }\n            while (startI + i < maxI && centerJ + i < maxJ && !image.get(centerJ + i, startI + i) &&\n                stateCount[3] < maxCount) {\n                stateCount[3]++;\n                i++;\n            }\n            if (startI + i >= maxI || centerJ + i >= maxJ || stateCount[3] >= maxCount) {\n                return false;\n            }\n            while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i) &&\n                stateCount[4] < maxCount) {\n                stateCount[4]++;\n                i++;\n            }\n            if (stateCount[4] >= maxCount) {\n                return false;\n            }\n            // If we found a finder-pattern-like section, but its size is more than 100% different than\n            // the original, assume it's a false positive\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n            return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal &&\n                FinderPatternFinder.foundPatternCross(stateCount);\n        }\n        /**\n         * <p>After a horizontal scan finds a potential finder pattern, this method\n         * \"cross-checks\" by scanning down vertically through the center of the possible\n         * finder pattern to see if the same proportion is detected.</p>\n         *\n         * @param startI row where a finder pattern was detected\n         * @param centerJ center of the section that appears to cross a finder pattern\n         * @param maxCount maximum reasonable number of modules that should be\n         * observed in any reading state, based on the results of the horizontal scan\n         * @return vertical center of finder pattern, or {@link Float#NaN} if not found\n         */\n        crossCheckVertical(startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n            const image = this.image;\n            const maxI = image.getHeight();\n            const stateCount = this.getCrossCheckStateCount();\n            // Start counting up from center\n            let i = startI;\n            while (i >= 0 && image.get(centerJ, i)) {\n                stateCount[2]++;\n                i--;\n            }\n            if (i < 0) {\n                return NaN;\n            }\n            while (i >= 0 && !image.get(centerJ, i) && stateCount[1] <= maxCount) {\n                stateCount[1]++;\n                i--;\n            }\n            // If already too many modules in this state or ran off the edge:\n            if (i < 0 || stateCount[1] > maxCount) {\n                return NaN;\n            }\n            while (i >= 0 && image.get(centerJ, i) && stateCount[0] <= maxCount) {\n                stateCount[0]++;\n                i--;\n            }\n            if (stateCount[0] > maxCount) {\n                return NaN;\n            }\n            // Now also count down from center\n            i = startI + 1;\n            while (i < maxI && image.get(centerJ, i)) {\n                stateCount[2]++;\n                i++;\n            }\n            if (i === maxI) {\n                return NaN;\n            }\n            while (i < maxI && !image.get(centerJ, i) && stateCount[3] < maxCount) {\n                stateCount[3]++;\n                i++;\n            }\n            if (i === maxI || stateCount[3] >= maxCount) {\n                return NaN;\n            }\n            while (i < maxI && image.get(centerJ, i) && stateCount[4] < maxCount) {\n                stateCount[4]++;\n                i++;\n            }\n            if (stateCount[4] >= maxCount) {\n                return NaN;\n            }\n            // If we found a finder-pattern-like section, but its size is more than 40% different than\n            // the original, assume it's a false positive\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +\n                stateCount[4];\n            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n                return NaN;\n            }\n            return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, i) : NaN;\n        }\n        /**\n         * <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,\n         * except it reads horizontally instead of vertically. This is used to cross-cross\n         * check a vertical cross check and locate the real center of the alignment pattern.</p>\n         */\n        crossCheckHorizontal(startJ /*int*/, centerI /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n            const image = this.image;\n            const maxJ = image.getWidth();\n            const stateCount = this.getCrossCheckStateCount();\n            let j = startJ;\n            while (j >= 0 && image.get(j, centerI)) {\n                stateCount[2]++;\n                j--;\n            }\n            if (j < 0) {\n                return NaN;\n            }\n            while (j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount) {\n                stateCount[1]++;\n                j--;\n            }\n            if (j < 0 || stateCount[1] > maxCount) {\n                return NaN;\n            }\n            while (j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount) {\n                stateCount[0]++;\n                j--;\n            }\n            if (stateCount[0] > maxCount) {\n                return NaN;\n            }\n            j = startJ + 1;\n            while (j < maxJ && image.get(j, centerI)) {\n                stateCount[2]++;\n                j++;\n            }\n            if (j === maxJ) {\n                return NaN;\n            }\n            while (j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount) {\n                stateCount[3]++;\n                j++;\n            }\n            if (j === maxJ || stateCount[3] >= maxCount) {\n                return NaN;\n            }\n            while (j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount) {\n                stateCount[4]++;\n                j++;\n            }\n            if (stateCount[4] >= maxCount) {\n                return NaN;\n            }\n            // If we found a finder-pattern-like section, but its size is significantly different than\n            // the original, assume it's a false positive\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +\n                stateCount[4];\n            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {\n                return NaN;\n            }\n            return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, j) : NaN;\n        }\n        /**\n         * <p>This is called when a horizontal scan finds a possible alignment pattern. It will\n         * cross check with a vertical scan, and if successful, will, ah, cross-cross-check\n         * with another horizontal scan. This is needed primarily to locate the real horizontal\n         * center of the pattern in cases of extreme skew.\n         * And then we cross-cross-cross check with another diagonal scan.</p>\n         *\n         * <p>If that succeeds the finder pattern location is added to a list that tracks\n         * the number of times each location has been nearly-matched as a finder pattern.\n         * Each additional find is more evidence that the location is in fact a finder\n         * pattern center\n         *\n         * @param stateCount reading state module counts from horizontal scan\n         * @param i row where finder pattern may be found\n         * @param j end of possible finder pattern in row\n         * @param pureBarcode true if in \"pure barcode\" mode\n         * @return true if a finder pattern candidate was found this time\n         */\n        handlePossibleCenter(stateCount, i /*int*/, j /*int*/, pureBarcode) {\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +\n                stateCount[4];\n            let centerJ = FinderPatternFinder.centerFromEnd(stateCount, j);\n            let centerI = this.crossCheckVertical(i, /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal);\n            if (!isNaN(centerI)) {\n                // Re-cross check\n                centerJ = this.crossCheckHorizontal(/*(int) */ Math.floor(centerJ), /*(int) */ Math.floor(centerI), stateCount[2], stateCountTotal);\n                if (!isNaN(centerJ) &&\n                    (!pureBarcode || this.crossCheckDiagonal(/*(int) */ Math.floor(centerI), /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal))) {\n                    const estimatedModuleSize = stateCountTotal / 7.0;\n                    let found = false;\n                    const possibleCenters = this.possibleCenters;\n                    for (let index = 0, length = possibleCenters.length; index < length; index++) {\n                        const center = possibleCenters[index];\n                        // Look for about the same center and module size:\n                        if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n                            possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        const point = new FinderPattern$1(centerJ, centerI, estimatedModuleSize);\n                        possibleCenters.push(point);\n                        if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {\n                            this.resultPointCallback.foundPossibleResultPoint(point);\n                        }\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n        /**\n         * @return number of rows we could safely skip during scanning, based on the first\n         *         two finder patterns that have been located. In some cases their position will\n         *         allow us to infer that the third pattern must lie below a certain point farther\n         *         down in the image.\n         */\n        findRowSkip() {\n            const max = this.possibleCenters.length;\n            if (max <= 1) {\n                return 0;\n            }\n            let firstConfirmedCenter = null;\n            for (const center of this.possibleCenters) {\n                if (center.getCount() >= FinderPatternFinder.CENTER_QUORUM) {\n                    if (firstConfirmedCenter == null) {\n                        firstConfirmedCenter = center;\n                    }\n                    else {\n                        // We have two confirmed centers\n                        // How far down can we skip before resuming looking for the next\n                        // pattern? In the worst case, only the difference between the\n                        // difference in the x / y coordinates of the two centers.\n                        // This is the case where you find top left last.\n                        this.hasSkipped = true;\n                        return /*(int) */ Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) -\n                            Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2);\n                    }\n                }\n            }\n            return 0;\n        }\n        /**\n         * @return true iff we have found at least 3 finder patterns that have been detected\n         *         at least {@link #CENTER_QUORUM} times each, and, the estimated module size of the\n         *         candidates is \"pretty similar\"\n         */\n        haveMultiplyConfirmedCenters() {\n            let confirmedCount = 0;\n            let totalModuleSize = 0.0;\n            const max = this.possibleCenters.length;\n            for (const pattern of this.possibleCenters) {\n                if (pattern.getCount() >= FinderPatternFinder.CENTER_QUORUM) {\n                    confirmedCount++;\n                    totalModuleSize += pattern.getEstimatedModuleSize();\n                }\n            }\n            if (confirmedCount < 3) {\n                return false;\n            }\n            // OK, we have at least 3 confirmed centers, but, it's possible that one is a \"false positive\"\n            // and that we need to keep looking. We detect this by asking if the estimated module sizes\n            // vary too much. We arbitrarily say that when the total deviation from average exceeds\n            // 5% of the total module size estimates, it's too much.\n            const average = totalModuleSize / max;\n            let totalDeviation = 0.0;\n            for (const pattern of this.possibleCenters) {\n                totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);\n            }\n            return totalDeviation <= 0.05 * totalModuleSize;\n        }\n        /**\n         * @return the 3 best {@link FinderPattern}s from our list of candidates. The \"best\" are\n         *         those that have been detected at least {@link #CENTER_QUORUM} times, and whose module\n         *         size differs from the average among those patterns the least\n         * @throws NotFoundException if 3 such finder patterns do not exist\n         */\n        selectBestPatterns() {\n            const startSize = this.possibleCenters.length;\n            if (startSize < 3) {\n                // Couldn't find enough finder patterns\n                throw new NotFoundException();\n            }\n            const possibleCenters = this.possibleCenters;\n            let average;\n            // Filter outlier possibilities whose module size is too different\n            if (startSize > 3) {\n                // But we can only afford to do so if we have at least 4 possibilities to choose from\n                let totalModuleSize = 0.0;\n                let square = 0.0;\n                for (const center of this.possibleCenters) {\n                    const size = center.getEstimatedModuleSize();\n                    totalModuleSize += size;\n                    square += size * size;\n                }\n                average = totalModuleSize / startSize;\n                let stdDev = Math.sqrt(square / startSize - average * average);\n                possibleCenters.sort(\n                /**\n                 * <p>Orders by furthest from average</p>\n                 */\n                // FurthestFromAverageComparator implements Comparator<FinderPattern>\n                (center1, center2) => {\n                    const dA = Math.abs(center2.getEstimatedModuleSize() - average);\n                    const dB = Math.abs(center1.getEstimatedModuleSize() - average);\n                    return dA < dB ? -1 : dA > dB ? 1 : 0;\n                });\n                const limit = Math.max(0.2 * average, stdDev);\n                for (let i = 0; i < possibleCenters.length && possibleCenters.length > 3; i++) {\n                    const pattern = possibleCenters[i];\n                    if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {\n                        possibleCenters.splice(i, 1);\n                        i--;\n                    }\n                }\n            }\n            if (possibleCenters.length > 3) {\n                // Throw away all but those first size candidate points we found.\n                let totalModuleSize = 0.0;\n                for (const possibleCenter of possibleCenters) {\n                    totalModuleSize += possibleCenter.getEstimatedModuleSize();\n                }\n                average = totalModuleSize / possibleCenters.length;\n                possibleCenters.sort(\n                /**\n                 * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>\n                 */\n                // CenterComparator implements Comparator<FinderPattern>\n                (center1, center2) => {\n                    if (center2.getCount() === center1.getCount()) {\n                        const dA = Math.abs(center2.getEstimatedModuleSize() - average);\n                        const dB = Math.abs(center1.getEstimatedModuleSize() - average);\n                        return dA < dB ? 1 : dA > dB ? -1 : 0;\n                    }\n                    else {\n                        return center2.getCount() - center1.getCount();\n                    }\n                });\n                possibleCenters.splice(3); // this is not realy necessary as we only return first 3 anyway\n            }\n            return [\n                possibleCenters[0],\n                possibleCenters[1],\n                possibleCenters[2]\n            ];\n        }\n    }\n    FinderPatternFinder.CENTER_QUORUM = 2;\n    FinderPatternFinder.MIN_SKIP = 3; // 1 pixel/module times 3 modules/center\n    FinderPatternFinder.MAX_MODULES = 57; // support up to version 10 for mobile clients\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*import java.util.Map;*/\n    /**\n     * <p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code\n     * is rotated or skewed, or partially obscured.</p>\n     *\n     * @author Sean Owen\n     */\n    class Detector$2 {\n        constructor(image) {\n            this.image = image;\n        }\n        getImage() {\n            return this.image;\n        }\n        getResultPointCallback() {\n            return this.resultPointCallback;\n        }\n        /**\n         * <p>Detects a QR Code in an image.</p>\n         *\n         * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n         * @throws NotFoundException if QR Code cannot be found\n         * @throws FormatException if a QR Code cannot be decoded\n         */\n        // public detect(): DetectorResult /*throws NotFoundException, FormatException*/ {\n        //   return detect(null)\n        // }\n        /**\n         * <p>Detects a QR Code in an image.</p>\n         *\n         * @param hints optional hints to detector\n         * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n         * @throws NotFoundException if QR Code cannot be found\n         * @throws FormatException if a QR Code cannot be decoded\n         */\n        detect(hints) {\n            this.resultPointCallback = (hints === null || hints === undefined) ? null :\n                /*(ResultPointCallback) */ hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);\n            const finder = new FinderPatternFinder(this.image, this.resultPointCallback);\n            const info = finder.find(hints);\n            return this.processFinderPatternInfo(info);\n        }\n        processFinderPatternInfo(info) {\n            const topLeft = info.getTopLeft();\n            const topRight = info.getTopRight();\n            const bottomLeft = info.getBottomLeft();\n            const moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);\n            if (moduleSize < 1.0) {\n                throw new NotFoundException('No pattern found in proccess finder.');\n            }\n            const dimension = Detector$2.computeDimension(topLeft, topRight, bottomLeft, moduleSize);\n            const provisionalVersion = Version$1.getProvisionalVersionForDimension(dimension);\n            const modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;\n            let alignmentPattern = null;\n            // Anything above version 1 has an alignment pattern\n            if (provisionalVersion.getAlignmentPatternCenters().length > 0) {\n                // Guess where a \"bottom right\" finder pattern would have been\n                const bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();\n                const bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();\n                // Estimate that alignment pattern is closer by 3 modules\n                // from \"bottom right\" to known top left location\n                const correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;\n                const estAlignmentX = /*(int) */ Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));\n                const estAlignmentY = /*(int) */ Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));\n                // Kind of arbitrary -- expand search radius before giving up\n                for (let i = 4; i <= 16; i <<= 1) {\n                    try {\n                        alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);\n                        break;\n                    }\n                    catch (re /*NotFoundException*/) {\n                        if (!(re instanceof NotFoundException)) {\n                            throw re;\n                        }\n                        // try next round\n                    }\n                }\n                // If we didn't find alignment pattern... well try anyway without it\n            }\n            const transform = Detector$2.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);\n            const bits = Detector$2.sampleGrid(this.image, transform, dimension);\n            let points;\n            if (alignmentPattern === null) {\n                points = [bottomLeft, topLeft, topRight];\n            }\n            else {\n                points = [bottomLeft, topLeft, topRight, alignmentPattern];\n            }\n            return new DetectorResult(bits, points);\n        }\n        static createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension /*int*/) {\n            const dimMinusThree = dimension - 3.5;\n            let bottomRightX; /*float*/\n            let bottomRightY; /*float*/\n            let sourceBottomRightX; /*float*/\n            let sourceBottomRightY; /*float*/\n            if (alignmentPattern !== null) {\n                bottomRightX = alignmentPattern.getX();\n                bottomRightY = alignmentPattern.getY();\n                sourceBottomRightX = dimMinusThree - 3.0;\n                sourceBottomRightY = sourceBottomRightX;\n            }\n            else {\n                // Don't have an alignment pattern, just make up the bottom-right point\n                bottomRightX = (topRight.getX() - topLeft.getX()) + bottomLeft.getX();\n                bottomRightY = (topRight.getY() - topLeft.getY()) + bottomLeft.getY();\n                sourceBottomRightX = dimMinusThree;\n                sourceBottomRightY = dimMinusThree;\n            }\n            return PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());\n        }\n        static sampleGrid(image, transform, dimension /*int*/) {\n            const sampler = GridSamplerInstance.getInstance();\n            return sampler.sampleGridWithTransform(image, dimension, dimension, transform);\n        }\n        /**\n         * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position\n         * of the finder patterns and estimated module size.</p>\n         */\n        static computeDimension(topLeft, topRight, bottomLeft, moduleSize /*float*/) {\n            const tltrCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, topRight) / moduleSize);\n            const tlblCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, bottomLeft) / moduleSize);\n            let dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;\n            switch (dimension & 0x03) { // mod 4\n                case 0:\n                    dimension++;\n                    break;\n                // 1? do nothing\n                case 2:\n                    dimension--;\n                    break;\n                case 3:\n                    throw new NotFoundException('Dimensions could be not found.');\n            }\n            return dimension;\n        }\n        /**\n         * <p>Computes an average estimated module size based on estimated derived from the positions\n         * of the three finder patterns.</p>\n         *\n         * @param topLeft detected top-left finder pattern center\n         * @param topRight detected top-right finder pattern center\n         * @param bottomLeft detected bottom-left finder pattern center\n         * @return estimated module size\n         */\n        calculateModuleSize(topLeft, topRight, bottomLeft) {\n            // Take the average\n            return (this.calculateModuleSizeOneWay(topLeft, topRight) +\n                this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;\n        }\n        /**\n         * <p>Estimates module size based on two finder patterns -- it uses\n         * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the\n         * width of each, measuring along the axis between their centers.</p>\n         */\n        calculateModuleSizeOneWay(pattern, otherPattern) {\n            const moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(pattern.getX()), \n            /*(int) */ Math.floor(pattern.getY()), \n            /*(int) */ Math.floor(otherPattern.getX()), \n            /*(int) */ Math.floor(otherPattern.getY()));\n            const moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(otherPattern.getX()), \n            /*(int) */ Math.floor(otherPattern.getY()), \n            /*(int) */ Math.floor(pattern.getX()), \n            /*(int) */ Math.floor(pattern.getY()));\n            if (isNaN(moduleSizeEst1)) {\n                return moduleSizeEst2 / 7.0;\n            }\n            if (isNaN(moduleSizeEst2)) {\n                return moduleSizeEst1 / 7.0;\n            }\n            // Average them, and divide by 7 since we've counted the width of 3 black modules,\n            // and 1 white and 1 black module on either side. Ergo, divide sum by 14.\n            return (moduleSizeEst1 + moduleSizeEst2) / 14.0;\n        }\n        /**\n         * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of\n         * a finder pattern by looking for a black-white-black run from the center in the direction\n         * of another point (another finder pattern center), and in the opposite direction too.\n         */\n        sizeOfBlackWhiteBlackRunBothWays(fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {\n            let result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);\n            // Now count other way -- don't run off image though of course\n            let scale = 1.0;\n            let otherToX = fromX - (toX - fromX);\n            if (otherToX < 0) {\n                scale = fromX / /*(float) */ (fromX - otherToX);\n                otherToX = 0;\n            }\n            else if (otherToX >= this.image.getWidth()) {\n                scale = (this.image.getWidth() - 1 - fromX) / /*(float) */ (otherToX - fromX);\n                otherToX = this.image.getWidth() - 1;\n            }\n            let otherToY = /*(int) */ Math.floor(fromY - (toY - fromY) * scale);\n            scale = 1.0;\n            if (otherToY < 0) {\n                scale = fromY / /*(float) */ (fromY - otherToY);\n                otherToY = 0;\n            }\n            else if (otherToY >= this.image.getHeight()) {\n                scale = (this.image.getHeight() - 1 - fromY) / /*(float) */ (otherToY - fromY);\n                otherToY = this.image.getHeight() - 1;\n            }\n            otherToX = /*(int) */ Math.floor(fromX + (otherToX - fromX) * scale);\n            result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);\n            // Middle pixel is double-counted this way; subtract 1\n            return result - 1.0;\n        }\n        /**\n         * <p>This method traces a line from a point in the image, in the direction towards another point.\n         * It begins in a black region, and keeps going until it finds white, then black, then white again.\n         * It reports the distance from the start to this point.</p>\n         *\n         * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern\n         * may be skewed or rotated.</p>\n         */\n        sizeOfBlackWhiteBlackRun(fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {\n            // Mild variant of Bresenham's algorithm\n            // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm\n            const steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n            if (steep) {\n                let temp = fromX;\n                fromX = fromY;\n                fromY = temp;\n                temp = toX;\n                toX = toY;\n                toY = temp;\n            }\n            const dx = Math.abs(toX - fromX);\n            const dy = Math.abs(toY - fromY);\n            let error = -dx / 2;\n            const xstep = fromX < toX ? 1 : -1;\n            const ystep = fromY < toY ? 1 : -1;\n            // In black pixels, looking for white, first or second time.\n            let state = 0;\n            // Loop up until x == toX, but not beyond\n            const xLimit = toX + xstep;\n            for (let x = fromX, y = fromY; x !== xLimit; x += xstep) {\n                const realX = steep ? y : x;\n                const realY = steep ? x : y;\n                // Does current pixel mean we have moved white to black or vice versa?\n                // Scanning black in state 0,2 and white in state 1, so if we find the wrong\n                // color, advance to next state or end if we are in state 2 already\n                if ((state === 1) === this.image.get(realX, realY)) {\n                    if (state === 2) {\n                        return MathUtils.distance(x, y, fromX, fromY);\n                    }\n                    state++;\n                }\n                error += dy;\n                if (error > 0) {\n                    if (y === toY) {\n                        break;\n                    }\n                    y += ystep;\n                    error -= dx;\n                }\n            }\n            // Found black-white-black; give the benefit of the doubt that the next pixel outside the image\n            // is \"white\" so this last point at (toX+xStep,toY) is the right ending. This is really a\n            // small approximation; (toX+xStep,toY+yStep) might be really correct. Ignore this.\n            if (state === 2) {\n                return MathUtils.distance(toX + xstep, toY, fromX, fromY);\n            }\n            // else we didn't find even black-white-black; no estimate is really possible\n            return NaN;\n        }\n        /**\n         * <p>Attempts to locate an alignment pattern in a limited region of the image, which is\n         * guessed to contain it. This method uses {@link AlignmentPattern}.</p>\n         *\n         * @param overallEstModuleSize estimated module size so far\n         * @param estAlignmentX x coordinate of center of area probably containing alignment pattern\n         * @param estAlignmentY y coordinate of above\n         * @param allowanceFactor number of pixels in all directions to search from the center\n         * @return {@link AlignmentPattern} if found, or null otherwise\n         * @throws NotFoundException if an unexpected error occurs during detection\n         */\n        findAlignmentInRegion(overallEstModuleSize /*float*/, estAlignmentX /*int*/, estAlignmentY /*int*/, allowanceFactor /*float*/) {\n            // Look for an alignment pattern (3 modules in size) around where it\n            // should be\n            const allowance = /*(int) */ Math.floor(allowanceFactor * overallEstModuleSize);\n            const alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);\n            const alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);\n            if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {\n                throw new NotFoundException('Alignment top exceeds estimated module size.');\n            }\n            const alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);\n            const alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);\n            if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {\n                throw new NotFoundException('Alignment bottom exceeds estimated module size.');\n            }\n            const alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);\n            return alignmentFinder.find();\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*import java.util.List;*/\n    /*import java.util.Map;*/\n    /**\n     * This implementation can detect and decode QR Codes in an image.\n     *\n     * @author Sean Owen\n     */\n    class QRCodeReader {\n        constructor() {\n            this.decoder = new Decoder$2();\n        }\n        getDecoder() {\n            return this.decoder;\n        }\n        /**\n         * Locates and decodes a QR code in an image.\n         *\n         * @return a representing: string the content encoded by the QR code\n         * @throws NotFoundException if a QR code cannot be found\n         * @throws FormatException if a QR code cannot be decoded\n         * @throws ChecksumException if error correction fails\n         */\n        /*@Override*/\n        // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {\n        //   return this.decode(image, null)\n        // }\n        /*@Override*/\n        decode(image, hints) {\n            let decoderResult;\n            let points;\n            if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType$1.PURE_BARCODE)) {\n                const bits = QRCodeReader.extractPureBits(image.getBlackMatrix());\n                decoderResult = this.decoder.decodeBitMatrix(bits, hints);\n                points = QRCodeReader.NO_POINTS;\n            }\n            else {\n                const detectorResult = new Detector$2(image.getBlackMatrix()).detect(hints);\n                decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);\n                points = detectorResult.getPoints();\n            }\n            // If the code was mirrored: swap the bottom-left and the top-right points.\n            if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {\n                decoderResult.getOther().applyMirroredCorrection(points);\n            }\n            const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat$1.QR_CODE, undefined);\n            const byteSegments = decoderResult.getByteSegments();\n            if (byteSegments !== null) {\n                result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);\n            }\n            const ecLevel = decoderResult.getECLevel();\n            if (ecLevel !== null) {\n                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);\n            }\n            if (decoderResult.hasStructuredAppend()) {\n                result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());\n                result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());\n            }\n            return result;\n        }\n        /*@Override*/\n        reset() {\n            // do nothing\n        }\n        /**\n         * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n         * which contains only an unrotated, unskewed, image of a code, with some white border\n         * around it. This is a specialized method that works exceptionally fast in this special\n         * case.\n         *\n         * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)\n         */\n        static extractPureBits(image) {\n            const leftTopBlack = image.getTopLeftOnBit();\n            const rightBottomBlack = image.getBottomRightOnBit();\n            if (leftTopBlack === null || rightBottomBlack === null) {\n                throw new NotFoundException();\n            }\n            const moduleSize = this.moduleSize(leftTopBlack, image);\n            let top = leftTopBlack[1];\n            let bottom = rightBottomBlack[1];\n            let left = leftTopBlack[0];\n            let right = rightBottomBlack[0];\n            // Sanity check!\n            if (left >= right || top >= bottom) {\n                throw new NotFoundException();\n            }\n            if (bottom - top !== right - left) {\n                // Special case, where bottom-right module wasn't black so we found something else in the last row\n                // Assume it's a square, so use height as the width\n                right = left + (bottom - top);\n                if (right >= image.getWidth()) {\n                    // Abort if that would not make sense -- off image\n                    throw new NotFoundException();\n                }\n            }\n            const matrixWidth = Math.round((right - left + 1) / moduleSize);\n            const matrixHeight = Math.round((bottom - top + 1) / moduleSize);\n            if (matrixWidth <= 0 || matrixHeight <= 0) {\n                throw new NotFoundException();\n            }\n            if (matrixHeight !== matrixWidth) {\n                // Only possibly decode square regions\n                throw new NotFoundException();\n            }\n            // Push in the \"border\" by half the module width so that we start\n            // sampling in the middle of the module. Just in case the image is a\n            // little off, this will help recover.\n            const nudge = /*(int) */ Math.floor(moduleSize / 2.0);\n            top += nudge;\n            left += nudge;\n            // But careful that this does not sample off the edge\n            // \"right\" is the farthest-right valid pixel location -- right+1 is not necessarily\n            // This is positive by how much the inner x loop below would be too large\n            const nudgedTooFarRight = left + /*(int) */ Math.floor((matrixWidth - 1) * moduleSize) - right;\n            if (nudgedTooFarRight > 0) {\n                if (nudgedTooFarRight > nudge) {\n                    // Neither way fits; abort\n                    throw new NotFoundException();\n                }\n                left -= nudgedTooFarRight;\n            }\n            // See logic above\n            const nudgedTooFarDown = top + /*(int) */ Math.floor((matrixHeight - 1) * moduleSize) - bottom;\n            if (nudgedTooFarDown > 0) {\n                if (nudgedTooFarDown > nudge) {\n                    // Neither way fits; abort\n                    throw new NotFoundException();\n                }\n                top -= nudgedTooFarDown;\n            }\n            // Now just read off the bits\n            const bits = new BitMatrix(matrixWidth, matrixHeight);\n            for (let y = 0; y < matrixHeight; y++) {\n                const iOffset = top + /*(int) */ Math.floor(y * moduleSize);\n                for (let x = 0; x < matrixWidth; x++) {\n                    if (image.get(left + /*(int) */ Math.floor(x * moduleSize), iOffset)) {\n                        bits.set(x, y);\n                    }\n                }\n            }\n            return bits;\n        }\n        static moduleSize(leftTopBlack, image) {\n            const height = image.getHeight();\n            const width = image.getWidth();\n            let x = leftTopBlack[0];\n            let y = leftTopBlack[1];\n            let inBlack = true;\n            let transitions = 0;\n            while (x < width && y < height) {\n                if (inBlack !== image.get(x, y)) {\n                    if (++transitions === 5) {\n                        break;\n                    }\n                    inBlack = !inBlack;\n                }\n                x++;\n                y++;\n            }\n            if (x === width || y === height) {\n                throw new NotFoundException();\n            }\n            return (x - leftTopBlack[0]) / 7.0;\n        }\n    }\n    QRCodeReader.NO_POINTS = new Array();\n\n    /*\n    * Copyright 2009 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /**\n     * @author SITA Lab (kevin.osullivan@sita.aero)\n     * @author Guenther Grau\n     */\n    /*public final*/ class PDF417Common {\n        PDF417Common() {\n        }\n        /**\n         * @param moduleBitCount values to sum\n         * @return sum of values\n         * @deprecated call {@link MathUtils#sum(int[])}\n         */\n        // @Deprecated\n        static getBitCountSum(moduleBitCount) {\n            return MathUtils.sum(moduleBitCount);\n        }\n        static toIntArray(list) {\n            if (list == null || !list.length) {\n                return PDF417Common.EMPTY_INT_ARRAY;\n            }\n            const result = new Int32Array(list.length);\n            let i = 0;\n            for (const integer of list) {\n                result[i++] = integer;\n            }\n            return result;\n        }\n        /**\n         * @param symbol encoded symbol to translate to a codeword\n         * @return the codeword corresponding to the symbol.\n         */\n        static getCodeword(symbol /*int*/) {\n            const i = Arrays.binarySearch(PDF417Common.SYMBOL_TABLE, symbol & 0x3FFFF);\n            if (i < 0) {\n                return -1;\n            }\n            return (PDF417Common.CODEWORD_TABLE[i] - 1) % PDF417Common.NUMBER_OF_CODEWORDS;\n        }\n    }\n    PDF417Common.NUMBER_OF_CODEWORDS = 929;\n    // Maximum Codewords (Data + Error).\n    PDF417Common.MAX_CODEWORDS_IN_BARCODE = PDF417Common.NUMBER_OF_CODEWORDS - 1;\n    PDF417Common.MIN_ROWS_IN_BARCODE = 3;\n    PDF417Common.MAX_ROWS_IN_BARCODE = 90;\n    // One left row indication column + max 30 data columns + one right row indicator column\n    // public static /*final*/ MAX_CODEWORDS_IN_ROW: /*int*/ number = 32;\n    PDF417Common.MODULES_IN_CODEWORD = 17;\n    PDF417Common.MODULES_IN_STOP_PATTERN = 18;\n    PDF417Common.BARS_IN_MODULE = 8;\n    PDF417Common.EMPTY_INT_ARRAY = new Int32Array([]);\n    /**\n     * The sorted table of all possible symbols. Extracted from the PDF417\n     * specification. The index of a symbol in this table corresponds to the\n     * index into the codeword table.\n     */\n    PDF417Common.SYMBOL_TABLE = Int32Array.from([\n        0x1025e, 0x1027a, 0x1029e, 0x102bc, 0x102f2, 0x102f4, 0x1032e, 0x1034e, 0x1035c, 0x10396, 0x103a6, 0x103ac,\n        0x10422, 0x10428, 0x10436, 0x10442, 0x10444, 0x10448, 0x10450, 0x1045e, 0x10466, 0x1046c, 0x1047a, 0x10482,\n        0x1049e, 0x104a0, 0x104bc, 0x104c6, 0x104d8, 0x104ee, 0x104f2, 0x104f4, 0x10504, 0x10508, 0x10510, 0x1051e,\n        0x10520, 0x1053c, 0x10540, 0x10578, 0x10586, 0x1058c, 0x10598, 0x105b0, 0x105be, 0x105ce, 0x105dc, 0x105e2,\n        0x105e4, 0x105e8, 0x105f6, 0x1062e, 0x1064e, 0x1065c, 0x1068e, 0x1069c, 0x106b8, 0x106de, 0x106fa, 0x10716,\n        0x10726, 0x1072c, 0x10746, 0x1074c, 0x10758, 0x1076e, 0x10792, 0x10794, 0x107a2, 0x107a4, 0x107a8, 0x107b6,\n        0x10822, 0x10828, 0x10842, 0x10848, 0x10850, 0x1085e, 0x10866, 0x1086c, 0x1087a, 0x10882, 0x10884, 0x10890,\n        0x1089e, 0x108a0, 0x108bc, 0x108c6, 0x108cc, 0x108d8, 0x108ee, 0x108f2, 0x108f4, 0x10902, 0x10908, 0x1091e,\n        0x10920, 0x1093c, 0x10940, 0x10978, 0x10986, 0x10998, 0x109b0, 0x109be, 0x109ce, 0x109dc, 0x109e2, 0x109e4,\n        0x109e8, 0x109f6, 0x10a08, 0x10a10, 0x10a1e, 0x10a20, 0x10a3c, 0x10a40, 0x10a78, 0x10af0, 0x10b06, 0x10b0c,\n        0x10b18, 0x10b30, 0x10b3e, 0x10b60, 0x10b7c, 0x10b8e, 0x10b9c, 0x10bb8, 0x10bc2, 0x10bc4, 0x10bc8, 0x10bd0,\n        0x10bde, 0x10be6, 0x10bec, 0x10c2e, 0x10c4e, 0x10c5c, 0x10c62, 0x10c64, 0x10c68, 0x10c76, 0x10c8e, 0x10c9c,\n        0x10cb8, 0x10cc2, 0x10cc4, 0x10cc8, 0x10cd0, 0x10cde, 0x10ce6, 0x10cec, 0x10cfa, 0x10d0e, 0x10d1c, 0x10d38,\n        0x10d70, 0x10d7e, 0x10d82, 0x10d84, 0x10d88, 0x10d90, 0x10d9e, 0x10da0, 0x10dbc, 0x10dc6, 0x10dcc, 0x10dd8,\n        0x10dee, 0x10df2, 0x10df4, 0x10e16, 0x10e26, 0x10e2c, 0x10e46, 0x10e58, 0x10e6e, 0x10e86, 0x10e8c, 0x10e98,\n        0x10eb0, 0x10ebe, 0x10ece, 0x10edc, 0x10f0a, 0x10f12, 0x10f14, 0x10f22, 0x10f28, 0x10f36, 0x10f42, 0x10f44,\n        0x10f48, 0x10f50, 0x10f5e, 0x10f66, 0x10f6c, 0x10fb2, 0x10fb4, 0x11022, 0x11028, 0x11042, 0x11048, 0x11050,\n        0x1105e, 0x1107a, 0x11082, 0x11084, 0x11090, 0x1109e, 0x110a0, 0x110bc, 0x110c6, 0x110cc, 0x110d8, 0x110ee,\n        0x110f2, 0x110f4, 0x11102, 0x1111e, 0x11120, 0x1113c, 0x11140, 0x11178, 0x11186, 0x11198, 0x111b0, 0x111be,\n        0x111ce, 0x111dc, 0x111e2, 0x111e4, 0x111e8, 0x111f6, 0x11208, 0x1121e, 0x11220, 0x11278, 0x112f0, 0x1130c,\n        0x11330, 0x1133e, 0x11360, 0x1137c, 0x1138e, 0x1139c, 0x113b8, 0x113c2, 0x113c8, 0x113d0, 0x113de, 0x113e6,\n        0x113ec, 0x11408, 0x11410, 0x1141e, 0x11420, 0x1143c, 0x11440, 0x11478, 0x114f0, 0x115e0, 0x1160c, 0x11618,\n        0x11630, 0x1163e, 0x11660, 0x1167c, 0x116c0, 0x116f8, 0x1171c, 0x11738, 0x11770, 0x1177e, 0x11782, 0x11784,\n        0x11788, 0x11790, 0x1179e, 0x117a0, 0x117bc, 0x117c6, 0x117cc, 0x117d8, 0x117ee, 0x1182e, 0x11834, 0x1184e,\n        0x1185c, 0x11862, 0x11864, 0x11868, 0x11876, 0x1188e, 0x1189c, 0x118b8, 0x118c2, 0x118c8, 0x118d0, 0x118de,\n        0x118e6, 0x118ec, 0x118fa, 0x1190e, 0x1191c, 0x11938, 0x11970, 0x1197e, 0x11982, 0x11984, 0x11990, 0x1199e,\n        0x119a0, 0x119bc, 0x119c6, 0x119cc, 0x119d8, 0x119ee, 0x119f2, 0x119f4, 0x11a0e, 0x11a1c, 0x11a38, 0x11a70,\n        0x11a7e, 0x11ae0, 0x11afc, 0x11b08, 0x11b10, 0x11b1e, 0x11b20, 0x11b3c, 0x11b40, 0x11b78, 0x11b8c, 0x11b98,\n        0x11bb0, 0x11bbe, 0x11bce, 0x11bdc, 0x11be2, 0x11be4, 0x11be8, 0x11bf6, 0x11c16, 0x11c26, 0x11c2c, 0x11c46,\n        0x11c4c, 0x11c58, 0x11c6e, 0x11c86, 0x11c98, 0x11cb0, 0x11cbe, 0x11cce, 0x11cdc, 0x11ce2, 0x11ce4, 0x11ce8,\n        0x11cf6, 0x11d06, 0x11d0c, 0x11d18, 0x11d30, 0x11d3e, 0x11d60, 0x11d7c, 0x11d8e, 0x11d9c, 0x11db8, 0x11dc4,\n        0x11dc8, 0x11dd0, 0x11dde, 0x11de6, 0x11dec, 0x11dfa, 0x11e0a, 0x11e12, 0x11e14, 0x11e22, 0x11e24, 0x11e28,\n        0x11e36, 0x11e42, 0x11e44, 0x11e50, 0x11e5e, 0x11e66, 0x11e6c, 0x11e82, 0x11e84, 0x11e88, 0x11e90, 0x11e9e,\n        0x11ea0, 0x11ebc, 0x11ec6, 0x11ecc, 0x11ed8, 0x11eee, 0x11f1a, 0x11f2e, 0x11f32, 0x11f34, 0x11f4e, 0x11f5c,\n        0x11f62, 0x11f64, 0x11f68, 0x11f76, 0x12048, 0x1205e, 0x12082, 0x12084, 0x12090, 0x1209e, 0x120a0, 0x120bc,\n        0x120d8, 0x120f2, 0x120f4, 0x12108, 0x1211e, 0x12120, 0x1213c, 0x12140, 0x12178, 0x12186, 0x12198, 0x121b0,\n        0x121be, 0x121e2, 0x121e4, 0x121e8, 0x121f6, 0x12204, 0x12210, 0x1221e, 0x12220, 0x12278, 0x122f0, 0x12306,\n        0x1230c, 0x12330, 0x1233e, 0x12360, 0x1237c, 0x1238e, 0x1239c, 0x123b8, 0x123c2, 0x123c8, 0x123d0, 0x123e6,\n        0x123ec, 0x1241e, 0x12420, 0x1243c, 0x124f0, 0x125e0, 0x12618, 0x1263e, 0x12660, 0x1267c, 0x126c0, 0x126f8,\n        0x12738, 0x12770, 0x1277e, 0x12782, 0x12784, 0x12790, 0x1279e, 0x127a0, 0x127bc, 0x127c6, 0x127cc, 0x127d8,\n        0x127ee, 0x12820, 0x1283c, 0x12840, 0x12878, 0x128f0, 0x129e0, 0x12bc0, 0x12c18, 0x12c30, 0x12c3e, 0x12c60,\n        0x12c7c, 0x12cc0, 0x12cf8, 0x12df0, 0x12e1c, 0x12e38, 0x12e70, 0x12e7e, 0x12ee0, 0x12efc, 0x12f04, 0x12f08,\n        0x12f10, 0x12f20, 0x12f3c, 0x12f40, 0x12f78, 0x12f86, 0x12f8c, 0x12f98, 0x12fb0, 0x12fbe, 0x12fce, 0x12fdc,\n        0x1302e, 0x1304e, 0x1305c, 0x13062, 0x13068, 0x1308e, 0x1309c, 0x130b8, 0x130c2, 0x130c8, 0x130d0, 0x130de,\n        0x130ec, 0x130fa, 0x1310e, 0x13138, 0x13170, 0x1317e, 0x13182, 0x13184, 0x13190, 0x1319e, 0x131a0, 0x131bc,\n        0x131c6, 0x131cc, 0x131d8, 0x131f2, 0x131f4, 0x1320e, 0x1321c, 0x13270, 0x1327e, 0x132e0, 0x132fc, 0x13308,\n        0x1331e, 0x13320, 0x1333c, 0x13340, 0x13378, 0x13386, 0x13398, 0x133b0, 0x133be, 0x133ce, 0x133dc, 0x133e2,\n        0x133e4, 0x133e8, 0x133f6, 0x1340e, 0x1341c, 0x13438, 0x13470, 0x1347e, 0x134e0, 0x134fc, 0x135c0, 0x135f8,\n        0x13608, 0x13610, 0x1361e, 0x13620, 0x1363c, 0x13640, 0x13678, 0x136f0, 0x1370c, 0x13718, 0x13730, 0x1373e,\n        0x13760, 0x1377c, 0x1379c, 0x137b8, 0x137c2, 0x137c4, 0x137c8, 0x137d0, 0x137de, 0x137e6, 0x137ec, 0x13816,\n        0x13826, 0x1382c, 0x13846, 0x1384c, 0x13858, 0x1386e, 0x13874, 0x13886, 0x13898, 0x138b0, 0x138be, 0x138ce,\n        0x138dc, 0x138e2, 0x138e4, 0x138e8, 0x13906, 0x1390c, 0x13930, 0x1393e, 0x13960, 0x1397c, 0x1398e, 0x1399c,\n        0x139b8, 0x139c8, 0x139d0, 0x139de, 0x139e6, 0x139ec, 0x139fa, 0x13a06, 0x13a0c, 0x13a18, 0x13a30, 0x13a3e,\n        0x13a60, 0x13a7c, 0x13ac0, 0x13af8, 0x13b0e, 0x13b1c, 0x13b38, 0x13b70, 0x13b7e, 0x13b88, 0x13b90, 0x13b9e,\n        0x13ba0, 0x13bbc, 0x13bcc, 0x13bd8, 0x13bee, 0x13bf2, 0x13bf4, 0x13c12, 0x13c14, 0x13c22, 0x13c24, 0x13c28,\n        0x13c36, 0x13c42, 0x13c48, 0x13c50, 0x13c5e, 0x13c66, 0x13c6c, 0x13c82, 0x13c84, 0x13c90, 0x13c9e, 0x13ca0,\n        0x13cbc, 0x13cc6, 0x13ccc, 0x13cd8, 0x13cee, 0x13d02, 0x13d04, 0x13d08, 0x13d10, 0x13d1e, 0x13d20, 0x13d3c,\n        0x13d40, 0x13d78, 0x13d86, 0x13d8c, 0x13d98, 0x13db0, 0x13dbe, 0x13dce, 0x13ddc, 0x13de4, 0x13de8, 0x13df6,\n        0x13e1a, 0x13e2e, 0x13e32, 0x13e34, 0x13e4e, 0x13e5c, 0x13e62, 0x13e64, 0x13e68, 0x13e76, 0x13e8e, 0x13e9c,\n        0x13eb8, 0x13ec2, 0x13ec4, 0x13ec8, 0x13ed0, 0x13ede, 0x13ee6, 0x13eec, 0x13f26, 0x13f2c, 0x13f3a, 0x13f46,\n        0x13f4c, 0x13f58, 0x13f6e, 0x13f72, 0x13f74, 0x14082, 0x1409e, 0x140a0, 0x140bc, 0x14104, 0x14108, 0x14110,\n        0x1411e, 0x14120, 0x1413c, 0x14140, 0x14178, 0x1418c, 0x14198, 0x141b0, 0x141be, 0x141e2, 0x141e4, 0x141e8,\n        0x14208, 0x14210, 0x1421e, 0x14220, 0x1423c, 0x14240, 0x14278, 0x142f0, 0x14306, 0x1430c, 0x14318, 0x14330,\n        0x1433e, 0x14360, 0x1437c, 0x1438e, 0x143c2, 0x143c4, 0x143c8, 0x143d0, 0x143e6, 0x143ec, 0x14408, 0x14410,\n        0x1441e, 0x14420, 0x1443c, 0x14440, 0x14478, 0x144f0, 0x145e0, 0x1460c, 0x14618, 0x14630, 0x1463e, 0x14660,\n        0x1467c, 0x146c0, 0x146f8, 0x1471c, 0x14738, 0x14770, 0x1477e, 0x14782, 0x14784, 0x14788, 0x14790, 0x147a0,\n        0x147bc, 0x147c6, 0x147cc, 0x147d8, 0x147ee, 0x14810, 0x14820, 0x1483c, 0x14840, 0x14878, 0x148f0, 0x149e0,\n        0x14bc0, 0x14c30, 0x14c3e, 0x14c60, 0x14c7c, 0x14cc0, 0x14cf8, 0x14df0, 0x14e38, 0x14e70, 0x14e7e, 0x14ee0,\n        0x14efc, 0x14f04, 0x14f08, 0x14f10, 0x14f1e, 0x14f20, 0x14f3c, 0x14f40, 0x14f78, 0x14f86, 0x14f8c, 0x14f98,\n        0x14fb0, 0x14fce, 0x14fdc, 0x15020, 0x15040, 0x15078, 0x150f0, 0x151e0, 0x153c0, 0x15860, 0x1587c, 0x158c0,\n        0x158f8, 0x159f0, 0x15be0, 0x15c70, 0x15c7e, 0x15ce0, 0x15cfc, 0x15dc0, 0x15df8, 0x15e08, 0x15e10, 0x15e20,\n        0x15e40, 0x15e78, 0x15ef0, 0x15f0c, 0x15f18, 0x15f30, 0x15f60, 0x15f7c, 0x15f8e, 0x15f9c, 0x15fb8, 0x1604e,\n        0x1605c, 0x1608e, 0x1609c, 0x160b8, 0x160c2, 0x160c4, 0x160c8, 0x160de, 0x1610e, 0x1611c, 0x16138, 0x16170,\n        0x1617e, 0x16184, 0x16188, 0x16190, 0x1619e, 0x161a0, 0x161bc, 0x161c6, 0x161cc, 0x161d8, 0x161f2, 0x161f4,\n        0x1620e, 0x1621c, 0x16238, 0x16270, 0x1627e, 0x162e0, 0x162fc, 0x16304, 0x16308, 0x16310, 0x1631e, 0x16320,\n        0x1633c, 0x16340, 0x16378, 0x16386, 0x1638c, 0x16398, 0x163b0, 0x163be, 0x163ce, 0x163dc, 0x163e2, 0x163e4,\n        0x163e8, 0x163f6, 0x1640e, 0x1641c, 0x16438, 0x16470, 0x1647e, 0x164e0, 0x164fc, 0x165c0, 0x165f8, 0x16610,\n        0x1661e, 0x16620, 0x1663c, 0x16640, 0x16678, 0x166f0, 0x16718, 0x16730, 0x1673e, 0x16760, 0x1677c, 0x1678e,\n        0x1679c, 0x167b8, 0x167c2, 0x167c4, 0x167c8, 0x167d0, 0x167de, 0x167e6, 0x167ec, 0x1681c, 0x16838, 0x16870,\n        0x168e0, 0x168fc, 0x169c0, 0x169f8, 0x16bf0, 0x16c10, 0x16c1e, 0x16c20, 0x16c3c, 0x16c40, 0x16c78, 0x16cf0,\n        0x16de0, 0x16e18, 0x16e30, 0x16e3e, 0x16e60, 0x16e7c, 0x16ec0, 0x16ef8, 0x16f1c, 0x16f38, 0x16f70, 0x16f7e,\n        0x16f84, 0x16f88, 0x16f90, 0x16f9e, 0x16fa0, 0x16fbc, 0x16fc6, 0x16fcc, 0x16fd8, 0x17026, 0x1702c, 0x17046,\n        0x1704c, 0x17058, 0x1706e, 0x17086, 0x1708c, 0x17098, 0x170b0, 0x170be, 0x170ce, 0x170dc, 0x170e8, 0x17106,\n        0x1710c, 0x17118, 0x17130, 0x1713e, 0x17160, 0x1717c, 0x1718e, 0x1719c, 0x171b8, 0x171c2, 0x171c4, 0x171c8,\n        0x171d0, 0x171de, 0x171e6, 0x171ec, 0x171fa, 0x17206, 0x1720c, 0x17218, 0x17230, 0x1723e, 0x17260, 0x1727c,\n        0x172c0, 0x172f8, 0x1730e, 0x1731c, 0x17338, 0x17370, 0x1737e, 0x17388, 0x17390, 0x1739e, 0x173a0, 0x173bc,\n        0x173cc, 0x173d8, 0x173ee, 0x173f2, 0x173f4, 0x1740c, 0x17418, 0x17430, 0x1743e, 0x17460, 0x1747c, 0x174c0,\n        0x174f8, 0x175f0, 0x1760e, 0x1761c, 0x17638, 0x17670, 0x1767e, 0x176e0, 0x176fc, 0x17708, 0x17710, 0x1771e,\n        0x17720, 0x1773c, 0x17740, 0x17778, 0x17798, 0x177b0, 0x177be, 0x177dc, 0x177e2, 0x177e4, 0x177e8, 0x17822,\n        0x17824, 0x17828, 0x17836, 0x17842, 0x17844, 0x17848, 0x17850, 0x1785e, 0x17866, 0x1786c, 0x17882, 0x17884,\n        0x17888, 0x17890, 0x1789e, 0x178a0, 0x178bc, 0x178c6, 0x178cc, 0x178d8, 0x178ee, 0x178f2, 0x178f4, 0x17902,\n        0x17904, 0x17908, 0x17910, 0x1791e, 0x17920, 0x1793c, 0x17940, 0x17978, 0x17986, 0x1798c, 0x17998, 0x179b0,\n        0x179be, 0x179ce, 0x179dc, 0x179e2, 0x179e4, 0x179e8, 0x179f6, 0x17a04, 0x17a08, 0x17a10, 0x17a1e, 0x17a20,\n        0x17a3c, 0x17a40, 0x17a78, 0x17af0, 0x17b06, 0x17b0c, 0x17b18, 0x17b30, 0x17b3e, 0x17b60, 0x17b7c, 0x17b8e,\n        0x17b9c, 0x17bb8, 0x17bc4, 0x17bc8, 0x17bd0, 0x17bde, 0x17be6, 0x17bec, 0x17c2e, 0x17c32, 0x17c34, 0x17c4e,\n        0x17c5c, 0x17c62, 0x17c64, 0x17c68, 0x17c76, 0x17c8e, 0x17c9c, 0x17cb8, 0x17cc2, 0x17cc4, 0x17cc8, 0x17cd0,\n        0x17cde, 0x17ce6, 0x17cec, 0x17d0e, 0x17d1c, 0x17d38, 0x17d70, 0x17d82, 0x17d84, 0x17d88, 0x17d90, 0x17d9e,\n        0x17da0, 0x17dbc, 0x17dc6, 0x17dcc, 0x17dd8, 0x17dee, 0x17e26, 0x17e2c, 0x17e3a, 0x17e46, 0x17e4c, 0x17e58,\n        0x17e6e, 0x17e72, 0x17e74, 0x17e86, 0x17e8c, 0x17e98, 0x17eb0, 0x17ece, 0x17edc, 0x17ee2, 0x17ee4, 0x17ee8,\n        0x17ef6, 0x1813a, 0x18172, 0x18174, 0x18216, 0x18226, 0x1823a, 0x1824c, 0x18258, 0x1826e, 0x18272, 0x18274,\n        0x18298, 0x182be, 0x182e2, 0x182e4, 0x182e8, 0x182f6, 0x1835e, 0x1837a, 0x183ae, 0x183d6, 0x18416, 0x18426,\n        0x1842c, 0x1843a, 0x18446, 0x18458, 0x1846e, 0x18472, 0x18474, 0x18486, 0x184b0, 0x184be, 0x184ce, 0x184dc,\n        0x184e2, 0x184e4, 0x184e8, 0x184f6, 0x18506, 0x1850c, 0x18518, 0x18530, 0x1853e, 0x18560, 0x1857c, 0x1858e,\n        0x1859c, 0x185b8, 0x185c2, 0x185c4, 0x185c8, 0x185d0, 0x185de, 0x185e6, 0x185ec, 0x185fa, 0x18612, 0x18614,\n        0x18622, 0x18628, 0x18636, 0x18642, 0x18650, 0x1865e, 0x1867a, 0x18682, 0x18684, 0x18688, 0x18690, 0x1869e,\n        0x186a0, 0x186bc, 0x186c6, 0x186cc, 0x186d8, 0x186ee, 0x186f2, 0x186f4, 0x1872e, 0x1874e, 0x1875c, 0x18796,\n        0x187a6, 0x187ac, 0x187d2, 0x187d4, 0x18826, 0x1882c, 0x1883a, 0x18846, 0x1884c, 0x18858, 0x1886e, 0x18872,\n        0x18874, 0x18886, 0x18898, 0x188b0, 0x188be, 0x188ce, 0x188dc, 0x188e2, 0x188e4, 0x188e8, 0x188f6, 0x1890c,\n        0x18930, 0x1893e, 0x18960, 0x1897c, 0x1898e, 0x189b8, 0x189c2, 0x189c8, 0x189d0, 0x189de, 0x189e6, 0x189ec,\n        0x189fa, 0x18a18, 0x18a30, 0x18a3e, 0x18a60, 0x18a7c, 0x18ac0, 0x18af8, 0x18b1c, 0x18b38, 0x18b70, 0x18b7e,\n        0x18b82, 0x18b84, 0x18b88, 0x18b90, 0x18b9e, 0x18ba0, 0x18bbc, 0x18bc6, 0x18bcc, 0x18bd8, 0x18bee, 0x18bf2,\n        0x18bf4, 0x18c22, 0x18c24, 0x18c28, 0x18c36, 0x18c42, 0x18c48, 0x18c50, 0x18c5e, 0x18c66, 0x18c7a, 0x18c82,\n        0x18c84, 0x18c90, 0x18c9e, 0x18ca0, 0x18cbc, 0x18ccc, 0x18cf2, 0x18cf4, 0x18d04, 0x18d08, 0x18d10, 0x18d1e,\n        0x18d20, 0x18d3c, 0x18d40, 0x18d78, 0x18d86, 0x18d98, 0x18dce, 0x18de2, 0x18de4, 0x18de8, 0x18e2e, 0x18e32,\n        0x18e34, 0x18e4e, 0x18e5c, 0x18e62, 0x18e64, 0x18e68, 0x18e8e, 0x18e9c, 0x18eb8, 0x18ec2, 0x18ec4, 0x18ec8,\n        0x18ed0, 0x18efa, 0x18f16, 0x18f26, 0x18f2c, 0x18f46, 0x18f4c, 0x18f58, 0x18f6e, 0x18f8a, 0x18f92, 0x18f94,\n        0x18fa2, 0x18fa4, 0x18fa8, 0x18fb6, 0x1902c, 0x1903a, 0x19046, 0x1904c, 0x19058, 0x19072, 0x19074, 0x19086,\n        0x19098, 0x190b0, 0x190be, 0x190ce, 0x190dc, 0x190e2, 0x190e8, 0x190f6, 0x19106, 0x1910c, 0x19130, 0x1913e,\n        0x19160, 0x1917c, 0x1918e, 0x1919c, 0x191b8, 0x191c2, 0x191c8, 0x191d0, 0x191de, 0x191e6, 0x191ec, 0x191fa,\n        0x19218, 0x1923e, 0x19260, 0x1927c, 0x192c0, 0x192f8, 0x19338, 0x19370, 0x1937e, 0x19382, 0x19384, 0x19390,\n        0x1939e, 0x193a0, 0x193bc, 0x193c6, 0x193cc, 0x193d8, 0x193ee, 0x193f2, 0x193f4, 0x19430, 0x1943e, 0x19460,\n        0x1947c, 0x194c0, 0x194f8, 0x195f0, 0x19638, 0x19670, 0x1967e, 0x196e0, 0x196fc, 0x19702, 0x19704, 0x19708,\n        0x19710, 0x19720, 0x1973c, 0x19740, 0x19778, 0x19786, 0x1978c, 0x19798, 0x197b0, 0x197be, 0x197ce, 0x197dc,\n        0x197e2, 0x197e4, 0x197e8, 0x19822, 0x19824, 0x19842, 0x19848, 0x19850, 0x1985e, 0x19866, 0x1987a, 0x19882,\n        0x19884, 0x19890, 0x1989e, 0x198a0, 0x198bc, 0x198cc, 0x198f2, 0x198f4, 0x19902, 0x19908, 0x1991e, 0x19920,\n        0x1993c, 0x19940, 0x19978, 0x19986, 0x19998, 0x199ce, 0x199e2, 0x199e4, 0x199e8, 0x19a08, 0x19a10, 0x19a1e,\n        0x19a20, 0x19a3c, 0x19a40, 0x19a78, 0x19af0, 0x19b18, 0x19b3e, 0x19b60, 0x19b9c, 0x19bc2, 0x19bc4, 0x19bc8,\n        0x19bd0, 0x19be6, 0x19c2e, 0x19c34, 0x19c4e, 0x19c5c, 0x19c62, 0x19c64, 0x19c68, 0x19c8e, 0x19c9c, 0x19cb8,\n        0x19cc2, 0x19cc8, 0x19cd0, 0x19ce6, 0x19cfa, 0x19d0e, 0x19d1c, 0x19d38, 0x19d70, 0x19d7e, 0x19d82, 0x19d84,\n        0x19d88, 0x19d90, 0x19da0, 0x19dcc, 0x19df2, 0x19df4, 0x19e16, 0x19e26, 0x19e2c, 0x19e46, 0x19e4c, 0x19e58,\n        0x19e74, 0x19e86, 0x19e8c, 0x19e98, 0x19eb0, 0x19ebe, 0x19ece, 0x19ee2, 0x19ee4, 0x19ee8, 0x19f0a, 0x19f12,\n        0x19f14, 0x19f22, 0x19f24, 0x19f28, 0x19f42, 0x19f44, 0x19f48, 0x19f50, 0x19f5e, 0x19f6c, 0x19f9a, 0x19fae,\n        0x19fb2, 0x19fb4, 0x1a046, 0x1a04c, 0x1a072, 0x1a074, 0x1a086, 0x1a08c, 0x1a098, 0x1a0b0, 0x1a0be, 0x1a0e2,\n        0x1a0e4, 0x1a0e8, 0x1a0f6, 0x1a106, 0x1a10c, 0x1a118, 0x1a130, 0x1a13e, 0x1a160, 0x1a17c, 0x1a18e, 0x1a19c,\n        0x1a1b8, 0x1a1c2, 0x1a1c4, 0x1a1c8, 0x1a1d0, 0x1a1de, 0x1a1e6, 0x1a1ec, 0x1a218, 0x1a230, 0x1a23e, 0x1a260,\n        0x1a27c, 0x1a2c0, 0x1a2f8, 0x1a31c, 0x1a338, 0x1a370, 0x1a37e, 0x1a382, 0x1a384, 0x1a388, 0x1a390, 0x1a39e,\n        0x1a3a0, 0x1a3bc, 0x1a3c6, 0x1a3cc, 0x1a3d8, 0x1a3ee, 0x1a3f2, 0x1a3f4, 0x1a418, 0x1a430, 0x1a43e, 0x1a460,\n        0x1a47c, 0x1a4c0, 0x1a4f8, 0x1a5f0, 0x1a61c, 0x1a638, 0x1a670, 0x1a67e, 0x1a6e0, 0x1a6fc, 0x1a702, 0x1a704,\n        0x1a708, 0x1a710, 0x1a71e, 0x1a720, 0x1a73c, 0x1a740, 0x1a778, 0x1a786, 0x1a78c, 0x1a798, 0x1a7b0, 0x1a7be,\n        0x1a7ce, 0x1a7dc, 0x1a7e2, 0x1a7e4, 0x1a7e8, 0x1a830, 0x1a860, 0x1a87c, 0x1a8c0, 0x1a8f8, 0x1a9f0, 0x1abe0,\n        0x1ac70, 0x1ac7e, 0x1ace0, 0x1acfc, 0x1adc0, 0x1adf8, 0x1ae04, 0x1ae08, 0x1ae10, 0x1ae20, 0x1ae3c, 0x1ae40,\n        0x1ae78, 0x1aef0, 0x1af06, 0x1af0c, 0x1af18, 0x1af30, 0x1af3e, 0x1af60, 0x1af7c, 0x1af8e, 0x1af9c, 0x1afb8,\n        0x1afc4, 0x1afc8, 0x1afd0, 0x1afde, 0x1b042, 0x1b05e, 0x1b07a, 0x1b082, 0x1b084, 0x1b088, 0x1b090, 0x1b09e,\n        0x1b0a0, 0x1b0bc, 0x1b0cc, 0x1b0f2, 0x1b0f4, 0x1b102, 0x1b104, 0x1b108, 0x1b110, 0x1b11e, 0x1b120, 0x1b13c,\n        0x1b140, 0x1b178, 0x1b186, 0x1b198, 0x1b1ce, 0x1b1e2, 0x1b1e4, 0x1b1e8, 0x1b204, 0x1b208, 0x1b210, 0x1b21e,\n        0x1b220, 0x1b23c, 0x1b240, 0x1b278, 0x1b2f0, 0x1b30c, 0x1b33e, 0x1b360, 0x1b39c, 0x1b3c2, 0x1b3c4, 0x1b3c8,\n        0x1b3d0, 0x1b3e6, 0x1b410, 0x1b41e, 0x1b420, 0x1b43c, 0x1b440, 0x1b478, 0x1b4f0, 0x1b5e0, 0x1b618, 0x1b660,\n        0x1b67c, 0x1b6c0, 0x1b738, 0x1b782, 0x1b784, 0x1b788, 0x1b790, 0x1b79e, 0x1b7a0, 0x1b7cc, 0x1b82e, 0x1b84e,\n        0x1b85c, 0x1b88e, 0x1b89c, 0x1b8b8, 0x1b8c2, 0x1b8c4, 0x1b8c8, 0x1b8d0, 0x1b8e6, 0x1b8fa, 0x1b90e, 0x1b91c,\n        0x1b938, 0x1b970, 0x1b97e, 0x1b982, 0x1b984, 0x1b988, 0x1b990, 0x1b99e, 0x1b9a0, 0x1b9cc, 0x1b9f2, 0x1b9f4,\n        0x1ba0e, 0x1ba1c, 0x1ba38, 0x1ba70, 0x1ba7e, 0x1bae0, 0x1bafc, 0x1bb08, 0x1bb10, 0x1bb20, 0x1bb3c, 0x1bb40,\n        0x1bb98, 0x1bbce, 0x1bbe2, 0x1bbe4, 0x1bbe8, 0x1bc16, 0x1bc26, 0x1bc2c, 0x1bc46, 0x1bc4c, 0x1bc58, 0x1bc72,\n        0x1bc74, 0x1bc86, 0x1bc8c, 0x1bc98, 0x1bcb0, 0x1bcbe, 0x1bcce, 0x1bce2, 0x1bce4, 0x1bce8, 0x1bd06, 0x1bd0c,\n        0x1bd18, 0x1bd30, 0x1bd3e, 0x1bd60, 0x1bd7c, 0x1bd9c, 0x1bdc2, 0x1bdc4, 0x1bdc8, 0x1bdd0, 0x1bde6, 0x1bdfa,\n        0x1be12, 0x1be14, 0x1be22, 0x1be24, 0x1be28, 0x1be42, 0x1be44, 0x1be48, 0x1be50, 0x1be5e, 0x1be66, 0x1be82,\n        0x1be84, 0x1be88, 0x1be90, 0x1be9e, 0x1bea0, 0x1bebc, 0x1becc, 0x1bef4, 0x1bf1a, 0x1bf2e, 0x1bf32, 0x1bf34,\n        0x1bf4e, 0x1bf5c, 0x1bf62, 0x1bf64, 0x1bf68, 0x1c09a, 0x1c0b2, 0x1c0b4, 0x1c11a, 0x1c132, 0x1c134, 0x1c162,\n        0x1c164, 0x1c168, 0x1c176, 0x1c1ba, 0x1c21a, 0x1c232, 0x1c234, 0x1c24e, 0x1c25c, 0x1c262, 0x1c264, 0x1c268,\n        0x1c276, 0x1c28e, 0x1c2c2, 0x1c2c4, 0x1c2c8, 0x1c2d0, 0x1c2de, 0x1c2e6, 0x1c2ec, 0x1c2fa, 0x1c316, 0x1c326,\n        0x1c33a, 0x1c346, 0x1c34c, 0x1c372, 0x1c374, 0x1c41a, 0x1c42e, 0x1c432, 0x1c434, 0x1c44e, 0x1c45c, 0x1c462,\n        0x1c464, 0x1c468, 0x1c476, 0x1c48e, 0x1c49c, 0x1c4b8, 0x1c4c2, 0x1c4c8, 0x1c4d0, 0x1c4de, 0x1c4e6, 0x1c4ec,\n        0x1c4fa, 0x1c51c, 0x1c538, 0x1c570, 0x1c57e, 0x1c582, 0x1c584, 0x1c588, 0x1c590, 0x1c59e, 0x1c5a0, 0x1c5bc,\n        0x1c5c6, 0x1c5cc, 0x1c5d8, 0x1c5ee, 0x1c5f2, 0x1c5f4, 0x1c616, 0x1c626, 0x1c62c, 0x1c63a, 0x1c646, 0x1c64c,\n        0x1c658, 0x1c66e, 0x1c672, 0x1c674, 0x1c686, 0x1c68c, 0x1c698, 0x1c6b0, 0x1c6be, 0x1c6ce, 0x1c6dc, 0x1c6e2,\n        0x1c6e4, 0x1c6e8, 0x1c712, 0x1c714, 0x1c722, 0x1c728, 0x1c736, 0x1c742, 0x1c744, 0x1c748, 0x1c750, 0x1c75e,\n        0x1c766, 0x1c76c, 0x1c77a, 0x1c7ae, 0x1c7d6, 0x1c7ea, 0x1c81a, 0x1c82e, 0x1c832, 0x1c834, 0x1c84e, 0x1c85c,\n        0x1c862, 0x1c864, 0x1c868, 0x1c876, 0x1c88e, 0x1c89c, 0x1c8b8, 0x1c8c2, 0x1c8c8, 0x1c8d0, 0x1c8de, 0x1c8e6,\n        0x1c8ec, 0x1c8fa, 0x1c90e, 0x1c938, 0x1c970, 0x1c97e, 0x1c982, 0x1c984, 0x1c990, 0x1c99e, 0x1c9a0, 0x1c9bc,\n        0x1c9c6, 0x1c9cc, 0x1c9d8, 0x1c9ee, 0x1c9f2, 0x1c9f4, 0x1ca38, 0x1ca70, 0x1ca7e, 0x1cae0, 0x1cafc, 0x1cb02,\n        0x1cb04, 0x1cb08, 0x1cb10, 0x1cb20, 0x1cb3c, 0x1cb40, 0x1cb78, 0x1cb86, 0x1cb8c, 0x1cb98, 0x1cbb0, 0x1cbbe,\n        0x1cbce, 0x1cbdc, 0x1cbe2, 0x1cbe4, 0x1cbe8, 0x1cbf6, 0x1cc16, 0x1cc26, 0x1cc2c, 0x1cc3a, 0x1cc46, 0x1cc58,\n        0x1cc72, 0x1cc74, 0x1cc86, 0x1ccb0, 0x1ccbe, 0x1ccce, 0x1cce2, 0x1cce4, 0x1cce8, 0x1cd06, 0x1cd0c, 0x1cd18,\n        0x1cd30, 0x1cd3e, 0x1cd60, 0x1cd7c, 0x1cd9c, 0x1cdc2, 0x1cdc4, 0x1cdc8, 0x1cdd0, 0x1cdde, 0x1cde6, 0x1cdfa,\n        0x1ce22, 0x1ce28, 0x1ce42, 0x1ce50, 0x1ce5e, 0x1ce66, 0x1ce7a, 0x1ce82, 0x1ce84, 0x1ce88, 0x1ce90, 0x1ce9e,\n        0x1cea0, 0x1cebc, 0x1cecc, 0x1cef2, 0x1cef4, 0x1cf2e, 0x1cf32, 0x1cf34, 0x1cf4e, 0x1cf5c, 0x1cf62, 0x1cf64,\n        0x1cf68, 0x1cf96, 0x1cfa6, 0x1cfac, 0x1cfca, 0x1cfd2, 0x1cfd4, 0x1d02e, 0x1d032, 0x1d034, 0x1d04e, 0x1d05c,\n        0x1d062, 0x1d064, 0x1d068, 0x1d076, 0x1d08e, 0x1d09c, 0x1d0b8, 0x1d0c2, 0x1d0c4, 0x1d0c8, 0x1d0d0, 0x1d0de,\n        0x1d0e6, 0x1d0ec, 0x1d0fa, 0x1d11c, 0x1d138, 0x1d170, 0x1d17e, 0x1d182, 0x1d184, 0x1d188, 0x1d190, 0x1d19e,\n        0x1d1a0, 0x1d1bc, 0x1d1c6, 0x1d1cc, 0x1d1d8, 0x1d1ee, 0x1d1f2, 0x1d1f4, 0x1d21c, 0x1d238, 0x1d270, 0x1d27e,\n        0x1d2e0, 0x1d2fc, 0x1d302, 0x1d304, 0x1d308, 0x1d310, 0x1d31e, 0x1d320, 0x1d33c, 0x1d340, 0x1d378, 0x1d386,\n        0x1d38c, 0x1d398, 0x1d3b0, 0x1d3be, 0x1d3ce, 0x1d3dc, 0x1d3e2, 0x1d3e4, 0x1d3e8, 0x1d3f6, 0x1d470, 0x1d47e,\n        0x1d4e0, 0x1d4fc, 0x1d5c0, 0x1d5f8, 0x1d604, 0x1d608, 0x1d610, 0x1d620, 0x1d640, 0x1d678, 0x1d6f0, 0x1d706,\n        0x1d70c, 0x1d718, 0x1d730, 0x1d73e, 0x1d760, 0x1d77c, 0x1d78e, 0x1d79c, 0x1d7b8, 0x1d7c2, 0x1d7c4, 0x1d7c8,\n        0x1d7d0, 0x1d7de, 0x1d7e6, 0x1d7ec, 0x1d826, 0x1d82c, 0x1d83a, 0x1d846, 0x1d84c, 0x1d858, 0x1d872, 0x1d874,\n        0x1d886, 0x1d88c, 0x1d898, 0x1d8b0, 0x1d8be, 0x1d8ce, 0x1d8e2, 0x1d8e4, 0x1d8e8, 0x1d8f6, 0x1d90c, 0x1d918,\n        0x1d930, 0x1d93e, 0x1d960, 0x1d97c, 0x1d99c, 0x1d9c2, 0x1d9c4, 0x1d9c8, 0x1d9d0, 0x1d9e6, 0x1d9fa, 0x1da0c,\n        0x1da18, 0x1da30, 0x1da3e, 0x1da60, 0x1da7c, 0x1dac0, 0x1daf8, 0x1db38, 0x1db82, 0x1db84, 0x1db88, 0x1db90,\n        0x1db9e, 0x1dba0, 0x1dbcc, 0x1dbf2, 0x1dbf4, 0x1dc22, 0x1dc42, 0x1dc44, 0x1dc48, 0x1dc50, 0x1dc5e, 0x1dc66,\n        0x1dc7a, 0x1dc82, 0x1dc84, 0x1dc88, 0x1dc90, 0x1dc9e, 0x1dca0, 0x1dcbc, 0x1dccc, 0x1dcf2, 0x1dcf4, 0x1dd04,\n        0x1dd08, 0x1dd10, 0x1dd1e, 0x1dd20, 0x1dd3c, 0x1dd40, 0x1dd78, 0x1dd86, 0x1dd98, 0x1ddce, 0x1dde2, 0x1dde4,\n        0x1dde8, 0x1de2e, 0x1de32, 0x1de34, 0x1de4e, 0x1de5c, 0x1de62, 0x1de64, 0x1de68, 0x1de8e, 0x1de9c, 0x1deb8,\n        0x1dec2, 0x1dec4, 0x1dec8, 0x1ded0, 0x1dee6, 0x1defa, 0x1df16, 0x1df26, 0x1df2c, 0x1df46, 0x1df4c, 0x1df58,\n        0x1df72, 0x1df74, 0x1df8a, 0x1df92, 0x1df94, 0x1dfa2, 0x1dfa4, 0x1dfa8, 0x1e08a, 0x1e092, 0x1e094, 0x1e0a2,\n        0x1e0a4, 0x1e0a8, 0x1e0b6, 0x1e0da, 0x1e10a, 0x1e112, 0x1e114, 0x1e122, 0x1e124, 0x1e128, 0x1e136, 0x1e142,\n        0x1e144, 0x1e148, 0x1e150, 0x1e166, 0x1e16c, 0x1e17a, 0x1e19a, 0x1e1b2, 0x1e1b4, 0x1e20a, 0x1e212, 0x1e214,\n        0x1e222, 0x1e224, 0x1e228, 0x1e236, 0x1e242, 0x1e248, 0x1e250, 0x1e25e, 0x1e266, 0x1e26c, 0x1e27a, 0x1e282,\n        0x1e284, 0x1e288, 0x1e290, 0x1e2a0, 0x1e2bc, 0x1e2c6, 0x1e2cc, 0x1e2d8, 0x1e2ee, 0x1e2f2, 0x1e2f4, 0x1e31a,\n        0x1e332, 0x1e334, 0x1e35c, 0x1e362, 0x1e364, 0x1e368, 0x1e3ba, 0x1e40a, 0x1e412, 0x1e414, 0x1e422, 0x1e428,\n        0x1e436, 0x1e442, 0x1e448, 0x1e450, 0x1e45e, 0x1e466, 0x1e46c, 0x1e47a, 0x1e482, 0x1e484, 0x1e490, 0x1e49e,\n        0x1e4a0, 0x1e4bc, 0x1e4c6, 0x1e4cc, 0x1e4d8, 0x1e4ee, 0x1e4f2, 0x1e4f4, 0x1e502, 0x1e504, 0x1e508, 0x1e510,\n        0x1e51e, 0x1e520, 0x1e53c, 0x1e540, 0x1e578, 0x1e586, 0x1e58c, 0x1e598, 0x1e5b0, 0x1e5be, 0x1e5ce, 0x1e5dc,\n        0x1e5e2, 0x1e5e4, 0x1e5e8, 0x1e5f6, 0x1e61a, 0x1e62e, 0x1e632, 0x1e634, 0x1e64e, 0x1e65c, 0x1e662, 0x1e668,\n        0x1e68e, 0x1e69c, 0x1e6b8, 0x1e6c2, 0x1e6c4, 0x1e6c8, 0x1e6d0, 0x1e6e6, 0x1e6fa, 0x1e716, 0x1e726, 0x1e72c,\n        0x1e73a, 0x1e746, 0x1e74c, 0x1e758, 0x1e772, 0x1e774, 0x1e792, 0x1e794, 0x1e7a2, 0x1e7a4, 0x1e7a8, 0x1e7b6,\n        0x1e812, 0x1e814, 0x1e822, 0x1e824, 0x1e828, 0x1e836, 0x1e842, 0x1e844, 0x1e848, 0x1e850, 0x1e85e, 0x1e866,\n        0x1e86c, 0x1e87a, 0x1e882, 0x1e884, 0x1e888, 0x1e890, 0x1e89e, 0x1e8a0, 0x1e8bc, 0x1e8c6, 0x1e8cc, 0x1e8d8,\n        0x1e8ee, 0x1e8f2, 0x1e8f4, 0x1e902, 0x1e904, 0x1e908, 0x1e910, 0x1e920, 0x1e93c, 0x1e940, 0x1e978, 0x1e986,\n        0x1e98c, 0x1e998, 0x1e9b0, 0x1e9be, 0x1e9ce, 0x1e9dc, 0x1e9e2, 0x1e9e4, 0x1e9e8, 0x1e9f6, 0x1ea04, 0x1ea08,\n        0x1ea10, 0x1ea20, 0x1ea40, 0x1ea78, 0x1eaf0, 0x1eb06, 0x1eb0c, 0x1eb18, 0x1eb30, 0x1eb3e, 0x1eb60, 0x1eb7c,\n        0x1eb8e, 0x1eb9c, 0x1ebb8, 0x1ebc2, 0x1ebc4, 0x1ebc8, 0x1ebd0, 0x1ebde, 0x1ebe6, 0x1ebec, 0x1ec1a, 0x1ec2e,\n        0x1ec32, 0x1ec34, 0x1ec4e, 0x1ec5c, 0x1ec62, 0x1ec64, 0x1ec68, 0x1ec8e, 0x1ec9c, 0x1ecb8, 0x1ecc2, 0x1ecc4,\n        0x1ecc8, 0x1ecd0, 0x1ece6, 0x1ecfa, 0x1ed0e, 0x1ed1c, 0x1ed38, 0x1ed70, 0x1ed7e, 0x1ed82, 0x1ed84, 0x1ed88,\n        0x1ed90, 0x1ed9e, 0x1eda0, 0x1edcc, 0x1edf2, 0x1edf4, 0x1ee16, 0x1ee26, 0x1ee2c, 0x1ee3a, 0x1ee46, 0x1ee4c,\n        0x1ee58, 0x1ee6e, 0x1ee72, 0x1ee74, 0x1ee86, 0x1ee8c, 0x1ee98, 0x1eeb0, 0x1eebe, 0x1eece, 0x1eedc, 0x1eee2,\n        0x1eee4, 0x1eee8, 0x1ef12, 0x1ef22, 0x1ef24, 0x1ef28, 0x1ef36, 0x1ef42, 0x1ef44, 0x1ef48, 0x1ef50, 0x1ef5e,\n        0x1ef66, 0x1ef6c, 0x1ef7a, 0x1efae, 0x1efb2, 0x1efb4, 0x1efd6, 0x1f096, 0x1f0a6, 0x1f0ac, 0x1f0ba, 0x1f0ca,\n        0x1f0d2, 0x1f0d4, 0x1f116, 0x1f126, 0x1f12c, 0x1f13a, 0x1f146, 0x1f14c, 0x1f158, 0x1f16e, 0x1f172, 0x1f174,\n        0x1f18a, 0x1f192, 0x1f194, 0x1f1a2, 0x1f1a4, 0x1f1a8, 0x1f1da, 0x1f216, 0x1f226, 0x1f22c, 0x1f23a, 0x1f246,\n        0x1f258, 0x1f26e, 0x1f272, 0x1f274, 0x1f286, 0x1f28c, 0x1f298, 0x1f2b0, 0x1f2be, 0x1f2ce, 0x1f2dc, 0x1f2e2,\n        0x1f2e4, 0x1f2e8, 0x1f2f6, 0x1f30a, 0x1f312, 0x1f314, 0x1f322, 0x1f328, 0x1f342, 0x1f344, 0x1f348, 0x1f350,\n        0x1f35e, 0x1f366, 0x1f37a, 0x1f39a, 0x1f3ae, 0x1f3b2, 0x1f3b4, 0x1f416, 0x1f426, 0x1f42c, 0x1f43a, 0x1f446,\n        0x1f44c, 0x1f458, 0x1f46e, 0x1f472, 0x1f474, 0x1f486, 0x1f48c, 0x1f498, 0x1f4b0, 0x1f4be, 0x1f4ce, 0x1f4dc,\n        0x1f4e2, 0x1f4e4, 0x1f4e8, 0x1f4f6, 0x1f506, 0x1f50c, 0x1f518, 0x1f530, 0x1f53e, 0x1f560, 0x1f57c, 0x1f58e,\n        0x1f59c, 0x1f5b8, 0x1f5c2, 0x1f5c4, 0x1f5c8, 0x1f5d0, 0x1f5de, 0x1f5e6, 0x1f5ec, 0x1f5fa, 0x1f60a, 0x1f612,\n        0x1f614, 0x1f622, 0x1f624, 0x1f628, 0x1f636, 0x1f642, 0x1f644, 0x1f648, 0x1f650, 0x1f65e, 0x1f666, 0x1f67a,\n        0x1f682, 0x1f684, 0x1f688, 0x1f690, 0x1f69e, 0x1f6a0, 0x1f6bc, 0x1f6cc, 0x1f6f2, 0x1f6f4, 0x1f71a, 0x1f72e,\n        0x1f732, 0x1f734, 0x1f74e, 0x1f75c, 0x1f762, 0x1f764, 0x1f768, 0x1f776, 0x1f796, 0x1f7a6, 0x1f7ac, 0x1f7ba,\n        0x1f7d2, 0x1f7d4, 0x1f89a, 0x1f8ae, 0x1f8b2, 0x1f8b4, 0x1f8d6, 0x1f8ea, 0x1f91a, 0x1f92e, 0x1f932, 0x1f934,\n        0x1f94e, 0x1f95c, 0x1f962, 0x1f964, 0x1f968, 0x1f976, 0x1f996, 0x1f9a6, 0x1f9ac, 0x1f9ba, 0x1f9ca, 0x1f9d2,\n        0x1f9d4, 0x1fa1a, 0x1fa2e, 0x1fa32, 0x1fa34, 0x1fa4e, 0x1fa5c, 0x1fa62, 0x1fa64, 0x1fa68, 0x1fa76, 0x1fa8e,\n        0x1fa9c, 0x1fab8, 0x1fac2, 0x1fac4, 0x1fac8, 0x1fad0, 0x1fade, 0x1fae6, 0x1faec, 0x1fb16, 0x1fb26, 0x1fb2c,\n        0x1fb3a, 0x1fb46, 0x1fb4c, 0x1fb58, 0x1fb6e, 0x1fb72, 0x1fb74, 0x1fb8a, 0x1fb92, 0x1fb94, 0x1fba2, 0x1fba4,\n        0x1fba8, 0x1fbb6, 0x1fbda\n    ]);\n    /**\n     * This table contains to codewords for all symbols.\n     */\n    PDF417Common.CODEWORD_TABLE = Int32Array.from([\n        2627, 1819, 2622, 2621, 1813, 1812, 2729, 2724, 2723, 2779, 2774, 2773, 902, 896, 908, 868, 865, 861, 859, 2511,\n        873, 871, 1780, 835, 2493, 825, 2491, 842, 837, 844, 1764, 1762, 811, 810, 809, 2483, 807, 2482, 806, 2480, 815,\n        814, 813, 812, 2484, 817, 816, 1745, 1744, 1742, 1746, 2655, 2637, 2635, 2626, 2625, 2623, 2628, 1820, 2752,\n        2739, 2737, 2728, 2727, 2725, 2730, 2785, 2783, 2778, 2777, 2775, 2780, 787, 781, 747, 739, 736, 2413, 754, 752,\n        1719, 692, 689, 681, 2371, 678, 2369, 700, 697, 694, 703, 1688, 1686, 642, 638, 2343, 631, 2341, 627, 2338, 651,\n        646, 643, 2345, 654, 652, 1652, 1650, 1647, 1654, 601, 599, 2322, 596, 2321, 594, 2319, 2317, 611, 610, 608, 606,\n        2324, 603, 2323, 615, 614, 612, 1617, 1616, 1614, 1612, 616, 1619, 1618, 2575, 2538, 2536, 905, 901, 898, 909,\n        2509, 2507, 2504, 870, 867, 864, 860, 2512, 875, 872, 1781, 2490, 2489, 2487, 2485, 1748, 836, 834, 832, 830,\n        2494, 827, 2492, 843, 841, 839, 845, 1765, 1763, 2701, 2676, 2674, 2653, 2648, 2656, 2634, 2633, 2631, 2629,\n        1821, 2638, 2636, 2770, 2763, 2761, 2750, 2745, 2753, 2736, 2735, 2733, 2731, 1848, 2740, 2738, 2786, 2784, 591,\n        588, 576, 569, 566, 2296, 1590, 537, 534, 526, 2276, 522, 2274, 545, 542, 539, 548, 1572, 1570, 481, 2245, 466,\n        2242, 462, 2239, 492, 485, 482, 2249, 496, 494, 1534, 1531, 1528, 1538, 413, 2196, 406, 2191, 2188, 425, 419,\n        2202, 415, 2199, 432, 430, 427, 1472, 1467, 1464, 433, 1476, 1474, 368, 367, 2160, 365, 2159, 362, 2157, 2155,\n        2152, 378, 377, 375, 2166, 372, 2165, 369, 2162, 383, 381, 379, 2168, 1419, 1418, 1416, 1414, 385, 1411, 384,\n        1423, 1422, 1420, 1424, 2461, 802, 2441, 2439, 790, 786, 783, 794, 2409, 2406, 2403, 750, 742, 738, 2414, 756,\n        753, 1720, 2367, 2365, 2362, 2359, 1663, 693, 691, 684, 2373, 680, 2370, 702, 699, 696, 704, 1690, 1687, 2337,\n        2336, 2334, 2332, 1624, 2329, 1622, 640, 637, 2344, 634, 2342, 630, 2340, 650, 648, 645, 2346, 655, 653, 1653,\n        1651, 1649, 1655, 2612, 2597, 2595, 2571, 2568, 2565, 2576, 2534, 2529, 2526, 1787, 2540, 2537, 907, 904, 900,\n        910, 2503, 2502, 2500, 2498, 1768, 2495, 1767, 2510, 2508, 2506, 869, 866, 863, 2513, 876, 874, 1782, 2720, 2713,\n        2711, 2697, 2694, 2691, 2702, 2672, 2670, 2664, 1828, 2678, 2675, 2647, 2646, 2644, 2642, 1823, 2639, 1822, 2654,\n        2652, 2650, 2657, 2771, 1855, 2765, 2762, 1850, 1849, 2751, 2749, 2747, 2754, 353, 2148, 344, 342, 336, 2142,\n        332, 2140, 345, 1375, 1373, 306, 2130, 299, 2128, 295, 2125, 319, 314, 311, 2132, 1354, 1352, 1349, 1356, 262,\n        257, 2101, 253, 2096, 2093, 274, 273, 267, 2107, 263, 2104, 280, 278, 275, 1316, 1311, 1308, 1320, 1318, 2052,\n        202, 2050, 2044, 2040, 219, 2063, 212, 2060, 208, 2055, 224, 221, 2066, 1260, 1258, 1252, 231, 1248, 229, 1266,\n        1264, 1261, 1268, 155, 1998, 153, 1996, 1994, 1991, 1988, 165, 164, 2007, 162, 2006, 159, 2003, 2000, 172, 171,\n        169, 2012, 166, 2010, 1186, 1184, 1182, 1179, 175, 1176, 173, 1192, 1191, 1189, 1187, 176, 1194, 1193, 2313,\n        2307, 2305, 592, 589, 2294, 2292, 2289, 578, 572, 568, 2297, 580, 1591, 2272, 2267, 2264, 1547, 538, 536, 529,\n        2278, 525, 2275, 547, 544, 541, 1574, 1571, 2237, 2235, 2229, 1493, 2225, 1489, 478, 2247, 470, 2244, 465, 2241,\n        493, 488, 484, 2250, 498, 495, 1536, 1533, 1530, 1539, 2187, 2186, 2184, 2182, 1432, 2179, 1430, 2176, 1427, 414,\n        412, 2197, 409, 2195, 405, 2193, 2190, 426, 424, 421, 2203, 418, 2201, 431, 429, 1473, 1471, 1469, 1466, 434,\n        1477, 1475, 2478, 2472, 2470, 2459, 2457, 2454, 2462, 803, 2437, 2432, 2429, 1726, 2443, 2440, 792, 789, 785,\n        2401, 2399, 2393, 1702, 2389, 1699, 2411, 2408, 2405, 745, 741, 2415, 758, 755, 1721, 2358, 2357, 2355, 2353,\n        1661, 2350, 1660, 2347, 1657, 2368, 2366, 2364, 2361, 1666, 690, 687, 2374, 683, 2372, 701, 698, 705, 1691, 1689,\n        2619, 2617, 2610, 2608, 2605, 2613, 2593, 2588, 2585, 1803, 2599, 2596, 2563, 2561, 2555, 1797, 2551, 1795, 2573,\n        2570, 2567, 2577, 2525, 2524, 2522, 2520, 1786, 2517, 1785, 2514, 1783, 2535, 2533, 2531, 2528, 1788, 2541, 2539,\n        906, 903, 911, 2721, 1844, 2715, 2712, 1838, 1836, 2699, 2696, 2693, 2703, 1827, 1826, 1824, 2673, 2671, 2669,\n        2666, 1829, 2679, 2677, 1858, 1857, 2772, 1854, 1853, 1851, 1856, 2766, 2764, 143, 1987, 139, 1986, 135, 133,\n        131, 1984, 128, 1983, 125, 1981, 138, 137, 136, 1985, 1133, 1132, 1130, 112, 110, 1974, 107, 1973, 104, 1971,\n        1969, 122, 121, 119, 117, 1977, 114, 1976, 124, 1115, 1114, 1112, 1110, 1117, 1116, 84, 83, 1953, 81, 1952, 78,\n        1950, 1948, 1945, 94, 93, 91, 1959, 88, 1958, 85, 1955, 99, 97, 95, 1961, 1086, 1085, 1083, 1081, 1078, 100,\n        1090, 1089, 1087, 1091, 49, 47, 1917, 44, 1915, 1913, 1910, 1907, 59, 1926, 56, 1925, 53, 1922, 1919, 66, 64,\n        1931, 61, 1929, 1042, 1040, 1038, 71, 1035, 70, 1032, 68, 1048, 1047, 1045, 1043, 1050, 1049, 12, 10, 1869, 1867,\n        1864, 1861, 21, 1880, 19, 1877, 1874, 1871, 28, 1888, 25, 1886, 22, 1883, 982, 980, 977, 974, 32, 30, 991, 989,\n        987, 984, 34, 995, 994, 992, 2151, 2150, 2147, 2146, 2144, 356, 355, 354, 2149, 2139, 2138, 2136, 2134, 1359,\n        343, 341, 338, 2143, 335, 2141, 348, 347, 346, 1376, 1374, 2124, 2123, 2121, 2119, 1326, 2116, 1324, 310, 308,\n        305, 2131, 302, 2129, 298, 2127, 320, 318, 316, 313, 2133, 322, 321, 1355, 1353, 1351, 1357, 2092, 2091, 2089,\n        2087, 1276, 2084, 1274, 2081, 1271, 259, 2102, 256, 2100, 252, 2098, 2095, 272, 269, 2108, 266, 2106, 281, 279,\n        277, 1317, 1315, 1313, 1310, 282, 1321, 1319, 2039, 2037, 2035, 2032, 1203, 2029, 1200, 1197, 207, 2053, 205,\n        2051, 201, 2049, 2046, 2043, 220, 218, 2064, 215, 2062, 211, 2059, 228, 226, 223, 2069, 1259, 1257, 1254, 232,\n        1251, 230, 1267, 1265, 1263, 2316, 2315, 2312, 2311, 2309, 2314, 2304, 2303, 2301, 2299, 1593, 2308, 2306, 590,\n        2288, 2287, 2285, 2283, 1578, 2280, 1577, 2295, 2293, 2291, 579, 577, 574, 571, 2298, 582, 581, 1592, 2263, 2262,\n        2260, 2258, 1545, 2255, 1544, 2252, 1541, 2273, 2271, 2269, 2266, 1550, 535, 532, 2279, 528, 2277, 546, 543, 549,\n        1575, 1573, 2224, 2222, 2220, 1486, 2217, 1485, 2214, 1482, 1479, 2238, 2236, 2234, 2231, 1496, 2228, 1492, 480,\n        477, 2248, 473, 2246, 469, 2243, 490, 487, 2251, 497, 1537, 1535, 1532, 2477, 2476, 2474, 2479, 2469, 2468, 2466,\n        2464, 1730, 2473, 2471, 2453, 2452, 2450, 2448, 1729, 2445, 1728, 2460, 2458, 2456, 2463, 805, 804, 2428, 2427,\n        2425, 2423, 1725, 2420, 1724, 2417, 1722, 2438, 2436, 2434, 2431, 1727, 2444, 2442, 793, 791, 788, 795, 2388,\n        2386, 2384, 1697, 2381, 1696, 2378, 1694, 1692, 2402, 2400, 2398, 2395, 1703, 2392, 1701, 2412, 2410, 2407, 751,\n        748, 744, 2416, 759, 757, 1807, 2620, 2618, 1806, 1805, 2611, 2609, 2607, 2614, 1802, 1801, 1799, 2594, 2592,\n        2590, 2587, 1804, 2600, 2598, 1794, 1793, 1791, 1789, 2564, 2562, 2560, 2557, 1798, 2554, 1796, 2574, 2572, 2569,\n        2578, 1847, 1846, 2722, 1843, 1842, 1840, 1845, 2716, 2714, 1835, 1834, 1832, 1830, 1839, 1837, 2700, 2698, 2695,\n        2704, 1817, 1811, 1810, 897, 862, 1777, 829, 826, 838, 1760, 1758, 808, 2481, 1741, 1740, 1738, 1743, 2624, 1818,\n        2726, 2776, 782, 740, 737, 1715, 686, 679, 695, 1682, 1680, 639, 628, 2339, 647, 644, 1645, 1643, 1640, 1648,\n        602, 600, 597, 595, 2320, 593, 2318, 609, 607, 604, 1611, 1610, 1608, 1606, 613, 1615, 1613, 2328, 926, 924, 892,\n        886, 899, 857, 850, 2505, 1778, 824, 823, 821, 819, 2488, 818, 2486, 833, 831, 828, 840, 1761, 1759, 2649, 2632,\n        2630, 2746, 2734, 2732, 2782, 2781, 570, 567, 1587, 531, 527, 523, 540, 1566, 1564, 476, 467, 463, 2240, 486,\n        483, 1524, 1521, 1518, 1529, 411, 403, 2192, 399, 2189, 423, 416, 1462, 1457, 1454, 428, 1468, 1465, 2210, 366,\n        363, 2158, 360, 2156, 357, 2153, 376, 373, 370, 2163, 1410, 1409, 1407, 1405, 382, 1402, 380, 1417, 1415, 1412,\n        1421, 2175, 2174, 777, 774, 771, 784, 732, 725, 722, 2404, 743, 1716, 676, 674, 668, 2363, 665, 2360, 685, 1684,\n        1681, 626, 624, 622, 2335, 620, 2333, 617, 2330, 641, 635, 649, 1646, 1644, 1642, 2566, 928, 925, 2530, 2527,\n        894, 891, 888, 2501, 2499, 2496, 858, 856, 854, 851, 1779, 2692, 2668, 2665, 2645, 2643, 2640, 2651, 2768, 2759,\n        2757, 2744, 2743, 2741, 2748, 352, 1382, 340, 337, 333, 1371, 1369, 307, 300, 296, 2126, 315, 312, 1347, 1342,\n        1350, 261, 258, 250, 2097, 246, 2094, 271, 268, 264, 1306, 1301, 1298, 276, 1312, 1309, 2115, 203, 2048, 195,\n        2045, 191, 2041, 213, 209, 2056, 1246, 1244, 1238, 225, 1234, 222, 1256, 1253, 1249, 1262, 2080, 2079, 154, 1997,\n        150, 1995, 147, 1992, 1989, 163, 160, 2004, 156, 2001, 1175, 1174, 1172, 1170, 1167, 170, 1164, 167, 1185, 1183,\n        1180, 1177, 174, 1190, 1188, 2025, 2024, 2022, 587, 586, 564, 559, 556, 2290, 573, 1588, 520, 518, 512, 2268,\n        508, 2265, 530, 1568, 1565, 461, 457, 2233, 450, 2230, 446, 2226, 479, 471, 489, 1526, 1523, 1520, 397, 395,\n        2185, 392, 2183, 389, 2180, 2177, 410, 2194, 402, 422, 1463, 1461, 1459, 1456, 1470, 2455, 799, 2433, 2430, 779,\n        776, 773, 2397, 2394, 2390, 734, 728, 724, 746, 1717, 2356, 2354, 2351, 2348, 1658, 677, 675, 673, 670, 667, 688,\n        1685, 1683, 2606, 2589, 2586, 2559, 2556, 2552, 927, 2523, 2521, 2518, 2515, 1784, 2532, 895, 893, 890, 2718,\n        2709, 2707, 2689, 2687, 2684, 2663, 2662, 2660, 2658, 1825, 2667, 2769, 1852, 2760, 2758, 142, 141, 1139, 1138,\n        134, 132, 129, 126, 1982, 1129, 1128, 1126, 1131, 113, 111, 108, 105, 1972, 101, 1970, 120, 118, 115, 1109, 1108,\n        1106, 1104, 123, 1113, 1111, 82, 79, 1951, 75, 1949, 72, 1946, 92, 89, 86, 1956, 1077, 1076, 1074, 1072, 98,\n        1069, 96, 1084, 1082, 1079, 1088, 1968, 1967, 48, 45, 1916, 42, 1914, 39, 1911, 1908, 60, 57, 54, 1923, 50, 1920,\n        1031, 1030, 1028, 1026, 67, 1023, 65, 1020, 62, 1041, 1039, 1036, 1033, 69, 1046, 1044, 1944, 1943, 1941, 11, 9,\n        1868, 7, 1865, 1862, 1859, 20, 1878, 16, 1875, 13, 1872, 970, 968, 966, 963, 29, 960, 26, 23, 983, 981, 978, 975,\n        33, 971, 31, 990, 988, 985, 1906, 1904, 1902, 993, 351, 2145, 1383, 331, 330, 328, 326, 2137, 323, 2135, 339,\n        1372, 1370, 294, 293, 291, 289, 2122, 286, 2120, 283, 2117, 309, 303, 317, 1348, 1346, 1344, 245, 244, 242, 2090,\n        239, 2088, 236, 2085, 2082, 260, 2099, 249, 270, 1307, 1305, 1303, 1300, 1314, 189, 2038, 186, 2036, 183, 2033,\n        2030, 2026, 206, 198, 2047, 194, 216, 1247, 1245, 1243, 1240, 227, 1237, 1255, 2310, 2302, 2300, 2286, 2284,\n        2281, 565, 563, 561, 558, 575, 1589, 2261, 2259, 2256, 2253, 1542, 521, 519, 517, 514, 2270, 511, 533, 1569,\n        1567, 2223, 2221, 2218, 2215, 1483, 2211, 1480, 459, 456, 453, 2232, 449, 474, 491, 1527, 1525, 1522, 2475, 2467,\n        2465, 2451, 2449, 2446, 801, 800, 2426, 2424, 2421, 2418, 1723, 2435, 780, 778, 775, 2387, 2385, 2382, 2379,\n        1695, 2375, 1693, 2396, 735, 733, 730, 727, 749, 1718, 2616, 2615, 2604, 2603, 2601, 2584, 2583, 2581, 2579,\n        1800, 2591, 2550, 2549, 2547, 2545, 1792, 2542, 1790, 2558, 929, 2719, 1841, 2710, 2708, 1833, 1831, 2690, 2688,\n        2686, 1815, 1809, 1808, 1774, 1756, 1754, 1737, 1736, 1734, 1739, 1816, 1711, 1676, 1674, 633, 629, 1638, 1636,\n        1633, 1641, 598, 1605, 1604, 1602, 1600, 605, 1609, 1607, 2327, 887, 853, 1775, 822, 820, 1757, 1755, 1584, 524,\n        1560, 1558, 468, 464, 1514, 1511, 1508, 1519, 408, 404, 400, 1452, 1447, 1444, 417, 1458, 1455, 2208, 364, 361,\n        358, 2154, 1401, 1400, 1398, 1396, 374, 1393, 371, 1408, 1406, 1403, 1413, 2173, 2172, 772, 726, 723, 1712, 672,\n        669, 666, 682, 1678, 1675, 625, 623, 621, 618, 2331, 636, 632, 1639, 1637, 1635, 920, 918, 884, 880, 889, 849,\n        848, 847, 846, 2497, 855, 852, 1776, 2641, 2742, 2787, 1380, 334, 1367, 1365, 301, 297, 1340, 1338, 1335, 1343,\n        255, 251, 247, 1296, 1291, 1288, 265, 1302, 1299, 2113, 204, 196, 192, 2042, 1232, 1230, 1224, 214, 1220, 210,\n        1242, 1239, 1235, 1250, 2077, 2075, 151, 148, 1993, 144, 1990, 1163, 1162, 1160, 1158, 1155, 161, 1152, 157,\n        1173, 1171, 1168, 1165, 168, 1181, 1178, 2021, 2020, 2018, 2023, 585, 560, 557, 1585, 516, 509, 1562, 1559, 458,\n        447, 2227, 472, 1516, 1513, 1510, 398, 396, 393, 390, 2181, 386, 2178, 407, 1453, 1451, 1449, 1446, 420, 1460,\n        2209, 769, 764, 720, 712, 2391, 729, 1713, 664, 663, 661, 659, 2352, 656, 2349, 671, 1679, 1677, 2553, 922, 919,\n        2519, 2516, 885, 883, 881, 2685, 2661, 2659, 2767, 2756, 2755, 140, 1137, 1136, 130, 127, 1125, 1124, 1122, 1127,\n        109, 106, 102, 1103, 1102, 1100, 1098, 116, 1107, 1105, 1980, 80, 76, 73, 1947, 1068, 1067, 1065, 1063, 90, 1060,\n        87, 1075, 1073, 1070, 1080, 1966, 1965, 46, 43, 40, 1912, 36, 1909, 1019, 1018, 1016, 1014, 58, 1011, 55, 1008,\n        51, 1029, 1027, 1024, 1021, 63, 1037, 1034, 1940, 1939, 1937, 1942, 8, 1866, 4, 1863, 1, 1860, 956, 954, 952,\n        949, 946, 17, 14, 969, 967, 964, 961, 27, 957, 24, 979, 976, 972, 1901, 1900, 1898, 1896, 986, 1905, 1903, 350,\n        349, 1381, 329, 327, 324, 1368, 1366, 292, 290, 287, 284, 2118, 304, 1341, 1339, 1337, 1345, 243, 240, 237, 2086,\n        233, 2083, 254, 1297, 1295, 1293, 1290, 1304, 2114, 190, 187, 184, 2034, 180, 2031, 177, 2027, 199, 1233, 1231,\n        1229, 1226, 217, 1223, 1241, 2078, 2076, 584, 555, 554, 552, 550, 2282, 562, 1586, 507, 506, 504, 502, 2257, 499,\n        2254, 515, 1563, 1561, 445, 443, 441, 2219, 438, 2216, 435, 2212, 460, 454, 475, 1517, 1515, 1512, 2447, 798,\n        797, 2422, 2419, 770, 768, 766, 2383, 2380, 2376, 721, 719, 717, 714, 731, 1714, 2602, 2582, 2580, 2548, 2546,\n        2543, 923, 921, 2717, 2706, 2705, 2683, 2682, 2680, 1771, 1752, 1750, 1733, 1732, 1731, 1735, 1814, 1707, 1670,\n        1668, 1631, 1629, 1626, 1634, 1599, 1598, 1596, 1594, 1603, 1601, 2326, 1772, 1753, 1751, 1581, 1554, 1552, 1504,\n        1501, 1498, 1509, 1442, 1437, 1434, 401, 1448, 1445, 2206, 1392, 1391, 1389, 1387, 1384, 359, 1399, 1397, 1394,\n        1404, 2171, 2170, 1708, 1672, 1669, 619, 1632, 1630, 1628, 1773, 1378, 1363, 1361, 1333, 1328, 1336, 1286, 1281,\n        1278, 248, 1292, 1289, 2111, 1218, 1216, 1210, 197, 1206, 193, 1228, 1225, 1221, 1236, 2073, 2071, 1151, 1150,\n        1148, 1146, 152, 1143, 149, 1140, 145, 1161, 1159, 1156, 1153, 158, 1169, 1166, 2017, 2016, 2014, 2019, 1582,\n        510, 1556, 1553, 452, 448, 1506, 1500, 394, 391, 387, 1443, 1441, 1439, 1436, 1450, 2207, 765, 716, 713, 1709,\n        662, 660, 657, 1673, 1671, 916, 914, 879, 878, 877, 882, 1135, 1134, 1121, 1120, 1118, 1123, 1097, 1096, 1094,\n        1092, 103, 1101, 1099, 1979, 1059, 1058, 1056, 1054, 77, 1051, 74, 1066, 1064, 1061, 1071, 1964, 1963, 1007,\n        1006, 1004, 1002, 999, 41, 996, 37, 1017, 1015, 1012, 1009, 52, 1025, 1022, 1936, 1935, 1933, 1938, 942, 940,\n        938, 935, 932, 5, 2, 955, 953, 950, 947, 18, 943, 15, 965, 962, 958, 1895, 1894, 1892, 1890, 973, 1899, 1897,\n        1379, 325, 1364, 1362, 288, 285, 1334, 1332, 1330, 241, 238, 234, 1287, 1285, 1283, 1280, 1294, 2112, 188, 185,\n        181, 178, 2028, 1219, 1217, 1215, 1212, 200, 1209, 1227, 2074, 2072, 583, 553, 551, 1583, 505, 503, 500, 513,\n        1557, 1555, 444, 442, 439, 436, 2213, 455, 451, 1507, 1505, 1502, 796, 763, 762, 760, 767, 711, 710, 708, 706,\n        2377, 718, 715, 1710, 2544, 917, 915, 2681, 1627, 1597, 1595, 2325, 1769, 1749, 1747, 1499, 1438, 1435, 2204,\n        1390, 1388, 1385, 1395, 2169, 2167, 1704, 1665, 1662, 1625, 1623, 1620, 1770, 1329, 1282, 1279, 2109, 1214, 1207,\n        1222, 2068, 2065, 1149, 1147, 1144, 1141, 146, 1157, 1154, 2013, 2011, 2008, 2015, 1579, 1549, 1546, 1495, 1487,\n        1433, 1431, 1428, 1425, 388, 1440, 2205, 1705, 658, 1667, 1664, 1119, 1095, 1093, 1978, 1057, 1055, 1052, 1062,\n        1962, 1960, 1005, 1003, 1000, 997, 38, 1013, 1010, 1932, 1930, 1927, 1934, 941, 939, 936, 933, 6, 930, 3, 951,\n        948, 944, 1889, 1887, 1884, 1881, 959, 1893, 1891, 35, 1377, 1360, 1358, 1327, 1325, 1322, 1331, 1277, 1275,\n        1272, 1269, 235, 1284, 2110, 1205, 1204, 1201, 1198, 182, 1195, 179, 1213, 2070, 2067, 1580, 501, 1551, 1548,\n        440, 437, 1497, 1494, 1490, 1503, 761, 709, 707, 1706, 913, 912, 2198, 1386, 2164, 2161, 1621, 1766, 2103, 1208,\n        2058, 2054, 1145, 1142, 2005, 2002, 1999, 2009, 1488, 1429, 1426, 2200, 1698, 1659, 1656, 1975, 1053, 1957, 1954,\n        1001, 998, 1924, 1921, 1918, 1928, 937, 934, 931, 1879, 1876, 1873, 1870, 945, 1885, 1882, 1323, 1273, 1270,\n        2105, 1202, 1199, 1196, 1211, 2061, 2057, 1576, 1543, 1540, 1484, 1481, 1478, 1491, 1700\n    ]);\n\n    /*\n    * Copyright 2007 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    // import java.util.List;\n    /**\n     * @author Guenther Grau\n     */\n    /*public final*/ class PDF417DetectorResult {\n        constructor(bits, points) {\n            this.bits = bits;\n            this.points = points;\n        }\n        getBits() {\n            return this.bits;\n        }\n        getPoints() {\n            return this.points;\n        }\n    }\n\n    /*\n    * Copyright 2009 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    // import java.util.ArrayList;\n    // import java.util.Arrays;\n    // import java.util.List;\n    // import java.util.Map;\n    /**\n     * <p>Encapsulates logic that can detect a PDF417 Code in an image, even if the\n     * PDF417 Code is rotated or skewed, or partially obscured.</p>\n     *\n     * @author SITA Lab (kevin.osullivan@sita.aero)\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Guenther Grau\n     */\n    /*public*/ /*final*/ class Detector$3 {\n        /**\n         * <p>Detects a PDF417 Code in an image. Only checks 0 and 180 degree rotations.</p>\n         *\n         * @param image barcode image to decode\n         * @param hints optional hints to detector\n         * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will\n         * be found and returned\n         * @return {@link PDF417DetectorResult} encapsulating results of detecting a PDF417 code\n         * @throws NotFoundException if no PDF417 Code can be found\n         */\n        static detectMultiple(image, hints, multiple) {\n            // TODO detection improvement, tryHarder could try several different luminance thresholds/blackpoints or even\n            // different binarizers\n            // boolean tryHarder = hints != null && hints.containsKey(DecodeHintType.TRY_HARDER);\n            let bitMatrix = image.getBlackMatrix();\n            let barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);\n            if (!barcodeCoordinates.length) {\n                bitMatrix = bitMatrix.clone();\n                bitMatrix.rotate180();\n                barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);\n            }\n            return new PDF417DetectorResult(bitMatrix, barcodeCoordinates);\n        }\n        /**\n         * Detects PDF417 codes in an image. Only checks 0 degree rotation\n         * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will\n         * be found and returned\n         * @param bitMatrix bit matrix to detect barcodes in\n         * @return List of ResultPoint arrays containing the coordinates of found barcodes\n         */\n        static detect(multiple, bitMatrix) {\n            const barcodeCoordinates = new Array();\n            let row = 0;\n            let column = 0;\n            let foundBarcodeInRow = false;\n            while (row < bitMatrix.getHeight()) {\n                const vertices = Detector$3.findVertices(bitMatrix, row, column);\n                if (vertices[0] == null && vertices[3] == null) {\n                    if (!foundBarcodeInRow) {\n                        // we didn't find any barcode so that's the end of searching\n                        break;\n                    }\n                    // we didn't find a barcode starting at the given column and row. Try again from the first column and slightly\n                    // below the lowest barcode we found so far.\n                    foundBarcodeInRow = false;\n                    column = 0;\n                    for (const barcodeCoordinate of barcodeCoordinates) {\n                        if (barcodeCoordinate[1] != null) {\n                            row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));\n                        }\n                        if (barcodeCoordinate[3] != null) {\n                            row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));\n                        }\n                    }\n                    row += Detector$3.ROW_STEP;\n                    continue;\n                }\n                foundBarcodeInRow = true;\n                barcodeCoordinates.push(vertices);\n                if (!multiple) {\n                    break;\n                }\n                // if we didn't find a right row indicator column, then continue the search for the next barcode after the\n                // start pattern of the barcode just found.\n                if (vertices[2] != null) {\n                    column = Math.trunc(vertices[2].getX());\n                    row = Math.trunc(vertices[2].getY());\n                }\n                else {\n                    column = Math.trunc(vertices[4].getX());\n                    row = Math.trunc(vertices[4].getY());\n                }\n            }\n            return barcodeCoordinates;\n        }\n        /**\n         * Locate the vertices and the codewords area of a black blob using the Start\n         * and Stop patterns as locators.\n         *\n         * @param matrix the scanned barcode image.\n         * @return an array containing the vertices:\n         *           vertices[0] x, y top left barcode\n         *           vertices[1] x, y bottom left barcode\n         *           vertices[2] x, y top right barcode\n         *           vertices[3] x, y bottom right barcode\n         *           vertices[4] x, y top left codeword area\n         *           vertices[5] x, y bottom left codeword area\n         *           vertices[6] x, y top right codeword area\n         *           vertices[7] x, y bottom right codeword area\n         */\n        static findVertices(matrix, startRow, startColumn) {\n            const height = matrix.getHeight();\n            const width = matrix.getWidth();\n            // const result = new ResultPoint[8];\n            const result = new Array(8);\n            Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.START_PATTERN), Detector$3.INDEXES_START_PATTERN);\n            if (result[4] != null) {\n                startColumn = Math.trunc(result[4].getX());\n                startRow = Math.trunc(result[4].getY());\n            }\n            Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.STOP_PATTERN), Detector$3.INDEXES_STOP_PATTERN);\n            return result;\n        }\n        static copyToResult(result, tmpResult, destinationIndexes) {\n            for (let i = 0; i < destinationIndexes.length; i++) {\n                result[destinationIndexes[i]] = tmpResult[i];\n            }\n        }\n        static findRowsWithPattern(matrix, height, width, startRow, startColumn, pattern) {\n            // const result = new ResultPoint[4];\n            const result = new Array(4);\n            let found = false;\n            const counters = new Int32Array(pattern.length);\n            for (; startRow < height; startRow += Detector$3.ROW_STEP) {\n                let loc = Detector$3.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);\n                if (loc != null) {\n                    while (startRow > 0) {\n                        const previousRowLoc = Detector$3.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);\n                        if (previousRowLoc != null) {\n                            loc = previousRowLoc;\n                        }\n                        else {\n                            startRow++;\n                            break;\n                        }\n                    }\n                    result[0] = new ResultPoint(loc[0], startRow);\n                    result[1] = new ResultPoint(loc[1], startRow);\n                    found = true;\n                    break;\n                }\n            }\n            let stopRow = startRow + 1;\n            // Last row of the current symbol that contains pattern\n            if (found) {\n                let skippedRowCount = 0;\n                let previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);\n                for (; stopRow < height; stopRow++) {\n                    const loc = Detector$3.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);\n                    // a found pattern is only considered to belong to the same barcode if the start and end positions\n                    // don't differ too much. Pattern drift should be not bigger than two for consecutive rows. With\n                    // a higher number of skipped rows drift could be larger. To keep it simple for now, we allow a slightly\n                    // larger drift and don't check for skipped rows.\n                    if (loc != null &&\n                        Math.abs(previousRowLoc[0] - loc[0]) < Detector$3.MAX_PATTERN_DRIFT &&\n                        Math.abs(previousRowLoc[1] - loc[1]) < Detector$3.MAX_PATTERN_DRIFT) {\n                        previousRowLoc = loc;\n                        skippedRowCount = 0;\n                    }\n                    else {\n                        if (skippedRowCount > Detector$3.SKIPPED_ROW_COUNT_MAX) {\n                            break;\n                        }\n                        else {\n                            skippedRowCount++;\n                        }\n                    }\n                }\n                stopRow -= skippedRowCount + 1;\n                result[2] = new ResultPoint(previousRowLoc[0], stopRow);\n                result[3] = new ResultPoint(previousRowLoc[1], stopRow);\n            }\n            if (stopRow - startRow < Detector$3.BARCODE_MIN_HEIGHT) {\n                Arrays.fill(result, null);\n            }\n            return result;\n        }\n        /**\n         * @param matrix row of black/white values to search\n         * @param column x position to start search\n         * @param row y position to start search\n         * @param width the number of pixels to search on this row\n         * @param pattern pattern of counts of number of black and white pixels that are\n         *                 being searched for as a pattern\n         * @param counters array of counters, as long as pattern, to re-use\n         * @return start/end horizontal offset of guard pattern, as an array of two ints.\n         */\n        static findGuardPattern(matrix, column, row, width, whiteFirst, pattern, counters) {\n            Arrays.fillWithin(counters, 0, counters.length, 0);\n            let patternStart = column;\n            let pixelDrift = 0;\n            // if there are black pixels left of the current pixel shift to the left, but only for MAX_PIXEL_DRIFT pixels\n            while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector$3.MAX_PIXEL_DRIFT) {\n                patternStart--;\n            }\n            let x = patternStart;\n            let counterPosition = 0;\n            let patternLength = pattern.length;\n            for (let isWhite = whiteFirst; x < width; x++) {\n                let pixel = matrix.get(x, row);\n                if (pixel !== isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (counterPosition === patternLength - 1) {\n                        if (Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {\n                            return new Int32Array([patternStart, x]);\n                        }\n                        patternStart += counters[0] + counters[1];\n                        System.arraycopy(counters, 2, counters, 0, counterPosition - 1);\n                        counters[counterPosition - 1] = 0;\n                        counters[counterPosition] = 0;\n                        counterPosition--;\n                    }\n                    else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            if (counterPosition === patternLength - 1 &&\n                Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {\n                return new Int32Array([patternStart, x - 1]);\n            }\n            return null;\n        }\n        /**\n         * Determines how closely a set of observed counts of runs of black/white\n         * values matches a given target pattern. This is reported as the ratio of\n         * the total variance from the expected pattern proportions across all\n         * pattern elements, to the length of the pattern.\n         *\n         * @param counters observed counters\n         * @param pattern expected pattern\n         * @param maxIndividualVariance The most any counter can differ before we give up\n         * @return ratio of total variance between counters and pattern compared to total pattern size\n         */\n        static patternMatchVariance(counters, pattern, maxIndividualVariance) {\n            let numCounters = counters.length;\n            let total = 0;\n            let patternLength = 0;\n            for (let i = 0; i < numCounters; i++) {\n                total += counters[i];\n                patternLength += pattern[i];\n            }\n            if (total < patternLength) {\n                // If we don't even have one pixel per unit of bar width, assume this\n                // is too small to reliably match, so fail:\n                return /*Float.POSITIVE_INFINITY*/ Infinity;\n            }\n            // We're going to fake floating-point math in integers. We just need to use more bits.\n            // Scale up patternLength so that intermediate values below like scaledCounter will have\n            // more \"significant digits\".\n            let unitBarWidth = total / patternLength;\n            maxIndividualVariance *= unitBarWidth;\n            let totalVariance = 0.0;\n            for (let x = 0; x < numCounters; x++) {\n                let counter = counters[x];\n                let scaledPattern = pattern[x] * unitBarWidth;\n                let variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n                if (variance > maxIndividualVariance) {\n                    return /*Float.POSITIVE_INFINITY*/ Infinity;\n                }\n                totalVariance += variance;\n            }\n            return totalVariance / total;\n        }\n    }\n    Detector$3.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);\n    Detector$3.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);\n    Detector$3.MAX_AVG_VARIANCE = 0.42;\n    Detector$3.MAX_INDIVIDUAL_VARIANCE = 0.8;\n    // B S B S B S B S Bar/Space pattern\n    // 11111111 0 1 0 1 0 1 000\n    Detector$3.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]);\n    // 1111111 0 1 000 1 0 1 00 1\n    Detector$3.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);\n    Detector$3.MAX_PIXEL_DRIFT = 3;\n    Detector$3.MAX_PATTERN_DRIFT = 5;\n    // if we set the value too low, then we don't detect the correct height of the bar if the start patterns are damaged.\n    // if we set the value too high, then we might detect the start pattern from a neighbor barcode.\n    Detector$3.SKIPPED_ROW_COUNT_MAX = 25;\n    // A PDF471 barcode should have at least 3 rows, with each row being >= 3 times the module width. Therefore it should be at least\n    // 9 pixels tall. To be conservative, we use about half the size to ensure we don't miss it.\n    Detector$3.ROW_STEP = 5;\n    Detector$3.BARCODE_MIN_HEIGHT = 10;\n\n    /*\n    * Copyright 2012 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /**\n     * @author Sean Owen\n     * @see com.google.zxing.common.reedsolomon.GenericGFPoly\n     */\n    /*final*/ class ModulusPoly {\n        constructor(field, coefficients) {\n            if (coefficients.length === 0) {\n                throw new IllegalArgumentException();\n            }\n            this.field = field;\n            let coefficientsLength = /*int*/ coefficients.length;\n            if (coefficientsLength > 1 && coefficients[0] === 0) {\n                // Leading term must be non-zero for anything except the constant polynomial \"0\"\n                let firstNonZero = /*int*/ 1;\n                while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {\n                    firstNonZero++;\n                }\n                if (firstNonZero === coefficientsLength) {\n                    this.coefficients = new Int32Array([0]);\n                }\n                else {\n                    this.coefficients = new Int32Array(coefficientsLength - firstNonZero);\n                    System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);\n                }\n            }\n            else {\n                this.coefficients = coefficients;\n            }\n        }\n        getCoefficients() {\n            return this.coefficients;\n        }\n        /**\n         * @return degree of this polynomial\n         */\n        getDegree() {\n            return this.coefficients.length - 1;\n        }\n        /**\n         * @return true iff this polynomial is the monomial \"0\"\n         */\n        isZero() {\n            return this.coefficients[0] === 0;\n        }\n        /**\n         * @return coefficient of x^degree term in this polynomial\n         */\n        getCoefficient(degree) {\n            return this.coefficients[this.coefficients.length - 1 - degree];\n        }\n        /**\n         * @return evaluation of this polynomial at a given point\n         */\n        evaluateAt(a) {\n            if (a === 0) {\n                // Just return the x^0 coefficient\n                return this.getCoefficient(0);\n            }\n            if (a === 1) {\n                // Just the sum of the coefficients\n                let sum = /*int*/ 0;\n                for (let coefficient /*int*/ of this.coefficients) {\n                    sum = this.field.add(sum, coefficient);\n                }\n                return sum;\n            }\n            let result = /*int*/ this.coefficients[0];\n            let size = /*int*/ this.coefficients.length;\n            for (let i /*int*/ = 1; i < size; i++) {\n                result = this.field.add(this.field.multiply(a, result), this.coefficients[i]);\n            }\n            return result;\n        }\n        add(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException('ModulusPolys do not have same ModulusGF field');\n            }\n            if (this.isZero()) {\n                return other;\n            }\n            if (other.isZero()) {\n                return this;\n            }\n            let smallerCoefficients = this.coefficients;\n            let largerCoefficients = other.coefficients;\n            if (smallerCoefficients.length > largerCoefficients.length) {\n                let temp = smallerCoefficients;\n                smallerCoefficients = largerCoefficients;\n                largerCoefficients = temp;\n            }\n            let sumDiff = new Int32Array(largerCoefficients.length);\n            let lengthDiff = /*int*/ largerCoefficients.length - smallerCoefficients.length;\n            // Copy high-order terms only found in higher-degree polynomial's coefficients\n            System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);\n            for (let i /*int*/ = lengthDiff; i < largerCoefficients.length; i++) {\n                sumDiff[i] = this.field.add(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);\n            }\n            return new ModulusPoly(this.field, sumDiff);\n        }\n        subtract(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException('ModulusPolys do not have same ModulusGF field');\n            }\n            if (other.isZero()) {\n                return this;\n            }\n            return this.add(other.negative());\n        }\n        multiply(other) {\n            if (other instanceof ModulusPoly) {\n                return this.multiplyOther(other);\n            }\n            return this.multiplyScalar(other);\n        }\n        multiplyOther(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException('ModulusPolys do not have same ModulusGF field');\n            }\n            if (this.isZero() || other.isZero()) {\n                // return this.field.getZero();\n                return new ModulusPoly(this.field, new Int32Array([0]));\n            }\n            let aCoefficients = this.coefficients;\n            let aLength = /*int*/ aCoefficients.length;\n            let bCoefficients = other.coefficients;\n            let bLength = /*int*/ bCoefficients.length;\n            let product = new Int32Array(aLength + bLength - 1);\n            for (let i /*int*/ = 0; i < aLength; i++) {\n                let aCoeff = /*int*/ aCoefficients[i];\n                for (let j /*int*/ = 0; j < bLength; j++) {\n                    product[i + j] = this.field.add(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));\n                }\n            }\n            return new ModulusPoly(this.field, product);\n        }\n        negative() {\n            let size = /*int*/ this.coefficients.length;\n            let negativeCoefficients = new Int32Array(size);\n            for (let i /*int*/ = 0; i < size; i++) {\n                negativeCoefficients[i] = this.field.subtract(0, this.coefficients[i]);\n            }\n            return new ModulusPoly(this.field, negativeCoefficients);\n        }\n        multiplyScalar(scalar) {\n            if (scalar === 0) {\n                return new ModulusPoly(this.field, new Int32Array([0]));\n            }\n            if (scalar === 1) {\n                return this;\n            }\n            let size = /*int*/ this.coefficients.length;\n            let product = new Int32Array(size);\n            for (let i /*int*/ = 0; i < size; i++) {\n                product[i] = this.field.multiply(this.coefficients[i], scalar);\n            }\n            return new ModulusPoly(this.field, product);\n        }\n        multiplyByMonomial(degree, coefficient) {\n            if (degree < 0) {\n                throw new IllegalArgumentException();\n            }\n            if (coefficient === 0) {\n                return new ModulusPoly(this.field, new Int32Array([0]));\n            }\n            let size = /*int*/ this.coefficients.length;\n            let product = new Int32Array(size + degree);\n            for (let i /*int*/ = 0; i < size; i++) {\n                product[i] = this.field.multiply(this.coefficients[i], coefficient);\n            }\n            return new ModulusPoly(this.field, product);\n        }\n        /*\n        ModulusPoly[] divide(other: ModulusPoly) {\n          if (!field.equals(other.field)) {\n            throw new IllegalArgumentException(\"ModulusPolys do not have same ModulusGF field\");\n          }\n          if (other.isZero()) {\n            throw new IllegalArgumentException(\"Divide by 0\");\n          }\n      \n          let quotient: ModulusPoly = field.getZero();\n          let remainder: ModulusPoly = this;\n      \n          let denominatorLeadingTerm: /*int/ number = other.getCoefficient(other.getDegree());\n          let inverseDenominatorLeadingTerm: /*int/ number = field.inverse(denominatorLeadingTerm);\n      \n          while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {\n            let degreeDifference: /*int/ number = remainder.getDegree() - other.getDegree();\n            let scale: /*int/ number = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);\n            let term: ModulusPoly = other.multiplyByMonomial(degreeDifference, scale);\n            let iterationQuotient: ModulusPoly = field.buildMonomial(degreeDifference, scale);\n            quotient = quotient.add(iterationQuotient);\n            remainder = remainder.subtract(term);\n          }\n      \n          return new ModulusPoly[] { quotient, remainder };\n        }\n        */\n        // @Override\n        toString() {\n            let result = new StringBuilder( /*8 * this.getDegree()*/); // dynamic string size in JS\n            for (let degree /*int*/ = this.getDegree(); degree >= 0; degree--) {\n                let coefficient = /*int*/ this.getCoefficient(degree);\n                if (coefficient !== 0) {\n                    if (coefficient < 0) {\n                        result.append(' - ');\n                        coefficient = -coefficient;\n                    }\n                    else {\n                        if (result.length() > 0) {\n                            result.append(' + ');\n                        }\n                    }\n                    if (degree === 0 || coefficient !== 1) {\n                        result.append(coefficient);\n                    }\n                    if (degree !== 0) {\n                        if (degree === 1) {\n                            result.append('x');\n                        }\n                        else {\n                            result.append('x^');\n                            result.append(degree);\n                        }\n                    }\n                }\n            }\n            return result.toString();\n        }\n    }\n\n    class ModulusBase {\n        add(a, b) {\n            return (a + b) % this.modulus;\n        }\n        subtract(a, b) {\n            return (this.modulus + a - b) % this.modulus;\n        }\n        exp(a) {\n            return this.expTable[a];\n        }\n        log(a) {\n            if (a === 0) {\n                throw new IllegalArgumentException();\n            }\n            return this.logTable[a];\n        }\n        inverse(a) {\n            if (a === 0) {\n                throw new ArithmeticException();\n            }\n            return this.expTable[this.modulus - this.logTable[a] - 1];\n        }\n        multiply(a, b) {\n            if (a === 0 || b === 0) {\n                return 0;\n            }\n            return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.modulus - 1)];\n        }\n        getSize() {\n            return this.modulus;\n        }\n        equals(o) {\n            return o === this;\n        }\n    }\n\n    /*\n     * Copyright 2012 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>A field based on powers of a generator integer, modulo some modulus.</p>\n     *\n     * @author Sean Owen\n     * @see com.google.zxing.common.reedsolomon.GenericGF\n     */\n    /*public final*/ class ModulusGF extends ModulusBase {\n        // private /*final*/ modulus: /*int*/ number;\n        constructor(modulus, generator) {\n            super();\n            this.modulus = modulus;\n            this.expTable = new Int32Array(modulus);\n            this.logTable = new Int32Array(modulus);\n            let x = /*int*/ 1;\n            for (let i /*int*/ = 0; i < modulus; i++) {\n                this.expTable[i] = x;\n                x = (x * generator) % modulus;\n            }\n            for (let i /*int*/ = 0; i < modulus - 1; i++) {\n                this.logTable[this.expTable[i]] = i;\n            }\n            // logTable[0] == 0 but this should never be used\n            this.zero = new ModulusPoly(this, new Int32Array([0]));\n            this.one = new ModulusPoly(this, new Int32Array([1]));\n        }\n        getZero() {\n            return this.zero;\n        }\n        getOne() {\n            return this.one;\n        }\n        buildMonomial(degree, coefficient) {\n            if (degree < 0) {\n                throw new IllegalArgumentException();\n            }\n            if (coefficient === 0) {\n                return this.zero;\n            }\n            let coefficients = new Int32Array(degree + 1);\n            coefficients[0] = coefficient;\n            return new ModulusPoly(this, coefficients);\n        }\n    }\n    ModulusGF.PDF417_GF = new ModulusGF(PDF417Common.NUMBER_OF_CODEWORDS, 3);\n\n    /*\n    * Copyright 2012 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /**\n     * <p>PDF417 error correction implementation.</p>\n     *\n     * <p>This <a href=\"http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example\">example</a>\n     * is quite useful in understanding the algorithm.</p>\n     *\n     * @author Sean Owen\n     * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder\n     */\n    /*public final*/ class ErrorCorrection {\n        constructor() {\n            this.field = ModulusGF.PDF417_GF;\n        }\n        /**\n         * @param received received codewords\n         * @param numECCodewords number of those codewords used for EC\n         * @param erasures location of erasures\n         * @return number of errors\n         * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors\n         */\n        decode(received, numECCodewords, erasures) {\n            let poly = new ModulusPoly(this.field, received);\n            let S = new Int32Array(numECCodewords);\n            let error = false;\n            for (let i /*int*/ = numECCodewords; i > 0; i--) {\n                let evaluation = poly.evaluateAt(this.field.exp(i));\n                S[numECCodewords - i] = evaluation;\n                if (evaluation !== 0) {\n                    error = true;\n                }\n            }\n            if (!error) {\n                return 0;\n            }\n            let knownErrors = this.field.getOne();\n            if (erasures != null) {\n                for (const erasure of erasures) {\n                    let b = this.field.exp(received.length - 1 - erasure);\n                    // Add (1 - bx) term:\n                    let term = new ModulusPoly(this.field, new Int32Array([this.field.subtract(0, b), 1]));\n                    knownErrors = knownErrors.multiply(term);\n                }\n            }\n            let syndrome = new ModulusPoly(this.field, S);\n            // syndrome = syndrome.multiply(knownErrors);\n            let sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);\n            let sigma = sigmaOmega[0];\n            let omega = sigmaOmega[1];\n            // sigma = sigma.multiply(knownErrors);\n            let errorLocations = this.findErrorLocations(sigma);\n            let errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);\n            for (let i /*int*/ = 0; i < errorLocations.length; i++) {\n                let position = received.length - 1 - this.field.log(errorLocations[i]);\n                if (position < 0) {\n                    throw ChecksumException.getChecksumInstance();\n                }\n                received[position] = this.field.subtract(received[position], errorMagnitudes[i]);\n            }\n            return errorLocations.length;\n        }\n        /**\n         *\n         * @param ModulusPoly\n         * @param a\n         * @param ModulusPoly\n         * @param b\n         * @param int\n         * @param R\n         * @throws ChecksumException\n         */\n        runEuclideanAlgorithm(a, b, R) {\n            // Assume a's degree is >= b's\n            if (a.getDegree() < b.getDegree()) {\n                let temp = a;\n                a = b;\n                b = temp;\n            }\n            let rLast = a;\n            let r = b;\n            let tLast = this.field.getZero();\n            let t = this.field.getOne();\n            // Run Euclidean algorithm until r's degree is less than R/2\n            while (r.getDegree() >= Math.round(R / 2)) {\n                let rLastLast = rLast;\n                let tLastLast = tLast;\n                rLast = r;\n                tLast = t;\n                // Divide rLastLast by rLast, with quotient in q and remainder in r\n                if (rLast.isZero()) {\n                    // Oops, Euclidean algorithm already terminated?\n                    throw ChecksumException.getChecksumInstance();\n                }\n                r = rLastLast;\n                let q = this.field.getZero();\n                let denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n                let dltInverse = this.field.inverse(denominatorLeadingTerm);\n                while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n                    let degreeDiff = r.getDegree() - rLast.getDegree();\n                    let scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n                    q = q.add(this.field.buildMonomial(degreeDiff, scale));\n                    r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));\n                }\n                t = q.multiply(tLast).subtract(tLastLast).negative();\n            }\n            let sigmaTildeAtZero = t.getCoefficient(0);\n            if (sigmaTildeAtZero === 0) {\n                throw ChecksumException.getChecksumInstance();\n            }\n            let inverse = this.field.inverse(sigmaTildeAtZero);\n            let sigma = t.multiply(inverse);\n            let omega = r.multiply(inverse);\n            return [sigma, omega];\n        }\n        /**\n         *\n         * @param errorLocator\n         * @throws ChecksumException\n         */\n        findErrorLocations(errorLocator) {\n            // This is a direct application of Chien's search\n            let numErrors = errorLocator.getDegree();\n            let result = new Int32Array(numErrors);\n            let e = 0;\n            for (let i /*int*/ = 1; i < this.field.getSize() && e < numErrors; i++) {\n                if (errorLocator.evaluateAt(i) === 0) {\n                    result[e] = this.field.inverse(i);\n                    e++;\n                }\n            }\n            if (e !== numErrors) {\n                throw ChecksumException.getChecksumInstance();\n            }\n            return result;\n        }\n        findErrorMagnitudes(errorEvaluator, errorLocator, errorLocations) {\n            let errorLocatorDegree = errorLocator.getDegree();\n            let formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);\n            for (let i /*int*/ = 1; i <= errorLocatorDegree; i++) {\n                formalDerivativeCoefficients[errorLocatorDegree - i] =\n                    this.field.multiply(i, errorLocator.getCoefficient(i));\n            }\n            let formalDerivative = new ModulusPoly(this.field, formalDerivativeCoefficients);\n            // This is directly applying Forney's Formula\n            let s = errorLocations.length;\n            let result = new Int32Array(s);\n            for (let i /*int*/ = 0; i < s; i++) {\n                let xiInverse = this.field.inverse(errorLocations[i]);\n                let numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));\n                let denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));\n                result[i] = this.field.multiply(numerator, denominator);\n            }\n            return result;\n        }\n    }\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /**\n     * @author Guenther Grau\n     */\n    /*final*/ class BoundingBox {\n        constructor(image, topLeft, bottomLeft, topRight, bottomRight) {\n            if (image instanceof BoundingBox) {\n                this.constructor_2(image);\n            }\n            else {\n                this.constructor_1(image, topLeft, bottomLeft, topRight, bottomRight);\n            }\n        }\n        /**\n         *\n         * @param image\n         * @param topLeft\n         * @param bottomLeft\n         * @param topRight\n         * @param bottomRight\n         *\n         * @throws NotFoundException\n         */\n        constructor_1(image, topLeft, bottomLeft, topRight, bottomRight) {\n            const leftUnspecified = topLeft == null || bottomLeft == null;\n            const rightUnspecified = topRight == null || bottomRight == null;\n            if (leftUnspecified && rightUnspecified) {\n                throw new NotFoundException();\n            }\n            if (leftUnspecified) {\n                topLeft = new ResultPoint(0, topRight.getY());\n                bottomLeft = new ResultPoint(0, bottomRight.getY());\n            }\n            else if (rightUnspecified) {\n                topRight = new ResultPoint(image.getWidth() - 1, topLeft.getY());\n                bottomRight = new ResultPoint(image.getWidth() - 1, bottomLeft.getY());\n            }\n            this.image = image;\n            this.topLeft = topLeft;\n            this.bottomLeft = bottomLeft;\n            this.topRight = topRight;\n            this.bottomRight = bottomRight;\n            this.minX = Math.trunc(Math.min(topLeft.getX(), bottomLeft.getX()));\n            this.maxX = Math.trunc(Math.max(topRight.getX(), bottomRight.getX()));\n            this.minY = Math.trunc(Math.min(topLeft.getY(), topRight.getY()));\n            this.maxY = Math.trunc(Math.max(bottomLeft.getY(), bottomRight.getY()));\n        }\n        constructor_2(boundingBox) {\n            this.image = boundingBox.image;\n            this.topLeft = boundingBox.getTopLeft();\n            this.bottomLeft = boundingBox.getBottomLeft();\n            this.topRight = boundingBox.getTopRight();\n            this.bottomRight = boundingBox.getBottomRight();\n            this.minX = boundingBox.getMinX();\n            this.maxX = boundingBox.getMaxX();\n            this.minY = boundingBox.getMinY();\n            this.maxY = boundingBox.getMaxY();\n        }\n        /**\n         * @throws NotFoundException\n         */\n        static merge(leftBox, rightBox) {\n            if (leftBox == null) {\n                return rightBox;\n            }\n            if (rightBox == null) {\n                return leftBox;\n            }\n            return new BoundingBox(leftBox.image, leftBox.topLeft, leftBox.bottomLeft, rightBox.topRight, rightBox.bottomRight);\n        }\n        /**\n         * @throws NotFoundException\n         */\n        addMissingRows(missingStartRows, missingEndRows, isLeft) {\n            let newTopLeft = this.topLeft;\n            let newBottomLeft = this.bottomLeft;\n            let newTopRight = this.topRight;\n            let newBottomRight = this.bottomRight;\n            if (missingStartRows > 0) {\n                let top = isLeft ? this.topLeft : this.topRight;\n                let newMinY = Math.trunc(top.getY() - missingStartRows);\n                if (newMinY < 0) {\n                    newMinY = 0;\n                }\n                let newTop = new ResultPoint(top.getX(), newMinY);\n                if (isLeft) {\n                    newTopLeft = newTop;\n                }\n                else {\n                    newTopRight = newTop;\n                }\n            }\n            if (missingEndRows > 0) {\n                let bottom = isLeft ? this.bottomLeft : this.bottomRight;\n                let newMaxY = Math.trunc(bottom.getY() + missingEndRows);\n                if (newMaxY >= this.image.getHeight()) {\n                    newMaxY = this.image.getHeight() - 1;\n                }\n                let newBottom = new ResultPoint(bottom.getX(), newMaxY);\n                if (isLeft) {\n                    newBottomLeft = newBottom;\n                }\n                else {\n                    newBottomRight = newBottom;\n                }\n            }\n            return new BoundingBox(this.image, newTopLeft, newBottomLeft, newTopRight, newBottomRight);\n        }\n        getMinX() {\n            return this.minX;\n        }\n        getMaxX() {\n            return this.maxX;\n        }\n        getMinY() {\n            return this.minY;\n        }\n        getMaxY() {\n            return this.maxY;\n        }\n        getTopLeft() {\n            return this.topLeft;\n        }\n        getTopRight() {\n            return this.topRight;\n        }\n        getBottomLeft() {\n            return this.bottomLeft;\n        }\n        getBottomRight() {\n            return this.bottomRight;\n        }\n    }\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // package com.google.zxing.pdf417.decoder;\n    /**\n     * @author Guenther Grau\n     */\n    /*final*/ class BarcodeMetadata {\n        constructor(columnCount, rowCountUpperPart, rowCountLowerPart, errorCorrectionLevel) {\n            this.columnCount = columnCount;\n            this.errorCorrectionLevel = errorCorrectionLevel;\n            this.rowCountUpperPart = rowCountUpperPart;\n            this.rowCountLowerPart = rowCountLowerPart;\n            this.rowCount = rowCountUpperPart + rowCountLowerPart;\n        }\n        getColumnCount() {\n            return this.columnCount;\n        }\n        getErrorCorrectionLevel() {\n            return this.errorCorrectionLevel;\n        }\n        getRowCount() {\n            return this.rowCount;\n        }\n        getRowCountUpperPart() {\n            return this.rowCountUpperPart;\n        }\n        getRowCountLowerPart() {\n            return this.rowCountLowerPart;\n        }\n    }\n\n    /**\n     * Java Formatter class polyfill that works in the JS way.\n     */\n    class Formatter {\n        constructor() {\n            this.buffer = '';\n        }\n        /**\n         *\n         * @see https://stackoverflow.com/a/13439711/4367683\n         *\n         * @param str\n         * @param arr\n         */\n        static form(str, arr) {\n            let i = -1;\n            function callback(exp, p0, p1, p2, p3, p4) {\n                if (exp === '%%')\n                    return '%';\n                if (arr[++i] === undefined)\n                    return undefined;\n                exp = p2 ? parseInt(p2.substr(1)) : undefined;\n                let base = p3 ? parseInt(p3.substr(1)) : undefined;\n                let val;\n                switch (p4) {\n                    case 's':\n                        val = arr[i];\n                        break;\n                    case 'c':\n                        val = arr[i][0];\n                        break;\n                    case 'f':\n                        val = parseFloat(arr[i]).toFixed(exp);\n                        break;\n                    case 'p':\n                        val = parseFloat(arr[i]).toPrecision(exp);\n                        break;\n                    case 'e':\n                        val = parseFloat(arr[i]).toExponential(exp);\n                        break;\n                    case 'x':\n                        val = parseInt(arr[i]).toString(base ? base : 16);\n                        break;\n                    case 'd':\n                        val = parseFloat(parseInt(arr[i], base ? base : 10).toPrecision(exp)).toFixed(0);\n                        break;\n                }\n                val = typeof val === 'object' ? JSON.stringify(val) : (+val).toString(base);\n                let size = parseInt(p1); /* padding size */\n                let ch = p1 && (p1[0] + '') === '0' ? '0' : ' '; /* isnull? */\n                while (val.length < size)\n                    val = p0 !== undefined ? val + ch : ch + val; /* isminus? */\n                return val;\n            }\n            let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;\n            return str.replace(regex, callback);\n        }\n        /**\n         *\n         * @param append The new string to append.\n         * @param args Argumets values to be formated.\n         */\n        format(append, ...args) {\n            this.buffer += Formatter.form(append, args);\n        }\n        /**\n         * Returns the Formatter string value.\n         */\n        toString() {\n            return this.buffer;\n        }\n    }\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * @author Guenther Grau\n     */\n    class DetectionResultColumn {\n        constructor(boundingBox) {\n            this.boundingBox = new BoundingBox(boundingBox);\n            // this.codewords = new Codeword[boundingBox.getMaxY() - boundingBox.getMinY() + 1];\n            this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);\n        }\n        /*final*/ getCodewordNearby(imageRow) {\n            let codeword = this.getCodeword(imageRow);\n            if (codeword != null) {\n                return codeword;\n            }\n            for (let i = 1; i < DetectionResultColumn.MAX_NEARBY_DISTANCE; i++) {\n                let nearImageRow = this.imageRowToCodewordIndex(imageRow) - i;\n                if (nearImageRow >= 0) {\n                    codeword = this.codewords[nearImageRow];\n                    if (codeword != null) {\n                        return codeword;\n                    }\n                }\n                nearImageRow = this.imageRowToCodewordIndex(imageRow) + i;\n                if (nearImageRow < this.codewords.length) {\n                    codeword = this.codewords[nearImageRow];\n                    if (codeword != null) {\n                        return codeword;\n                    }\n                }\n            }\n            return null;\n        }\n        /*final int*/ imageRowToCodewordIndex(imageRow) {\n            return imageRow - this.boundingBox.getMinY();\n        }\n        /*final void*/ setCodeword(imageRow, codeword) {\n            this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;\n        }\n        /*final*/ getCodeword(imageRow) {\n            return this.codewords[this.imageRowToCodewordIndex(imageRow)];\n        }\n        /*final*/ getBoundingBox() {\n            return this.boundingBox;\n        }\n        /*final*/ getCodewords() {\n            return this.codewords;\n        }\n        // @Override\n        toString() {\n            const formatter = new Formatter();\n            let row = 0;\n            for (const codeword of this.codewords) {\n                if (codeword == null) {\n                    formatter.format('%3d:    |   %n', row++);\n                    continue;\n                }\n                formatter.format('%3d: %3d|%3d%n', row++, codeword.getRowNumber(), codeword.getValue());\n            }\n            return formatter.toString();\n        }\n    }\n    DetectionResultColumn.MAX_NEARBY_DISTANCE = 5;\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // import java.util.ArrayList;\n    // import java.util.Collection;\n    // import java.util.HashMap;\n    // import java.util.Map;\n    // import java.util.Map.Entry;\n    /**\n     * @author Guenther Grau\n     */\n    /*final*/ class BarcodeValue {\n        constructor() {\n            this.values = new Map();\n        }\n        /**\n         * Add an occurrence of a value\n         */\n        setValue(value) {\n            value = Math.trunc(value);\n            let confidence = this.values.get(value);\n            if (confidence == null) {\n                confidence = 0;\n            }\n            confidence++;\n            this.values.set(value, confidence);\n        }\n        /**\n         * Determines the maximum occurrence of a set value and returns all values which were set with this occurrence.\n         * @return an array of int, containing the values with the highest occurrence, or null, if no value was set\n         */\n        getValue() {\n            let maxConfidence = -1;\n            let result = new Array();\n            for (const [key, value] of this.values.entries()) {\n                const entry = {\n                    getKey: () => key,\n                    getValue: () => value,\n                };\n                if (entry.getValue() > maxConfidence) {\n                    maxConfidence = entry.getValue();\n                    result = [];\n                    result.push(entry.getKey());\n                }\n                else if (entry.getValue() === maxConfidence) {\n                    result.push(entry.getKey());\n                }\n            }\n            return PDF417Common.toIntArray(result);\n        }\n        getConfidence(value) {\n            return this.values.get(value);\n        }\n    }\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * @author Guenther Grau\n     */\n    /*final*/ class DetectionResultRowIndicatorColumn extends DetectionResultColumn {\n        constructor(boundingBox, isLeft) {\n            super(boundingBox);\n            this._isLeft = isLeft;\n        }\n        setRowNumbers() {\n            for (let codeword /*Codeword*/ of this.getCodewords()) {\n                if (codeword != null) {\n                    codeword.setRowNumberAsRowIndicatorColumn();\n                }\n            }\n        }\n        // TODO implement properly\n        // TODO maybe we should add missing codewords to store the correct row number to make\n        // finding row numbers for other columns easier\n        // use row height count to make detection of invalid row numbers more reliable\n        adjustCompleteIndicatorColumnRowNumbers(barcodeMetadata) {\n            let codewords = this.getCodewords();\n            this.setRowNumbers();\n            this.removeIncorrectCodewords(codewords, barcodeMetadata);\n            let boundingBox = this.getBoundingBox();\n            let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();\n            let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();\n            let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));\n            let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));\n            // We need to be careful using the average row height. Barcode could be skewed so that we have smaller and\n            // taller rows\n            // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();\n            let barcodeRow = -1;\n            let maxRowHeight = 1;\n            let currentRowHeight = 0;\n            for (let codewordsRow /*int*/ = firstRow; codewordsRow < lastRow; codewordsRow++) {\n                if (codewords[codewordsRow] == null) {\n                    continue;\n                }\n                let codeword = codewords[codewordsRow];\n                //      float expectedRowNumber = (codewordsRow - firstRow) / averageRowHeight;\n                //      if (Math.abs(codeword.getRowNumber() - expectedRowNumber) > 2) {\n                //        SimpleLog.log(LEVEL.WARNING,\n                //            \"Removing codeword, rowNumberSkew too high, codeword[\" + codewordsRow + \"]: Expected Row: \" +\n                //                expectedRowNumber + \", RealRow: \" + codeword.getRowNumber() + \", value: \" + codeword.getValue());\n                //        codewords[codewordsRow] = null;\n                //      }\n                let rowDifference = codeword.getRowNumber() - barcodeRow;\n                // TODO improve handling with case where first row indicator doesn't start with 0\n                if (rowDifference === 0) {\n                    currentRowHeight++;\n                }\n                else if (rowDifference === 1) {\n                    maxRowHeight = Math.max(maxRowHeight, currentRowHeight);\n                    currentRowHeight = 1;\n                    barcodeRow = codeword.getRowNumber();\n                }\n                else if (rowDifference < 0 ||\n                    codeword.getRowNumber() >= barcodeMetadata.getRowCount() ||\n                    rowDifference > codewordsRow) {\n                    codewords[codewordsRow] = null;\n                }\n                else {\n                    let checkedRows;\n                    if (maxRowHeight > 2) {\n                        checkedRows = (maxRowHeight - 2) * rowDifference;\n                    }\n                    else {\n                        checkedRows = rowDifference;\n                    }\n                    let closePreviousCodewordFound = checkedRows >= codewordsRow;\n                    for (let i /*int*/ = 1; i <= checkedRows && !closePreviousCodewordFound; i++) {\n                        // there must be (height * rowDifference) number of codewords missing. For now we assume height = 1.\n                        // This should hopefully get rid of most problems already.\n                        closePreviousCodewordFound = codewords[codewordsRow - i] != null;\n                    }\n                    if (closePreviousCodewordFound) {\n                        codewords[codewordsRow] = null;\n                    }\n                    else {\n                        barcodeRow = codeword.getRowNumber();\n                        currentRowHeight = 1;\n                    }\n                }\n            }\n            // return (int) (averageRowHeight + 0.5);\n        }\n        getRowHeights() {\n            let barcodeMetadata = this.getBarcodeMetadata();\n            if (barcodeMetadata == null) {\n                return null;\n            }\n            this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);\n            let result = new Int32Array(barcodeMetadata.getRowCount());\n            for (let codeword /*Codeword*/ of this.getCodewords()) {\n                if (codeword != null) {\n                    let rowNumber = codeword.getRowNumber();\n                    if (rowNumber >= result.length) {\n                        // We have more rows than the barcode metadata allows for, ignore them.\n                        continue;\n                    }\n                    result[rowNumber]++;\n                } // else throw exception?\n            }\n            return result;\n        }\n        // TODO maybe we should add missing codewords to store the correct row number to make\n        // finding row numbers for other columns easier\n        // use row height count to make detection of invalid row numbers more reliable\n        adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata) {\n            let boundingBox = this.getBoundingBox();\n            let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();\n            let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();\n            let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));\n            let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));\n            // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();\n            let codewords = this.getCodewords();\n            let barcodeRow = -1;\n            for (let codewordsRow /*int*/ = firstRow; codewordsRow < lastRow; codewordsRow++) {\n                if (codewords[codewordsRow] == null) {\n                    continue;\n                }\n                let codeword = codewords[codewordsRow];\n                codeword.setRowNumberAsRowIndicatorColumn();\n                let rowDifference = codeword.getRowNumber() - barcodeRow;\n                // TODO improve handling with case where first row indicator doesn't start with 0\n                if (rowDifference === 0) ;\n                else if (rowDifference === 1) {\n                    barcodeRow = codeword.getRowNumber();\n                }\n                else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {\n                    codewords[codewordsRow] = null;\n                }\n                else {\n                    barcodeRow = codeword.getRowNumber();\n                }\n            }\n            // return (int) (averageRowHeight + 0.5);\n        }\n        getBarcodeMetadata() {\n            let codewords = this.getCodewords();\n            let barcodeColumnCount = new BarcodeValue();\n            let barcodeRowCountUpperPart = new BarcodeValue();\n            let barcodeRowCountLowerPart = new BarcodeValue();\n            let barcodeECLevel = new BarcodeValue();\n            for (let codeword /*Codeword*/ of codewords) {\n                if (codeword == null) {\n                    continue;\n                }\n                codeword.setRowNumberAsRowIndicatorColumn();\n                let rowIndicatorValue = codeword.getValue() % 30;\n                let codewordRowNumber = codeword.getRowNumber();\n                if (!this._isLeft) {\n                    codewordRowNumber += 2;\n                }\n                switch (codewordRowNumber % 3) {\n                    case 0:\n                        barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1);\n                        break;\n                    case 1:\n                        barcodeECLevel.setValue(rowIndicatorValue / 3);\n                        barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3);\n                        break;\n                    case 2:\n                        barcodeColumnCount.setValue(rowIndicatorValue + 1);\n                        break;\n                }\n            }\n            // Maybe we should check if we have ambiguous values?\n            if ((barcodeColumnCount.getValue().length === 0) ||\n                (barcodeRowCountUpperPart.getValue().length === 0) ||\n                (barcodeRowCountLowerPart.getValue().length === 0) ||\n                (barcodeECLevel.getValue().length === 0) ||\n                barcodeColumnCount.getValue()[0] < 1 ||\n                barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common.MIN_ROWS_IN_BARCODE ||\n                barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] > PDF417Common.MAX_ROWS_IN_BARCODE) {\n                return null;\n            }\n            let barcodeMetadata = new BarcodeMetadata(barcodeColumnCount.getValue()[0], barcodeRowCountUpperPart.getValue()[0], barcodeRowCountLowerPart.getValue()[0], barcodeECLevel.getValue()[0]);\n            this.removeIncorrectCodewords(codewords, barcodeMetadata);\n            return barcodeMetadata;\n        }\n        removeIncorrectCodewords(codewords, barcodeMetadata) {\n            // Remove codewords which do not match the metadata\n            // TODO Maybe we should keep the incorrect codewords for the start and end positions?\n            for (let codewordRow /*int*/ = 0; codewordRow < codewords.length; codewordRow++) {\n                let codeword = codewords[codewordRow];\n                if (codewords[codewordRow] == null) {\n                    continue;\n                }\n                let rowIndicatorValue = codeword.getValue() % 30;\n                let codewordRowNumber = codeword.getRowNumber();\n                if (codewordRowNumber > barcodeMetadata.getRowCount()) {\n                    codewords[codewordRow] = null;\n                    continue;\n                }\n                if (!this._isLeft) {\n                    codewordRowNumber += 2;\n                }\n                switch (codewordRowNumber % 3) {\n                    case 0:\n                        if (rowIndicatorValue * 3 + 1 !== barcodeMetadata.getRowCountUpperPart()) {\n                            codewords[codewordRow] = null;\n                        }\n                        break;\n                    case 1:\n                        if (Math.trunc(rowIndicatorValue / 3) !== barcodeMetadata.getErrorCorrectionLevel() ||\n                            rowIndicatorValue % 3 !== barcodeMetadata.getRowCountLowerPart()) {\n                            codewords[codewordRow] = null;\n                        }\n                        break;\n                    case 2:\n                        if (rowIndicatorValue + 1 !== barcodeMetadata.getColumnCount()) {\n                            codewords[codewordRow] = null;\n                        }\n                        break;\n                }\n            }\n        }\n        isLeft() {\n            return this._isLeft;\n        }\n        // @Override\n        toString() {\n            return 'IsLeft: ' + this._isLeft + '\\n' + super.toString();\n        }\n    }\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * @author Guenther Grau\n     */\n    /*final*/ class DetectionResult {\n        constructor(barcodeMetadata, boundingBox) {\n            /*final*/ this.ADJUST_ROW_NUMBER_SKIP = 2;\n            this.barcodeMetadata = barcodeMetadata;\n            this.barcodeColumnCount = barcodeMetadata.getColumnCount();\n            this.boundingBox = boundingBox;\n            // this.detectionResultColumns = new DetectionResultColumn[this.barcodeColumnCount + 2];\n            this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);\n        }\n        getDetectionResultColumns() {\n            this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);\n            this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);\n            let unadjustedCodewordCount = PDF417Common.MAX_CODEWORDS_IN_BARCODE;\n            let previousUnadjustedCount;\n            do {\n                previousUnadjustedCount = unadjustedCodewordCount;\n                unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();\n            } while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);\n            return this.detectionResultColumns;\n        }\n        adjustIndicatorColumnRowNumbers(detectionResultColumn) {\n            if (detectionResultColumn != null) {\n                detectionResultColumn\n                    .adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);\n            }\n        }\n        // TODO ensure that no detected codewords with unknown row number are left\n        // we should be able to estimate the row height and use it as a hint for the row number\n        // we should also fill the rows top to bottom and bottom to top\n        /**\n         * @return number of codewords which don't have a valid row number. Note that the count is not accurate as codewords\n         * will be counted several times. It just serves as an indicator to see when we can stop adjusting row numbers\n         */\n        adjustRowNumbersAndGetCount() {\n            let unadjustedCount = this.adjustRowNumbersByRow();\n            if (unadjustedCount === 0) {\n                return 0;\n            }\n            for (let barcodeColumn /*int*/ = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++) {\n                let codewords = this.detectionResultColumns[barcodeColumn].getCodewords();\n                for (let codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {\n                    if (codewords[codewordsRow] == null) {\n                        continue;\n                    }\n                    if (!codewords[codewordsRow].hasValidRowNumber()) {\n                        this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);\n                    }\n                }\n            }\n            return unadjustedCount;\n        }\n        adjustRowNumbersByRow() {\n            this.adjustRowNumbersFromBothRI();\n            // TODO we should only do full row adjustments if row numbers of left and right row indicator column match.\n            // Maybe it's even better to calculated the height (rows: d) and divide it by the number of barcode\n            // rows. This, together with the LRI and RRI row numbers should allow us to get a good estimate where a row\n            // number starts and ends.\n            let unadjustedCount = this.adjustRowNumbersFromLRI();\n            return unadjustedCount + this.adjustRowNumbersFromRRI();\n        }\n        adjustRowNumbersFromBothRI() {\n            if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {\n                return;\n            }\n            let LRIcodewords = this.detectionResultColumns[0].getCodewords();\n            let RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();\n            for (let codewordsRow /*int*/ = 0; codewordsRow < LRIcodewords.length; codewordsRow++) {\n                if (LRIcodewords[codewordsRow] != null &&\n                    RRIcodewords[codewordsRow] != null &&\n                    LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {\n                    for (let barcodeColumn /*int*/ = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++) {\n                        let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                        if (codeword == null) {\n                            continue;\n                        }\n                        codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());\n                        if (!codeword.hasValidRowNumber()) {\n                            this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;\n                        }\n                    }\n                }\n            }\n        }\n        adjustRowNumbersFromRRI() {\n            if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {\n                return 0;\n            }\n            let unadjustedCount = 0;\n            let codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();\n            for (let codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {\n                if (codewords[codewordsRow] == null) {\n                    continue;\n                }\n                let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();\n                let invalidRowCounts = 0;\n                for (let barcodeColumn /*int*/ = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--) {\n                    let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                    if (codeword != null) {\n                        invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);\n                        if (!codeword.hasValidRowNumber()) {\n                            unadjustedCount++;\n                        }\n                    }\n                }\n            }\n            return unadjustedCount;\n        }\n        adjustRowNumbersFromLRI() {\n            if (this.detectionResultColumns[0] == null) {\n                return 0;\n            }\n            let unadjustedCount = 0;\n            let codewords = this.detectionResultColumns[0].getCodewords();\n            for (let codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {\n                if (codewords[codewordsRow] == null) {\n                    continue;\n                }\n                let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();\n                let invalidRowCounts = 0;\n                for (let barcodeColumn /*int*/ = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++) {\n                    let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                    if (codeword != null) {\n                        invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);\n                        if (!codeword.hasValidRowNumber()) {\n                            unadjustedCount++;\n                        }\n                    }\n                }\n            }\n            return unadjustedCount;\n        }\n        static adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword) {\n            if (codeword == null) {\n                return invalidRowCounts;\n            }\n            if (!codeword.hasValidRowNumber()) {\n                if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {\n                    codeword.setRowNumber(rowIndicatorRowNumber);\n                    invalidRowCounts = 0;\n                }\n                else {\n                    ++invalidRowCounts;\n                }\n            }\n            return invalidRowCounts;\n        }\n        adjustRowNumbers(barcodeColumn, codewordsRow, codewords) {\n            if (!this.detectionResultColumns[barcodeColumn - 1]) {\n                return;\n            }\n            let codeword = codewords[codewordsRow];\n            let previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();\n            let nextColumnCodewords = previousColumnCodewords;\n            if (this.detectionResultColumns[barcodeColumn + 1] != null) {\n                nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();\n            }\n            // let otherCodewords: Codeword[] = new Codeword[14];\n            let otherCodewords = new Array(14);\n            otherCodewords[2] = previousColumnCodewords[codewordsRow];\n            otherCodewords[3] = nextColumnCodewords[codewordsRow];\n            if (codewordsRow > 0) {\n                otherCodewords[0] = codewords[codewordsRow - 1];\n                otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];\n                otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];\n            }\n            if (codewordsRow > 1) {\n                otherCodewords[8] = codewords[codewordsRow - 2];\n                otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];\n                otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];\n            }\n            if (codewordsRow < codewords.length - 1) {\n                otherCodewords[1] = codewords[codewordsRow + 1];\n                otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];\n                otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];\n            }\n            if (codewordsRow < codewords.length - 2) {\n                otherCodewords[9] = codewords[codewordsRow + 2];\n                otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];\n                otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];\n            }\n            for (let otherCodeword of otherCodewords) {\n                if (DetectionResult.adjustRowNumber(codeword, otherCodeword)) {\n                    return;\n                }\n            }\n        }\n        /**\n         * @return true, if row number was adjusted, false otherwise\n         */\n        static adjustRowNumber(codeword, otherCodeword) {\n            if (otherCodeword == null) {\n                return false;\n            }\n            if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {\n                codeword.setRowNumber(otherCodeword.getRowNumber());\n                return true;\n            }\n            return false;\n        }\n        getBarcodeColumnCount() {\n            return this.barcodeColumnCount;\n        }\n        getBarcodeRowCount() {\n            return this.barcodeMetadata.getRowCount();\n        }\n        getBarcodeECLevel() {\n            return this.barcodeMetadata.getErrorCorrectionLevel();\n        }\n        setBoundingBox(boundingBox) {\n            this.boundingBox = boundingBox;\n        }\n        getBoundingBox() {\n            return this.boundingBox;\n        }\n        setDetectionResultColumn(barcodeColumn, detectionResultColumn) {\n            this.detectionResultColumns[barcodeColumn] = detectionResultColumn;\n        }\n        getDetectionResultColumn(barcodeColumn) {\n            return this.detectionResultColumns[barcodeColumn];\n        }\n        // @Override\n        toString() {\n            let rowIndicatorColumn = this.detectionResultColumns[0];\n            if (rowIndicatorColumn == null) {\n                rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];\n            }\n            // try (\n            let formatter = new Formatter();\n            // ) {\n            for (let codewordsRow /*int*/ = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++) {\n                formatter.format('CW %3d:', codewordsRow);\n                for (let barcodeColumn /*int*/ = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++) {\n                    if (this.detectionResultColumns[barcodeColumn] == null) {\n                        formatter.format('    |   ');\n                        continue;\n                    }\n                    let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                    if (codeword == null) {\n                        formatter.format('    |   ');\n                        continue;\n                    }\n                    formatter.format(' %3d|%3d', codeword.getRowNumber(), codeword.getValue());\n                }\n                formatter.format('%n');\n            }\n            return formatter.toString();\n            // }\n        }\n    }\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // package com.google.zxing.pdf417.decoder;\n    /**\n     * @author Guenther Grau\n     */\n    /*final*/ class Codeword {\n        constructor(startX, endX, bucket, value) {\n            this.rowNumber = Codeword.BARCODE_ROW_UNKNOWN;\n            this.startX = Math.trunc(startX);\n            this.endX = Math.trunc(endX);\n            this.bucket = Math.trunc(bucket);\n            this.value = Math.trunc(value);\n        }\n        hasValidRowNumber() {\n            return this.isValidRowNumber(this.rowNumber);\n        }\n        isValidRowNumber(rowNumber) {\n            return rowNumber !== Codeword.BARCODE_ROW_UNKNOWN && this.bucket === (rowNumber % 3) * 3;\n        }\n        setRowNumberAsRowIndicatorColumn() {\n            this.rowNumber = Math.trunc((Math.trunc(this.value / 30)) * 3 + Math.trunc(this.bucket / 3));\n        }\n        getWidth() {\n            return this.endX - this.startX;\n        }\n        getStartX() {\n            return this.startX;\n        }\n        getEndX() {\n            return this.endX;\n        }\n        getBucket() {\n            return this.bucket;\n        }\n        getValue() {\n            return this.value;\n        }\n        getRowNumber() {\n            return this.rowNumber;\n        }\n        setRowNumber(rowNumber) {\n            this.rowNumber = rowNumber;\n        }\n        //   @Override\n        toString() {\n            return this.rowNumber + '|' + this.value;\n        }\n    }\n    Codeword.BARCODE_ROW_UNKNOWN = -1;\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /**\n     * @author Guenther Grau\n     * @author creatale GmbH (christoph.schulz@creatale.de)\n     */\n    /*final*/ class PDF417CodewordDecoder {\n        /* @note\n         * this action have to be performed before first use of class\n         * - static constructor\n         * working with 32bit float (based from Java logic)\n        */\n        static initialize() {\n            // Pre-computes the symbol ratio table.\n            for ( /*int*/let i = 0; i < PDF417Common.SYMBOL_TABLE.length; i++) {\n                let currentSymbol = PDF417Common.SYMBOL_TABLE[i];\n                let currentBit = currentSymbol & 0x1;\n                for ( /*int*/let j = 0; j < PDF417Common.BARS_IN_MODULE; j++) {\n                    let size = 0.0;\n                    while ((currentSymbol & 0x1) === currentBit) {\n                        size += 1.0;\n                        currentSymbol >>= 1;\n                    }\n                    currentBit = currentSymbol & 0x1;\n                    if (!PDF417CodewordDecoder.RATIOS_TABLE[i]) {\n                        PDF417CodewordDecoder.RATIOS_TABLE[i] = new Array(PDF417Common.BARS_IN_MODULE);\n                    }\n                    PDF417CodewordDecoder.RATIOS_TABLE[i][PDF417Common.BARS_IN_MODULE - j - 1] = Math.fround(size / PDF417Common.MODULES_IN_CODEWORD);\n                }\n            }\n            this.bSymbolTableReady = true;\n        }\n        static getDecodedValue(moduleBitCount) {\n            let decodedValue = PDF417CodewordDecoder.getDecodedCodewordValue(PDF417CodewordDecoder.sampleBitCounts(moduleBitCount));\n            if (decodedValue !== -1) {\n                return decodedValue;\n            }\n            return PDF417CodewordDecoder.getClosestDecodedValue(moduleBitCount);\n        }\n        static sampleBitCounts(moduleBitCount) {\n            let bitCountSum = MathUtils.sum(moduleBitCount);\n            let result = new Int32Array(PDF417Common.BARS_IN_MODULE);\n            let bitCountIndex = 0;\n            let sumPreviousBits = 0;\n            for ( /*int*/let i = 0; i < PDF417Common.MODULES_IN_CODEWORD; i++) {\n                let sampleIndex = bitCountSum / (2 * PDF417Common.MODULES_IN_CODEWORD) +\n                    (i * bitCountSum) / PDF417Common.MODULES_IN_CODEWORD;\n                if (sumPreviousBits + moduleBitCount[bitCountIndex] <= sampleIndex) {\n                    sumPreviousBits += moduleBitCount[bitCountIndex];\n                    bitCountIndex++;\n                }\n                result[bitCountIndex]++;\n            }\n            return result;\n        }\n        static getDecodedCodewordValue(moduleBitCount) {\n            let decodedValue = PDF417CodewordDecoder.getBitValue(moduleBitCount);\n            return PDF417Common.getCodeword(decodedValue) === -1 ? -1 : decodedValue;\n        }\n        static getBitValue(moduleBitCount) {\n            let result = /*long*/ 0;\n            for (let /*int*/ i = 0; i < moduleBitCount.length; i++) {\n                for ( /*int*/let bit = 0; bit < moduleBitCount[i]; bit++) {\n                    result = (result << 1) | (i % 2 === 0 ? 1 : 0);\n                }\n            }\n            return Math.trunc(result);\n        }\n        // working with 32bit float (as in Java)\n        static getClosestDecodedValue(moduleBitCount) {\n            let bitCountSum = MathUtils.sum(moduleBitCount);\n            let bitCountRatios = new Array(PDF417Common.BARS_IN_MODULE);\n            if (bitCountSum > 1) {\n                for (let /*int*/ i = 0; i < bitCountRatios.length; i++) {\n                    bitCountRatios[i] = Math.fround(moduleBitCount[i] / bitCountSum);\n                }\n            }\n            let bestMatchError = Float.MAX_VALUE;\n            let bestMatch = -1;\n            if (!this.bSymbolTableReady) {\n                PDF417CodewordDecoder.initialize();\n            }\n            for ( /*int*/let j = 0; j < PDF417CodewordDecoder.RATIOS_TABLE.length; j++) {\n                let error = 0.0;\n                let ratioTableRow = PDF417CodewordDecoder.RATIOS_TABLE[j];\n                for ( /*int*/let k = 0; k < PDF417Common.BARS_IN_MODULE; k++) {\n                    let diff = Math.fround(ratioTableRow[k] - bitCountRatios[k]);\n                    error += Math.fround(diff * diff);\n                    if (error >= bestMatchError) {\n                        break;\n                    }\n                }\n                if (error < bestMatchError) {\n                    bestMatchError = error;\n                    bestMatch = PDF417Common.SYMBOL_TABLE[j];\n                }\n            }\n            return bestMatch;\n        }\n    }\n    // flag that the table is ready for use\n    PDF417CodewordDecoder.bSymbolTableReady = false;\n    PDF417CodewordDecoder.RATIOS_TABLE = new Array(PDF417Common.SYMBOL_TABLE.length).map(x => x = new Array(PDF417Common.BARS_IN_MODULE));\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // package com.google.zxing.pdf417;\n    /**\n     * @author Guenther Grau\n     */\n    /*public final*/ class PDF417ResultMetadata {\n        constructor() {\n            this.segmentCount = -1;\n            this.fileSize = -1;\n            this.timestamp = -1;\n            this.checksum = -1;\n        }\n        /**\n         * The Segment ID represents the segment of the whole file distributed over different symbols.\n         *\n         * @return File segment index\n         */\n        getSegmentIndex() {\n            return this.segmentIndex;\n        }\n        setSegmentIndex(segmentIndex) {\n            this.segmentIndex = segmentIndex;\n        }\n        /**\n         * Is the same for each related PDF417 symbol\n         *\n         * @return File ID\n         */\n        getFileId() {\n            return this.fileId;\n        }\n        setFileId(fileId) {\n            this.fileId = fileId;\n        }\n        /**\n         * @return always null\n         * @deprecated use dedicated already parsed fields\n         */\n        //   @Deprecated\n        getOptionalData() {\n            return this.optionalData;\n        }\n        /**\n         * @param optionalData old optional data format as int array\n         * @deprecated parse and use new fields\n         */\n        //   @Deprecated\n        setOptionalData(optionalData) {\n            this.optionalData = optionalData;\n        }\n        /**\n         * @return true if it is the last segment\n         */\n        isLastSegment() {\n            return this.lastSegment;\n        }\n        setLastSegment(lastSegment) {\n            this.lastSegment = lastSegment;\n        }\n        /**\n         * @return count of segments, -1 if not set\n         */\n        getSegmentCount() {\n            return this.segmentCount;\n        }\n        setSegmentCount(segmentCount /*int*/) {\n            this.segmentCount = segmentCount;\n        }\n        getSender() {\n            return this.sender || null;\n        }\n        setSender(sender) {\n            this.sender = sender;\n        }\n        getAddressee() {\n            return this.addressee || null;\n        }\n        setAddressee(addressee) {\n            this.addressee = addressee;\n        }\n        /**\n         * Filename of the encoded file\n         *\n         * @return filename\n         */\n        getFileName() {\n            return this.fileName;\n        }\n        setFileName(fileName) {\n            this.fileName = fileName;\n        }\n        /**\n         * filesize in bytes of the encoded file\n         *\n         * @return filesize in bytes, -1 if not set\n         */\n        getFileSize() {\n            return this.fileSize;\n        }\n        setFileSize(fileSize /*long*/) {\n            this.fileSize = fileSize;\n        }\n        /**\n         * 16-bit CRC checksum using CCITT-16\n         *\n         * @return crc checksum, -1 if not set\n         */\n        getChecksum() {\n            return this.checksum;\n        }\n        setChecksum(checksum /*int*/) {\n            this.checksum = checksum;\n        }\n        /**\n         * unix epock timestamp, elapsed seconds since 1970-01-01\n         *\n         * @return elapsed seconds, -1 if not set\n         */\n        getTimestamp() {\n            return this.timestamp;\n        }\n        setTimestamp(timestamp /*long*/) {\n            this.timestamp = timestamp;\n        }\n    }\n\n    /**\n     * Ponyfill for Java's Long class.\n     */\n    class Long {\n        /**\n         * Parses a string to a number, since JS has no really Int64.\n         *\n         * @param num Numeric string.\n         * @param radix Destination radix.\n         */\n        static parseLong(num, radix = undefined) {\n            return parseInt(num, radix);\n        }\n    }\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class NullPointerException extends Exception {\n    }\n    NullPointerException.kind = 'NullPointerException';\n\n    /*\n     * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.\n     * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n     *\n     * This code is free software; you can redistribute it and/or modify it\n     * under the terms of the GNU General Public License version 2 only, as\n     * published by the Free Software Foundation.  Oracle designates this\n     * particular file as subject to the \"Classpath\" exception as provided\n     * by Oracle in the LICENSE file that accompanied this code.\n     *\n     * This code is distributed in the hope that it will be useful, but WITHOUT\n     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n     * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n     * version 2 for more details (a copy is included in the LICENSE file that\n     * accompanied this code).\n     *\n     * You should have received a copy of the GNU General Public License version\n     * 2 along with this work; if not, write to the Free Software Foundation,\n     * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n     *\n     * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n     * or visit www.oracle.com if you need additional information or have any\n     * questions.\n     */\n    // package java.io;\n    /**\n     * This abstract class is the superclass of all classes representing\n     * an output stream of bytes. An output stream accepts output bytes\n     * and sends them to some sink.\n     * <p>\n     * Applications that need to define a subclass of\n     * <code>OutputStream</code> must always provide at least a method\n     * that writes one byte of output.\n     *\n     * @author  Arthur van Hoff\n     * @see     java.io.BufferedOutputStream\n     * @see     java.io.ByteArrayOutputStream\n     * @see     java.io.DataOutputStream\n     * @see     java.io.FilterOutputStream\n     * @see     java.io.InputStream\n     * @see     java.io.OutputStream#write(int)\n     * @since   JDK1.0\n     */\n    /*public*/ class OutputStream /*implements Closeable, Flushable*/ {\n        /**\n         * Writes <code>b.length</code> bytes from the specified byte array\n         * to this output stream. The general contract for <code>write(b)</code>\n         * is that it should have exactly the same effect as the call\n         * <code>write(b, 0, b.length)</code>.\n         *\n         * @param      b   the data.\n         * @exception  IOException  if an I/O error occurs.\n         * @see        java.io.OutputStream#write(byte[], int, int)\n         */\n        writeBytes(b) {\n            this.writeBytesOffset(b, 0, b.length);\n        }\n        /**\n         * Writes <code>len</code> bytes from the specified byte array\n         * starting at offset <code>off</code> to this output stream.\n         * The general contract for <code>write(b, off, len)</code> is that\n         * some of the bytes in the array <code>b</code> are written to the\n         * output stream in order; element <code>b[off]</code> is the first\n         * byte written and <code>b[off+len-1]</code> is the last byte written\n         * by this operation.\n         * <p>\n         * The <code>write</code> method of <code>OutputStream</code> calls\n         * the write method of one argument on each of the bytes to be\n         * written out. Subclasses are encouraged to override this method and\n         * provide a more efficient implementation.\n         * <p>\n         * If <code>b</code> is <code>null</code>, a\n         * <code>NullPointerException</code> is thrown.\n         * <p>\n         * If <code>off</code> is negative, or <code>len</code> is negative, or\n         * <code>off+len</code> is greater than the length of the array\n         * <code>b</code>, then an <tt>IndexOutOfBoundsException</tt> is thrown.\n         *\n         * @param      b     the data.\n         * @param      off   the start offset in the data.\n         * @param      len   the number of bytes to write.\n         * @exception  IOException  if an I/O error occurs. In particular,\n         *             an <code>IOException</code> is thrown if the output\n         *             stream is closed.\n         */\n        writeBytesOffset(b, off, len) {\n            if (b == null) {\n                throw new NullPointerException();\n            }\n            else if ((off < 0) || (off > b.length) || (len < 0) ||\n                ((off + len) > b.length) || ((off + len) < 0)) {\n                throw new IndexOutOfBoundsException();\n            }\n            else if (len === 0) {\n                return;\n            }\n            for (let i = 0; i < len; i++) {\n                this.write(b[off + i]);\n            }\n        }\n        /**\n         * Flushes this output stream and forces any buffered output bytes\n         * to be written out. The general contract of <code>flush</code> is\n         * that calling it is an indication that, if any bytes previously\n         * written have been buffered by the implementation of the output\n         * stream, such bytes should immediately be written to their\n         * intended destination.\n         * <p>\n         * If the intended destination of this stream is an abstraction provided by\n         * the underlying operating system, for example a file, then flushing the\n         * stream guarantees only that bytes previously written to the stream are\n         * passed to the operating system for writing; it does not guarantee that\n         * they are actually written to a physical device such as a disk drive.\n         * <p>\n         * The <code>flush</code> method of <code>OutputStream</code> does nothing.\n         *\n         * @exception  IOException  if an I/O error occurs.\n         */\n        flush() {\n        }\n        /**\n         * Closes this output stream and releases any system resources\n         * associated with this stream. The general contract of <code>close</code>\n         * is that it closes the output stream. A closed stream cannot perform\n         * output operations and cannot be reopened.\n         * <p>\n         * The <code>close</code> method of <code>OutputStream</code> does nothing.\n         *\n         * @exception  IOException  if an I/O error occurs.\n         */\n        close() {\n        }\n    }\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class OutOfMemoryError extends Exception {\n    }\n\n    /*\n     * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.\n     * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n     *\n     * This code is free software; you can redistribute it and/or modify it\n     * under the terms of the GNU General Public License version 2 only, as\n     * published by the Free Software Foundation.  Oracle designates this\n     * particular file as subject to the \"Classpath\" exception as provided\n     * by Oracle in the LICENSE file that accompanied this code.\n     *\n     * This code is distributed in the hope that it will be useful, but WITHOUT\n     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n     * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n     * version 2 for more details (a copy is included in the LICENSE file that\n     * accompanied this code).\n     *\n     * You should have received a copy of the GNU General Public License version\n     * 2 along with this work; if not, write to the Free Software Foundation,\n     * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n     *\n     * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n     * or visit www.oracle.com if you need additional information or have any\n     * questions.\n     */\n    /**\n     * This class implements an output stream in which the data is\n     * written into a byte array. The buffer automatically grows as data\n     * is written to it.\n     * The data can be retrieved using <code>toByteArray()</code> and\n     * <code>toString()</code>.\n     * <p>\n     * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an <tt>IOException</tt>.\n     *\n     * @author  Arthur van Hoff\n     * @since   JDK1.0\n     */\n    /*public*/ class ByteArrayOutputStream extends OutputStream {\n        /**\n         * Creates a new byte array output stream. The buffer capacity is\n         * initially 32 bytes, though its size increases if necessary.\n         */\n        // public constructor() {\n        //     this(32);\n        // }\n        /**\n         * Creates a new byte array output stream, with a buffer capacity of\n         * the specified size, in bytes.\n         *\n         * @param   size   the initial size.\n         * @exception  IllegalArgumentException if size is negative.\n         */\n        constructor(size = 32) {\n            super();\n            /**\n             * The number of valid bytes in the buffer.\n             */\n            this.count = 0;\n            if (size < 0) {\n                throw new IllegalArgumentException('Negative initial size: '\n                    + size);\n            }\n            this.buf = new Uint8Array(size);\n        }\n        /**\n         * Increases the capacity if necessary to ensure that it can hold\n         * at least the number of elements specified by the minimum\n         * capacity argument.\n         *\n         * @param minCapacity the desired minimum capacity\n         * @throws OutOfMemoryError if {@code minCapacity < 0}.  This is\n         * interpreted as a request for the unsatisfiably large capacity\n         * {@code (long) Integer.MAX_VALUE + (minCapacity - Integer.MAX_VALUE)}.\n         */\n        ensureCapacity(minCapacity) {\n            // overflow-conscious code\n            if (minCapacity - this.buf.length > 0)\n                this.grow(minCapacity);\n        }\n        /**\n         * Increases the capacity to ensure that it can hold at least the\n         * number of elements specified by the minimum capacity argument.\n         *\n         * @param minCapacity the desired minimum capacity\n         */\n        grow(minCapacity) {\n            // overflow-conscious code\n            let oldCapacity = this.buf.length;\n            let newCapacity = oldCapacity << 1;\n            if (newCapacity - minCapacity < 0)\n                newCapacity = minCapacity;\n            if (newCapacity < 0) {\n                if (minCapacity < 0) // overflow\n                    throw new OutOfMemoryError();\n                newCapacity = Integer.MAX_VALUE;\n            }\n            this.buf = Arrays.copyOfUint8Array(this.buf, newCapacity);\n        }\n        /**\n         * Writes the specified byte to this byte array output stream.\n         *\n         * @param   b   the byte to be written.\n         */\n        write(b) {\n            this.ensureCapacity(this.count + 1);\n            this.buf[this.count] = /*(byte)*/ b;\n            this.count += 1;\n        }\n        /**\n         * Writes <code>len</code> bytes from the specified byte array\n         * starting at offset <code>off</code> to this byte array output stream.\n         *\n         * @param   b     the data.\n         * @param   off   the start offset in the data.\n         * @param   len   the number of bytes to write.\n         */\n        writeBytesOffset(b, off, len) {\n            if ((off < 0) || (off > b.length) || (len < 0) ||\n                ((off + len) - b.length > 0)) {\n                throw new IndexOutOfBoundsException();\n            }\n            this.ensureCapacity(this.count + len);\n            System.arraycopy(b, off, this.buf, this.count, len);\n            this.count += len;\n        }\n        /**\n         * Writes the complete contents of this byte array output stream to\n         * the specified output stream argument, as if by calling the output\n         * stream's write method using <code>out.write(buf, 0, count)</code>.\n         *\n         * @param      out   the output stream to which to write the data.\n         * @exception  IOException  if an I/O error occurs.\n         */\n        writeTo(out) {\n            out.writeBytesOffset(this.buf, 0, this.count);\n        }\n        /**\n         * Resets the <code>count</code> field of this byte array output\n         * stream to zero, so that all currently accumulated output in the\n         * output stream is discarded. The output stream can be used again,\n         * reusing the already allocated buffer space.\n         *\n         * @see     java.io.ByteArrayInputStream#count\n         */\n        reset() {\n            this.count = 0;\n        }\n        /**\n         * Creates a newly allocated byte array. Its size is the current\n         * size of this output stream and the valid contents of the buffer\n         * have been copied into it.\n         *\n         * @return  the current contents of this output stream, as a byte array.\n         * @see     java.io.ByteArrayOutputStream#size()\n         */\n        toByteArray() {\n            return Arrays.copyOfUint8Array(this.buf, this.count);\n        }\n        /**\n         * Returns the current size of the buffer.\n         *\n         * @return  the value of the <code>count</code> field, which is the number\n         *          of valid bytes in this output stream.\n         * @see     java.io.ByteArrayOutputStream#count\n         */\n        size() {\n            return this.count;\n        }\n        toString(param) {\n            if (!param) {\n                return this.toString_void();\n            }\n            if (typeof param === 'string') {\n                return this.toString_string(param);\n            }\n            return this.toString_number(param);\n        }\n        /**\n         * Converts the buffer's contents into a string decoding bytes using the\n         * platform's default character set. The length of the new <tt>String</tt>\n         * is a function of the character set, and hence may not be equal to the\n         * size of the buffer.\n         *\n         * <p> This method always replaces malformed-input and unmappable-character\n         * sequences with the default replacement string for the platform's\n         * default character set. The {@linkplain java.nio.charset.CharsetDecoder}\n         * class should be used when more control over the decoding process is\n         * required.\n         *\n         * @return String decoded from the buffer's contents.\n         * @since  JDK1.1\n         */\n        toString_void() {\n            return new String(this.buf /*, 0, this.count*/).toString();\n        }\n        /**\n         * Converts the buffer's contents into a string by decoding the bytes using\n         * the specified {@link java.nio.charset.Charset charsetName}. The length of\n         * the new <tt>String</tt> is a function of the charset, and hence may not be\n         * equal to the length of the byte array.\n         *\n         * <p> This method always replaces malformed-input and unmappable-character\n         * sequences with this charset's default replacement string. The {@link\n         * java.nio.charset.CharsetDecoder} class should be used when more control\n         * over the decoding process is required.\n         *\n         * @param  charsetName  the name of a supported\n         *              {@linkplain java.nio.charset.Charset </code>charset<code>}\n         * @return String decoded from the buffer's contents.\n         * @exception  UnsupportedEncodingException\n         *             If the named charset is not supported\n         * @since   JDK1.1\n         */\n        toString_string(charsetName) {\n            return new String(this.buf /*, 0, this.count, charsetName*/).toString();\n        }\n        /**\n         * Creates a newly allocated string. Its size is the current size of\n         * the output stream and the valid contents of the buffer have been\n         * copied into it. Each character <i>c</i> in the resulting string is\n         * constructed from the corresponding element <i>b</i> in the byte\n         * array such that:\n         * <blockquote><pre>\n         *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))\n         * </pre></blockquote>\n         *\n         * @deprecated This method does not properly convert bytes into characters.\n         * As of JDK&nbsp;1.1, the preferred way to do this is via the\n         * <code>toString(String enc)</code> method, which takes an encoding-name\n         * argument, or the <code>toString()</code> method, which uses the\n         * platform's default character encoding.\n         *\n         * @param      hibyte    the high byte of each resulting Unicode character.\n         * @return     the current contents of the output stream, as a string.\n         * @see        java.io.ByteArrayOutputStream#size()\n         * @see        java.io.ByteArrayOutputStream#toString(String)\n         * @see        java.io.ByteArrayOutputStream#toString()\n         */\n        // @Deprecated\n        toString_number(hibyte) {\n            return new String(this.buf /*, hibyte, 0, this.count*/).toString();\n        }\n        /**\n         * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\n         * this class can be called after the stream has been closed without\n         * generating an <tt>IOException</tt>.\n         * <p>\n         *\n         * @throws IOException\n         */\n        close() {\n        }\n    }\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*private*/ var Mode$2;\n    (function (Mode) {\n        Mode[Mode[\"ALPHA\"] = 0] = \"ALPHA\";\n        Mode[Mode[\"LOWER\"] = 1] = \"LOWER\";\n        Mode[Mode[\"MIXED\"] = 2] = \"MIXED\";\n        Mode[Mode[\"PUNCT\"] = 3] = \"PUNCT\";\n        Mode[Mode[\"ALPHA_SHIFT\"] = 4] = \"ALPHA_SHIFT\";\n        Mode[Mode[\"PUNCT_SHIFT\"] = 5] = \"PUNCT_SHIFT\";\n    })(Mode$2 || (Mode$2 = {}));\n    /**\n     * Indirectly access the global BigInt constructor, it\n     * allows browsers that doesn't support BigInt to run\n     * the library without breaking due to \"undefined BigInt\"\n     * errors.\n     */\n    function getBigIntConstructor() {\n        if (typeof window !== 'undefined') {\n            return window['BigInt'] || null;\n        }\n        if (typeof __webpack_require__.g !== 'undefined') {\n            return __webpack_require__.g['BigInt'] || null;\n        }\n        if (typeof self !== 'undefined') {\n            return self['BigInt'] || null;\n        }\n        throw new Error('Can\\'t search globals for BigInt!');\n    }\n    /**\n     * Used to store the BigInt constructor.\n     */\n    let BigInteger;\n    /**\n     * This function creates a bigint value. It allows browsers\n     * that doesn't support BigInt to run the rest of the library\n     * by not directly accessing the BigInt constructor.\n     */\n    function createBigInt(num) {\n        if (typeof BigInteger === 'undefined') {\n            BigInteger = getBigIntConstructor();\n        }\n        if (BigInteger === null) {\n            throw new Error('BigInt is not supported!');\n        }\n        return BigInteger(num);\n    }\n    function getEXP900() {\n        // in Java - array with length = 16\n        let EXP900 = [];\n        EXP900[0] = createBigInt(1);\n        let nineHundred = createBigInt(900);\n        EXP900[1] = nineHundred;\n        // in Java - array with length = 16\n        for (let i /*int*/ = 2; i < 16; i++) {\n            EXP900[i] = EXP900[i - 1] * nineHundred;\n        }\n        return EXP900;\n    }\n    /**\n     * <p>This class contains the methods for decoding the PDF417 codewords.</p>\n     *\n     * @author SITA Lab (kevin.osullivan@sita.aero)\n     * @author Guenther Grau\n     */\n    /*final*/ class DecodedBitStreamParser$2 {\n        //   private DecodedBitStreamParser() {\n        // }\n        /**\n         *\n         * @param codewords\n         * @param ecLevel\n         *\n         * @throws FormatException\n         */\n        static decode(codewords, ecLevel) {\n            // pass encoding to result (will be used for decode symbols in byte mode)\n            let result = new StringBuilder('');\n            // let encoding: Charset = StandardCharsets.ISO_8859_1;\n            let encoding = CharacterSetECI.ISO8859_1;\n            /**\n             * @note the next command is specific from this TypeScript library\n             * because TS can't properly cast some values to char and\n             * convert it to string later correctly due to encoding\n             * differences from Java version. As reported here:\n             * https://github.com/zxing-js/library/pull/264/files#r382831593\n             */\n            result.enableDecoding(encoding);\n            // Get compaction mode\n            let codeIndex = 1;\n            let code = codewords[codeIndex++];\n            let resultMetadata = new PDF417ResultMetadata();\n            while (codeIndex < codewords[0]) {\n                switch (code) {\n                    case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                        codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);\n                        break;\n                    case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                    case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                        codeIndex = DecodedBitStreamParser$2.byteCompaction(code, codewords, encoding, codeIndex, result);\n                        break;\n                    case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                        result.append(/*(char)*/ codewords[codeIndex++]);\n                        break;\n                    case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:\n                        codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex, result);\n                        break;\n                    case DecodedBitStreamParser$2.ECI_CHARSET:\n                        let charsetECI = CharacterSetECI.getCharacterSetECIByValue(codewords[codeIndex++]);\n                        // encoding = Charset.forName(charsetECI.getName());\n                        break;\n                    case DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE:\n                        // Can't do anything with generic ECI; skip its 2 characters\n                        codeIndex += 2;\n                        break;\n                    case DecodedBitStreamParser$2.ECI_USER_DEFINED:\n                        // Can't do anything with user ECI; skip its 1 character\n                        codeIndex++;\n                        break;\n                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                        codeIndex = DecodedBitStreamParser$2.decodeMacroBlock(codewords, codeIndex, resultMetadata);\n                        break;\n                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                    case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                        // Should not see these outside a macro block\n                        throw new FormatException();\n                    default:\n                        // Default to text compaction. During testing numerous barcodes\n                        // appeared to be missing the starting mode. In these cases defaulting\n                        // to text compaction seems to work.\n                        codeIndex--;\n                        codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);\n                        break;\n                }\n                if (codeIndex < codewords.length) {\n                    code = codewords[codeIndex++];\n                }\n                else {\n                    throw FormatException.getFormatInstance();\n                }\n            }\n            if (result.length() === 0) {\n                throw FormatException.getFormatInstance();\n            }\n            let decoderResult = new DecoderResult(null, result.toString(), null, ecLevel);\n            decoderResult.setOther(resultMetadata);\n            return decoderResult;\n        }\n        /**\n         *\n         * @param int\n         * @param param1\n         * @param codewords\n         * @param int\n         * @param codeIndex\n         * @param PDF417ResultMetadata\n         * @param resultMetadata\n         *\n         * @throws FormatException\n         */\n        // @SuppressWarnings(\"deprecation\")\n        static decodeMacroBlock(codewords, codeIndex, resultMetadata) {\n            if (codeIndex + DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {\n                // we must have at least two bytes left for the segment index\n                throw FormatException.getFormatInstance();\n            }\n            let segmentIndexArray = new Int32Array(DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS);\n            for (let i /*int*/ = 0; i < DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++) {\n                segmentIndexArray[i] = codewords[codeIndex];\n            }\n            resultMetadata.setSegmentIndex(Integer.parseInt(DecodedBitStreamParser$2.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS)));\n            let fileId = new StringBuilder();\n            codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, fileId);\n            resultMetadata.setFileId(fileId.toString());\n            let optionalFieldsStart = -1;\n            if (codewords[codeIndex] === DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {\n                optionalFieldsStart = codeIndex + 1;\n            }\n            while (codeIndex < codewords[0]) {\n                switch (codewords[codeIndex]) {\n                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                        codeIndex++;\n                        switch (codewords[codeIndex]) {\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:\n                                let fileName = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, fileName);\n                                resultMetadata.setFileName(fileName.toString());\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER:\n                                let sender = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, sender);\n                                resultMetadata.setSender(sender.toString());\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:\n                                let addressee = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, addressee);\n                                resultMetadata.setAddressee(addressee.toString());\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:\n                                let segmentCount = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, segmentCount);\n                                resultMetadata.setSegmentCount(Integer.parseInt(segmentCount.toString()));\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:\n                                let timestamp = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, timestamp);\n                                resultMetadata.setTimestamp(Long.parseLong(timestamp.toString()));\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:\n                                let checksum = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, checksum);\n                                resultMetadata.setChecksum(Integer.parseInt(checksum.toString()));\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:\n                                let fileSize = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, fileSize);\n                                resultMetadata.setFileSize(Long.parseLong(fileSize.toString()));\n                                break;\n                            default:\n                                throw FormatException.getFormatInstance();\n                        }\n                        break;\n                    case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                        codeIndex++;\n                        resultMetadata.setLastSegment(true);\n                        break;\n                    default:\n                        throw FormatException.getFormatInstance();\n                }\n            }\n            // copy optional fields to additional options\n            if (optionalFieldsStart !== -1) {\n                let optionalFieldsLength = codeIndex - optionalFieldsStart;\n                if (resultMetadata.isLastSegment()) {\n                    // do not include terminator\n                    optionalFieldsLength--;\n                }\n                resultMetadata.setOptionalData(Arrays.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));\n            }\n            return codeIndex;\n        }\n        /**\n         * Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be\n         * encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as\n         * well as selected control characters.\n         *\n         * @param codewords The array of codewords (data + error)\n         * @param codeIndex The current index into the codeword array.\n         * @param result    The decoded data is appended to the result.\n         * @return The next index into the codeword array.\n         */\n        static textCompaction(codewords, codeIndex, result) {\n            // 2 character per codeword\n            let textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);\n            // Used to hold the byte compaction value if there is a mode shift\n            let byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);\n            let index = 0;\n            let end = false;\n            while ((codeIndex < codewords[0]) && !end) {\n                let code = codewords[codeIndex++];\n                if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {\n                    textCompactionData[index] = code / 30;\n                    textCompactionData[index + 1] = code % 30;\n                    index += 2;\n                }\n                else {\n                    switch (code) {\n                        case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                            // reinitialize text compaction mode to alpha sub mode\n                            textCompactionData[index++] = DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH;\n                            break;\n                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                        case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                        case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                            codeIndex--;\n                            end = true;\n                            break;\n                        case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                            // The Mode Shift codeword 913 shall cause a temporary\n                            // switch from Text Compaction mode to Byte Compaction mode.\n                            // This switch shall be in effect for only the next codeword,\n                            // after which the mode shall revert to the prevailing sub-mode\n                            // of the Text Compaction mode. Codeword 913 is only available\n                            // in Text Compaction mode; its use is described in 5.4.2.4.\n                            textCompactionData[index] = DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;\n                            code = codewords[codeIndex++];\n                            byteCompactionData[index] = code;\n                            index++;\n                            break;\n                    }\n                }\n            }\n            DecodedBitStreamParser$2.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);\n            return codeIndex;\n        }\n        /**\n         * The Text Compaction mode includes all the printable ASCII characters\n         * (i.e. values from 32 to 126) and three ASCII control characters: HT or tab\n         * (9: e), LF or line feed (10: e), and CR or carriage\n         * return (13: e). The Text Compaction mode also includes various latch\n         * and shift characters which are used exclusively within the mode. The Text\n         * Compaction mode encodes up to 2 characters per codeword. The compaction rules\n         * for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode\n         * switches are defined in 5.4.2.3.\n         *\n         * @param textCompactionData The text compaction data.\n         * @param byteCompactionData The byte compaction data if there\n         *                           was a mode shift.\n         * @param length             The size of the text compaction and byte compaction data.\n         * @param result             The decoded data is appended to the result.\n         */\n        static decodeTextCompaction(textCompactionData, byteCompactionData, length, result) {\n            // Beginning from an initial state of the Alpha sub-mode\n            // The default compaction mode for PDF417 in effect at the start of each symbol shall always be Text\n            // Compaction mode Alpha sub-mode (alphabetic: uppercase). A latch codeword from another mode to the Text\n            // Compaction mode shall always switch to the Text Compaction Alpha sub-mode.\n            let subMode = Mode$2.ALPHA;\n            let priorToShiftMode = Mode$2.ALPHA;\n            let i = 0;\n            while (i < length) {\n                let subModeCh = textCompactionData[i];\n                let ch = /*char*/ '';\n                switch (subMode) {\n                    case Mode$2.ALPHA:\n                        // Alpha (alphabetic: uppercase)\n                        if (subModeCh < 26) {\n                            // Upper case Alpha Character\n                            // Note: 65 = 'A' ASCII -> there is byte code of symbol\n                            ch = /*(char)('A' + subModeCh) */ String.fromCharCode(65 + subModeCh);\n                        }\n                        else {\n                            switch (subModeCh) {\n                                case 26:\n                                    ch = ' ';\n                                    break;\n                                case DecodedBitStreamParser$2.LL:\n                                    subMode = Mode$2.LOWER;\n                                    break;\n                                case DecodedBitStreamParser$2.ML:\n                                    subMode = Mode$2.MIXED;\n                                    break;\n                                case DecodedBitStreamParser$2.PS:\n                                    // Shift to punctuation\n                                    priorToShiftMode = subMode;\n                                    subMode = Mode$2.PUNCT_SHIFT;\n                                    break;\n                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                    result.append(/*(char)*/ byteCompactionData[i]);\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Mode$2.LOWER:\n                        // Lower (alphabetic: lowercase)\n                        if (subModeCh < 26) {\n                            ch = /*(char)('a' + subModeCh)*/ String.fromCharCode(97 + subModeCh);\n                        }\n                        else {\n                            switch (subModeCh) {\n                                case 26:\n                                    ch = ' ';\n                                    break;\n                                case DecodedBitStreamParser$2.AS:\n                                    // Shift to alpha\n                                    priorToShiftMode = subMode;\n                                    subMode = Mode$2.ALPHA_SHIFT;\n                                    break;\n                                case DecodedBitStreamParser$2.ML:\n                                    subMode = Mode$2.MIXED;\n                                    break;\n                                case DecodedBitStreamParser$2.PS:\n                                    // Shift to punctuation\n                                    priorToShiftMode = subMode;\n                                    subMode = Mode$2.PUNCT_SHIFT;\n                                    break;\n                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                    // TODO Does this need to use the current character encoding? See other occurrences below\n                                    result.append(/*(char)*/ byteCompactionData[i]);\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Mode$2.MIXED:\n                        // Mixed (punctuation: e)\n                        if (subModeCh < DecodedBitStreamParser$2.PL) {\n                            ch = DecodedBitStreamParser$2.MIXED_CHARS[subModeCh];\n                        }\n                        else {\n                            switch (subModeCh) {\n                                case DecodedBitStreamParser$2.PL:\n                                    subMode = Mode$2.PUNCT;\n                                    break;\n                                case 26:\n                                    ch = ' ';\n                                    break;\n                                case DecodedBitStreamParser$2.LL:\n                                    subMode = Mode$2.LOWER;\n                                    break;\n                                case DecodedBitStreamParser$2.AL:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                                case DecodedBitStreamParser$2.PS:\n                                    // Shift to punctuation\n                                    priorToShiftMode = subMode;\n                                    subMode = Mode$2.PUNCT_SHIFT;\n                                    break;\n                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                    result.append(/*(char)*/ byteCompactionData[i]);\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Mode$2.PUNCT:\n                        // Punctuation\n                        if (subModeCh < DecodedBitStreamParser$2.PAL) {\n                            ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];\n                        }\n                        else {\n                            switch (subModeCh) {\n                                case DecodedBitStreamParser$2.PAL:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                    result.append(/*(char)*/ byteCompactionData[i]);\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Mode$2.ALPHA_SHIFT:\n                        // Restore sub-mode\n                        subMode = priorToShiftMode;\n                        if (subModeCh < 26) {\n                            ch = /*(char)('A' + subModeCh)*/ String.fromCharCode(65 + subModeCh);\n                        }\n                        else {\n                            switch (subModeCh) {\n                                case 26:\n                                    ch = ' ';\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Mode$2.PUNCT_SHIFT:\n                        // Restore sub-mode\n                        subMode = priorToShiftMode;\n                        if (subModeCh < DecodedBitStreamParser$2.PAL) {\n                            ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];\n                        }\n                        else {\n                            switch (subModeCh) {\n                                case DecodedBitStreamParser$2.PAL:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                    // PS before Shift-to-Byte is used as a padding character,\n                                    // see 5.4.2.4 of the specification\n                                    result.append(/*(char)*/ byteCompactionData[i]);\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                }\n                // if (ch !== 0) {\n                if (ch !== '') {\n                    // Append decoded character to result\n                    result.append(ch);\n                }\n                i++;\n            }\n        }\n        /**\n         * Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.\n         * This includes all ASCII characters value 0 to 127 inclusive and provides for international\n         * character set support.\n         *\n         * @param mode      The byte compaction mode i.e. 901 or 924\n         * @param codewords The array of codewords (data + error)\n         * @param encoding  Currently active character encoding\n         * @param codeIndex The current index into the codeword array.\n         * @param result    The decoded data is appended to the result.\n         * @return The next index into the codeword array.\n         */\n        static /*int*/ byteCompaction(mode, codewords, encoding, codeIndex, result) {\n            let decodedBytes = new ByteArrayOutputStream();\n            let count = 0;\n            let value = /*long*/ 0;\n            let end = false;\n            switch (mode) {\n                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                    // Total number of Byte Compaction characters to be encoded\n                    // is not a multiple of 6\n                    let byteCompactedCodewords = new Int32Array(6);\n                    let nextCode = codewords[codeIndex++];\n                    while ((codeIndex < codewords[0]) && !end) {\n                        byteCompactedCodewords[count++] = nextCode;\n                        // Base 900\n                        value = 900 * value + nextCode;\n                        nextCode = codewords[codeIndex++];\n                        // perhaps it should be ok to check only nextCode >= TEXT_COMPACTION_MODE_LATCH\n                        switch (nextCode) {\n                            case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                            case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:\n                            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                            case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                                codeIndex--;\n                                end = true;\n                                break;\n                            default:\n                                if ((count % 5 === 0) && (count > 0)) {\n                                    // Decode every 5 codewords\n                                    // Convert to Base 256\n                                    for (let j /*int*/ = 0; j < 6; ++j) {\n                                        /* @note\n                                         * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n                                         * So the next bitwise operation could not be done with simple numbers\n                                         */\n                                        decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));\n                                    }\n                                    value = 0;\n                                    count = 0;\n                                }\n                                break;\n                        }\n                    }\n                    // if the end of all codewords is reached the last codeword needs to be added\n                    if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {\n                        byteCompactedCodewords[count++] = nextCode;\n                    }\n                    // If Byte Compaction mode is invoked with codeword 901,\n                    // the last group of codewords is interpreted directly\n                    // as one byte per codeword, without compaction.\n                    for (let i /*int*/ = 0; i < count; i++) {\n                        decodedBytes.write(/*(byte)*/ byteCompactedCodewords[i]);\n                    }\n                    break;\n                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                    // Total number of Byte Compaction characters to be encoded\n                    // is an integer multiple of 6\n                    while (codeIndex < codewords[0] && !end) {\n                        let code = codewords[codeIndex++];\n                        if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {\n                            count++;\n                            // Base 900\n                            value = 900 * value + code;\n                        }\n                        else {\n                            switch (code) {\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                                case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:\n                                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                                case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                                    codeIndex--;\n                                    end = true;\n                                    break;\n                            }\n                        }\n                        if ((count % 5 === 0) && (count > 0)) {\n                            // Decode every 5 codewords\n                            // Convert to Base 256\n                            /* @note\n                             * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n                             * So the next bitwise operation could not be done with simple numbers\n                            */\n                            for (let j /*int*/ = 0; j < 6; ++j) {\n                                decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));\n                            }\n                            value = 0;\n                            count = 0;\n                        }\n                    }\n                    break;\n            }\n            result.append(StringEncoding.decode(decodedBytes.toByteArray(), encoding));\n            return codeIndex;\n        }\n        /**\n         * Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.\n         *\n         * @param codewords The array of codewords (data + error)\n         * @param codeIndex The current index into the codeword array.\n         * @param result    The decoded data is appended to the result.\n         * @return The next index into the codeword array.\n         *\n         * @throws FormatException\n         */\n        static numericCompaction(codewords, codeIndex /*int*/, result) {\n            let count = 0;\n            let end = false;\n            let numericCodewords = new Int32Array(DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS);\n            while (codeIndex < codewords[0] && !end) {\n                let code = codewords[codeIndex++];\n                if (codeIndex === codewords[0]) {\n                    end = true;\n                }\n                if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {\n                    numericCodewords[count] = code;\n                    count++;\n                }\n                else {\n                    switch (code) {\n                        case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                        case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                            codeIndex--;\n                            end = true;\n                            break;\n                    }\n                }\n                if ((count % DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {\n                    // Re-invoking Numeric Compaction mode (by using codeword 902\n                    // while in Numeric Compaction mode) serves  to terminate the\n                    // current Numeric Compaction mode grouping as described in 5.4.4.2,\n                    // and then to start a new one grouping.\n                    result.append(DecodedBitStreamParser$2.decodeBase900toBase10(numericCodewords, count));\n                    count = 0;\n                }\n            }\n            return codeIndex;\n        }\n        /**\n         * Convert a list of Numeric Compacted codewords from Base 900 to Base 10.\n         *\n         * @param codewords The array of codewords\n         * @param count     The number of codewords\n         * @return The decoded string representing the Numeric data.\n         *\n         * EXAMPLE\n         * Encode the fifteen digit numeric string 000213298174000\n         * Prefix the numeric string with a 1 and set the initial value of\n         * t = 1 000 213 298 174 000\n         * Calculate codeword 0\n         * d0 = 1 000 213 298 174 000 mod 900 = 200\n         *\n         * t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082\n         * Calculate codeword 1\n         * d1 = 1 111 348 109 082 mod 900 = 282\n         *\n         * t = 1 111 348 109 082 div 900 = 1 234 831 232\n         * Calculate codeword 2\n         * d2 = 1 234 831 232 mod 900 = 632\n         *\n         * t = 1 234 831 232 div 900 = 1 372 034\n         * Calculate codeword 3\n         * d3 = 1 372 034 mod 900 = 434\n         *\n         * t = 1 372 034 div 900 = 1 524\n         * Calculate codeword 4\n         * d4 = 1 524 mod 900 = 624\n         *\n         * t = 1 524 div 900 = 1\n         * Calculate codeword 5\n         * d5 = 1 mod 900 = 1\n         * t = 1 div 900 = 0\n         * Codeword sequence is: 1, 624, 434, 632, 282, 200\n         *\n         * Decode the above codewords involves\n         *   1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +\n         * 632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000\n         *\n         * Remove leading 1 =>  Result is 000213298174000\n         *\n         * @throws FormatException\n         */\n        static decodeBase900toBase10(codewords, count) {\n            let result = createBigInt(0);\n            for (let i /*int*/ = 0; i < count; i++) {\n                result += DecodedBitStreamParser$2.EXP900[count - i - 1] * createBigInt(codewords[i]);\n            }\n            let resultString = result.toString();\n            if (resultString.charAt(0) !== '1') {\n                throw new FormatException();\n            }\n            return resultString.substring(1);\n        }\n    }\n    DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH = 900;\n    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH = 901;\n    DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH = 902;\n    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6 = 924;\n    DecodedBitStreamParser$2.ECI_USER_DEFINED = 925;\n    DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE = 926;\n    DecodedBitStreamParser$2.ECI_CHARSET = 927;\n    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;\n    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;\n    DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR = 922;\n    DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;\n    DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS = 15;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;\n    DecodedBitStreamParser$2.PL = 25;\n    DecodedBitStreamParser$2.LL = 27;\n    DecodedBitStreamParser$2.AS = 27;\n    DecodedBitStreamParser$2.ML = 28;\n    DecodedBitStreamParser$2.AL = 28;\n    DecodedBitStreamParser$2.PS = 29;\n    DecodedBitStreamParser$2.PAL = 29;\n    DecodedBitStreamParser$2.PUNCT_CHARS = ';<>@[\\\\]_`~!\\r\\t,:\\n-.$/\"|*()?{}\\'';\n    DecodedBitStreamParser$2.MIXED_CHARS = '0123456789&\\r\\t,:#-.$/+%*=^';\n    /**\n     * Table containing values for the exponent of 900.\n     * This is used in the numeric compaction decode algorithm.\n     */\n    DecodedBitStreamParser$2.EXP900 = getBigIntConstructor() ? getEXP900() : [];\n    DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS = 2;\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    // import java.util.ArrayList;\n    // import java.util.Collection;\n    // import java.util.Formatter;\n    // import java.util.List;\n    /**\n     * @author Guenther Grau\n     */\n    /*public final*/ class PDF417ScanningDecoder {\n        constructor() { }\n        /**\n         * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern\n         *\n         * columns. That way width can be deducted from the pattern column.\n         * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider\n         * than it should be. This can happen if the scanner used a bad blackpoint.\n         *\n         * @param BitMatrix\n         * @param image\n         * @param ResultPoint\n         * @param imageTopLeft\n         * @param ResultPoint\n         * @param imageBottomLeft\n         * @param ResultPoint\n         * @param imageTopRight\n         * @param ResultPoint\n         * @param imageBottomRight\n         * @param int\n         * @param minCodewordWidth\n         * @param int\n         * @param maxCodewordWidth\n         *\n         * @throws NotFoundException\n         * @throws FormatException\n         * @throws ChecksumException\n         */\n        static decode(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {\n            let boundingBox = new BoundingBox(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);\n            let leftRowIndicatorColumn = null;\n            let rightRowIndicatorColumn = null;\n            let detectionResult;\n            for (let firstPass /*boolean*/ = true;; firstPass = false) {\n                if (imageTopLeft != null) {\n                    leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);\n                }\n                if (imageTopRight != null) {\n                    rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);\n                }\n                detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);\n                if (detectionResult == null) {\n                    throw NotFoundException.getNotFoundInstance();\n                }\n                let resultBox = detectionResult.getBoundingBox();\n                if (firstPass && resultBox != null &&\n                    (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {\n                    boundingBox = resultBox;\n                }\n                else {\n                    break;\n                }\n            }\n            detectionResult.setBoundingBox(boundingBox);\n            let maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;\n            detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);\n            detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);\n            let leftToRight = leftRowIndicatorColumn != null;\n            for (let barcodeColumnCount /*int*/ = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {\n                let barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;\n                if (detectionResult.getDetectionResultColumn(barcodeColumn) !== /* null */ undefined) {\n                    // This will be the case for the opposite row indicator column, which doesn't need to be decoded again.\n                    continue;\n                }\n                let detectionResultColumn;\n                if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {\n                    detectionResultColumn = new DetectionResultRowIndicatorColumn(boundingBox, barcodeColumn === 0);\n                }\n                else {\n                    detectionResultColumn = new DetectionResultColumn(boundingBox);\n                }\n                detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);\n                let startColumn = -1;\n                let previousStartColumn = startColumn;\n                // TODO start at a row for which we know the start position, then detect upwards and downwards from there.\n                for (let imageRow /*int*/ = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {\n                    startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);\n                    if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {\n                        if (previousStartColumn === -1) {\n                            continue;\n                        }\n                        startColumn = previousStartColumn;\n                    }\n                    let codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n                    if (codeword != null) {\n                        detectionResultColumn.setCodeword(imageRow, codeword);\n                        previousStartColumn = startColumn;\n                        minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());\n                        maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());\n                    }\n                }\n            }\n            return PDF417ScanningDecoder.createDecoderResult(detectionResult);\n        }\n        /**\n         *\n         * @param leftRowIndicatorColumn\n         * @param rightRowIndicatorColumn\n         *\n         * @throws NotFoundException\n         */\n        static merge(leftRowIndicatorColumn, rightRowIndicatorColumn) {\n            if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {\n                return null;\n            }\n            let barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);\n            if (barcodeMetadata == null) {\n                return null;\n            }\n            let boundingBox = BoundingBox.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));\n            return new DetectionResult(barcodeMetadata, boundingBox);\n        }\n        /**\n         *\n         * @param rowIndicatorColumn\n         *\n         * @throws NotFoundException\n         */\n        static adjustBoundingBox(rowIndicatorColumn) {\n            if (rowIndicatorColumn == null) {\n                return null;\n            }\n            let rowHeights = rowIndicatorColumn.getRowHeights();\n            if (rowHeights == null) {\n                return null;\n            }\n            let maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);\n            let missingStartRows = 0;\n            for (let rowHeight /*int*/ of rowHeights) {\n                missingStartRows += maxRowHeight - rowHeight;\n                if (rowHeight > 0) {\n                    break;\n                }\n            }\n            let codewords = rowIndicatorColumn.getCodewords();\n            for (let row /*int*/ = 0; missingStartRows > 0 && codewords[row] == null; row++) {\n                missingStartRows--;\n            }\n            let missingEndRows = 0;\n            for (let row /*int*/ = rowHeights.length - 1; row >= 0; row--) {\n                missingEndRows += maxRowHeight - rowHeights[row];\n                if (rowHeights[row] > 0) {\n                    break;\n                }\n            }\n            for (let row /*int*/ = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {\n                missingEndRows--;\n            }\n            return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());\n        }\n        static getMax(values) {\n            let maxValue = -1;\n            for (let value /*int*/ of values) {\n                maxValue = Math.max(maxValue, value);\n            }\n            return maxValue;\n        }\n        static getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn) {\n            let leftBarcodeMetadata;\n            if (leftRowIndicatorColumn == null ||\n                (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {\n                return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();\n            }\n            let rightBarcodeMetadata;\n            if (rightRowIndicatorColumn == null ||\n                (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {\n                return leftBarcodeMetadata;\n            }\n            if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() &&\n                leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() &&\n                leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {\n                return null;\n            }\n            return leftBarcodeMetadata;\n        }\n        static getRowIndicatorColumn(image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {\n            let rowIndicatorColumn = new DetectionResultRowIndicatorColumn(boundingBox, leftToRight);\n            for (let i /*int*/ = 0; i < 2; i++) {\n                let increment = i === 0 ? 1 : -1;\n                let startColumn = Math.trunc(Math.trunc(startPoint.getX()));\n                for (let imageRow /*int*/ = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() &&\n                    imageRow >= boundingBox.getMinY(); imageRow += increment) {\n                    let codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n                    if (codeword != null) {\n                        rowIndicatorColumn.setCodeword(imageRow, codeword);\n                        if (leftToRight) {\n                            startColumn = codeword.getStartX();\n                        }\n                        else {\n                            startColumn = codeword.getEndX();\n                        }\n                    }\n                }\n            }\n            return rowIndicatorColumn;\n        }\n        /**\n         *\n         * @param detectionResult\n         * @param BarcodeValue\n         * @param param2\n         * @param param3\n         * @param barcodeMatrix\n         *\n         * @throws NotFoundException\n         */\n        static adjustCodewordCount(detectionResult, barcodeMatrix) {\n            let barcodeMatrix01 = barcodeMatrix[0][1];\n            let numberOfCodewords = barcodeMatrix01.getValue();\n            let calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() *\n                detectionResult.getBarcodeRowCount() -\n                PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());\n            if (numberOfCodewords.length === 0) {\n                if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common.MAX_CODEWORDS_IN_BARCODE) {\n                    throw NotFoundException.getNotFoundInstance();\n                }\n                barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n            }\n            else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {\n                // The calculated one is more reliable as it is derived from the row indicator columns\n                barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n            }\n        }\n        /**\n         *\n         * @param detectionResult\n         *\n         * @throws FormatException\n         * @throws ChecksumException\n         * @throws NotFoundException\n         */\n        static createDecoderResult(detectionResult) {\n            let barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);\n            PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);\n            let erasures /*Collection<Integer>*/ = new Array();\n            let codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());\n            let ambiguousIndexValuesList = /*List<int[]>*/ [];\n            let ambiguousIndexesList = /*Collection<Integer>*/ new Array();\n            for (let row /*int*/ = 0; row < detectionResult.getBarcodeRowCount(); row++) {\n                for (let column /*int*/ = 0; column < detectionResult.getBarcodeColumnCount(); column++) {\n                    let values = barcodeMatrix[row][column + 1].getValue();\n                    let codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;\n                    if (values.length === 0) {\n                        erasures.push(codewordIndex);\n                    }\n                    else if (values.length === 1) {\n                        codewords[codewordIndex] = values[0];\n                    }\n                    else {\n                        ambiguousIndexesList.push(codewordIndex);\n                        ambiguousIndexValuesList.push(values);\n                    }\n                }\n            }\n            let ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);\n            for (let i /*int*/ = 0; i < ambiguousIndexValues.length; i++) {\n                ambiguousIndexValues[i] = ambiguousIndexValuesList[i];\n            }\n            return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common.toIntArray(erasures), PDF417Common.toIntArray(ambiguousIndexesList), ambiguousIndexValues);\n        }\n        /**\n         * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The\n         * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value\n         * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of\n         * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the\n         * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,\n         * so decoding the normal barcodes is not affected by this.\n         *\n         * @param erasureArray contains the indexes of erasures\n         * @param ambiguousIndexes array with the indexes that have more than one most likely value\n         * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must\n         * be the same length as the ambiguousIndexes array\n         *\n         * @throws FormatException\n         * @throws ChecksumException\n         */\n        static createDecoderResultFromAmbiguousValues(ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {\n            let ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);\n            let tries = 100;\n            while (tries-- > 0) {\n                for (let i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {\n                    codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];\n                }\n                try {\n                    return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);\n                }\n                catch (err) {\n                    let ignored = err instanceof ChecksumException;\n                    if (!ignored) {\n                        throw err;\n                    }\n                }\n                if (ambiguousIndexCount.length === 0) {\n                    throw ChecksumException.getChecksumInstance();\n                }\n                for (let i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {\n                    if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {\n                        ambiguousIndexCount[i]++;\n                        break;\n                    }\n                    else {\n                        ambiguousIndexCount[i] = 0;\n                        if (i === ambiguousIndexCount.length - 1) {\n                            throw ChecksumException.getChecksumInstance();\n                        }\n                    }\n                }\n            }\n            throw ChecksumException.getChecksumInstance();\n        }\n        static createBarcodeMatrix(detectionResult) {\n            // let barcodeMatrix: BarcodeValue[][] =\n            // new BarcodeValue[detectionResult.getBarcodeRowCount()][detectionResult.getBarcodeColumnCount() + 2];\n            let barcodeMatrix = Array.from({ length: detectionResult.getBarcodeRowCount() }, () => new Array(detectionResult.getBarcodeColumnCount() + 2));\n            for (let row /*int*/ = 0; row < barcodeMatrix.length; row++) {\n                for (let column /*int*/ = 0; column < barcodeMatrix[row].length; column++) {\n                    barcodeMatrix[row][column] = new BarcodeValue();\n                }\n            }\n            let column = 0;\n            for (let detectionResultColumn /*DetectionResultColumn*/ of detectionResult.getDetectionResultColumns()) {\n                if (detectionResultColumn != null) {\n                    for (let codeword /*Codeword*/ of detectionResultColumn.getCodewords()) {\n                        if (codeword != null) {\n                            let rowNumber = codeword.getRowNumber();\n                            if (rowNumber >= 0) {\n                                if (rowNumber >= barcodeMatrix.length) {\n                                    // We have more rows than the barcode metadata allows for, ignore them.\n                                    continue;\n                                }\n                                barcodeMatrix[rowNumber][column].setValue(codeword.getValue());\n                            }\n                        }\n                    }\n                }\n                column++;\n            }\n            return barcodeMatrix;\n        }\n        static isValidBarcodeColumn(detectionResult, barcodeColumn) {\n            return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;\n        }\n        static getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight) {\n            let offset = leftToRight ? 1 : -1;\n            let codeword = null;\n            if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n                codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);\n            }\n            if (codeword != null) {\n                return leftToRight ? codeword.getEndX() : codeword.getStartX();\n            }\n            codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);\n            if (codeword != null) {\n                return leftToRight ? codeword.getStartX() : codeword.getEndX();\n            }\n            if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n                codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);\n            }\n            if (codeword != null) {\n                return leftToRight ? codeword.getEndX() : codeword.getStartX();\n            }\n            let skippedColumns = 0;\n            while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n                barcodeColumn -= offset;\n                for (let previousRowCodeword /*Codeword*/ of detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords()) {\n                    if (previousRowCodeword != null) {\n                        return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) +\n                            offset *\n                                skippedColumns *\n                                (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());\n                    }\n                }\n                skippedColumns++;\n            }\n            return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();\n        }\n        static detectCodeword(image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {\n            startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n            // we usually know fairly exact now how long a codeword is. We should provide minimum and maximum expected length\n            // and try to adjust the read pixels, e.g. remove single pixel errors or try to cut off exceeding pixels.\n            // min and maxCodewordWidth should not be used as they are calculated for the whole barcode an can be inaccurate\n            // for the current position\n            let moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n            if (moduleBitCount == null) {\n                return null;\n            }\n            let endColumn;\n            let codewordBitCount = MathUtils.sum(moduleBitCount);\n            if (leftToRight) {\n                endColumn = startColumn + codewordBitCount;\n            }\n            else {\n                for (let i /*int*/ = 0; i < moduleBitCount.length / 2; i++) {\n                    let tmpCount = moduleBitCount[i];\n                    moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];\n                    moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;\n                }\n                endColumn = startColumn;\n                startColumn = endColumn - codewordBitCount;\n            }\n            // TODO implement check for width and correction of black and white bars\n            // use start (and maybe stop pattern) to determine if black bars are wider than white bars. If so, adjust.\n            // should probably done only for codewords with a lot more than 17 bits.\n            // The following fixes 10-1.png, which has wide black bars and small white bars\n            //    for (let i /*int*/ = 0; i < moduleBitCount.length; i++) {\n            //      if (i % 2 === 0) {\n            //        moduleBitCount[i]--;\n            //      } else {\n            //        moduleBitCount[i]++;\n            //      }\n            //    }\n            // We could also use the width of surrounding codewords for more accurate results, but this seems\n            // sufficient for now\n            if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {\n                // We could try to use the startX and endX position of the codeword in the same column in the previous row,\n                // create the bit count from it and normalize it to 8. This would help with single pixel errors.\n                return null;\n            }\n            let decodedValue = PDF417CodewordDecoder.getDecodedValue(moduleBitCount);\n            let codeword = PDF417Common.getCodeword(decodedValue);\n            if (codeword === -1) {\n                return null;\n            }\n            return new Codeword(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);\n        }\n        static getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {\n            let imageColumn = startColumn;\n            let moduleBitCount = new Int32Array(8);\n            let moduleNumber = 0;\n            let increment = leftToRight ? 1 : -1;\n            let previousPixelValue = leftToRight;\n            while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) &&\n                moduleNumber < moduleBitCount.length) {\n                if (image.get(imageColumn, imageRow) === previousPixelValue) {\n                    moduleBitCount[moduleNumber]++;\n                    imageColumn += increment;\n                }\n                else {\n                    moduleNumber++;\n                    previousPixelValue = !previousPixelValue;\n                }\n            }\n            if (moduleNumber === moduleBitCount.length ||\n                ((imageColumn === (leftToRight ? maxColumn : minColumn)) &&\n                    moduleNumber === moduleBitCount.length - 1)) {\n                return moduleBitCount;\n            }\n            return null;\n        }\n        static getNumberOfECCodeWords(barcodeECLevel) {\n            return 2 << barcodeECLevel;\n        }\n        static adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {\n            let correctedStartColumn = codewordStartColumn;\n            let increment = leftToRight ? -1 : 1;\n            // there should be no black pixels before the start column. If there are, then we need to start earlier.\n            for (let i /*int*/ = 0; i < 2; i++) {\n                while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) &&\n                    leftToRight === image.get(correctedStartColumn, imageRow)) {\n                    if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {\n                        return codewordStartColumn;\n                    }\n                    correctedStartColumn += increment;\n                }\n                increment = -increment;\n                leftToRight = !leftToRight;\n            }\n            return correctedStartColumn;\n        }\n        static checkCodewordSkew(codewordSize, minCodewordWidth, maxCodewordWidth) {\n            return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize &&\n                codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;\n        }\n        /**\n         * @throws FormatException,\n         * @throws ChecksumException\n         */\n        static decodeCodewords(codewords, ecLevel, erasures) {\n            if (codewords.length === 0) {\n                throw FormatException.getFormatInstance();\n            }\n            let numECCodewords = 1 << (ecLevel + 1);\n            let correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);\n            PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);\n            // Decode the codewords\n            let decoderResult = DecodedBitStreamParser$2.decode(codewords, '' + ecLevel);\n            decoderResult.setErrorsCorrected(correctedErrorsCount);\n            decoderResult.setErasures(erasures.length);\n            return decoderResult;\n        }\n        /**\n         * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n         * correct the errors in-place.</p>\n         *\n         * @param codewords   data and error correction codewords\n         * @param erasures positions of any known erasures\n         * @param numECCodewords number of error correction codewords that are available in codewords\n         * @throws ChecksumException if error correction fails\n         */\n        static correctErrors(codewords, erasures, numECCodewords) {\n            if (erasures != null &&\n                erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS ||\n                numECCodewords < 0 ||\n                numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {\n                // Too many errors or EC Codewords is corrupted\n                throw ChecksumException.getChecksumInstance();\n            }\n            return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);\n        }\n        /**\n         * Verify that all is OK with the codeword array.\n         * @throws FormatException\n         */\n        static verifyCodewordCount(codewords, numECCodewords) {\n            if (codewords.length < 4) {\n                // Codeword array size should be at least 4 allowing for\n                // Count CW, At least one Data CW, Error Correction CW, Error Correction CW\n                throw FormatException.getFormatInstance();\n            }\n            // The first codeword, the Symbol Length Descriptor, shall always encode the total number of data\n            // codewords in the symbol, including the Symbol Length Descriptor itself, data codewords and pad\n            // codewords, but excluding the number of error correction codewords.\n            let numberOfCodewords = codewords[0];\n            if (numberOfCodewords > codewords.length) {\n                throw FormatException.getFormatInstance();\n            }\n            if (numberOfCodewords === 0) {\n                // Reset to the length of the array - 8 (Allow for at least level 3 Error Correction (8 Error Codewords)\n                if (numECCodewords < codewords.length) {\n                    codewords[0] = codewords.length - numECCodewords;\n                }\n                else {\n                    throw FormatException.getFormatInstance();\n                }\n            }\n        }\n        static getBitCountForCodeword(codeword) {\n            let result = new Int32Array(8);\n            let previousValue = 0;\n            let i = result.length - 1;\n            while (true) {\n                if ((codeword & 0x1) !== previousValue) {\n                    previousValue = codeword & 0x1;\n                    i--;\n                    if (i < 0) {\n                        break;\n                    }\n                }\n                result[i]++;\n                codeword >>= 1;\n            }\n            return result;\n        }\n        static getCodewordBucketNumber(codeword) {\n            if (codeword instanceof Int32Array) {\n                return this.getCodewordBucketNumber_Int32Array(codeword);\n            }\n            return this.getCodewordBucketNumber_number(codeword);\n        }\n        static getCodewordBucketNumber_number(codeword) {\n            return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));\n        }\n        static getCodewordBucketNumber_Int32Array(moduleBitCount) {\n            return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;\n        }\n        static toString(barcodeMatrix) {\n            let formatter = new Formatter();\n            // try (let formatter = new Formatter()) {\n            for (let row /*int*/ = 0; row < barcodeMatrix.length; row++) {\n                formatter.format('Row %2d: ', row);\n                for (let column /*int*/ = 0; column < barcodeMatrix[row].length; column++) {\n                    let barcodeValue = barcodeMatrix[row][column];\n                    if (barcodeValue.getValue().length === 0) {\n                        formatter.format('        ', null);\n                    }\n                    else {\n                        formatter.format('%4d(%2d)', barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));\n                    }\n                }\n                formatter.format('%n');\n            }\n            return formatter.toString();\n            // }\n        }\n    }\n    /*final*/ PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;\n    /*final*/ PDF417ScanningDecoder.MAX_ERRORS = 3;\n    /*final*/ PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;\n    /*final*/ PDF417ScanningDecoder.errorCorrection = new ErrorCorrection();\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // import java.util.ArrayList;\n    // import java.util.List;\n    // import java.util.Map;\n    /**\n     * This implementation can detect and decode PDF417 codes in an image.\n     *\n     * @author Guenther Grau\n     */\n    /*public final*/ class PDF417Reader {\n        // private static /*final Result[]*/ EMPTY_RESULT_ARRAY: Result[] = new Result([0]);\n        /**\n         * Locates and decodes a PDF417 code in an image.\n         *\n         * @return a String representing the content encoded by the PDF417 code\n         * @throws NotFoundException if a PDF417 code cannot be found,\n         * @throws FormatException if a PDF417 cannot be decoded\n         * @throws ChecksumException\n         */\n        // @Override\n        decode(image, hints = null) {\n            let result = PDF417Reader.decode(image, hints, false);\n            if (result == null || result.length === 0 || result[0] == null) {\n                throw NotFoundException.getNotFoundInstance();\n            }\n            return result[0];\n        }\n        /**\n         *\n         * @param BinaryBitmap\n         * @param image\n         * @throws NotFoundException\n         */\n        //   @Override\n        decodeMultiple(image, hints = null) {\n            try {\n                return PDF417Reader.decode(image, hints, true);\n            }\n            catch (ignored) {\n                if (ignored instanceof FormatException || ignored instanceof ChecksumException) {\n                    throw NotFoundException.getNotFoundInstance();\n                }\n                throw ignored;\n            }\n        }\n        /**\n         *\n         * @param image\n         * @param hints\n         * @param multiple\n         *\n         * @throws NotFoundException\n         * @throws FormatExceptionß\n         * @throws ChecksumException\n         */\n        static decode(image, hints, multiple) {\n            const results = new Array();\n            const detectorResult = Detector$3.detectMultiple(image, hints, multiple);\n            for (const points of detectorResult.getPoints()) {\n                const decoderResult = PDF417ScanningDecoder.decode(detectorResult.getBits(), points[4], points[5], points[6], points[7], PDF417Reader.getMinCodewordWidth(points), PDF417Reader.getMaxCodewordWidth(points));\n                const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat$1.PDF_417);\n                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, decoderResult.getECLevel());\n                const pdf417ResultMetadata = decoderResult.getOther();\n                if (pdf417ResultMetadata != null) {\n                    result.putMetadata(ResultMetadataType$1.PDF417_EXTRA_METADATA, pdf417ResultMetadata);\n                }\n                results.push(result);\n            }\n            return results.map(x => x);\n        }\n        static getMaxWidth(p1, p2) {\n            if (p1 == null || p2 == null) {\n                return 0;\n            }\n            return Math.trunc(Math.abs(p1.getX() - p2.getX()));\n        }\n        static getMinWidth(p1, p2) {\n            if (p1 == null || p2 == null) {\n                return Integer.MAX_VALUE;\n            }\n            return Math.trunc(Math.abs(p1.getX() - p2.getX()));\n        }\n        static getMaxCodewordWidth(p) {\n            return Math.floor(Math.max(Math.max(PDF417Reader.getMaxWidth(p[0], p[4]), PDF417Reader.getMaxWidth(p[6], p[2]) * PDF417Common.MODULES_IN_CODEWORD /\n                PDF417Common.MODULES_IN_STOP_PATTERN), Math.max(PDF417Reader.getMaxWidth(p[1], p[5]), PDF417Reader.getMaxWidth(p[7], p[3]) * PDF417Common.MODULES_IN_CODEWORD /\n                PDF417Common.MODULES_IN_STOP_PATTERN)));\n        }\n        static getMinCodewordWidth(p) {\n            return Math.floor(Math.min(Math.min(PDF417Reader.getMinWidth(p[0], p[4]), PDF417Reader.getMinWidth(p[6], p[2]) * PDF417Common.MODULES_IN_CODEWORD /\n                PDF417Common.MODULES_IN_STOP_PATTERN), Math.min(PDF417Reader.getMinWidth(p[1], p[5]), PDF417Reader.getMinWidth(p[7], p[3]) * PDF417Common.MODULES_IN_CODEWORD /\n                PDF417Common.MODULES_IN_STOP_PATTERN)));\n        }\n        // @Override\n        reset() {\n            // nothing needs to be reset\n        }\n    }\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class ReaderException extends Exception {\n    }\n    ReaderException.kind = 'ReaderException';\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing {*/\n    /**\n     * MultiFormatReader is a convenience class and the main entry point into the library for most uses.\n     * By default it attempts to decode all barcode formats that the library supports. Optionally, you\n     * can provide a hints object to request different behavior, for example only decoding QR codes.\n     *\n     * @author Sean Owen\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class MultiFormatReader {\n        /**\n         * Creates an instance of this class\n         * \n         * @param {Boolean} verbose if 'true' logs will be dumped to console, otherwise hidden.\n         * @param hints The hints to use, clearing the previous state.\n         */\n        constructor(verbose, hints) {\n            this.verbose = (verbose === true);\n            if (hints) {\n                this.setHints(hints);\n            }\n        }\n        /**\n         * This version of decode honors the intent of Reader.decode(BinaryBitmap) in that it\n         * passes null as a hint to the decoders. However, that makes it inefficient to call repeatedly.\n         * Use setHints() followed by decodeWithState() for continuous scan applications.\n         *\n         * @param image The pixel data to decode\n         * @return The contents of the image\n         *\n         * @throws NotFoundException Any errors which occurred\n         */\n        /*@Override*/\n        // public decode(image: BinaryBitmap): Result {\n        //   setHints(null)\n        //   return decodeInternal(image)\n        // }\n        /**\n         * Decode an image using the hints provided. Does not honor existing state.\n         *\n         * @param image The pixel data to decode\n         * @param hints The hints to use, clearing the previous state.\n         * @return The contents of the image\n         *\n         * @throws NotFoundException Any errors which occurred\n         */\n        /*@Override*/\n        decode(image, hints) {\n            if (hints) {\n                this.setHints(hints);\n            }\n            return this.decodeInternal(image);\n        }\n        /**\n         * Decode an image using the state set up by calling setHints() previously. Continuous scan\n         * clients will get a <b>large</b> speed increase by using this instead of decode().\n         *\n         * @param image The pixel data to decode\n         * @return The contents of the image\n         *\n         * @throws NotFoundException Any errors which occurred\n         */\n        decodeWithState(image) {\n            // Make sure to set up the default state so we don't crash\n            if (this.readers === null || this.readers === undefined) {\n                this.setHints(null);\n            }\n            return this.decodeInternal(image);\n        }\n        /**\n         * This method adds state to the MultiFormatReader. By setting the hints once, subsequent calls\n         * to decodeWithState(image) can reuse the same set of readers without reallocating memory. This\n         * is important for performance in continuous scan clients.\n         *\n         * @param hints The set of hints to use for subsequent calls to decode(image)\n         */\n        setHints(hints) {\n            this.hints = hints;\n            const tryHarder = !isNullOrUndefined(hints)\n                && hints.get(DecodeHintType$1.TRY_HARDER) === true;\n            const formats = isNullOrUndefined(hints) ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);\n            const readers = new Array();\n            if (!isNullOrUndefined(formats)) {\n                const addOneDReader = formats.some(f => {\n                    return (\n                        f === BarcodeFormat$1.UPC_A ||\n                        f === BarcodeFormat$1.UPC_E ||\n                        f === BarcodeFormat$1.EAN_13 ||\n                        f === BarcodeFormat$1.EAN_8 ||\n                        f === BarcodeFormat$1.CODABAR ||\n                        f === BarcodeFormat$1.CODE_39 ||\n                        f === BarcodeFormat$1.CODE_93 ||\n                        f === BarcodeFormat$1.CODE_128 ||\n                        f === BarcodeFormat$1.ITF ||\n                        f === BarcodeFormat$1.RSS_14 ||\n                        f === BarcodeFormat$1.RSS_EXPANDED);\n                });\n                // Put 1D readers upfront in \"normal\" mode\n                if (addOneDReader && !tryHarder) {\n                    readers.push(new MultiFormatOneDReader(hints, this.verbose));\n                }\n                if (formats.includes(BarcodeFormat$1.QR_CODE)) {\n                    readers.push(new QRCodeReader());\n                }\n                if (formats.includes(BarcodeFormat$1.DATA_MATRIX)) {\n                    readers.push(new DataMatrixReader());\n                }\n                if (formats.includes(BarcodeFormat$1.AZTEC)) {\n                    readers.push(new AztecReader());\n                }\n                if (formats.includes(BarcodeFormat$1.PDF_417)) {\n                    readers.push(new PDF417Reader());\n                }\n                // if (formats.includes(BarcodeFormat.MAXICODE)) {\n                //    readers.push(new MaxiCodeReader())\n                // }\n                // At end in \"try harder\" mode\n                if (addOneDReader && tryHarder) {\n                    readers.push(new MultiFormatOneDReader(hints, this.verbose));\n                }\n            }\n            if (readers.length === 0) {\n                if (!tryHarder) {\n                    readers.push(new MultiFormatOneDReader(hints, this.verbose));\n                }\n                readers.push(new QRCodeReader());\n                readers.push(new DataMatrixReader());\n                readers.push(new AztecReader());\n                readers.push(new PDF417Reader());\n                // readers.push(new MaxiCodeReader())\n                if (tryHarder) {\n                    readers.push(new MultiFormatOneDReader(hints, this.verbose));\n                }\n            }\n            this.readers = readers; // .toArray(new Reader[readers.size()])\n        }\n        /*@Override*/\n        reset() {\n            if (this.readers !== null) {\n                for (const reader of this.readers) {\n                    reader.reset();\n                }\n            }\n        }\n        /**\n         * @throws NotFoundException\n         */\n        decodeInternal(image) {\n            if (this.readers === null) {\n                throw new ReaderException('No readers where selected, nothing can be read.');\n            }\n            for (const reader of this.readers) {\n                // Trying to decode with ${reader} reader.\n                try {\n                    return reader.decode(image, this.hints);\n                }\n                catch (ex) {\n                    if (ex instanceof ReaderException) {\n                        continue;\n                    }\n                    // Bad Exception.\n                }\n            }\n            throw new NotFoundException('No MultiFormat Readers were able to detect the code.');\n        }\n    }\n\n    class BrowserMultiFormatReader extends BrowserCodeReader {\n        constructor(hints = null, timeBetweenScansMillis = 500) {\n            const reader = new MultiFormatReader();\n            reader.setHints(hints);\n            super(reader, timeBetweenScansMillis);\n        }\n        /**\n         * Overwrite decodeBitmap to call decodeWithState, which will pay\n         * attention to the hints set in the constructor function\n         */\n        decodeBitmap(binaryBitmap) {\n            return this.reader.decodeWithState(binaryBitmap);\n        }\n    }\n\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * QR Code reader to use from browser.\n     */\n    class BrowserPDF417Reader extends BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserPDF417Reader.\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n         */\n        constructor(timeBetweenScansMillis = 500) {\n            super(new PDF417Reader(), timeBetweenScansMillis);\n        }\n    }\n\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * QR Code reader to use from browser.\n     */\n    class BrowserQRCodeReader extends BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserQRCodeReader.\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n         */\n        constructor(timeBetweenScansMillis = 500) {\n            super(new QRCodeReader(), timeBetweenScansMillis);\n        }\n    }\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing {*/\n    /**\n     * These are a set of hints that you may pass to Writers to specify their behavior.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    var EncodeHintType;\n    (function (EncodeHintType) {\n        /**\n         * Specifies what degree of error correction to use, for example in QR Codes.\n         * Type depends on the encoder. For example for QR codes it's type\n         * {@link com.google.zxing.qrcode.decoder.ErrorCorrectionLevel ErrorCorrectionLevel}.\n         * For Aztec it is of type {@link Integer}, representing the minimal percentage of error correction words.\n         * For PDF417 it is of type {@link Integer}, valid values being 0 to 8.\n         * In all cases, it can also be a {@link String} representation of the desired value as well.\n         * Note: an Aztec symbol should have a minimum of 25% EC words.\n         */\n        EncodeHintType[EncodeHintType[\"ERROR_CORRECTION\"] = 0] = \"ERROR_CORRECTION\";\n        /**\n         * Specifies what character encoding to use where applicable (type {@link String})\n         */\n        EncodeHintType[EncodeHintType[\"CHARACTER_SET\"] = 1] = \"CHARACTER_SET\";\n        /**\n         * Specifies the matrix shape for Data Matrix (type {@link com.google.zxing.datamatrix.encoder.SymbolShapeHint})\n         */\n        EncodeHintType[EncodeHintType[\"DATA_MATRIX_SHAPE\"] = 2] = \"DATA_MATRIX_SHAPE\";\n        /**\n         * Specifies a minimum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.\n         *\n         * @deprecated use width/height params in\n         * {@link com.google.zxing.datamatrix.DataMatrixWriter#encode(String, BarcodeFormat, int, int)}\n         */\n        /*@Deprecated*/\n        EncodeHintType[EncodeHintType[\"MIN_SIZE\"] = 3] = \"MIN_SIZE\";\n        /**\n         * Specifies a maximum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.\n         *\n         * @deprecated without replacement\n         */\n        /*@Deprecated*/\n        EncodeHintType[EncodeHintType[\"MAX_SIZE\"] = 4] = \"MAX_SIZE\";\n        /**\n         * Specifies margin, in pixels, to use when generating the barcode. The meaning can vary\n         * by format; for example it controls margin before and after the barcode horizontally for\n         * most 1D formats. (Type {@link Integer}, or {@link String} representation of the integer value).\n         */\n        EncodeHintType[EncodeHintType[\"MARGIN\"] = 5] = \"MARGIN\";\n        /**\n         * Specifies whether to use compact mode for PDF417 (type {@link Boolean}, or \"true\" or \"false\"\n         * {@link String} value).\n         */\n        EncodeHintType[EncodeHintType[\"PDF417_COMPACT\"] = 6] = \"PDF417_COMPACT\";\n        /**\n         * Specifies what compaction mode to use for PDF417 (type\n         * {@link com.google.zxing.pdf417.encoder.Compaction Compaction} or {@link String} value of one of its\n         * enum values).\n         */\n        EncodeHintType[EncodeHintType[\"PDF417_COMPACTION\"] = 7] = \"PDF417_COMPACTION\";\n        /**\n         * Specifies the minimum and maximum number of rows and columns for PDF417 (type\n         * {@link com.google.zxing.pdf417.encoder.Dimensions Dimensions}).\n         */\n        EncodeHintType[EncodeHintType[\"PDF417_DIMENSIONS\"] = 8] = \"PDF417_DIMENSIONS\";\n        /**\n         * Specifies the required number of layers for an Aztec code.\n         * A negative number (-1, -2, -3, -4) specifies a compact Aztec code.\n         * 0 indicates to use the minimum number of layers (the default).\n         * A positive number (1, 2, .. 32) specifies a normal (non-compact) Aztec code.\n         * (Type {@link Integer}, or {@link String} representation of the integer value).\n         */\n        EncodeHintType[EncodeHintType[\"AZTEC_LAYERS\"] = 9] = \"AZTEC_LAYERS\";\n        /**\n         * Specifies the exact version of QR code to be encoded.\n         * (Type {@link Integer}, or {@link String} representation of the integer value).\n         */\n        EncodeHintType[EncodeHintType[\"QR_VERSION\"] = 10] = \"QR_VERSION\";\n    })(EncodeHintType || (EncodeHintType = {}));\n    var EncodeHintType$1 = EncodeHintType;\n\n    /**\n     * <p>Implements Reed-Solomon encoding, as the name implies.</p>\n     *\n     * @author Sean Owen\n     * @author William Rucklidge\n     */\n    class ReedSolomonEncoder {\n        /**\n         * A reed solomon error-correcting encoding constructor is created by\n         * passing as Galois Field with of size equal to the number of code\n         * words (symbols) in the alphabet (the number of values in each\n         * element of arrays that are encoded/decoded).\n         * @param field A galois field with a number of elements equal to the size\n         * of the alphabet of symbols to encode.\n         */\n        constructor(field) {\n            this.field = field;\n            this.cachedGenerators = [];\n            this.cachedGenerators.push(new GenericGFPoly(field, Int32Array.from([1])));\n        }\n        buildGenerator(degree /*int*/) {\n            const cachedGenerators = this.cachedGenerators;\n            if (degree >= cachedGenerators.length) {\n                let lastGenerator = cachedGenerators[cachedGenerators.length - 1];\n                const field = this.field;\n                for (let d = cachedGenerators.length; d <= degree; d++) {\n                    const nextGenerator = lastGenerator.multiply(new GenericGFPoly(field, Int32Array.from([1, field.exp(d - 1 + field.getGeneratorBase())])));\n                    cachedGenerators.push(nextGenerator);\n                    lastGenerator = nextGenerator;\n                }\n            }\n            return cachedGenerators[degree];\n        }\n        /**\n         * <p>Encode a sequence of code words (symbols) using Reed-Solomon to allow decoders\n         * to detect and correct errors that may have been introduced when the resulting\n         * data is stored or transmitted.</p>\n         *\n         * @param toEncode array used for both and output. Caller initializes the array with\n         * the code words (symbols) to be encoded followed by empty elements allocated to make\n         * space for error-correction code words in the encoded output. The array contains\n         * the encdoded output when encode returns. Code words are encoded as numbers from\n         * 0 to n-1, where n is the number of possible code words (symbols), as determined\n         * by the size of the Galois Field passed in the constructor of this object.\n         * @param ecBytes the number of elements reserved in the array (first parameter)\n         * to store error-correction code words. Thus, the number of code words (symbols)\n         * to encode in the first parameter is thus toEncode.length - ecBytes.\n         * Note, the use of \"bytes\" in the name of this parameter is misleading, as there may\n         * be more or fewer than 256 symbols being encoded, as determined by the number of\n         * elements in the Galois Field passed as a constructor to this object.\n         * @throws IllegalArgumentException thrown in response to validation errros.\n         */\n        encode(toEncode, ecBytes /*int*/) {\n            if (ecBytes === 0) {\n                throw new IllegalArgumentException('No error correction bytes');\n            }\n            const dataBytes = toEncode.length - ecBytes;\n            if (dataBytes <= 0) {\n                throw new IllegalArgumentException('No data bytes provided');\n            }\n            const generator = this.buildGenerator(ecBytes);\n            const infoCoefficients = new Int32Array(dataBytes);\n            System.arraycopy(toEncode, 0, infoCoefficients, 0, dataBytes);\n            let info = new GenericGFPoly(this.field, infoCoefficients);\n            info = info.multiplyByMonomial(ecBytes, 1);\n            const remainder = info.divide(generator)[1];\n            const coefficients = remainder.getCoefficients();\n            const numZeroCoefficients = ecBytes - coefficients.length;\n            for (let i = 0; i < numZeroCoefficients; i++) {\n                toEncode[dataBytes + i] = 0;\n            }\n            System.arraycopy(coefficients, 0, toEncode, dataBytes + numZeroCoefficients, coefficients.length);\n        }\n    }\n\n    /**\n     * @author Satoru Takabayashi\n     * @author Daniel Switkin\n     * @author Sean Owen\n     */\n    class MaskUtil {\n        constructor() {\n            // do nothing\n        }\n        /**\n         * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and\n         * give penalty to them. Example: 00000 or 11111.\n         */\n        static applyMaskPenaltyRule1(matrix) {\n            return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);\n        }\n        /**\n         * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give\n         * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a\n         * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.\n         */\n        static applyMaskPenaltyRule2(matrix) {\n            let penalty = 0;\n            const array = matrix.getArray();\n            const width = matrix.getWidth();\n            const height = matrix.getHeight();\n            for (let y = 0; y < height - 1; y++) {\n                const arrayY = array[y];\n                for (let x = 0; x < width - 1; x++) {\n                    const value = arrayY[x];\n                    if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {\n                        penalty++;\n                    }\n                }\n            }\n            return MaskUtil.N2 * penalty;\n        }\n        /**\n         * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4\n         * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we\n         * find patterns like 000010111010000, we give penalty once.\n         */\n        static applyMaskPenaltyRule3(matrix) {\n            let numPenalties = 0;\n            const array = matrix.getArray();\n            const width = matrix.getWidth();\n            const height = matrix.getHeight();\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    const arrayY = array[y]; // We can at least optimize this access\n                    if (x + 6 < width &&\n                        arrayY[x] === 1 &&\n                        arrayY[x + 1] === 0 &&\n                        arrayY[x + 2] === 1 &&\n                        arrayY[x + 3] === 1 &&\n                        arrayY[x + 4] === 1 &&\n                        arrayY[x + 5] === 0 &&\n                        arrayY[x + 6] === 1 &&\n                        (MaskUtil.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil.isWhiteHorizontal(arrayY, x + 7, x + 11))) {\n                        numPenalties++;\n                    }\n                    if (y + 6 < height &&\n                        array[y][x] === 1 &&\n                        array[y + 1][x] === 0 &&\n                        array[y + 2][x] === 1 &&\n                        array[y + 3][x] === 1 &&\n                        array[y + 4][x] === 1 &&\n                        array[y + 5][x] === 0 &&\n                        array[y + 6][x] === 1 &&\n                        (MaskUtil.isWhiteVertical(array, x, y - 4, y) || MaskUtil.isWhiteVertical(array, x, y + 7, y + 11))) {\n                        numPenalties++;\n                    }\n                }\n            }\n            return numPenalties * MaskUtil.N3;\n        }\n        static isWhiteHorizontal(rowArray, from /*int*/, to /*int*/) {\n            from = Math.max(from, 0);\n            to = Math.min(to, rowArray.length);\n            for (let i = from; i < to; i++) {\n                if (rowArray[i] === 1) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        static isWhiteVertical(array, col /*int*/, from /*int*/, to /*int*/) {\n            from = Math.max(from, 0);\n            to = Math.min(to, array.length);\n            for (let i = from; i < to; i++) {\n                if (array[i][col] === 1) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /**\n         * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give\n         * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.\n         */\n        static applyMaskPenaltyRule4(matrix) {\n            let numDarkCells = 0;\n            const array = matrix.getArray();\n            const width = matrix.getWidth();\n            const height = matrix.getHeight();\n            for (let y = 0; y < height; y++) {\n                const arrayY = array[y];\n                for (let x = 0; x < width; x++) {\n                    if (arrayY[x] === 1) {\n                        numDarkCells++;\n                    }\n                }\n            }\n            const numTotalCells = matrix.getHeight() * matrix.getWidth();\n            const fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);\n            return fivePercentVariances * MaskUtil.N4;\n        }\n        /**\n         * Return the mask bit for \"getMaskPattern\" at \"x\" and \"y\". See 8.8 of JISX0510:2004 for mask\n         * pattern conditions.\n         */\n        static getDataMaskBit(maskPattern /*int*/, x /*int*/, y /*int*/) {\n            let intermediate; /*int*/\n            let temp; /*int*/\n            switch (maskPattern) {\n                case 0:\n                    intermediate = (y + x) & 0x1;\n                    break;\n                case 1:\n                    intermediate = y & 0x1;\n                    break;\n                case 2:\n                    intermediate = x % 3;\n                    break;\n                case 3:\n                    intermediate = (y + x) % 3;\n                    break;\n                case 4:\n                    intermediate = (Math.floor(y / 2) + Math.floor(x / 3)) & 0x1;\n                    break;\n                case 5:\n                    temp = y * x;\n                    intermediate = (temp & 0x1) + (temp % 3);\n                    break;\n                case 6:\n                    temp = y * x;\n                    intermediate = ((temp & 0x1) + (temp % 3)) & 0x1;\n                    break;\n                case 7:\n                    temp = y * x;\n                    intermediate = ((temp % 3) + ((y + x) & 0x1)) & 0x1;\n                    break;\n                default:\n                    throw new IllegalArgumentException('Invalid mask pattern: ' + maskPattern);\n            }\n            return intermediate === 0;\n        }\n        /**\n         * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both\n         * vertical and horizontal orders respectively.\n         */\n        static applyMaskPenaltyRule1Internal(matrix, isHorizontal) {\n            let penalty = 0;\n            const iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();\n            const jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();\n            const array = matrix.getArray();\n            for (let i = 0; i < iLimit; i++) {\n                let numSameBitCells = 0;\n                let prevBit = -1;\n                for (let j = 0; j < jLimit; j++) {\n                    const bit = isHorizontal ? array[i][j] : array[j][i];\n                    if (bit === prevBit) {\n                        numSameBitCells++;\n                    }\n                    else {\n                        if (numSameBitCells >= 5) {\n                            penalty += MaskUtil.N1 + (numSameBitCells - 5);\n                        }\n                        numSameBitCells = 1; // Include the cell itself.\n                        prevBit = bit;\n                    }\n                }\n                if (numSameBitCells >= 5) {\n                    penalty += MaskUtil.N1 + (numSameBitCells - 5);\n                }\n            }\n            return penalty;\n        }\n    }\n    // Penalty weights from section 6.8.2.1\n    MaskUtil.N1 = 3;\n    MaskUtil.N2 = 3;\n    MaskUtil.N3 = 40;\n    MaskUtil.N4 = 10;\n\n    /**\n     * JAVAPORT: The original code was a 2D array of ints, but since it only ever gets assigned\n     * -1, 0, and 1, I'm going to use less memory and go with bytes.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class ByteMatrix {\n        constructor(width /*int*/, height /*int*/) {\n            this.width = width;\n            this.height = height;\n            const bytes = new Array(height); // [height][width]\n            for (let i = 0; i !== height; i++) {\n                bytes[i] = new Uint8Array(width);\n            }\n            this.bytes = bytes;\n        }\n        getHeight() {\n            return this.height;\n        }\n        getWidth() {\n            return this.width;\n        }\n        get(x /*int*/, y /*int*/) {\n            return this.bytes[y][x];\n        }\n        /**\n         * @return an internal representation as bytes, in row-major order. array[y][x] represents point (x,y)\n         */\n        getArray() {\n            return this.bytes;\n        }\n        // TYPESCRIPTPORT: preffer to let two methods instead of override to avoid type comparison inside\n        setNumber(x /*int*/, y /*int*/, value /*byte|int*/) {\n            this.bytes[y][x] = value;\n        }\n        // public set(x: number /*int*/, y: number /*int*/, value: number /*int*/): void {\n        //   bytes[y][x] = (byte) value\n        // }\n        setBoolean(x /*int*/, y /*int*/, value) {\n            this.bytes[y][x] = /*(byte) */ (value ? 1 : 0);\n        }\n        clear(value /*byte*/) {\n            for (const aByte of this.bytes) {\n                Arrays.fill(aByte, value);\n            }\n        }\n        equals(o) {\n            if (!(o instanceof ByteMatrix)) {\n                return false;\n            }\n            const other = o;\n            if (this.width !== other.width) {\n                return false;\n            }\n            if (this.height !== other.height) {\n                return false;\n            }\n            for (let y = 0, height = this.height; y < height; ++y) {\n                const bytesY = this.bytes[y];\n                const otherBytesY = other.bytes[y];\n                for (let x = 0, width = this.width; x < width; ++x) {\n                    if (bytesY[x] !== otherBytesY[x]) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        /*@Override*/\n        toString() {\n            const result = new StringBuilder(); // (2 * width * height + 2)\n            for (let y = 0, height = this.height; y < height; ++y) {\n                const bytesY = this.bytes[y];\n                for (let x = 0, width = this.width; x < width; ++x) {\n                    switch (bytesY[x]) {\n                        case 0:\n                            result.append(' 0');\n                            break;\n                        case 1:\n                            result.append(' 1');\n                            break;\n                        default:\n                            result.append('  ');\n                            break;\n                    }\n                }\n                result.append('\\n');\n            }\n            return result.toString();\n        }\n    }\n\n    /**\n     * @author satorux@google.com (Satoru Takabayashi) - creator\n     * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n     */\n    class QRCode {\n        constructor() {\n            this.maskPattern = -1;\n        }\n        getMode() {\n            return this.mode;\n        }\n        getECLevel() {\n            return this.ecLevel;\n        }\n        getVersion() {\n            return this.version;\n        }\n        getMaskPattern() {\n            return this.maskPattern;\n        }\n        getMatrix() {\n            return this.matrix;\n        }\n        /*@Override*/\n        toString() {\n            const result = new StringBuilder(); // (200)\n            result.append('<<\\n');\n            result.append(' mode: ');\n            result.append(this.mode ? this.mode.toString() : 'null');\n            result.append('\\n ecLevel: ');\n            result.append(this.ecLevel ? this.ecLevel.toString() : 'null');\n            result.append('\\n version: ');\n            result.append(this.version ? this.version.toString() : 'null');\n            result.append('\\n maskPattern: ');\n            result.append(this.maskPattern.toString());\n            if (this.matrix) {\n                result.append('\\n matrix:\\n');\n                result.append(this.matrix.toString());\n            }\n            else {\n                result.append('\\n matrix: null\\n');\n            }\n            result.append('>>\\n');\n            return result.toString();\n        }\n        setMode(value) {\n            this.mode = value;\n        }\n        setECLevel(value) {\n            this.ecLevel = value;\n        }\n        setVersion(version) {\n            this.version = version;\n        }\n        setMaskPattern(value /*int*/) {\n            this.maskPattern = value;\n        }\n        setMatrix(value) {\n            this.matrix = value;\n        }\n        // Check if \"mask_pattern\" is valid.\n        static isValidMaskPattern(maskPattern /*int*/) {\n            return maskPattern >= 0 && maskPattern < QRCode.NUM_MASK_PATTERNS;\n        }\n    }\n    QRCode.NUM_MASK_PATTERNS = 8;\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class WriterException extends Exception {\n    }\n    WriterException.kind = 'WriterException';\n\n    /**\n     * @author satorux@google.com (Satoru Takabayashi) - creator\n     * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n     */\n    class MatrixUtil {\n        constructor() {\n            // do nothing\n        }\n        // Set all cells to -1 (TYPESCRIPTPORT: 255).  -1 (TYPESCRIPTPORT: 255) means that the cell is empty (not set yet).\n        //\n        // JAVAPORT: We shouldn't need to do this at all. The code should be rewritten to begin encoding\n        // with the ByteMatrix initialized all to zero.\n        static clearMatrix(matrix) {\n            // TYPESCRIPTPORT: we use UintArray se changed here from -1 to 255\n            matrix.clear(/*(byte) */ /*-1*/ 255);\n        }\n        // Build 2D matrix of QR Code from \"dataBits\" with \"ecLevel\", \"version\" and \"getMaskPattern\". On\n        // success, store the result in \"matrix\" and return true.\n        static buildMatrix(dataBits, ecLevel, version, maskPattern /*int*/, matrix) {\n            MatrixUtil.clearMatrix(matrix);\n            MatrixUtil.embedBasicPatterns(version, matrix);\n            // Type information appear with any version.\n            MatrixUtil.embedTypeInfo(ecLevel, maskPattern, matrix);\n            // Version info appear if version >= 7.\n            MatrixUtil.maybeEmbedVersionInfo(version, matrix);\n            // Data should be embedded at end.\n            MatrixUtil.embedDataBits(dataBits, maskPattern, matrix);\n        }\n        // Embed basic patterns. On success, modify the matrix and return true.\n        // The basic patterns are:\n        // - Position detection patterns\n        // - Timing patterns\n        // - Dark dot at the left bottom corner\n        // - Position adjustment patterns, if need be\n        static embedBasicPatterns(version, matrix) {\n            // Let's get started with embedding big squares at corners.\n            MatrixUtil.embedPositionDetectionPatternsAndSeparators(matrix);\n            // Then, embed the dark dot at the left bottom corner.\n            MatrixUtil.embedDarkDotAtLeftBottomCorner(matrix);\n            // Position adjustment patterns appear if version >= 2.\n            MatrixUtil.maybeEmbedPositionAdjustmentPatterns(version, matrix);\n            // Timing patterns should be embedded after position adj. patterns.\n            MatrixUtil.embedTimingPatterns(matrix);\n        }\n        // Embed type information. On success, modify the matrix.\n        static embedTypeInfo(ecLevel, maskPattern /*int*/, matrix) {\n            const typeInfoBits = new BitArray();\n            MatrixUtil.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);\n            for (let i = 0, size = typeInfoBits.getSize(); i < size; ++i) {\n                // Place bits in LSB to MSB order.  LSB (least significant bit) is the last value in\n                // \"typeInfoBits\".\n                const bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i);\n                // Type info bits at the left top corner. See 8.9 of JISX0510:2004 (p.46).\n                const coordinates = MatrixUtil.TYPE_INFO_COORDINATES[i];\n                const x1 = coordinates[0];\n                const y1 = coordinates[1];\n                matrix.setBoolean(x1, y1, bit);\n                if (i < 8) {\n                    // Right top corner.\n                    const x2 = matrix.getWidth() - i - 1;\n                    const y2 = 8;\n                    matrix.setBoolean(x2, y2, bit);\n                }\n                else {\n                    // Left bottom corner.\n                    const x2 = 8;\n                    const y2 = matrix.getHeight() - 7 + (i - 8);\n                    matrix.setBoolean(x2, y2, bit);\n                }\n            }\n        }\n        // Embed version information if need be. On success, modify the matrix and return true.\n        // See 8.10 of JISX0510:2004 (p.47) for how to embed version information.\n        static maybeEmbedVersionInfo(version, matrix) {\n            if (version.getVersionNumber() < 7) { // Version info is necessary if version >= 7.\n                return; // Don't need version info.\n            }\n            const versionInfoBits = new BitArray();\n            MatrixUtil.makeVersionInfoBits(version, versionInfoBits);\n            let bitIndex = 6 * 3 - 1; // It will decrease from 17 to 0.\n            for (let i = 0; i < 6; ++i) {\n                for (let j = 0; j < 3; ++j) {\n                    // Place bits in LSB (least significant bit) to MSB order.\n                    const bit = versionInfoBits.get(bitIndex);\n                    bitIndex--;\n                    // Left bottom corner.\n                    matrix.setBoolean(i, matrix.getHeight() - 11 + j, bit);\n                    // Right bottom corner.\n                    matrix.setBoolean(matrix.getHeight() - 11 + j, i, bit);\n                }\n            }\n        }\n        // Embed \"dataBits\" using \"getMaskPattern\". On success, modify the matrix and return true.\n        // For debugging purposes, it skips masking process if \"getMaskPattern\" is -1(TYPESCRIPTPORT: 255).\n        // See 8.7 of JISX0510:2004 (p.38) for how to embed data bits.\n        static embedDataBits(dataBits, maskPattern /*int*/, matrix) {\n            let bitIndex = 0;\n            let direction = -1;\n            // Start from the right bottom cell.\n            let x = matrix.getWidth() - 1;\n            let y = matrix.getHeight() - 1;\n            while (x > 0) {\n                // Skip the vertical timing pattern.\n                if (x === 6) {\n                    x -= 1;\n                }\n                while (y >= 0 && y < matrix.getHeight()) {\n                    for (let i = 0; i < 2; ++i) {\n                        const xx = x - i;\n                        // Skip the cell if it's not empty.\n                        if (!MatrixUtil.isEmpty(matrix.get(xx, y))) {\n                            continue;\n                        }\n                        let bit;\n                        if (bitIndex < dataBits.getSize()) {\n                            bit = dataBits.get(bitIndex);\n                            ++bitIndex;\n                        }\n                        else {\n                            // Padding bit. If there is no bit left, we'll fill the left cells with 0, as described\n                            // in 8.4.9 of JISX0510:2004 (p. 24).\n                            bit = false;\n                        }\n                        // Skip masking if mask_pattern is -1 (TYPESCRIPTPORT: 255).\n                        if (maskPattern !== 255 && MaskUtil.getDataMaskBit(maskPattern, xx, y)) {\n                            bit = !bit;\n                        }\n                        matrix.setBoolean(xx, y, bit);\n                    }\n                    y += direction;\n                }\n                direction = -direction; // Reverse the direction.\n                y += direction;\n                x -= 2; // Move to the left.\n            }\n            // All bits should be consumed.\n            if (bitIndex !== dataBits.getSize()) {\n                throw new WriterException('Not all bits consumed: ' + bitIndex + '/' + dataBits.getSize());\n            }\n        }\n        // Return the position of the most significant bit set (one: to) in the \"value\". The most\n        // significant bit is position 32. If there is no bit set, return 0. Examples:\n        // - findMSBSet(0) => 0\n        // - findMSBSet(1) => 1\n        // - findMSBSet(255) => 8\n        static findMSBSet(value /*int*/) {\n            return 32 - Integer.numberOfLeadingZeros(value);\n        }\n        // Calculate BCH (Bose-Chaudhuri-Hocquenghem) code for \"value\" using polynomial \"poly\". The BCH\n        // code is used for encoding type information and version information.\n        // Example: Calculation of version information of 7.\n        // f(x) is created from 7.\n        //   - 7 = 000111 in 6 bits\n        //   - f(x) = x^2 + x^1 + x^0\n        // g(x) is given by the standard (p. 67)\n        //   - g(x) = x^12 + x^11 + x^10 + x^9 + x^8 + x^5 + x^2 + 1\n        // Multiply f(x) by x^(18 - 6)\n        //   - f'(x) = f(x) * x^(18 - 6)\n        //   - f'(x) = x^14 + x^13 + x^12\n        // Calculate the remainder of f'(x) / g(x)\n        //         x^2\n        //         __________________________________________________\n        //   g(x) )x^14 + x^13 + x^12\n        //         x^14 + x^13 + x^12 + x^11 + x^10 + x^7 + x^4 + x^2\n        //         --------------------------------------------------\n        //                              x^11 + x^10 + x^7 + x^4 + x^2\n        //\n        // The remainder is x^11 + x^10 + x^7 + x^4 + x^2\n        // Encode it in binary: 110010010100\n        // The return value is 0xc94 (1100 1001 0100)\n        //\n        // Since all coefficients in the polynomials are 1 or 0, we can do the calculation by bit\n        // operations. We don't care if coefficients are positive or negative.\n        static calculateBCHCode(value /*int*/, poly /*int*/) {\n            if (poly === 0) {\n                throw new IllegalArgumentException('0 polynomial');\n            }\n            // If poly is \"1 1111 0010 0101\" (version info poly), msbSetInPoly is 13. We'll subtract 1\n            // from 13 to make it 12.\n            const msbSetInPoly = MatrixUtil.findMSBSet(poly);\n            value <<= msbSetInPoly - 1;\n            // Do the division business using exclusive-or operations.\n            while (MatrixUtil.findMSBSet(value) >= msbSetInPoly) {\n                value ^= poly << (MatrixUtil.findMSBSet(value) - msbSetInPoly);\n            }\n            // Now the \"value\" is the remainder (i.e. the BCH code)\n            return value;\n        }\n        // Make bit vector of type information. On success, store the result in \"bits\" and return true.\n        // Encode error correction level and mask pattern. See 8.9 of\n        // JISX0510:2004 (p.45) for details.\n        static makeTypeInfoBits(ecLevel, maskPattern /*int*/, bits) {\n            if (!QRCode.isValidMaskPattern(maskPattern)) {\n                throw new WriterException('Invalid mask pattern');\n            }\n            const typeInfo = (ecLevel.getBits() << 3) | maskPattern;\n            bits.appendBits(typeInfo, 5);\n            const bchCode = MatrixUtil.calculateBCHCode(typeInfo, MatrixUtil.TYPE_INFO_POLY);\n            bits.appendBits(bchCode, 10);\n            const maskBits = new BitArray();\n            maskBits.appendBits(MatrixUtil.TYPE_INFO_MASK_PATTERN, 15);\n            bits.xor(maskBits);\n            if (bits.getSize() !== 15) { // Just in case.\n                throw new WriterException('should not happen but we got: ' + bits.getSize());\n            }\n        }\n        // Make bit vector of version information. On success, store the result in \"bits\" and return true.\n        // See 8.10 of JISX0510:2004 (p.45) for details.\n        static makeVersionInfoBits(version, bits) {\n            bits.appendBits(version.getVersionNumber(), 6);\n            const bchCode = MatrixUtil.calculateBCHCode(version.getVersionNumber(), MatrixUtil.VERSION_INFO_POLY);\n            bits.appendBits(bchCode, 12);\n            if (bits.getSize() !== 18) { // Just in case.\n                throw new WriterException('should not happen but we got: ' + bits.getSize());\n            }\n        }\n        // Check if \"value\" is empty.\n        static isEmpty(value /*int*/) {\n            return value === 255; // -1\n        }\n        static embedTimingPatterns(matrix) {\n            // -8 is for skipping position detection patterns (7: size), and two horizontal/vertical\n            // separation patterns (1: size). Thus, 8 = 7 + 1.\n            for (let i = 8; i < matrix.getWidth() - 8; ++i) {\n                const bit = (i + 1) % 2;\n                // Horizontal line.\n                if (MatrixUtil.isEmpty(matrix.get(i, 6))) {\n                    matrix.setNumber(i, 6, bit);\n                }\n                // Vertical line.\n                if (MatrixUtil.isEmpty(matrix.get(6, i))) {\n                    matrix.setNumber(6, i, bit);\n                }\n            }\n        }\n        // Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46)\n        static embedDarkDotAtLeftBottomCorner(matrix) {\n            if (matrix.get(8, matrix.getHeight() - 8) === 0) {\n                throw new WriterException();\n            }\n            matrix.setNumber(8, matrix.getHeight() - 8, 1);\n        }\n        static embedHorizontalSeparationPattern(xStart /*int*/, yStart /*int*/, matrix) {\n            for (let x = 0; x < 8; ++x) {\n                if (!MatrixUtil.isEmpty(matrix.get(xStart + x, yStart))) {\n                    throw new WriterException();\n                }\n                matrix.setNumber(xStart + x, yStart, 0);\n            }\n        }\n        static embedVerticalSeparationPattern(xStart /*int*/, yStart /*int*/, matrix) {\n            for (let y = 0; y < 7; ++y) {\n                if (!MatrixUtil.isEmpty(matrix.get(xStart, yStart + y))) {\n                    throw new WriterException();\n                }\n                matrix.setNumber(xStart, yStart + y, 0);\n            }\n        }\n        static embedPositionAdjustmentPattern(xStart /*int*/, yStart /*int*/, matrix) {\n            for (let y = 0; y < 5; ++y) {\n                const patternY = MatrixUtil.POSITION_ADJUSTMENT_PATTERN[y];\n                for (let x = 0; x < 5; ++x) {\n                    matrix.setNumber(xStart + x, yStart + y, patternY[x]);\n                }\n            }\n        }\n        static embedPositionDetectionPattern(xStart /*int*/, yStart /*int*/, matrix) {\n            for (let y = 0; y < 7; ++y) {\n                const patternY = MatrixUtil.POSITION_DETECTION_PATTERN[y];\n                for (let x = 0; x < 7; ++x) {\n                    matrix.setNumber(xStart + x, yStart + y, patternY[x]);\n                }\n            }\n        }\n        // Embed position detection patterns and surrounding vertical/horizontal separators.\n        static embedPositionDetectionPatternsAndSeparators(matrix) {\n            // Embed three big squares at corners.\n            const pdpWidth = MatrixUtil.POSITION_DETECTION_PATTERN[0].length;\n            // Left top corner.\n            MatrixUtil.embedPositionDetectionPattern(0, 0, matrix);\n            // Right top corner.\n            MatrixUtil.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);\n            // Left bottom corner.\n            MatrixUtil.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);\n            // Embed horizontal separation patterns around the squares.\n            const hspWidth = 8;\n            // Left top corner.\n            MatrixUtil.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);\n            // Right top corner.\n            MatrixUtil.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth, hspWidth - 1, matrix);\n            // Left bottom corner.\n            MatrixUtil.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth, matrix);\n            // Embed vertical separation patterns around the squares.\n            const vspSize = 7;\n            // Left top corner.\n            MatrixUtil.embedVerticalSeparationPattern(vspSize, 0, matrix);\n            // Right top corner.\n            MatrixUtil.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0, matrix);\n            // Left bottom corner.\n            MatrixUtil.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize, matrix);\n        }\n        // Embed position adjustment patterns if need be.\n        static maybeEmbedPositionAdjustmentPatterns(version, matrix) {\n            if (version.getVersionNumber() < 2) { // The patterns appear if version >= 2\n                return;\n            }\n            const index = version.getVersionNumber() - 1;\n            const coordinates = MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];\n            for (let i = 0, length = coordinates.length; i !== length; i++) {\n                const y = coordinates[i];\n                if (y >= 0) {\n                    for (let j = 0; j !== length; j++) {\n                        const x = coordinates[j];\n                        if (x >= 0 && MatrixUtil.isEmpty(matrix.get(x, y))) {\n                            // If the cell is unset, we embed the position adjustment pattern here.\n                            // -2 is necessary since the x/y coordinates point to the center of the pattern, not the\n                            // left top corner.\n                            MatrixUtil.embedPositionAdjustmentPattern(x - 2, y - 2, matrix);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    MatrixUtil.POSITION_DETECTION_PATTERN = Array.from([\n        Int32Array.from([1, 1, 1, 1, 1, 1, 1]),\n        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),\n        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),\n        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),\n        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),\n        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),\n        Int32Array.from([1, 1, 1, 1, 1, 1, 1]),\n    ]);\n    MatrixUtil.POSITION_ADJUSTMENT_PATTERN = Array.from([\n        Int32Array.from([1, 1, 1, 1, 1]),\n        Int32Array.from([1, 0, 0, 0, 1]),\n        Int32Array.from([1, 0, 1, 0, 1]),\n        Int32Array.from([1, 0, 0, 0, 1]),\n        Int32Array.from([1, 1, 1, 1, 1]),\n    ]);\n    // From Appendix E. Table 1, JIS0510X:2004 (71: p). The table was double-checked by komatsu.\n    MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([\n        Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 18, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 22, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 26, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 30, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 34, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 22, 38, -1, -1, -1, -1]),\n        Int32Array.from([6, 24, 42, -1, -1, -1, -1]),\n        Int32Array.from([6, 26, 46, -1, -1, -1, -1]),\n        Int32Array.from([6, 28, 50, -1, -1, -1, -1]),\n        Int32Array.from([6, 30, 54, -1, -1, -1, -1]),\n        Int32Array.from([6, 32, 58, -1, -1, -1, -1]),\n        Int32Array.from([6, 34, 62, -1, -1, -1, -1]),\n        Int32Array.from([6, 26, 46, 66, -1, -1, -1]),\n        Int32Array.from([6, 26, 48, 70, -1, -1, -1]),\n        Int32Array.from([6, 26, 50, 74, -1, -1, -1]),\n        Int32Array.from([6, 30, 54, 78, -1, -1, -1]),\n        Int32Array.from([6, 30, 56, 82, -1, -1, -1]),\n        Int32Array.from([6, 30, 58, 86, -1, -1, -1]),\n        Int32Array.from([6, 34, 62, 90, -1, -1, -1]),\n        Int32Array.from([6, 28, 50, 72, 94, -1, -1]),\n        Int32Array.from([6, 26, 50, 74, 98, -1, -1]),\n        Int32Array.from([6, 30, 54, 78, 102, -1, -1]),\n        Int32Array.from([6, 28, 54, 80, 106, -1, -1]),\n        Int32Array.from([6, 32, 58, 84, 110, -1, -1]),\n        Int32Array.from([6, 30, 58, 86, 114, -1, -1]),\n        Int32Array.from([6, 34, 62, 90, 118, -1, -1]),\n        Int32Array.from([6, 26, 50, 74, 98, 122, -1]),\n        Int32Array.from([6, 30, 54, 78, 102, 126, -1]),\n        Int32Array.from([6, 26, 52, 78, 104, 130, -1]),\n        Int32Array.from([6, 30, 56, 82, 108, 134, -1]),\n        Int32Array.from([6, 34, 60, 86, 112, 138, -1]),\n        Int32Array.from([6, 30, 58, 86, 114, 142, -1]),\n        Int32Array.from([6, 34, 62, 90, 118, 146, -1]),\n        Int32Array.from([6, 30, 54, 78, 102, 126, 150]),\n        Int32Array.from([6, 24, 50, 76, 102, 128, 154]),\n        Int32Array.from([6, 28, 54, 80, 106, 132, 158]),\n        Int32Array.from([6, 32, 58, 84, 110, 136, 162]),\n        Int32Array.from([6, 26, 54, 82, 110, 138, 166]),\n        Int32Array.from([6, 30, 58, 86, 114, 142, 170]),\n    ]);\n    // Type info cells at the left top corner.\n    MatrixUtil.TYPE_INFO_COORDINATES = Array.from([\n        Int32Array.from([8, 0]),\n        Int32Array.from([8, 1]),\n        Int32Array.from([8, 2]),\n        Int32Array.from([8, 3]),\n        Int32Array.from([8, 4]),\n        Int32Array.from([8, 5]),\n        Int32Array.from([8, 7]),\n        Int32Array.from([8, 8]),\n        Int32Array.from([7, 8]),\n        Int32Array.from([5, 8]),\n        Int32Array.from([4, 8]),\n        Int32Array.from([3, 8]),\n        Int32Array.from([2, 8]),\n        Int32Array.from([1, 8]),\n        Int32Array.from([0, 8]),\n    ]);\n    // From Appendix D in JISX0510:2004 (p. 67)\n    MatrixUtil.VERSION_INFO_POLY = 0x1f25; // 1 1111 0010 0101\n    // From Appendix C in JISX0510:2004 (p.65).\n    MatrixUtil.TYPE_INFO_POLY = 0x537;\n    MatrixUtil.TYPE_INFO_MASK_PATTERN = 0x5412;\n\n    /*namespace com.google.zxing.qrcode.encoder {*/\n    class BlockPair {\n        constructor(dataBytes, errorCorrectionBytes) {\n            this.dataBytes = dataBytes;\n            this.errorCorrectionBytes = errorCorrectionBytes;\n        }\n        getDataBytes() {\n            return this.dataBytes;\n        }\n        getErrorCorrectionBytes() {\n            return this.errorCorrectionBytes;\n        }\n    }\n\n    /*import java.io.UnsupportedEncodingException;*/\n    /*import java.util.ArrayList;*/\n    /*import java.util.Collection;*/\n    /*import java.util.Map;*/\n    /**\n     * @author satorux@google.com (Satoru Takabayashi) - creator\n     * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n     */\n    class Encoder {\n        // TYPESCRIPTPORT: changed to UTF8, the default for js\n        constructor() { }\n        // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.\n        // Basically it applies four rules and summate all penalties.\n        static calculateMaskPenalty(matrix) {\n            return MaskUtil.applyMaskPenaltyRule1(matrix)\n                + MaskUtil.applyMaskPenaltyRule2(matrix)\n                + MaskUtil.applyMaskPenaltyRule3(matrix)\n                + MaskUtil.applyMaskPenaltyRule4(matrix);\n        }\n        /**\n         * @param content text to encode\n         * @param ecLevel error correction level to use\n         * @return {@link QRCode} representing the encoded QR code\n         * @throws WriterException if encoding can't succeed, because of for example invalid content\n         *   or configuration\n         */\n        // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {\n        //   return encode(content, ecLevel, null)\n        // }\n        static encode(content, ecLevel, hints = null) {\n            // Determine what character encoding has been specified by the caller, if any\n            let encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;\n            const hasEncodingHint = hints !== null && undefined !== hints.get(EncodeHintType$1.CHARACTER_SET);\n            if (hasEncodingHint) {\n                encoding = hints.get(EncodeHintType$1.CHARACTER_SET).toString();\n            }\n            // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n            // multiple modes / segments even if that were more efficient. Twould be nice.\n            const mode = this.chooseMode(content, encoding);\n            // This will store the header information, like mode and\n            // length, as well as \"header\" segments like an ECI segment.\n            const headerBits = new BitArray();\n            // Append ECI segment if applicable\n            if (mode === Mode$1.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {\n                const eci = CharacterSetECI.getCharacterSetECIByName(encoding);\n                if (eci !== undefined) {\n                    this.appendECI(eci, headerBits);\n                }\n            }\n            // (With ECI in place,) Write the mode marker\n            this.appendModeInfo(mode, headerBits);\n            // Collect data within the main segment, separately, to count its size if needed. Don't add it to\n            // main payload yet.\n            const dataBits = new BitArray();\n            this.appendBytes(content, mode, dataBits, encoding);\n            let version;\n            if (hints !== null && undefined !== hints.get(EncodeHintType$1.QR_VERSION)) {\n                const versionNumber = Number.parseInt(hints.get(EncodeHintType$1.QR_VERSION).toString(), 10);\n                version = Version$1.getVersionForNumber(versionNumber);\n                const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);\n                if (!this.willFit(bitsNeeded, version, ecLevel)) {\n                    throw new WriterException('Data too big for requested version');\n                }\n            }\n            else {\n                version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);\n            }\n            const headerAndDataBits = new BitArray();\n            headerAndDataBits.appendBitArray(headerBits);\n            // Find \"length\" of main segment and write it\n            const numLetters = mode === Mode$1.BYTE ? dataBits.getSizeInBytes() : content.length;\n            this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);\n            // Put data together into the overall payload\n            headerAndDataBits.appendBitArray(dataBits);\n            const ecBlocks = version.getECBlocksForLevel(ecLevel);\n            const numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();\n            // Terminate the bits properly.\n            this.terminateBits(numDataBytes, headerAndDataBits);\n            // Interleave data bits with error correction code.\n            const finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());\n            const qrCode = new QRCode();\n            qrCode.setECLevel(ecLevel);\n            qrCode.setMode(mode);\n            qrCode.setVersion(version);\n            //  Choose the mask pattern and set to \"qrCode\".\n            const dimension = version.getDimensionForVersion();\n            const matrix = new ByteMatrix(dimension, dimension);\n            const maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);\n            qrCode.setMaskPattern(maskPattern);\n            // Build the matrix and set it to \"qrCode\".\n            MatrixUtil.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);\n            qrCode.setMatrix(matrix);\n            return qrCode;\n        }\n        /**\n         * Decides the smallest version of QR code that will contain all of the provided data.\n         *\n         * @throws WriterException if the data cannot fit in any version\n         */\n        static recommendVersion(ecLevel, mode, headerBits, dataBits) {\n            // Hard part: need to know version to know how many bits length takes. But need to know how many\n            // bits it takes to know version. First we take a guess at version by assuming version will be\n            // the minimum, 1:\n            const provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version$1.getVersionForNumber(1));\n            const provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);\n            // Use that guess to calculate the right version. I am still not sure this works in 100% of cases.\n            const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);\n            return this.chooseVersion(bitsNeeded, ecLevel);\n        }\n        static calculateBitsNeeded(mode, headerBits, dataBits, version) {\n            return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();\n        }\n        /**\n         * @return the code point of the table used in alphanumeric mode or\n         *  -1 if there is no corresponding code in the table.\n         */\n        static getAlphanumericCode(code /*int*/) {\n            if (code < Encoder.ALPHANUMERIC_TABLE.length) {\n                return Encoder.ALPHANUMERIC_TABLE[code];\n            }\n            return -1;\n        }\n        // public static chooseMode(content: string): Mode {\n        //   return chooseMode(content, null);\n        // }\n        /**\n         * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;\n         * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.\n         */\n        static chooseMode(content, encoding = null) {\n            if (CharacterSetECI.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {\n                // Choose Kanji mode if all input are double-byte characters\n                return Mode$1.KANJI;\n            }\n            let hasNumeric = false;\n            let hasAlphanumeric = false;\n            for (let i = 0, length = content.length; i < length; ++i) {\n                const c = content.charAt(i);\n                if (Encoder.isDigit(c)) {\n                    hasNumeric = true;\n                }\n                else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {\n                    hasAlphanumeric = true;\n                }\n                else {\n                    return Mode$1.BYTE;\n                }\n            }\n            if (hasAlphanumeric) {\n                return Mode$1.ALPHANUMERIC;\n            }\n            if (hasNumeric) {\n                return Mode$1.NUMERIC;\n            }\n            return Mode$1.BYTE;\n        }\n        static isOnlyDoubleByteKanji(content) {\n            let bytes;\n            try {\n                bytes = StringEncoding.encode(content, CharacterSetECI.SJIS); // content.getBytes(\"Shift_JIS\"))\n            }\n            catch (ignored /*: UnsupportedEncodingException*/) {\n                return false;\n            }\n            const length = bytes.length;\n            if (length % 2 !== 0) {\n                return false;\n            }\n            for (let i = 0; i < length; i += 2) {\n                const byte1 = bytes[i] & 0xFF;\n                if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        static chooseMaskPattern(bits, ecLevel, version, matrix) {\n            let minPenalty = Number.MAX_SAFE_INTEGER; // Lower penalty is better.\n            let bestMaskPattern = -1;\n            // We try all mask patterns to choose the best one.\n            for (let maskPattern = 0; maskPattern < QRCode.NUM_MASK_PATTERNS; maskPattern++) {\n                MatrixUtil.buildMatrix(bits, ecLevel, version, maskPattern, matrix);\n                let penalty = this.calculateMaskPenalty(matrix);\n                if (penalty < minPenalty) {\n                    minPenalty = penalty;\n                    bestMaskPattern = maskPattern;\n                }\n            }\n            return bestMaskPattern;\n        }\n        static chooseVersion(numInputBits /*int*/, ecLevel) {\n            for (let versionNum = 1; versionNum <= 40; versionNum++) {\n                const version = Version$1.getVersionForNumber(versionNum);\n                if (Encoder.willFit(numInputBits, version, ecLevel)) {\n                    return version;\n                }\n            }\n            throw new WriterException('Data too big');\n        }\n        /**\n         * @return true if the number of input bits will fit in a code with the specified version and\n         * error correction level.\n         */\n        static willFit(numInputBits /*int*/, version, ecLevel) {\n            // In the following comments, we use numbers of Version 7-H.\n            // numBytes = 196\n            const numBytes = version.getTotalCodewords();\n            // getNumECBytes = 130\n            const ecBlocks = version.getECBlocksForLevel(ecLevel);\n            const numEcBytes = ecBlocks.getTotalECCodewords();\n            // getNumDataBytes = 196 - 130 = 66\n            const numDataBytes = numBytes - numEcBytes;\n            const totalInputBytes = (numInputBits + 7) / 8;\n            return numDataBytes >= totalInputBytes;\n        }\n        /**\n         * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).\n         */\n        static terminateBits(numDataBytes /*int*/, bits) {\n            const capacity = numDataBytes * 8;\n            if (bits.getSize() > capacity) {\n                throw new WriterException('data bits cannot fit in the QR Code' + bits.getSize() + ' > ' +\n                    capacity);\n            }\n            for (let i = 0; i < 4 && bits.getSize() < capacity; ++i) {\n                bits.appendBit(false);\n            }\n            // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.\n            // If the last byte isn't 8-bit aligned, we'll add padding bits.\n            const numBitsInLastByte = bits.getSize() & 0x07;\n            if (numBitsInLastByte > 0) {\n                for (let i = numBitsInLastByte; i < 8; i++) {\n                    bits.appendBit(false);\n                }\n            }\n            // If we have more space, we'll fill the space with padding patterns defined in 8.4.9 (p.24).\n            const numPaddingBytes = numDataBytes - bits.getSizeInBytes();\n            for (let i = 0; i < numPaddingBytes; ++i) {\n                bits.appendBits((i & 0x01) === 0 ? 0xEC : 0x11, 8);\n            }\n            if (bits.getSize() !== capacity) {\n                throw new WriterException('Bits size does not equal capacity');\n            }\n        }\n        /**\n         * Get number of data bytes and number of error correction bytes for block id \"blockID\". Store\n         * the result in \"numDataBytesInBlock\", and \"numECBytesInBlock\". See table 12 in 8.5.1 of\n         * JISX0510:2004 (p.30)\n         */\n        static getNumDataBytesAndNumECBytesForBlockID(numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/, blockID /*int*/, numDataBytesInBlock, numECBytesInBlock) {\n            if (blockID >= numRSBlocks) {\n                throw new WriterException('Block ID too large');\n            }\n            // numRsBlocksInGroup2 = 196 % 5 = 1\n            const numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;\n            // numRsBlocksInGroup1 = 5 - 1 = 4\n            const numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;\n            // numTotalBytesInGroup1 = 196 / 5 = 39\n            const numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);\n            // numTotalBytesInGroup2 = 39 + 1 = 40\n            const numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;\n            // numDataBytesInGroup1 = 66 / 5 = 13\n            const numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);\n            // numDataBytesInGroup2 = 13 + 1 = 14\n            const numDataBytesInGroup2 = numDataBytesInGroup1 + 1;\n            // numEcBytesInGroup1 = 39 - 13 = 26\n            const numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;\n            // numEcBytesInGroup2 = 40 - 14 = 26\n            const numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;\n            // Sanity checks.\n            // 26 = 26\n            if (numEcBytesInGroup1 !== numEcBytesInGroup2) {\n                throw new WriterException('EC bytes mismatch');\n            }\n            // 5 = 4 + 1.\n            if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {\n                throw new WriterException('RS blocks mismatch');\n            }\n            // 196 = (13 + 26) * 4 + (14 + 26) * 1\n            if (numTotalBytes !==\n                ((numDataBytesInGroup1 + numEcBytesInGroup1) *\n                    numRsBlocksInGroup1) +\n                    ((numDataBytesInGroup2 + numEcBytesInGroup2) *\n                        numRsBlocksInGroup2)) {\n                throw new WriterException('Total bytes mismatch');\n            }\n            if (blockID < numRsBlocksInGroup1) {\n                numDataBytesInBlock[0] = numDataBytesInGroup1;\n                numECBytesInBlock[0] = numEcBytesInGroup1;\n            }\n            else {\n                numDataBytesInBlock[0] = numDataBytesInGroup2;\n                numECBytesInBlock[0] = numEcBytesInGroup2;\n            }\n        }\n        /**\n         * Interleave \"bits\" with corresponding error correction bytes. On success, store the result in\n         * \"result\". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.\n         */\n        static interleaveWithECBytes(bits, numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/) {\n            // \"bits\" must have \"getNumDataBytes\" bytes of data.\n            if (bits.getSizeInBytes() !== numDataBytes) {\n                throw new WriterException('Number of bits and data bytes does not match');\n            }\n            // Step 1.  Divide data bytes into blocks and generate error correction bytes for them. We'll\n            // store the divided data bytes blocks and error correction bytes blocks into \"blocks\".\n            let dataBytesOffset = 0;\n            let maxNumDataBytes = 0;\n            let maxNumEcBytes = 0;\n            // Since, we know the number of reedsolmon blocks, we can initialize the vector with the number.\n            const blocks = new Array(); // new Array<BlockPair>(numRSBlocks)\n            for (let i = 0; i < numRSBlocks; ++i) {\n                const numDataBytesInBlock = new Int32Array(1);\n                const numEcBytesInBlock = new Int32Array(1);\n                Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);\n                const size = numDataBytesInBlock[0];\n                const dataBytes = new Uint8Array(size);\n                bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);\n                const ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);\n                blocks.push(new BlockPair(dataBytes, ecBytes));\n                maxNumDataBytes = Math.max(maxNumDataBytes, size);\n                maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);\n                dataBytesOffset += numDataBytesInBlock[0];\n            }\n            if (numDataBytes !== dataBytesOffset) {\n                throw new WriterException('Data bytes does not match offset');\n            }\n            const result = new BitArray();\n            // First, place data blocks.\n            for (let i = 0; i < maxNumDataBytes; ++i) {\n                for (const block of blocks) {\n                    const dataBytes = block.getDataBytes();\n                    if (i < dataBytes.length) {\n                        result.appendBits(dataBytes[i], 8);\n                    }\n                }\n            }\n            // Then, place error correction blocks.\n            for (let i = 0; i < maxNumEcBytes; ++i) {\n                for (const block of blocks) {\n                    const ecBytes = block.getErrorCorrectionBytes();\n                    if (i < ecBytes.length) {\n                        result.appendBits(ecBytes[i], 8);\n                    }\n                }\n            }\n            if (numTotalBytes !== result.getSizeInBytes()) { // Should be same.\n                throw new WriterException('Interleaving error: ' + numTotalBytes + ' and ' +\n                    result.getSizeInBytes() + ' differ.');\n            }\n            return result;\n        }\n        static generateECBytes(dataBytes, numEcBytesInBlock /*int*/) {\n            const numDataBytes = dataBytes.length;\n            const toEncode = new Int32Array(numDataBytes + numEcBytesInBlock); // int[numDataBytes + numEcBytesInBlock]\n            for (let i = 0; i < numDataBytes; i++) {\n                toEncode[i] = dataBytes[i] & 0xFF;\n            }\n            new ReedSolomonEncoder(GenericGF.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);\n            const ecBytes = new Uint8Array(numEcBytesInBlock);\n            for (let i = 0; i < numEcBytesInBlock; i++) {\n                ecBytes[i] = /*(byte) */ toEncode[numDataBytes + i];\n            }\n            return ecBytes;\n        }\n        /**\n         * Append mode info. On success, store the result in \"bits\".\n         */\n        static appendModeInfo(mode, bits) {\n            bits.appendBits(mode.getBits(), 4);\n        }\n        /**\n         * Append length info. On success, store the result in \"bits\".\n         */\n        static appendLengthInfo(numLetters /*int*/, version, mode, bits) {\n            const numBits = mode.getCharacterCountBits(version);\n            if (numLetters >= (1 << numBits)) {\n                throw new WriterException(numLetters + ' is bigger than ' + ((1 << numBits) - 1));\n            }\n            bits.appendBits(numLetters, numBits);\n        }\n        /**\n         * Append \"bytes\" in \"mode\" mode (encoding) into \"bits\". On success, store the result in \"bits\".\n         */\n        static appendBytes(content, mode, bits, encoding) {\n            switch (mode) {\n                case Mode$1.NUMERIC:\n                    Encoder.appendNumericBytes(content, bits);\n                    break;\n                case Mode$1.ALPHANUMERIC:\n                    Encoder.appendAlphanumericBytes(content, bits);\n                    break;\n                case Mode$1.BYTE:\n                    Encoder.append8BitBytes(content, bits, encoding);\n                    break;\n                case Mode$1.KANJI:\n                    Encoder.appendKanjiBytes(content, bits);\n                    break;\n                default:\n                    throw new WriterException('Invalid mode: ' + mode);\n            }\n        }\n        static getDigit(singleCharacter) {\n            return singleCharacter.charCodeAt(0) - 48;\n        }\n        static isDigit(singleCharacter) {\n            const cn = Encoder.getDigit(singleCharacter);\n            return cn >= 0 && cn <= 9;\n        }\n        static appendNumericBytes(content, bits) {\n            const length = content.length;\n            let i = 0;\n            while (i < length) {\n                const num1 = Encoder.getDigit(content.charAt(i));\n                if (i + 2 < length) {\n                    // Encode three numeric letters in ten bits.\n                    const num2 = Encoder.getDigit(content.charAt(i + 1));\n                    const num3 = Encoder.getDigit(content.charAt(i + 2));\n                    bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);\n                    i += 3;\n                }\n                else if (i + 1 < length) {\n                    // Encode two numeric letters in seven bits.\n                    const num2 = Encoder.getDigit(content.charAt(i + 1));\n                    bits.appendBits(num1 * 10 + num2, 7);\n                    i += 2;\n                }\n                else {\n                    // Encode one numeric letter in four bits.\n                    bits.appendBits(num1, 4);\n                    i++;\n                }\n            }\n        }\n        static appendAlphanumericBytes(content, bits) {\n            const length = content.length;\n            let i = 0;\n            while (i < length) {\n                const code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));\n                if (code1 === -1) {\n                    throw new WriterException();\n                }\n                if (i + 1 < length) {\n                    const code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));\n                    if (code2 === -1) {\n                        throw new WriterException();\n                    }\n                    // Encode two alphanumeric letters in 11 bits.\n                    bits.appendBits(code1 * 45 + code2, 11);\n                    i += 2;\n                }\n                else {\n                    // Encode one alphanumeric letter in six bits.\n                    bits.appendBits(code1, 6);\n                    i++;\n                }\n            }\n        }\n        static append8BitBytes(content, bits, encoding) {\n            let bytes;\n            try {\n                bytes = StringEncoding.encode(content, encoding);\n            }\n            catch (uee /*: UnsupportedEncodingException*/) {\n                throw new WriterException(uee);\n            }\n            for (let i = 0, length = bytes.length; i !== length; i++) {\n                const b = bytes[i];\n                bits.appendBits(b, 8);\n            }\n        }\n        /**\n         * @throws WriterException\n         */\n        static appendKanjiBytes(content, bits) {\n            let bytes;\n            try {\n                bytes = StringEncoding.encode(content, CharacterSetECI.SJIS);\n            }\n            catch (uee /*: UnsupportedEncodingException*/) {\n                throw new WriterException(uee);\n            }\n            const length = bytes.length;\n            for (let i = 0; i < length; i += 2) {\n                const byte1 = bytes[i] & 0xFF;\n                const byte2 = bytes[i + 1] & 0xFF;\n                const code = ((byte1 << 8) & 0xFFFFFFFF) | byte2;\n                let subtracted = -1;\n                if (code >= 0x8140 && code <= 0x9ffc) {\n                    subtracted = code - 0x8140;\n                }\n                else if (code >= 0xe040 && code <= 0xebbf) {\n                    subtracted = code - 0xc140;\n                }\n                if (subtracted === -1) {\n                    throw new WriterException('Invalid byte sequence');\n                }\n                const encoded = ((subtracted >> 8) * 0xc0) + (subtracted & 0xff);\n                bits.appendBits(encoded, 13);\n            }\n        }\n        static appendECI(eci, bits) {\n            bits.appendBits(Mode$1.ECI.getBits(), 4);\n            // This is correct for values up to 127, which is all we need now.\n            bits.appendBits(eci.getValue(), 8);\n        }\n    }\n    // The original table is defined in the table 5 of JISX0510:2004 (p.19).\n    Encoder.ALPHANUMERIC_TABLE = Int32Array.from([\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1,\n        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n    ]);\n    Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI.UTF8.getName(); // \"ISO-8859-1\"\n\n    /**\n     * @deprecated Moving to @zxing/browser\n     */\n    class BrowserQRCodeSvgWriter {\n        /**\n         * Writes and renders a QRCode SVG element.\n         *\n         * @param contents\n         * @param width\n         * @param height\n         * @param hints\n         */\n        write(contents, width, height, hints = null) {\n            if (contents.length === 0) {\n                throw new IllegalArgumentException('Found empty contents');\n            }\n            // if (format != BarcodeFormat.QR_CODE) {\n            //   throw new IllegalArgumentException(\"Can only encode QR_CODE, but got \" + format)\n            // }\n            if (width < 0 || height < 0) {\n                throw new IllegalArgumentException('Requested dimensions are too small: ' + width + 'x' + height);\n            }\n            let errorCorrectionLevel = ErrorCorrectionLevel.L;\n            let quietZone = BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE;\n            if (hints !== null) {\n                if (undefined !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {\n                    errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());\n                }\n                if (undefined !== hints.get(EncodeHintType$1.MARGIN)) {\n                    quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);\n                }\n            }\n            const code = Encoder.encode(contents, errorCorrectionLevel, hints);\n            return this.renderResult(code, width, height, quietZone);\n        }\n        /**\n         * Renders the result and then appends it to the DOM.\n         */\n        writeToDom(containerElement, contents, width, height, hints = null) {\n            if (typeof containerElement === 'string') {\n                containerElement = document.querySelector(containerElement);\n            }\n            const svgElement = this.write(contents, width, height, hints);\n            if (containerElement)\n                containerElement.appendChild(svgElement);\n        }\n        /**\n         * Note that the input matrix uses 0 == white, 1 == black.\n         * The output matrix uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).\n         */\n        renderResult(code, width /*int*/, height /*int*/, quietZone /*int*/) {\n            const input = code.getMatrix();\n            if (input === null) {\n                throw new IllegalStateException();\n            }\n            const inputWidth = input.getWidth();\n            const inputHeight = input.getHeight();\n            const qrWidth = inputWidth + (quietZone * 2);\n            const qrHeight = inputHeight + (quietZone * 2);\n            const outputWidth = Math.max(width, qrWidth);\n            const outputHeight = Math.max(height, qrHeight);\n            const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));\n            // Padding includes both the quiet zone and the extra white pixels to accommodate the requested\n            // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.\n            // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will\n            // handle all the padding from 100x100 (the actual QR) up to 200x160.\n            const leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);\n            const topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);\n            const svgElement = this.createSVGElement(outputWidth, outputHeight);\n            for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {\n                // Write the contents of this row of the barcode\n                for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {\n                    if (input.get(inputX, inputY) === 1) {\n                        const svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);\n                        svgElement.appendChild(svgRectElement);\n                    }\n                }\n            }\n            return svgElement;\n        }\n        /**\n         * Creates a SVG element.\n         *\n         * @param w SVG's width attribute\n         * @param h SVG's height attribute\n         */\n        createSVGElement(w, h) {\n            const svgElement = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, 'svg');\n            svgElement.setAttributeNS(null, 'height', w.toString());\n            svgElement.setAttributeNS(null, 'width', h.toString());\n            return svgElement;\n        }\n        /**\n         * Creates a SVG rect element.\n         *\n         * @param x Element's x coordinate\n         * @param y Element's y coordinate\n         * @param w Element's width attribute\n         * @param h Element's height attribute\n         */\n        createSvgRectElement(x, y, w, h) {\n            const rect = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, 'rect');\n            rect.setAttributeNS(null, 'x', x.toString());\n            rect.setAttributeNS(null, 'y', y.toString());\n            rect.setAttributeNS(null, 'height', w.toString());\n            rect.setAttributeNS(null, 'width', h.toString());\n            rect.setAttributeNS(null, 'fill', '#000000');\n            return rect;\n        }\n    }\n    BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE = 4;\n    /**\n     * SVG markup NameSpace\n     */\n    BrowserQRCodeSvgWriter.SVG_NS = 'http://www.w3.org/2000/svg';\n\n    /*import java.util.Map;*/\n    /**\n     * This object renders a QR Code as a BitMatrix 2D array of greyscale values.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class QRCodeWriter {\n        /*@Override*/\n        // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix\n        //     /*throws WriterException */ {\n        //   return encode(contents, format, width, height, null)\n        // }\n        /*@Override*/\n        encode(contents, format, width /*int*/, height /*int*/, hints) {\n            if (contents.length === 0) {\n                throw new IllegalArgumentException('Found empty contents');\n            }\n            if (format !== BarcodeFormat$1.QR_CODE) {\n                throw new IllegalArgumentException('Can only encode QR_CODE, but got ' + format);\n            }\n            if (width < 0 || height < 0) {\n                throw new IllegalArgumentException(`Requested dimensions are too small: ${width}x${height}`);\n            }\n            let errorCorrectionLevel = ErrorCorrectionLevel.L;\n            let quietZone = QRCodeWriter.QUIET_ZONE_SIZE;\n            if (hints !== null) {\n                if (undefined !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {\n                    errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());\n                }\n                if (undefined !== hints.get(EncodeHintType$1.MARGIN)) {\n                    quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);\n                }\n            }\n            const code = Encoder.encode(contents, errorCorrectionLevel, hints);\n            return QRCodeWriter.renderResult(code, width, height, quietZone);\n        }\n        // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses\n        // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).\n        static renderResult(code, width /*int*/, height /*int*/, quietZone /*int*/) {\n            const input = code.getMatrix();\n            if (input === null) {\n                throw new IllegalStateException();\n            }\n            const inputWidth = input.getWidth();\n            const inputHeight = input.getHeight();\n            const qrWidth = inputWidth + (quietZone * 2);\n            const qrHeight = inputHeight + (quietZone * 2);\n            const outputWidth = Math.max(width, qrWidth);\n            const outputHeight = Math.max(height, qrHeight);\n            const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));\n            // Padding includes both the quiet zone and the extra white pixels to accommodate the requested\n            // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.\n            // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will\n            // handle all the padding from 100x100 (the actual QR) up to 200x160.\n            const leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);\n            const topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);\n            const output = new BitMatrix(outputWidth, outputHeight);\n            for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {\n                // Write the contents of this row of the barcode\n                for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {\n                    if (input.get(inputX, inputY) === 1) {\n                        output.setRegion(outputX, outputY, multiple, multiple);\n                    }\n                }\n            }\n            return output;\n        }\n    }\n    QRCodeWriter.QUIET_ZONE_SIZE = 4;\n\n    /*import java.util.Map;*/\n    /**\n     * This is a factory class which finds the appropriate Writer subclass for the BarcodeFormat\n     * requested and encodes the barcode with the supplied contents.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class MultiFormatWriter {\n        /*@Override*/\n        // public encode(contents: string,\n        //                         format: BarcodeFormat,\n        //                         width: number /*int*/,\n        //                         height: number /*int*/): BitMatrix /*throws WriterException */ {\n        //   return encode(contents, format, width, height, null)\n        // }\n        /*@Override*/\n        encode(contents, format, width /*int*/, height /*int*/, hints) {\n            let writer;\n            switch (format) {\n                // case BarcodeFormat.EAN_8:\n                //   writer = new EAN8Writer()\n                //   break\n                // case BarcodeFormat.UPC_E:\n                //   writer = new UPCEWriter()\n                //   break\n                // case BarcodeFormat.EAN_13:\n                //   writer = new EAN13Writer()\n                //   break\n                // case BarcodeFormat.UPC_A:\n                //   writer = new UPCAWriter()\n                //   break\n                case BarcodeFormat$1.QR_CODE:\n                    writer = new QRCodeWriter();\n                    break;\n                // case BarcodeFormat.CODE_39:\n                //   writer = new Code39Writer()\n                //   break\n                // case BarcodeFormat.CODE_93:\n                //   writer = new Code93Writer()\n                //   break\n                // case BarcodeFormat.CODE_128:\n                //   writer = new Code128Writer()\n                //   break\n                // case BarcodeFormat.ITF:\n                //   writer = new ITFWriter()\n                //   break\n                // case BarcodeFormat.PDF_417:\n                //   writer = new PDF417Writer()\n                //   break\n                // case BarcodeFormat.CODABAR:\n                //   writer = new CodaBarWriter()\n                //   break\n                // case BarcodeFormat.DATA_MATRIX:\n                //   writer = new DataMatrixWriter()\n                //   break\n                // case BarcodeFormat.AZTEC:\n                //   writer = new AztecWriter()\n                //   break\n                default:\n                    throw new IllegalArgumentException('No encoder available for format ' + format);\n            }\n            return writer.encode(contents, format, width, height, hints);\n        }\n    }\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * This object extends LuminanceSource around an array of YUV data returned from the camera driver,\n     * with the option to crop to a rectangle within the full data. This can be used to exclude\n     * superfluous pixels around the perimeter and speed up decoding.\n     *\n     * It works for any pixel format where the Y channel is planar and appears first, including\n     * YCbCr_420_SP and YCbCr_422_SP.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class PlanarYUVLuminanceSource extends LuminanceSource {\n        constructor(yuvData, dataWidth /*int*/, dataHeight /*int*/, left /*int*/, top /*int*/, width /*int*/, height /*int*/, reverseHorizontal) {\n            super(width, height);\n            this.yuvData = yuvData;\n            this.dataWidth = dataWidth;\n            this.dataHeight = dataHeight;\n            this.left = left;\n            this.top = top;\n            if (left + width > dataWidth || top + height > dataHeight) {\n                throw new IllegalArgumentException('Crop rectangle does not fit within image data.');\n            }\n            if (reverseHorizontal) {\n                this.reverseHorizontal(width, height);\n            }\n        }\n        /*@Override*/\n        getRow(y /*int*/, row) {\n            if (y < 0 || y >= this.getHeight()) {\n                throw new IllegalArgumentException('Requested row is outside the image: ' + y);\n            }\n            const width = this.getWidth();\n            if (row === null || row === undefined || row.length < width) {\n                row = new Uint8ClampedArray(width);\n            }\n            const offset = (y + this.top) * this.dataWidth + this.left;\n            System.arraycopy(this.yuvData, offset, row, 0, width);\n            return row;\n        }\n        /*@Override*/\n        getMatrix() {\n            const width = this.getWidth();\n            const height = this.getHeight();\n            // If the caller asks for the entire underlying image, save the copy and give them the\n            // original data. The docs specifically warn that result.length must be ignored.\n            if (width === this.dataWidth && height === this.dataHeight) {\n                return this.yuvData;\n            }\n            const area = width * height;\n            const matrix = new Uint8ClampedArray(area);\n            let inputOffset = this.top * this.dataWidth + this.left;\n            // If the width matches the full width of the underlying data, perform a single copy.\n            if (width === this.dataWidth) {\n                System.arraycopy(this.yuvData, inputOffset, matrix, 0, area);\n                return matrix;\n            }\n            // Otherwise copy one cropped row at a time.\n            for (let y = 0; y < height; y++) {\n                const outputOffset = y * width;\n                System.arraycopy(this.yuvData, inputOffset, matrix, outputOffset, width);\n                inputOffset += this.dataWidth;\n            }\n            return matrix;\n        }\n        /*@Override*/\n        isCropSupported() {\n            return true;\n        }\n        /*@Override*/\n        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n            return new PlanarYUVLuminanceSource(this.yuvData, this.dataWidth, this.dataHeight, this.left + left, this.top + top, width, height, false);\n        }\n        renderThumbnail() {\n            const width = this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n            const height = this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n            const pixels = new Int32Array(width * height);\n            const yuv = this.yuvData;\n            let inputOffset = this.top * this.dataWidth + this.left;\n            for (let y = 0; y < height; y++) {\n                const outputOffset = y * width;\n                for (let x = 0; x < width; x++) {\n                    const grey = yuv[inputOffset + x * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR] & 0xff;\n                    pixels[outputOffset + x] = 0xFF000000 | (grey * 0x00010101);\n                }\n                inputOffset += this.dataWidth * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n            }\n            return pixels;\n        }\n        /**\n         * @return width of image from {@link #renderThumbnail()}\n         */\n        getThumbnailWidth() {\n            return this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n        }\n        /**\n         * @return height of image from {@link #renderThumbnail()}\n         */\n        getThumbnailHeight() {\n            return this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n        }\n        reverseHorizontal(width /*int*/, height /*int*/) {\n            const yuvData = this.yuvData;\n            for (let y = 0, rowStart = this.top * this.dataWidth + this.left; y < height; y++, rowStart += this.dataWidth) {\n                const middle = rowStart + width / 2;\n                for (let x1 = rowStart, x2 = rowStart + width - 1; x1 < middle; x1++, x2--) {\n                    const temp = yuvData[x1];\n                    yuvData[x1] = yuvData[x2];\n                    yuvData[x2] = temp;\n                }\n            }\n        }\n        invert() {\n            return new InvertedLuminanceSource(this);\n        }\n    }\n    PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR = 2;\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * This class is used to help decode images from files which arrive as RGB data from\n     * an ARGB pixel array. It does not support rotation.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Betaminos\n     */\n    class RGBLuminanceSource extends LuminanceSource {\n        constructor(luminances, width /*int*/, height /*int*/, dataWidth /*int*/, dataHeight /*int*/, left /*int*/, top /*int*/) {\n            super(width, height);\n            this.dataWidth = dataWidth;\n            this.dataHeight = dataHeight;\n            this.left = left;\n            this.top = top;\n            if (luminances.BYTES_PER_ELEMENT === 4) { // Int32Array\n                const size = width * height;\n                const luminancesUint8Array = new Uint8ClampedArray(size);\n                for (let offset = 0; offset < size; offset++) {\n                    const pixel = luminances[offset];\n                    const r = (pixel >> 16) & 0xff; // red\n                    const g2 = (pixel >> 7) & 0x1fe; // 2 * green\n                    const b = pixel & 0xff; // blue\n                    // Calculate green-favouring average cheaply\n                    luminancesUint8Array[offset] = /*(byte) */ ((r + g2 + b) / 4) & 0xFF;\n                }\n                this.luminances = luminancesUint8Array;\n            }\n            else {\n                this.luminances = luminances;\n            }\n            if (undefined === dataWidth) {\n                this.dataWidth = width;\n            }\n            if (undefined === dataHeight) {\n                this.dataHeight = height;\n            }\n            if (undefined === left) {\n                this.left = 0;\n            }\n            if (undefined === top) {\n                this.top = 0;\n            }\n            if (this.left + width > this.dataWidth || this.top + height > this.dataHeight) {\n                throw new IllegalArgumentException('Crop rectangle does not fit within image data.');\n            }\n        }\n        /*@Override*/\n        getRow(y /*int*/, row) {\n            if (y < 0 || y >= this.getHeight()) {\n                throw new IllegalArgumentException('Requested row is outside the image: ' + y);\n            }\n            const width = this.getWidth();\n            if (row === null || row === undefined || row.length < width) {\n                row = new Uint8ClampedArray(width);\n            }\n            const offset = (y + this.top) * this.dataWidth + this.left;\n            System.arraycopy(this.luminances, offset, row, 0, width);\n            return row;\n        }\n        /*@Override*/\n        getMatrix() {\n            const width = this.getWidth();\n            const height = this.getHeight();\n            // If the caller asks for the entire underlying image, save the copy and give them the\n            // original data. The docs specifically warn that result.length must be ignored.\n            if (width === this.dataWidth && height === this.dataHeight) {\n                return this.luminances;\n            }\n            const area = width * height;\n            const matrix = new Uint8ClampedArray(area);\n            let inputOffset = this.top * this.dataWidth + this.left;\n            // If the width matches the full width of the underlying data, perform a single copy.\n            if (width === this.dataWidth) {\n                System.arraycopy(this.luminances, inputOffset, matrix, 0, area);\n                return matrix;\n            }\n            // Otherwise copy one cropped row at a time.\n            for (let y = 0; y < height; y++) {\n                const outputOffset = y * width;\n                System.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);\n                inputOffset += this.dataWidth;\n            }\n            return matrix;\n        }\n        /*@Override*/\n        isCropSupported() {\n            return true;\n        }\n        /*@Override*/\n        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n            return new RGBLuminanceSource(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left, this.top + top);\n        }\n        invert() {\n            return new InvertedLuminanceSource(this);\n        }\n    }\n\n    /**\n     * Just to make a shortcut between Java code and TS code.\n     */\n    class Charset extends CharacterSetECI {\n        static forName(name) {\n            return this.getCharacterSetECIByName(name);\n        }\n    }\n\n    /**\n     * Just to make a shortcut between Java code and TS code.\n     */\n    class StandardCharsets {\n    }\n    StandardCharsets.ISO_8859_1 = CharacterSetECI.ISO8859_1;\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /**\n     * Aztec 2D code representation\n     *\n     * @author Rustam Abdullaev\n     */\n    /*public final*/ class AztecCode {\n        /**\n         * @return {@code true} if compact instead of full mode\n         */\n        isCompact() {\n            return this.compact;\n        }\n        setCompact(compact) {\n            this.compact = compact;\n        }\n        /**\n         * @return size in pixels (width and height)\n         */\n        getSize() {\n            return this.size;\n        }\n        setSize(size) {\n            this.size = size;\n        }\n        /**\n         * @return number of levels\n         */\n        getLayers() {\n            return this.layers;\n        }\n        setLayers(layers) {\n            this.layers = layers;\n        }\n        /**\n         * @return number of data codewords\n         */\n        getCodeWords() {\n            return this.codeWords;\n        }\n        setCodeWords(codeWords) {\n            this.codeWords = codeWords;\n        }\n        /**\n         * @return the symbol image\n         */\n        getMatrix() {\n            return this.matrix;\n        }\n        setMatrix(matrix) {\n            this.matrix = matrix;\n        }\n    }\n\n    class Collections {\n        /**\n         * The singletonList(T) method is used to return an immutable list containing only the specified object.\n         */\n        static singletonList(item) {\n            return [item];\n        }\n        /**\n         * The min(Collection<? extends T>, Comparator<? super T>) method is used to return the minimum element of the given collection, according to the order induced by the specified comparator.\n         */\n        static min(collection, comparator) {\n            return collection.sort(comparator)[0];\n        }\n    }\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    class Token {\n        constructor(previous) {\n            this.previous = previous;\n        }\n        getPrevious() {\n            return this.previous;\n        }\n    }\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /*final*/ class SimpleToken extends Token {\n        constructor(previous, value, bitCount) {\n            super(previous);\n            this.value = value;\n            this.bitCount = bitCount;\n        }\n        /**\n         * @Override\n         */\n        appendTo(bitArray, text) {\n            bitArray.appendBits(this.value, this.bitCount);\n        }\n        add(value, bitCount) {\n            return new SimpleToken(this, value, bitCount);\n        }\n        addBinaryShift(start, byteCount) {\n            // no-op can't binary shift a simple token\n            console.warn('addBinaryShift on SimpleToken, this simply returns a copy of this token');\n            return new SimpleToken(this, start, byteCount);\n        }\n        /**\n         * @Override\n         */\n        toString() {\n            let value = this.value & ((1 << this.bitCount) - 1);\n            value |= 1 << this.bitCount;\n            return '<' + Integer.toBinaryString(value | (1 << this.bitCount)).substring(1) + '>';\n        }\n    }\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /*final*/ class BinaryShiftToken extends SimpleToken {\n        constructor(previous, binaryShiftStart, binaryShiftByteCount) {\n            super(previous, 0, 0);\n            this.binaryShiftStart = binaryShiftStart;\n            this.binaryShiftByteCount = binaryShiftByteCount;\n        }\n        /**\n         * @Override\n         */\n        appendTo(bitArray, text) {\n            for (let i = 0; i < this.binaryShiftByteCount; i++) {\n                if (i === 0 || (i === 31 && this.binaryShiftByteCount <= 62)) {\n                    // We need a header before the first character, and before\n                    // character 31 when the total byte code is <= 62\n                    bitArray.appendBits(31, 5); // BINARY_SHIFT\n                    if (this.binaryShiftByteCount > 62) {\n                        bitArray.appendBits(this.binaryShiftByteCount - 31, 16);\n                    }\n                    else if (i === 0) {\n                        // 1 <= binaryShiftByteCode <= 62\n                        bitArray.appendBits(Math.min(this.binaryShiftByteCount, 31), 5);\n                    }\n                    else {\n                        // 32 <= binaryShiftCount <= 62 and i == 31\n                        bitArray.appendBits(this.binaryShiftByteCount - 31, 5);\n                    }\n                }\n                bitArray.appendBits(text[this.binaryShiftStart + i], 8);\n            }\n        }\n        addBinaryShift(start, byteCount) {\n            // int bitCount = (byteCount * 8) + (byteCount <= 31 ? 10 : byteCount <= 62 ? 20 : 21);\n            return new BinaryShiftToken(this, start, byteCount);\n        }\n        /**\n         * @Override\n         */\n        toString() {\n            return '<' + this.binaryShiftStart + '::' + (this.binaryShiftStart + this.binaryShiftByteCount - 1) + '>';\n        }\n    }\n\n    function addBinaryShift(token, start, byteCount) {\n        // int bitCount = (byteCount * 8) + (byteCount <= 31 ? 10 : byteCount <= 62 ? 20 : 21);\n        return new BinaryShiftToken(token, start, byteCount);\n    }\n    function add(token, value, bitCount) {\n        return new SimpleToken(token, value, bitCount);\n    }\n\n    const /*final*/ MODE_NAMES = [\n        'UPPER',\n        'LOWER',\n        'DIGIT',\n        'MIXED',\n        'PUNCT'\n    ];\n    const /*final*/ MODE_UPPER = 0; // 5 bits\n    const /*final*/ MODE_LOWER = 1; // 5 bits\n    const /*final*/ MODE_DIGIT = 2; // 4 bits\n    const /*final*/ MODE_MIXED = 3; // 5 bits\n    const /*final*/ MODE_PUNCT = 4; // 5 bits\n    const EMPTY_TOKEN = new SimpleToken(null, 0, 0);\n\n    // The Latch Table shows, for each pair of Modes, the optimal method for\n    // getting from one mode to another.  In the worst possible case, this can\n    // be up to 14 bits.  In the best possible case, we are already there!\n    // The high half-word of each entry gives the number of bits.\n    // The low half-word of each entry are the actual bits necessary to change\n    const LATCH_TABLE = [\n        Int32Array.from([\n            0,\n            (5 << 16) + 28,\n            (5 << 16) + 30,\n            (5 << 16) + 29,\n            (10 << 16) + (29 << 5) + 30 // UPPER -> MIXED -> PUNCT\n        ]),\n        Int32Array.from([\n            (9 << 16) + (30 << 4) + 14,\n            0,\n            (5 << 16) + 30,\n            (5 << 16) + 29,\n            (10 << 16) + (29 << 5) + 30 // LOWER -> MIXED -> PUNCT\n        ]),\n        Int32Array.from([\n            (4 << 16) + 14,\n            (9 << 16) + (14 << 5) + 28,\n            0,\n            (9 << 16) + (14 << 5) + 29,\n            (14 << 16) + (14 << 10) + (29 << 5) + 30\n            // DIGIT -> UPPER -> MIXED -> PUNCT\n        ]),\n        Int32Array.from([\n            (5 << 16) + 29,\n            (5 << 16) + 28,\n            (10 << 16) + (29 << 5) + 30,\n            0,\n            (5 << 16) + 30 // MIXED -> PUNCT\n        ]),\n        Int32Array.from([\n            (5 << 16) + 31,\n            (10 << 16) + (31 << 5) + 28,\n            (10 << 16) + (31 << 5) + 30,\n            (10 << 16) + (31 << 5) + 29,\n            0\n        ])\n    ];\n\n    function static_SHIFT_TABLE(SHIFT_TABLE) {\n        for (let table /*Int32Array*/ of SHIFT_TABLE) {\n            Arrays.fill(table, -1);\n        }\n        SHIFT_TABLE[MODE_UPPER][MODE_PUNCT] = 0;\n        SHIFT_TABLE[MODE_LOWER][MODE_PUNCT] = 0;\n        SHIFT_TABLE[MODE_LOWER][MODE_UPPER] = 28;\n        SHIFT_TABLE[MODE_MIXED][MODE_PUNCT] = 0;\n        SHIFT_TABLE[MODE_DIGIT][MODE_PUNCT] = 0;\n        SHIFT_TABLE[MODE_DIGIT][MODE_UPPER] = 15;\n        return SHIFT_TABLE;\n    }\n    const /*final*/ SHIFT_TABLE = static_SHIFT_TABLE(Arrays.createInt32Array(6, 6)); // mode shift codes, per table\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * State represents all information about a sequence necessary to generate the current output.\n     * Note that a state is immutable.\n     */\n    /*final*/ class State {\n        constructor(token, mode, binaryBytes, bitCount) {\n            this.token = token;\n            this.mode = mode;\n            this.binaryShiftByteCount = binaryBytes;\n            this.bitCount = bitCount;\n            // Make sure we match the token\n            // int binaryShiftBitCount = (binaryShiftByteCount * 8) +\n            //    (binaryShiftByteCount === 0 ? 0 :\n            //     binaryShiftByteCount <= 31 ? 10 :\n            //     binaryShiftByteCount <= 62 ? 20 : 21);\n            // assert this.bitCount === token.getTotalBitCount() + binaryShiftBitCount;\n        }\n        getMode() {\n            return this.mode;\n        }\n        getToken() {\n            return this.token;\n        }\n        getBinaryShiftByteCount() {\n            return this.binaryShiftByteCount;\n        }\n        getBitCount() {\n            return this.bitCount;\n        }\n        // Create a new state representing this state with a latch to a (not\n        // necessary different) mode, and then a code.\n        latchAndAppend(mode, value) {\n            // assert binaryShiftByteCount === 0;\n            let bitCount = this.bitCount;\n            let token = this.token;\n            if (mode !== this.mode) {\n                let latch = LATCH_TABLE[this.mode][mode];\n                token = add(token, latch & 0xffff, latch >> 16);\n                bitCount += latch >> 16;\n            }\n            let latchModeBitCount = mode === MODE_DIGIT ? 4 : 5;\n            token = add(token, value, latchModeBitCount);\n            return new State(token, mode, 0, bitCount + latchModeBitCount);\n        }\n        // Create a new state representing this state, with a temporary shift\n        // to a different mode to output a single value.\n        shiftAndAppend(mode, value) {\n            // assert binaryShiftByteCount === 0 && this.mode !== mode;\n            let token = this.token;\n            let thisModeBitCount = this.mode === MODE_DIGIT ? 4 : 5;\n            // Shifts exist only to UPPER and PUNCT, both with tokens size 5.\n            token = add(token, SHIFT_TABLE[this.mode][mode], thisModeBitCount);\n            token = add(token, value, 5);\n            return new State(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);\n        }\n        // Create a new state representing this state, but an additional character\n        // output in Binary Shift mode.\n        addBinaryShiftChar(index) {\n            let token = this.token;\n            let mode = this.mode;\n            let bitCount = this.bitCount;\n            if (this.mode === MODE_PUNCT || this.mode === MODE_DIGIT) {\n                // assert binaryShiftByteCount === 0;\n                let latch = LATCH_TABLE[mode][MODE_UPPER];\n                token = add(token, latch & 0xffff, latch >> 16);\n                bitCount += latch >> 16;\n                mode = MODE_UPPER;\n            }\n            let deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31\n                ? 18\n                : this.binaryShiftByteCount === 62\n                    ? 9\n                    : 8;\n            let result = new State(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);\n            if (result.binaryShiftByteCount === 2047 + 31) {\n                // The string is as long as it's allowed to be.  We should end it.\n                result = result.endBinaryShift(index + 1);\n            }\n            return result;\n        }\n        // Create the state identical to this one, but we are no longer in\n        // Binary Shift mode.\n        endBinaryShift(index) {\n            if (this.binaryShiftByteCount === 0) {\n                return this;\n            }\n            let token = this.token;\n            token = addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount);\n            // assert token.getTotalBitCount() === this.bitCount;\n            return new State(token, this.mode, 0, this.bitCount);\n        }\n        // Returns true if \"this\" state is better (equal: or) to be in than \"that\"\n        // state under all possible circumstances.\n        isBetterThanOrEqualTo(other) {\n            let newModeBitCount = this.bitCount + (LATCH_TABLE[this.mode][other.mode] >> 16);\n            if (this.binaryShiftByteCount < other.binaryShiftByteCount) {\n                // add additional B/S encoding cost of other, if any\n                newModeBitCount +=\n                    State.calculateBinaryShiftCost(other) -\n                        State.calculateBinaryShiftCost(this);\n            }\n            else if (this.binaryShiftByteCount > other.binaryShiftByteCount &&\n                other.binaryShiftByteCount > 0) {\n                // maximum possible additional cost (it: h)\n                newModeBitCount += 10;\n            }\n            return newModeBitCount <= other.bitCount;\n        }\n        toBitArray(text) {\n            // Reverse the tokens, so that they are in the order that they should\n            // be output\n            let symbols = [];\n            for (let token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {\n                symbols.unshift(token);\n            }\n            let bitArray = new BitArray();\n            // Add each token to the result.\n            for (const symbol of symbols) {\n                symbol.appendTo(bitArray, text);\n            }\n            // assert bitArray.getSize() === this.bitCount;\n            return bitArray;\n        }\n        /**\n         * @Override\n         */\n        toString() {\n            return StringUtils.format('%s bits=%d bytes=%d', MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);\n        }\n        static calculateBinaryShiftCost(state) {\n            if (state.binaryShiftByteCount > 62) {\n                return 21; // B/S with extended length\n            }\n            if (state.binaryShiftByteCount > 31) {\n                return 20; // two B/S\n            }\n            if (state.binaryShiftByteCount > 0) {\n                return 10; // one B/S\n            }\n            return 0;\n        }\n    }\n    State.INITIAL_STATE = new State(EMPTY_TOKEN, MODE_UPPER, 0, 0);\n\n    function static_CHAR_MAP(CHAR_MAP) {\n        const spaceCharCode = StringUtils.getCharCode(' ');\n        const pointCharCode = StringUtils.getCharCode('.');\n        const commaCharCode = StringUtils.getCharCode(',');\n        CHAR_MAP[MODE_UPPER][spaceCharCode] = 1;\n        const zUpperCharCode = StringUtils.getCharCode('Z');\n        const aUpperCharCode = StringUtils.getCharCode('A');\n        for (let c = aUpperCharCode; c <= zUpperCharCode; c++) {\n            CHAR_MAP[MODE_UPPER][c] = c - aUpperCharCode + 2;\n        }\n        CHAR_MAP[MODE_LOWER][spaceCharCode] = 1;\n        const zLowerCharCode = StringUtils.getCharCode('z');\n        const aLowerCharCode = StringUtils.getCharCode('a');\n        for (let c = aLowerCharCode; c <= zLowerCharCode; c++) {\n            CHAR_MAP[MODE_LOWER][c] = c - aLowerCharCode + 2;\n        }\n        CHAR_MAP[MODE_DIGIT][spaceCharCode] = 1;\n        const nineCharCode = StringUtils.getCharCode('9');\n        const zeroCharCode = StringUtils.getCharCode('0');\n        for (let c = zeroCharCode; c <= nineCharCode; c++) {\n            CHAR_MAP[MODE_DIGIT][c] = c - zeroCharCode + 2;\n        }\n        CHAR_MAP[MODE_DIGIT][commaCharCode] = 12;\n        CHAR_MAP[MODE_DIGIT][pointCharCode] = 13;\n        const mixedTable = [\n            '\\x00',\n            ' ',\n            '\\x01',\n            '\\x02',\n            '\\x03',\n            '\\x04',\n            '\\x05',\n            '\\x06',\n            '\\x07',\n            '\\b',\n            '\\t',\n            '\\n',\n            '\\x0b',\n            '\\f',\n            '\\r',\n            '\\x1b',\n            '\\x1c',\n            '\\x1d',\n            '\\x1e',\n            '\\x1f',\n            '@',\n            '\\\\',\n            '^',\n            '_',\n            '`',\n            '|',\n            '~',\n            '\\x7f'\n        ];\n        for (let i = 0; i < mixedTable.length; i++) {\n            CHAR_MAP[MODE_MIXED][StringUtils.getCharCode(mixedTable[i])] = i;\n        }\n        const punctTable = [\n            '\\x00',\n            '\\r',\n            '\\x00',\n            '\\x00',\n            '\\x00',\n            '\\x00',\n            '!',\n            '\\'',\n            '#',\n            '$',\n            '%',\n            '&',\n            '\\'',\n            '(',\n            ')',\n            '*',\n            '+',\n            ',',\n            '-',\n            '.',\n            '/',\n            ':',\n            ';',\n            '<',\n            '=',\n            '>',\n            '?',\n            '[',\n            ']',\n            '{',\n            '}'\n        ];\n        for (let i = 0; i < punctTable.length; i++) {\n            if (StringUtils.getCharCode(punctTable[i]) > 0) {\n                CHAR_MAP[MODE_PUNCT][StringUtils.getCharCode(punctTable[i])] = i;\n            }\n        }\n        return CHAR_MAP;\n    }\n    const CHAR_MAP = static_CHAR_MAP(Arrays.createInt32Array(5, 256));\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * This produces nearly optimal encodings of text into the first-level of\n     * encoding used by Aztec code.\n     *\n     * It uses a dynamic algorithm.  For each prefix of the string, it determines\n     * a set of encodings that could lead to this prefix.  We repeatedly add a\n     * character and generate a new set of optimal encodings until we have read\n     * through the entire input.\n     *\n     * @author Frank Yellin\n     * @author Rustam Abdullaev\n     */\n    /*public final*/ class HighLevelEncoder {\n        constructor(text) {\n            this.text = text;\n        }\n        /**\n         * @return text represented by this encoder encoded as a {@link BitArray}\n         */\n        encode() {\n            const spaceCharCode = StringUtils.getCharCode(' ');\n            const lineBreakCharCode = StringUtils.getCharCode('\\n');\n            let states = Collections.singletonList(State.INITIAL_STATE);\n            for (let index = 0; index < this.text.length; index++) {\n                let pairCode;\n                let nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;\n                switch (this.text[index]) {\n                    case StringUtils.getCharCode('\\r'):\n                        pairCode = nextChar === lineBreakCharCode ? 2 : 0;\n                        break;\n                    case StringUtils.getCharCode('.'):\n                        pairCode = nextChar === spaceCharCode ? 3 : 0;\n                        break;\n                    case StringUtils.getCharCode(','):\n                        pairCode = nextChar === spaceCharCode ? 4 : 0;\n                        break;\n                    case StringUtils.getCharCode(':'):\n                        pairCode = nextChar === spaceCharCode ? 5 : 0;\n                        break;\n                    default:\n                        pairCode = 0;\n                }\n                if (pairCode > 0) {\n                    // We have one of the four special PUNCT pairs.  Treat them specially.\n                    // Get a new set of states for the two new characters.\n                    states = HighLevelEncoder.updateStateListForPair(states, index, pairCode);\n                    index++;\n                }\n                else {\n                    // Get a new set of states for the new character.\n                    states = this.updateStateListForChar(states, index);\n                }\n            }\n            // We are left with a set of states.  Find the shortest one.\n            const minState = Collections.min(states, (a, b) => {\n                return a.getBitCount() - b.getBitCount();\n            });\n            // Convert it to a bit array, and return.\n            return minState.toBitArray(this.text);\n        }\n        // We update a set of states for a new character by updating each state\n        // for the new character, merging the results, and then removing the\n        // non-optimal states.\n        updateStateListForChar(states, index) {\n            const result = [];\n            for (let state /*State*/ of states) {\n                this.updateStateForChar(state, index, result);\n            }\n            return HighLevelEncoder.simplifyStates(result);\n        }\n        // Return a set of states that represent the possible ways of updating this\n        // state for the next character.  The resulting set of states are added to\n        // the \"result\" list.\n        updateStateForChar(state, index, result) {\n            let ch = (this.text[index] & 0xff);\n            let charInCurrentTable = CHAR_MAP[state.getMode()][ch] > 0;\n            let stateNoBinary = null;\n            for (let mode /*int*/ = 0; mode <= MODE_PUNCT; mode++) {\n                let charInMode = CHAR_MAP[mode][ch];\n                if (charInMode > 0) {\n                    if (stateNoBinary == null) {\n                        // Only create stateNoBinary the first time it's required.\n                        stateNoBinary = state.endBinaryShift(index);\n                    }\n                    // Try generating the character by latching to its mode\n                    if (!charInCurrentTable ||\n                        mode === state.getMode() ||\n                        mode === MODE_DIGIT) {\n                        // If the character is in the current table, we don't want to latch to\n                        // any other mode except possibly digit (which uses only 4 bits).  Any\n                        // other latch would be equally successful *after* this character, and\n                        // so wouldn't save any bits.\n                        const latchState = stateNoBinary.latchAndAppend(mode, charInMode);\n                        result.push(latchState);\n                    }\n                    // Try generating the character by switching to its mode.\n                    if (!charInCurrentTable &&\n                        SHIFT_TABLE[state.getMode()][mode] >= 0) {\n                        // It never makes sense to temporarily shift to another mode if the\n                        // character exists in the current mode.  That can never save bits.\n                        const shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);\n                        result.push(shiftState);\n                    }\n                }\n            }\n            if (state.getBinaryShiftByteCount() > 0 ||\n                CHAR_MAP[state.getMode()][ch] === 0) {\n                // It's never worthwhile to go into binary shift mode if you're not already\n                // in binary shift mode, and the character exists in your current mode.\n                // That can never save bits over just outputting the char in the current mode.\n                let binaryState = state.addBinaryShiftChar(index);\n                result.push(binaryState);\n            }\n        }\n        static updateStateListForPair(states, index, pairCode) {\n            const result = [];\n            for (let state /*State*/ of states) {\n                this.updateStateForPair(state, index, pairCode, result);\n            }\n            return this.simplifyStates(result);\n        }\n        static updateStateForPair(state, index, pairCode, result) {\n            let stateNoBinary = state.endBinaryShift(index);\n            // Possibility 1.  Latch to C.MODE_PUNCT, and then append this code\n            result.push(stateNoBinary.latchAndAppend(MODE_PUNCT, pairCode));\n            if (state.getMode() !== MODE_PUNCT) {\n                // Possibility 2.  Shift to C.MODE_PUNCT, and then append this code.\n                // Every state except C.MODE_PUNCT (handled above) can shift\n                result.push(stateNoBinary.shiftAndAppend(MODE_PUNCT, pairCode));\n            }\n            if (pairCode === 3 || pairCode === 4) {\n                // both characters are in DIGITS.  Sometimes better to just add two digits\n                let digitState = stateNoBinary\n                    .latchAndAppend(MODE_DIGIT, 16 - pairCode) // period or comma in DIGIT\n                    .latchAndAppend(MODE_DIGIT, 1); // space in DIGIT\n                result.push(digitState);\n            }\n            if (state.getBinaryShiftByteCount() > 0) {\n                // It only makes sense to do the characters as binary if we're already\n                // in binary mode.\n                let binaryState = state\n                    .addBinaryShiftChar(index)\n                    .addBinaryShiftChar(index + 1);\n                result.push(binaryState);\n            }\n        }\n        static simplifyStates(states) {\n            let result = [];\n            for (const newState of states) {\n                let add = true;\n                for (const oldState of result) {\n                    if (oldState.isBetterThanOrEqualTo(newState)) {\n                        add = false;\n                        break;\n                    }\n                    if (newState.isBetterThanOrEqualTo(oldState)) {\n                        // iterator.remove();\n                        result = result.filter(x => x !== oldState); // remove old state\n                    }\n                }\n                if (add) {\n                    result.push(newState);\n                }\n            }\n            return result;\n        }\n    }\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // package com.google.zxing.aztec.encoder;\n    // import com.google.zxing.common.BitArray;\n    // import com.google.zxing.common.BitMatrix;\n    // import com.google.zxing.common.reedsolomon.GenericGF;\n    // import com.google.zxing.common.reedsolomon.ReedSolomonEncoder;\n    /**\n     * Generates Aztec 2D barcodes.\n     *\n     * @author Rustam Abdullaev\n     */\n    /*public final*/ class Encoder$1 {\n        constructor() {\n        }\n        /**\n         * Encodes the given binary content as an Aztec symbol\n         *\n         * @param data input data string\n         * @return Aztec symbol matrix with metadata\n         */\n        static encodeBytes(data) {\n            return Encoder$1.encode(data, Encoder$1.DEFAULT_EC_PERCENT, Encoder$1.DEFAULT_AZTEC_LAYERS);\n        }\n        /**\n         * Encodes the given binary content as an Aztec symbol\n         *\n         * @param data input data string\n         * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,\n         *                      a minimum of 23% + 3 words is recommended)\n         * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers\n         * @return Aztec symbol matrix with metadata\n         */\n        static encode(data, minECCPercent, userSpecifiedLayers) {\n            // High-level encode\n            let bits = new HighLevelEncoder(data).encode();\n            // stuff bits and choose symbol size\n            let eccBits = Integer.truncDivision((bits.getSize() * minECCPercent), 100) + 11;\n            let totalSizeBits = bits.getSize() + eccBits;\n            let compact;\n            let layers;\n            let totalBitsInLayer;\n            let wordSize;\n            let stuffedBits;\n            if (userSpecifiedLayers !== Encoder$1.DEFAULT_AZTEC_LAYERS) {\n                compact = userSpecifiedLayers < 0;\n                layers = Math.abs(userSpecifiedLayers);\n                if (layers > (compact ? Encoder$1.MAX_NB_BITS_COMPACT : Encoder$1.MAX_NB_BITS)) {\n                    throw new IllegalArgumentException(StringUtils.format('Illegal value %s for layers', userSpecifiedLayers));\n                }\n                totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);\n                wordSize = Encoder$1.WORD_SIZE[layers];\n                let usableBitsInLayers = totalBitsInLayer - (totalBitsInLayer % wordSize);\n                stuffedBits = Encoder$1.stuffBits(bits, wordSize);\n                if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {\n                    throw new IllegalArgumentException('Data to large for user specified layer');\n                }\n                if (compact && stuffedBits.getSize() > wordSize * 64) {\n                    // Compact format only allows 64 data words, though C4 can hold more words than that\n                    throw new IllegalArgumentException('Data to large for user specified layer');\n                }\n            }\n            else {\n                wordSize = 0;\n                stuffedBits = null;\n                // We look at the possible table sizes in the order Compact1, Compact2, Compact3,\n                // Compact4, Normal4,...  Normal(i) for i < 4 isn't typically used since Compact(i+1)\n                // is the same size, but has more data.\n                for (let i /*int*/ = 0;; i++) {\n                    if (i > Encoder$1.MAX_NB_BITS) {\n                        throw new IllegalArgumentException('Data too large for an Aztec code');\n                    }\n                    compact = i <= 3;\n                    layers = compact ? i + 1 : i;\n                    totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);\n                    if (totalSizeBits > totalBitsInLayer) {\n                        continue;\n                    }\n                    // [Re]stuff the bits if this is the first opportunity, or if the\n                    // wordSize has changed\n                    if (stuffedBits == null || wordSize !== Encoder$1.WORD_SIZE[layers]) {\n                        wordSize = Encoder$1.WORD_SIZE[layers];\n                        stuffedBits = Encoder$1.stuffBits(bits, wordSize);\n                    }\n                    let usableBitsInLayers = totalBitsInLayer - (totalBitsInLayer % wordSize);\n                    if (compact && stuffedBits.getSize() > wordSize * 64) {\n                        // Compact format only allows 64 data words, though C4 can hold more words than that\n                        continue;\n                    }\n                    if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {\n                        break;\n                    }\n                }\n            }\n            let messageBits = Encoder$1.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);\n            // generate mode message\n            let messageSizeInWords = stuffedBits.getSize() / wordSize;\n            let modeMessage = Encoder$1.generateModeMessage(compact, layers, messageSizeInWords);\n            // allocate symbol\n            let baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n            let alignmentMap = new Int32Array(baseMatrixSize);\n            let matrixSize;\n            if (compact) {\n                // no alignment marks in compact mode, alignmentMap is a no-op\n                matrixSize = baseMatrixSize;\n                for (let i /*int*/ = 0; i < alignmentMap.length; i++) {\n                    alignmentMap[i] = i;\n                }\n            }\n            else {\n                matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision((Integer.truncDivision(baseMatrixSize, 2) - 1), 15);\n                let origCenter = Integer.truncDivision(baseMatrixSize, 2);\n                let center = Integer.truncDivision(matrixSize, 2);\n                for (let i /*int*/ = 0; i < origCenter; i++) {\n                    let newOffset = i + Integer.truncDivision(i, 15);\n                    alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n                    alignmentMap[origCenter + i] = center + newOffset + 1;\n                }\n            }\n            let matrix = new BitMatrix(matrixSize);\n            // draw data bits\n            for (let i /*int*/ = 0, rowOffset = 0; i < layers; i++) {\n                let rowSize = (layers - i) * 4 + (compact ? 9 : 12);\n                for (let j /*int*/ = 0; j < rowSize; j++) {\n                    let columnOffset = j * 2;\n                    for (let k /*int*/ = 0; k < 2; k++) {\n                        if (messageBits.get(rowOffset + columnOffset + k)) {\n                            matrix.set(alignmentMap[i * 2 + k], alignmentMap[i * 2 + j]);\n                        }\n                        if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k)) {\n                            matrix.set(alignmentMap[i * 2 + j], alignmentMap[baseMatrixSize - 1 - i * 2 - k]);\n                        }\n                        if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k)) {\n                            matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - k], alignmentMap[baseMatrixSize - 1 - i * 2 - j]);\n                        }\n                        if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k)) {\n                            matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - j], alignmentMap[i * 2 + k]);\n                        }\n                    }\n                }\n                rowOffset += rowSize * 8;\n            }\n            // draw mode message\n            Encoder$1.drawModeMessage(matrix, compact, matrixSize, modeMessage);\n            // draw alignment marks\n            if (compact) {\n                Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 5);\n            }\n            else {\n                Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 7);\n                for (let i /*int*/ = 0, j = 0; i < Integer.truncDivision(baseMatrixSize, 2) - 1; i += 15, j += 16) {\n                    for (let k /*int*/ = Integer.truncDivision(matrixSize, 2) & 1; k < matrixSize; k += 2) {\n                        matrix.set(Integer.truncDivision(matrixSize, 2) - j, k);\n                        matrix.set(Integer.truncDivision(matrixSize, 2) + j, k);\n                        matrix.set(k, Integer.truncDivision(matrixSize, 2) - j);\n                        matrix.set(k, Integer.truncDivision(matrixSize, 2) + j);\n                    }\n                }\n            }\n            let aztec = new AztecCode();\n            aztec.setCompact(compact);\n            aztec.setSize(matrixSize);\n            aztec.setLayers(layers);\n            aztec.setCodeWords(messageSizeInWords);\n            aztec.setMatrix(matrix);\n            return aztec;\n        }\n        static drawBullsEye(matrix, center, size) {\n            for (let i /*int*/ = 0; i < size; i += 2) {\n                for (let j /*int*/ = center - i; j <= center + i; j++) {\n                    matrix.set(j, center - i);\n                    matrix.set(j, center + i);\n                    matrix.set(center - i, j);\n                    matrix.set(center + i, j);\n                }\n            }\n            matrix.set(center - size, center - size);\n            matrix.set(center - size + 1, center - size);\n            matrix.set(center - size, center - size + 1);\n            matrix.set(center + size, center - size);\n            matrix.set(center + size, center - size + 1);\n            matrix.set(center + size, center + size - 1);\n        }\n        static generateModeMessage(compact, layers, messageSizeInWords) {\n            let modeMessage = new BitArray();\n            if (compact) {\n                modeMessage.appendBits(layers - 1, 2);\n                modeMessage.appendBits(messageSizeInWords - 1, 6);\n                modeMessage = Encoder$1.generateCheckWords(modeMessage, 28, 4);\n            }\n            else {\n                modeMessage.appendBits(layers - 1, 5);\n                modeMessage.appendBits(messageSizeInWords - 1, 11);\n                modeMessage = Encoder$1.generateCheckWords(modeMessage, 40, 4);\n            }\n            return modeMessage;\n        }\n        static drawModeMessage(matrix, compact, matrixSize, modeMessage) {\n            let center = Integer.truncDivision(matrixSize, 2);\n            if (compact) {\n                for (let i /*int*/ = 0; i < 7; i++) {\n                    let offset = center - 3 + i;\n                    if (modeMessage.get(i)) {\n                        matrix.set(offset, center - 5);\n                    }\n                    if (modeMessage.get(i + 7)) {\n                        matrix.set(center + 5, offset);\n                    }\n                    if (modeMessage.get(20 - i)) {\n                        matrix.set(offset, center + 5);\n                    }\n                    if (modeMessage.get(27 - i)) {\n                        matrix.set(center - 5, offset);\n                    }\n                }\n            }\n            else {\n                for (let i /*int*/ = 0; i < 10; i++) {\n                    let offset = center - 5 + i + Integer.truncDivision(i, 5);\n                    if (modeMessage.get(i)) {\n                        matrix.set(offset, center - 7);\n                    }\n                    if (modeMessage.get(i + 10)) {\n                        matrix.set(center + 7, offset);\n                    }\n                    if (modeMessage.get(29 - i)) {\n                        matrix.set(offset, center + 7);\n                    }\n                    if (modeMessage.get(39 - i)) {\n                        matrix.set(center - 7, offset);\n                    }\n                }\n            }\n        }\n        static generateCheckWords(bitArray, totalBits, wordSize) {\n            // bitArray is guaranteed to be a multiple of the wordSize, so no padding needed\n            let messageSizeInWords = bitArray.getSize() / wordSize;\n            let rs = new ReedSolomonEncoder(Encoder$1.getGF(wordSize));\n            let totalWords = Integer.truncDivision(totalBits, wordSize);\n            let messageWords = Encoder$1.bitsToWords(bitArray, wordSize, totalWords);\n            rs.encode(messageWords, totalWords - messageSizeInWords);\n            let startPad = totalBits % wordSize;\n            let messageBits = new BitArray();\n            messageBits.appendBits(0, startPad);\n            for (const messageWord /*: int*/ of Array.from(messageWords)) {\n                messageBits.appendBits(messageWord, wordSize);\n            }\n            return messageBits;\n        }\n        static bitsToWords(stuffedBits, wordSize, totalWords) {\n            let message = new Int32Array(totalWords);\n            let i;\n            let n;\n            for (i = 0, n = stuffedBits.getSize() / wordSize; i < n; i++) {\n                let value = 0;\n                for (let j /*int*/ = 0; j < wordSize; j++) {\n                    value |= stuffedBits.get(i * wordSize + j) ? (1 << wordSize - j - 1) : 0;\n                }\n                message[i] = value;\n            }\n            return message;\n        }\n        static getGF(wordSize) {\n            switch (wordSize) {\n                case 4:\n                    return GenericGF.AZTEC_PARAM;\n                case 6:\n                    return GenericGF.AZTEC_DATA_6;\n                case 8:\n                    return GenericGF.AZTEC_DATA_8;\n                case 10:\n                    return GenericGF.AZTEC_DATA_10;\n                case 12:\n                    return GenericGF.AZTEC_DATA_12;\n                default:\n                    throw new IllegalArgumentException('Unsupported word size ' + wordSize);\n            }\n        }\n        static stuffBits(bits, wordSize) {\n            let out = new BitArray();\n            let n = bits.getSize();\n            let mask = (1 << wordSize) - 2;\n            for (let i /*int*/ = 0; i < n; i += wordSize) {\n                let word = 0;\n                for (let j /*int*/ = 0; j < wordSize; j++) {\n                    if (i + j >= n || bits.get(i + j)) {\n                        word |= 1 << (wordSize - 1 - j);\n                    }\n                }\n                if ((word & mask) === mask) {\n                    out.appendBits(word & mask, wordSize);\n                    i--;\n                }\n                else if ((word & mask) === 0) {\n                    out.appendBits(word | 1, wordSize);\n                    i--;\n                }\n                else {\n                    out.appendBits(word, wordSize);\n                }\n            }\n            return out;\n        }\n        static totalBitsInLayer(layers, compact) {\n            return ((compact ? 88 : 112) + 16 * layers) * layers;\n        }\n    }\n    Encoder$1.DEFAULT_EC_PERCENT = 33; // default minimal percentage of error check words\n    Encoder$1.DEFAULT_AZTEC_LAYERS = 0;\n    Encoder$1.MAX_NB_BITS = 32;\n    Encoder$1.MAX_NB_BITS_COMPACT = 4;\n    Encoder$1.WORD_SIZE = Int32Array.from([\n        4, 6, 6, 8, 8, 8, 8, 8, 8, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n        12, 12, 12, 12, 12, 12, 12, 12, 12, 12\n    ]);\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /**\n     * Renders an Aztec code as a {@link BitMatrix}.\n     */\n    /*public final*/ class AztecWriter {\n        // @Override\n        encode(contents, format, width, height) {\n            return this.encodeWithHints(contents, format, width, height, null);\n        }\n        // @Override\n        encodeWithHints(contents, format, width, height, hints) {\n            let charset = StandardCharsets.ISO_8859_1;\n            let eccPercent = Encoder$1.DEFAULT_EC_PERCENT;\n            let layers = Encoder$1.DEFAULT_AZTEC_LAYERS;\n            if (hints != null) {\n                if (hints.has(EncodeHintType$1.CHARACTER_SET)) {\n                    charset = Charset.forName(hints.get(EncodeHintType$1.CHARACTER_SET).toString());\n                }\n                if (hints.has(EncodeHintType$1.ERROR_CORRECTION)) {\n                    eccPercent = Integer.parseInt(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());\n                }\n                if (hints.has(EncodeHintType$1.AZTEC_LAYERS)) {\n                    layers = Integer.parseInt(hints.get(EncodeHintType$1.AZTEC_LAYERS).toString());\n                }\n            }\n            return AztecWriter.encodeLayers(contents, format, width, height, charset, eccPercent, layers);\n        }\n        static encodeLayers(contents, format, width, height, charset, eccPercent, layers) {\n            if (format !== BarcodeFormat$1.AZTEC) {\n                throw new IllegalArgumentException('Can only encode AZTEC, but got ' + format);\n            }\n            let aztec = Encoder$1.encode(StringUtils.getBytes(contents, charset), eccPercent, layers);\n            return AztecWriter.renderResult(aztec, width, height);\n        }\n        static renderResult(code, width, height) {\n            let input = code.getMatrix();\n            if (input == null) {\n                throw new IllegalStateException();\n            }\n            let inputWidth = input.getWidth();\n            let inputHeight = input.getHeight();\n            let outputWidth = Math.max(width, inputWidth);\n            let outputHeight = Math.max(height, inputHeight);\n            let multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);\n            let leftPadding = (outputWidth - (inputWidth * multiple)) / 2;\n            let topPadding = (outputHeight - (inputHeight * multiple)) / 2;\n            let output = new BitMatrix(outputWidth, outputHeight);\n            for (let inputY /*int*/ = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {\n                // Write the contents of this row of the barcode\n                for (let inputX /*int*/ = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {\n                    if (input.get(inputX, inputY)) {\n                        output.setRegion(outputX, outputY, multiple, multiple);\n                    }\n                }\n            }\n            return output;\n        }\n    }\n\n    exports.AbstractExpandedDecoder = AbstractExpandedDecoder;\n    exports.ArgumentException = ArgumentException;\n    exports.ArithmeticException = ArithmeticException;\n    exports.AztecCode = AztecCode;\n    exports.AztecCodeReader = AztecReader;\n    exports.AztecCodeWriter = AztecWriter;\n    exports.AztecDecoder = Decoder;\n    exports.AztecDetector = Detector;\n    exports.AztecDetectorResult = AztecDetectorResult;\n    exports.AztecEncoder = Encoder$1;\n    exports.AztecHighLevelEncoder = HighLevelEncoder;\n    exports.AztecPoint = Point;\n    exports.BarcodeFormat = BarcodeFormat$1;\n    exports.Binarizer = Binarizer;\n    exports.BinaryBitmap = BinaryBitmap;\n    exports.BitArray = BitArray;\n    exports.BitMatrix = BitMatrix;\n    exports.BitSource = BitSource;\n    exports.BrowserAztecCodeReader = BrowserAztecCodeReader;\n    exports.BrowserBarcodeReader = BrowserBarcodeReader;\n    exports.BrowserCodeReader = BrowserCodeReader;\n    exports.BrowserDatamatrixCodeReader = BrowserDatamatrixCodeReader;\n    exports.BrowserMultiFormatReader = BrowserMultiFormatReader;\n    exports.BrowserPDF417Reader = BrowserPDF417Reader;\n    exports.BrowserQRCodeReader = BrowserQRCodeReader;\n    exports.BrowserQRCodeSvgWriter = BrowserQRCodeSvgWriter;\n    exports.CharacterSetECI = CharacterSetECI;\n    exports.ChecksumException = ChecksumException;\n    exports.Code128Reader = Code128Reader;\n    exports.Code39Reader = Code39Reader;\n    exports.DataMatrixDecodedBitStreamParser = DecodedBitStreamParser;\n    exports.DataMatrixReader = DataMatrixReader;\n    exports.DecodeHintType = DecodeHintType$1;\n    exports.DecoderResult = DecoderResult;\n    exports.DefaultGridSampler = DefaultGridSampler;\n    exports.DetectorResult = DetectorResult;\n    exports.EAN13Reader = EAN13Reader;\n    exports.EncodeHintType = EncodeHintType$1;\n    exports.Exception = Exception;\n    exports.FormatException = FormatException;\n    exports.GenericGF = GenericGF;\n    exports.GenericGFPoly = GenericGFPoly;\n    exports.GlobalHistogramBinarizer = GlobalHistogramBinarizer;\n    exports.GridSampler = GridSampler;\n    exports.GridSamplerInstance = GridSamplerInstance;\n    exports.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource;\n    exports.HybridBinarizer = HybridBinarizer;\n    exports.ITFReader = ITFReader;\n    exports.IllegalArgumentException = IllegalArgumentException;\n    exports.IllegalStateException = IllegalStateException;\n    exports.InvertedLuminanceSource = InvertedLuminanceSource;\n    exports.LuminanceSource = LuminanceSource;\n    exports.MathUtils = MathUtils;\n    exports.MultiFormatOneDReader = MultiFormatOneDReader;\n    exports.MultiFormatReader = MultiFormatReader;\n    exports.MultiFormatWriter = MultiFormatWriter;\n    exports.NotFoundException = NotFoundException;\n    exports.OneDReader = OneDReader;\n    exports.PDF417DecodedBitStreamParser = DecodedBitStreamParser$2;\n    exports.PDF417DecoderErrorCorrection = ErrorCorrection;\n    exports.PDF417Reader = PDF417Reader;\n    exports.PDF417ResultMetadata = PDF417ResultMetadata;\n    exports.PerspectiveTransform = PerspectiveTransform;\n    exports.PlanarYUVLuminanceSource = PlanarYUVLuminanceSource;\n    exports.QRCodeByteMatrix = ByteMatrix;\n    exports.QRCodeDataMask = DataMask;\n    exports.QRCodeDecodedBitStreamParser = DecodedBitStreamParser$1;\n    exports.QRCodeDecoderErrorCorrectionLevel = ErrorCorrectionLevel;\n    exports.QRCodeDecoderFormatInformation = FormatInformation;\n    exports.QRCodeEncoder = Encoder;\n    exports.QRCodeEncoderQRCode = QRCode;\n    exports.QRCodeMaskUtil = MaskUtil;\n    exports.QRCodeMatrixUtil = MatrixUtil;\n    exports.QRCodeMode = Mode$1;\n    exports.QRCodeReader = QRCodeReader;\n    exports.QRCodeVersion = Version$1;\n    exports.QRCodeWriter = QRCodeWriter;\n    exports.RGBLuminanceSource = RGBLuminanceSource;\n    exports.RSS14Reader = RSS14Reader;\n    exports.RSSExpandedReader = RSSExpandedReader;\n    exports.ReaderException = ReaderException;\n    exports.ReedSolomonDecoder = ReedSolomonDecoder;\n    exports.ReedSolomonEncoder = ReedSolomonEncoder;\n    exports.ReedSolomonException = ReedSolomonException;\n    exports.Result = Result;\n    exports.ResultMetadataType = ResultMetadataType$1;\n    exports.ResultPoint = ResultPoint;\n    exports.StringUtils = StringUtils;\n    exports.UnsupportedOperationException = UnsupportedOperationException;\n    exports.VideoInputDevice = VideoInputDevice;\n    exports.WhiteRectangleDetector = WhiteRectangleDetector;\n    exports.WriterException = WriterException;\n    exports.ZXingArrays = Arrays;\n    exports.ZXingCharset = Charset;\n    exports.ZXingInteger = Integer;\n    exports.ZXingStandardCharsets = StandardCharsets;\n    exports.ZXingStringBuilder = StringBuilder;\n    exports.ZXingStringEncoding = StringEncoding;\n    exports.ZXingSystem = System;\n    exports.createAbstractExpandedDecoder = createDecoder;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL3RoaXJkX3BhcnR5L3p4aW5nLWpzLnVtZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksS0FBNEQ7QUFDaEUsSUFBSSxDQUNzRztBQUMxRyxDQUFDLDZCQUE2Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRCQUE0QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEJBQTRCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQyxZQUFZLGNBQWMsbUJBQW1CLHlCQUF5QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELHNEQUFzRCxxQkFBcUI7QUFDM0Usb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUIsS0FBSyxlQUFlO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRCw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQsa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpQkFBaUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVksSUFBSSxvQkFBb0I7QUFDMUQ7QUFDQSxxRkFBcUY7QUFDckY7QUFDQSxxREFBcUQ7QUFDckQsMkNBQTJDLEtBQUssbUJBQW1CO0FBQ25FO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQSx5R0FBeUc7QUFDekc7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSyxtQkFBbUI7QUFDOUU7QUFDQSxxR0FBcUc7QUFDckc7QUFDQSx5RUFBeUU7QUFDekUsZ0NBQWdDLDBCQUEwQjtBQUMxRDtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0IsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssd0NBQXdDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9FQUFvRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFlBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSw2QkFBNkI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLGFBQWEsaUJBQWlCLEdBQUcsWUFBWSxHQUFHLGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZEQUE2RDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxpRUFBaUU7QUFDakU7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsdURBQXVEO0FBQ3ZELDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0JBQWdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxpQkFBaUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQztBQUNBLG1DQUFtQyxXQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsWUFBWTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RCxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQWdEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGdDQUFnQztBQUNqRyxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxpQ0FBaUM7QUFDMUcseUNBQXlDLGlDQUFpQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxpQ0FBaUM7QUFDekYsaURBQWlELGlDQUFpQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSxzRUFBc0U7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRCQUE0QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRCQUE0QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxvQ0FBb0MsdUJBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1QkFBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxZQUFZO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxxQkFBTSxtREFBbUQscUJBQU07QUFDbkcsZ0NBQWdDLCtEQUErRCxpQkFBaUI7QUFDaEg7QUFDQSx3Q0FBd0MsTUFBTSwrQkFBK0IsWUFBWTtBQUN6Rix1Q0FBdUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUM1RixvQ0FBb0M7QUFDcEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSx3QkFBd0I7QUFDMUY7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZCQUE2QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBLHNDQUFzQztBQUN0QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEMsbUJBQW1CLHlCQUF5QjtBQUM1QyxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDLG1CQUFtQiw4QkFBOEI7QUFDakQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQyxtQkFBbUIsOEJBQThCO0FBQ2pELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQyxtQkFBbUIseUJBQXlCO0FBQzVDLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQyxtQkFBbUIseUJBQXlCO0FBQzVDLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGVBQWU7QUFDL0U7QUFDQTtBQUNBLGdFQUFnRSxlQUFlLGVBQWUsTUFBTTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDLG1CQUFtQixRQUFRO0FBQzNCLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QyxtQkFBbUIsUUFBUTtBQUMzQixxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUMsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx1QkFBdUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNCQUFzQixXQUFXO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVyxTQUFTLDBCQUEwQjtBQUNsRSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0NBQXNDO0FBQzNDOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsYUFBYTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsZUFBZTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGNBQWM7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsY0FBYztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxjQUFjO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0RBQWdEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQkFBc0IsV0FBVztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsWUFBWTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGNBQWM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLCtCQUErQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCw2REFBNkQ7QUFDN0QseURBQXlEO0FBQ3pELHdEQUF3RDtBQUN4RCxpRUFBaUU7QUFDakUscUVBQXFFO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsS0FBSztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNDQUFzQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9CQUFvQjtBQUNoRTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxVQUFVO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx5QkFBeUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1DQUFtQyxLQUFLO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0JBQXdCO0FBQ3BFO0FBQ0EsaUNBQWlDLHlCQUF5QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxtQkFBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkJBQTJCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0NBQWtDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVCQUF1QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx5QkFBeUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQseUNBQXlDO0FBQ3pDLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUseUNBQXlDO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0EsNEJBQTRCLHdDQUF3QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHVHQUF1RztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQ0FBcUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkNBQTZDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSwyQ0FBMkMsMEJBQTBCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtCQUErQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQSwyREFBMkQsd0JBQXdCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRix1QkFBdUI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtDQUErQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQ0FBK0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQkFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxtQkFBbUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsWUFBWSx3QkFBd0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RCxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaUJBQWlCO0FBQ2hFO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQ0FBbUM7QUFDM0U7QUFDQSwrQ0FBK0MseUNBQXlDO0FBQ3hGO0FBQ0Esb0NBQW9DLHdCQUF3QjtBQUM1RDtBQUNBO0FBQ0Esd0NBQXdDLDJCQUEyQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3QkFBd0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1DQUFtQztBQUMvRCxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsU0FBUztBQUNoRSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixxQkFBcUI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxxQkFBcUI7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsVUFBVTtBQUNoRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0VBQWdFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMENBQTBDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx3Q0FBd0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEcsZ0NBQWdDO0FBQzlJO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RywwQkFBMEI7QUFDeEk7QUFDQTtBQUNBO0FBQ0EsOEdBQThHLHFCQUFxQjtBQUNuSTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEcsMkJBQTJCO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RyxnRUFBZ0U7QUFDOUs7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEcsMkJBQTJCO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHLDJCQUEyQjtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RyxnREFBZ0Q7QUFDOUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEMsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQyw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQiwyQkFBMkI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQ0FBZ0M7QUFDN0UsWUFBWSxxQkFBcUIsMEJBQTBCLHdCQUF3QjtBQUNuRixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVc7QUFDckUsb0VBQW9FLFlBQVk7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3QkFBd0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUNBQW1DO0FBQy9ELGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMscUJBQXFCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFNBQVM7QUFDakUsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSyxnQ0FBZ0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxjQUFjO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBLGdJQUFnSTtBQUNoSTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxQkFBcUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywwQkFBMEI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHNEQUFzRDtBQUN0RCwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGlCQUFpQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxpQ0FBaUM7QUFDakMsbUNBQW1DO0FBQ25DLGtDQUFrQztBQUNsQyw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0Isd0RBQXdEO0FBQ3hELHNEQUFzRDtBQUN0RCx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUJBQWlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQThDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGdCQUFnQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25ELDJEQUEyRCxzQkFBc0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdDQUFnQywwREFBMEQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0JBQStCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QywwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2REFBNkQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQXNEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsdUJBQXVCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsK0JBQStCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUsd0RBQXdELGFBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJDQUEyQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsaUVBQWlFO0FBQ2pFO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQ0FBK0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsd0JBQXdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaURBQWlEO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsd0JBQXdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQ0FBZ0M7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsNkNBQTZDO0FBQzdGO0FBQ0EsbURBQW1ELGlDQUFpQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQ0FBb0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDBDQUEwQztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaUNBQWlDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUscUVBQXFFO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaUNBQWlDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsK0ZBQStGO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHlEQUF5RDtBQUN4RztBQUNBLG9EQUFvRCw2Q0FBNkM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNDQUFzQztBQUMxRTtBQUNBO0FBQ0Esd0NBQXdDLGlDQUFpQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNDQUFzQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyQkFBMkI7QUFDL0QsMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyQkFBMkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrQ0FBK0M7QUFDbkY7QUFDQTtBQUNBLHdDQUF3QyxpQ0FBaUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQSxZQUFZLG1FQUFtRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJDQUEyQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVLEtBQUssY0FBYztBQUN2RTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssd0JBQXdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFNO0FBQ3pCLG1CQUFtQixxQkFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyREFBMkQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxPQUFPO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFdBQVc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywrQkFBK0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHdDQUF3QztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxtQ0FBbUM7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnREFBZ0Q7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFVBQVU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw4Q0FBOEM7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDRDQUE0QztBQUNsRiw2Q0FBNkMsa0RBQWtEO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQ0FBaUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdDQUFnQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdDQUFnQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDhDQUE4QztBQUMzRixzQ0FBc0MsNEJBQTRCO0FBQ2xFLDZDQUE2QyxvQ0FBb0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0JBQStCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMkJBQTJCO0FBQ3JFO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDRCQUE0QjtBQUNsRTtBQUNBLDZDQUE2QyxvQ0FBb0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQWdGO0FBQzVGLG9DQUFvQyxjQUFjO0FBQ2xELHFDQUFxQyxjQUFjO0FBQ25ELDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGFBQWE7QUFDekY7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDBEQUEwRDtBQUN2SDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLG1DQUFtQyxjQUFjLE1BQU0sY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsY0FBYztBQUNqRixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZEQUE2RCxJQUFJLGNBQWM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNERBQTREO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWMsTUFBTSxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWMsTUFBTSxjQUFjO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLLHdDQUF3QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDLGdDQUFnQyxXQUFXO0FBQzNDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxrREFBa0QsWUFBWTtBQUM5RDtBQUNBLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxVQUFVO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsNEJBQTRCLE9BQU87QUFDbkMsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUEsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixpQkFBaUI7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSxzQ0FBc0Msd0NBQXdDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9DQUFvQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxzQkFBc0I7QUFDN0U7QUFDQSw0REFBNEQscUJBQXFCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLE1BQU0sR0FBRyxPQUFPO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsc0JBQXNCO0FBQzdFO0FBQ0EsNERBQTRELHFCQUFxQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxZQUFZO0FBQzFGO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSxxQ0FBcUMsZUFBZTtBQUNwRDtBQUNBLG9EQUFvRDtBQUNwRCxxREFBcUQ7QUFDckQsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZ0JBQWdCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2Q7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQkFBMEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MseUJBQXlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxZQUFZO0FBQy9EO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msa0RBQWtEO0FBQ2pHLG1GQUFtRixnQkFBZ0I7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QyxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxPQUFPO0FBQ3JFO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsc0JBQXNCO0FBQ3JGO0FBQ0Esb0VBQW9FLHFCQUFxQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxhQUFhOztBQUVoRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvdGhpcmRfcGFydHkvenhpbmctanMudW1kLmpzPzMzYTAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5aWGluZyA9IHt9KSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgICBmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG5cbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXG4gICAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXhQcm90byh0YXJnZXQsIHByb3RvdHlwZSkge1xuICAgICAgICB2YXIgc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2Y7XG4gICAgICAgIHNldFByb3RvdHlwZU9mID8gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90b3R5cGUpIDogKHRhcmdldC5fX3Byb3RvX18gPSBwcm90b3R5cGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeFN0YWNrKHRhcmdldCwgZm4pIHtcbiAgICAgICAgaWYgKGZuID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGZuID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlO1xuICAgICAgICBjYXB0dXJlU3RhY2tUcmFjZSAmJiBjYXB0dXJlU3RhY2tUcmFjZSh0YXJnZXQsIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgQ3VzdG9tRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQ3VzdG9tRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsICduYW1lJywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBfbmV3VGFyZ2V0Lm5hbWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZml4UHJvdG8oX3RoaXMsIF9uZXdUYXJnZXQucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGZpeFN0YWNrKF90aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIEN1c3RvbUVycm9yO1xuICAgIH0pKEVycm9yKTtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBFeGNlcHRpb24gZXh0ZW5kcyBDdXN0b21FcnJvciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgRXhjZXB0aW9uIHRvIGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5XG4gICAgICAgICAqIHdpdGggc29tZSBtZXNzYWdlIGFuZCBwcm90b3R5cGUgZGVmaW5pdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRLaW5kKCkge1xuICAgICAgICAgICAgY29uc3QgZXggPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIGV4LmtpbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSXQncyB0eXBlZCBhcyBzdHJpbmcgc28gaXQgY2FuIGJlIGV4dGVuZGVkIGFuZCBvdmVycmlkZW4uXG4gICAgICovXG4gICAgRXhjZXB0aW9uLmtpbmQgPSAnRXhjZXB0aW9uJztcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBBcmd1bWVudEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIEFyZ3VtZW50RXhjZXB0aW9uLmtpbmQgPSAnQXJndW1lbnRFeGNlcHRpb24nO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbi5raW5kID0gJ0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbic7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIGNsYXNzIEJpbmFyeUJpdG1hcCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGJpbmFyaXplcikge1xuICAgICAgICAgICAgdGhpcy5iaW5hcml6ZXIgPSBiaW5hcml6ZXI7XG4gICAgICAgICAgICBpZiAoYmluYXJpemVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQmluYXJpemVyIG11c3QgYmUgbm9uLW51bGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHdpZHRoIG9mIHRoZSBiaXRtYXAuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyaXplci5nZXRXaWR0aCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBoZWlnaHQgb2YgdGhlIGJpdG1hcC5cbiAgICAgICAgICovXG4gICAgICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyaXplci5nZXRIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgb25lIHJvdyBvZiBsdW1pbmFuY2UgZGF0YSB0byAxIGJpdCBkYXRhLiBNYXkgYWN0dWFsbHkgZG8gdGhlIGNvbnZlcnNpb24sIG9yIHJldHVyblxuICAgICAgICAgKiBjYWNoZWQgZGF0YS4gQ2FsbGVycyBzaG91bGQgYXNzdW1lIHRoaXMgbWV0aG9kIGlzIGV4cGVuc2l2ZSBhbmQgY2FsbCBpdCBhcyBzZWxkb20gYXMgcG9zc2libGUuXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIGZvciBkZWNvZGluZyAxRCBiYXJjb2RlcyBhbmQgbWF5IGNob29zZSB0byBhcHBseSBzaGFycGVuaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geSBUaGUgcm93IHRvIGZldGNoLCB3aGljaCBtdXN0IGJlIGluIFswLCBiaXRtYXAgaGVpZ2h0KVxuICAgICAgICAgKiBAcGFyYW0gcm93IEFuIG9wdGlvbmFsIHByZWFsbG9jYXRlZCBhcnJheS4gSWYgbnVsbCBvciB0b28gc21hbGwsIGl0IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgICAgICogICAgICAgICAgICBJZiB1c2VkLCB0aGUgQmluYXJpemVyIHdpbGwgY2FsbCBCaXRBcnJheS5jbGVhcigpLiBBbHdheXMgdXNlIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGFycmF5IG9mIGJpdHMgZm9yIHRoaXMgcm93ICh0cnVlIG1lYW5zIGJsYWNrKS5cbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiByb3cgY2FuJ3QgYmUgYmluYXJpemVkXG4gICAgICAgICAqL1xuICAgICAgICBnZXRCbGFja1Jvdyh5IC8qaW50Ki8sIHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJpemVyLmdldEJsYWNrUm93KHksIHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGEgMkQgYXJyYXkgb2YgbHVtaW5hbmNlIGRhdGEgdG8gMSBiaXQuIEFzIGFib3ZlLCBhc3N1bWUgdGhpcyBtZXRob2QgaXMgZXhwZW5zaXZlXG4gICAgICAgICAqIGFuZCBkbyBub3QgY2FsbCBpdCByZXBlYXRlZGx5LiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZGVjb2RpbmcgMkQgYmFyY29kZXMgYW5kIG1heSBvclxuICAgICAgICAgKiBtYXkgbm90IGFwcGx5IHNoYXJwZW5pbmcuIFRoZXJlZm9yZSwgYSByb3cgZnJvbSB0aGlzIG1hdHJpeCBtYXkgbm90IGJlIGlkZW50aWNhbCB0byBvbmVcbiAgICAgICAgICogZmV0Y2hlZCB1c2luZyBnZXRCbGFja1JvdygpLCBzbyBkb24ndCBtaXggYW5kIG1hdGNoIGJldHdlZW4gdGhlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBUaGUgMkQgYXJyYXkgb2YgYml0cyBmb3IgdGhlIGltYWdlICh0cnVlIG1lYW5zIGJsYWNrKS5cbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBpbWFnZSBjYW4ndCBiZSBiaW5hcml6ZWQgdG8gbWFrZSBhIG1hdHJpeFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QmxhY2tNYXRyaXgoKSB7XG4gICAgICAgICAgICAvLyBUaGUgbWF0cml4IGlzIGNyZWF0ZWQgb24gZGVtYW5kIHRoZSBmaXJzdCB0aW1lIGl0IGlzIHJlcXVlc3RlZCwgdGhlbiBjYWNoZWQuIFRoZXJlIGFyZSB0d29cbiAgICAgICAgICAgIC8vIHJlYXNvbnMgZm9yIHRoaXM6XG4gICAgICAgICAgICAvLyAxLiBUaGlzIHdvcmsgd2lsbCBuZXZlciBiZSBkb25lIGlmIHRoZSBjYWxsZXIgb25seSBpbnN0YWxscyAxRCBSZWFkZXIgb2JqZWN0cywgb3IgaWYgYVxuICAgICAgICAgICAgLy8gICAgMUQgUmVhZGVyIGZpbmRzIGEgYmFyY29kZSBiZWZvcmUgdGhlIDJEIFJlYWRlcnMgcnVuLlxuICAgICAgICAgICAgLy8gMi4gVGhpcyB3b3JrIHdpbGwgb25seSBiZSBkb25lIG9uY2UgZXZlbiBpZiB0aGUgY2FsbGVyIGluc3RhbGxzIG11bHRpcGxlIDJEIFJlYWRlcnMuXG4gICAgICAgICAgICBpZiAodGhpcy5tYXRyaXggPT09IG51bGwgfHwgdGhpcy5tYXRyaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0cml4ID0gdGhpcy5iaW5hcml6ZXIuZ2V0QmxhY2tNYXRyaXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBXaGV0aGVyIHRoaXMgYml0bWFwIGNhbiBiZSBjcm9wcGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNDcm9wU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJpemVyLmdldEx1bWluYW5jZVNvdXJjZSgpLmlzQ3JvcFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIGNyb3BwZWQgaW1hZ2UgZGF0YS4gSW1wbGVtZW50YXRpb25zIG1heSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZVxuICAgICAgICAgKiBvcmlnaW5hbCBkYXRhIHJhdGhlciB0aGFuIGEgY29weS4gT25seSBjYWxsYWJsZSBpZiBpc0Nyb3BTdXBwb3J0ZWQoKSBpcyB0cnVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbGVmdCBjb29yZGluYXRlLCB3aGljaCBtdXN0IGJlIGluIFswLGdldFdpZHRoKCkpXG4gICAgICAgICAqIEBwYXJhbSB0b3AgVGhlIHRvcCBjb29yZGluYXRlLCB3aGljaCBtdXN0IGJlIGluIFswLGdldEhlaWdodCgpKVxuICAgICAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgdG8gY3JvcC5cbiAgICAgICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUgdG8gY3JvcC5cbiAgICAgICAgICogQHJldHVybiBBIGNyb3BwZWQgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGNyb3AobGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NvdXJjZSA9IHRoaXMuYmluYXJpemVyLmdldEx1bWluYW5jZVNvdXJjZSgpLmNyb3AobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5Qml0bWFwKHRoaXMuYmluYXJpemVyLmNyZWF0ZUJpbmFyaXplcihuZXdTb3VyY2UpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBXaGV0aGVyIHRoaXMgYml0bWFwIHN1cHBvcnRzIGNvdW50ZXItY2xvY2t3aXNlIHJvdGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNSb3RhdGVTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcml6ZXIuZ2V0THVtaW5hbmNlU291cmNlKCkuaXNSb3RhdGVTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCByb3RhdGVkIGltYWdlIGRhdGEgYnkgOTAgZGVncmVlcyBjb3VudGVyY2xvY2t3aXNlLlxuICAgICAgICAgKiBPbmx5IGNhbGxhYmxlIGlmIHtAbGluayAjaXNSb3RhdGVTdXBwb3J0ZWQoKX0gaXMgdHJ1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBBIHJvdGF0ZWQgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTb3VyY2UgPSB0aGlzLmJpbmFyaXplci5nZXRMdW1pbmFuY2VTb3VyY2UoKS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUJpdG1hcCh0aGlzLmJpbmFyaXplci5jcmVhdGVCaW5hcml6ZXIobmV3U291cmNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggcm90YXRlZCBpbWFnZSBkYXRhIGJ5IDQ1IGRlZ3JlZXMgY291bnRlcmNsb2Nrd2lzZS5cbiAgICAgICAgICogT25seSBjYWxsYWJsZSBpZiB7QGxpbmsgI2lzUm90YXRlU3VwcG9ydGVkKCl9IGlzIHRydWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gQSByb3RhdGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGVDb3VudGVyQ2xvY2t3aXNlNDUoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTb3VyY2UgPSB0aGlzLmJpbmFyaXplci5nZXRMdW1pbmFuY2VTb3VyY2UoKS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlNDUoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5Qml0bWFwKHRoaXMuYmluYXJpemVyLmNyZWF0ZUJpbmFyaXplcihuZXdTb3VyY2UpKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCbGFja01hdHJpeCgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSAvKjogTm90Rm91bmRFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBDaGVja3N1bUV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgICAgIHN0YXRpYyBnZXRDaGVja3N1bUluc3RhbmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVja3N1bUV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIENoZWNrc3VtRXhjZXB0aW9uLmtpbmQgPSAnQ2hlY2tzdW1FeGNlcHRpb24nO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBUaGlzIGNsYXNzIGhpZXJhcmNoeSBwcm92aWRlcyBhIHNldCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgbHVtaW5hbmNlIGRhdGEgdG8gMSBiaXQgZGF0YS5cbiAgICAgKiBJdCBhbGxvd3MgdGhlIGFsZ29yaXRobSB0byB2YXJ5IHBvbHltb3JwaGljYWxseSwgZm9yIGV4YW1wbGUgYWxsb3dpbmcgYSB2ZXJ5IGV4cGVuc2l2ZVxuICAgICAqIHRocmVzaG9sZGluZyB0ZWNobmlxdWUgZm9yIHNlcnZlcnMgYW5kIGEgZmFzdCBvbmUgZm9yIG1vYmlsZS4gSXQgYWxzbyBwZXJtaXRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAqIHRvIHZhcnksIGUuZy4gYSBKTkkgdmVyc2lvbiBmb3IgQW5kcm9pZCBhbmQgYSBKYXZhIGZhbGxiYWNrIHZlcnNpb24gZm9yIG90aGVyIHBsYXRmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICovXG4gICAgY2xhc3MgQmluYXJpemVyIHtcbiAgICAgICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRMdW1pbmFuY2VTb3VyY2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBTeXN0ZW0ge1xuICAgICAgICAvLyBwdWJsaWMgc3RhdGljIHZvaWQgYXJyYXljb3B5KE9iamVjdCBzcmMsIGludCBzcmNQb3MsIE9iamVjdCBkZXN0LCBpbnQgZGVzdFBvcywgaW50IGxlbmd0aClcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2VzIGEgY29weSBvZiBhIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGFycmF5Y29weShzcmMsIHNyY1BvcywgZGVzdCwgZGVzdFBvcywgbGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgdXNlIHNwbGl0IG9yIHNldD9cbiAgICAgICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY3VycmVudFRpbWVNaWxsaXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICB9XG4gICAgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbi5raW5kID0gJ0luZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24nO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiBleHRlbmRzIEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24ge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmRleCA9IHVuZGVmaW5lZCwgbWVzc2FnZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbi5raW5kID0gJ0FycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbic7XG5cbiAgICBjbGFzcyBBcnJheXMge1xuICAgICAgICAvKipcbiAgICAgICAgICogQXNzaWducyB0aGUgc3BlY2lmaWVkIGludCB2YWx1ZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCBhcnJheVxuICAgICAgICAgKiBvZiBpbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYSB0aGUgYXJyYXkgdG8gYmUgZmlsbGVkXG4gICAgICAgICAqIEBwYXJhbSB2YWwgdGhlIHZhbHVlIHRvIGJlIHN0b3JlZCBpbiBhbGwgZWxlbWVudHMgb2YgdGhlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZmlsbChhLCB2YWwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgIGFbaV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2lnbnMgdGhlIHNwZWNpZmllZCBpbnQgdmFsdWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWRcbiAgICAgICAgICogcmFuZ2Ugb2YgdGhlIHNwZWNpZmllZCBhcnJheSBvZiBpbnRzLiAgVGhlIHJhbmdlIHRvIGJlIGZpbGxlZFxuICAgICAgICAgKiBleHRlbmRzIGZyb20gaW5kZXgge0Bjb2RlIGZyb21JbmRleH0sIGluY2x1c2l2ZSwgdG8gaW5kZXhcbiAgICAgICAgICoge0Bjb2RlIHRvSW5kZXh9LCBleGNsdXNpdmUuICAoSWYge0Bjb2RlIGZyb21JbmRleD09dG9JbmRleH0sIHRoZVxuICAgICAgICAgKiByYW5nZSB0byBiZSBmaWxsZWQgaXMgZW1wdHkuKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYSB0aGUgYXJyYXkgdG8gYmUgZmlsbGVkXG4gICAgICAgICAqIEBwYXJhbSBmcm9tSW5kZXggdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IChpbmNsdXNpdmUpIHRvIGJlXG4gICAgICAgICAqICAgICAgICBmaWxsZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB0b0luZGV4IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBlbGVtZW50IChleGNsdXNpdmUpIHRvIGJlXG4gICAgICAgICAqICAgICAgICBmaWxsZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB2YWwgdGhlIHZhbHVlIHRvIGJlIHN0b3JlZCBpbiBhbGwgZWxlbWVudHMgb2YgdGhlIGFycmF5XG4gICAgICAgICAqIEB0aHJvd3MgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIHtAY29kZSBmcm9tSW5kZXggPiB0b0luZGV4fVxuICAgICAgICAgKiBAdGhyb3dzIEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiBpZiB7QGNvZGUgZnJvbUluZGV4IDwgMH0gb3JcbiAgICAgICAgICogICAgICAgICB7QGNvZGUgdG9JbmRleCA+IGEubGVuZ3RofVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZpbGxXaXRoaW4oYSwgZnJvbUluZGV4LCB0b0luZGV4LCB2YWwpIHtcbiAgICAgICAgICAgIEFycmF5cy5yYW5nZUNoZWNrKGEubGVuZ3RoLCBmcm9tSW5kZXgsIHRvSW5kZXgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZyb21JbmRleDsgaSA8IHRvSW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICBhW2ldID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgdGhhdCB7QGNvZGUgZnJvbUluZGV4fSBhbmQge0Bjb2RlIHRvSW5kZXh9IGFyZSBpblxuICAgICAgICAgKiB0aGUgcmFuZ2UgYW5kIHRocm93cyBhbiBleGNlcHRpb24gaWYgdGhleSBhcmVuJ3QuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcmFuZ2VDaGVjayhhcnJheUxlbmd0aCwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgICAgICBpZiAoZnJvbUluZGV4ID4gdG9JbmRleCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ2Zyb21JbmRleCgnICsgZnJvbUluZGV4ICsgJykgPiB0b0luZGV4KCcgKyB0b0luZGV4ICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbihmcm9tSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvSW5kZXggPiBhcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24odG9JbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFzTGlzdCguLi5hcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY3JlYXRlKHJvd3MsIGNvbHMsIHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgYXJyID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogcm93cyB9KTtcbiAgICAgICAgICAgIHJldHVybiBhcnIubWFwKHggPT4gQXJyYXkuZnJvbSh7IGxlbmd0aDogY29scyB9KS5maWxsKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNyZWF0ZUludDMyQXJyYXkocm93cywgY29scywgdmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBhcnIgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiByb3dzIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFyci5tYXAoeCA9PiBJbnQzMkFycmF5LmZyb20oeyBsZW5ndGg6IGNvbHMgfSkuZmlsbCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBlcXVhbHMoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2Vjb25kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmaXJzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlY29uZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3QubGVuZ3RoICE9PSBzZWNvbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGZpcnN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0W2ldICE9PSBzZWNvbmRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBoYXNoQ29kZShhKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDE7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IDMxICogcmVzdWx0ICsgZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZpbGxVaW50OEFycmF5KGEsIHZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFbaV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY29weU9mKG9yaWdpbmFsLCBuZXdMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5zbGljZSgwLCBuZXdMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjb3B5T2ZVaW50OEFycmF5KG9yaWdpbmFsLCBuZXdMZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggPD0gbmV3TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuICAgICAgICAgICAgICAgIG5ld0FycmF5LnNldChvcmlnaW5hbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLnNsaWNlKDAsIG5ld0xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNvcHlPZlJhbmdlKG9yaWdpbmFsLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gdG8gLSBmcm9tO1xuICAgICAgICAgICAgY29uc3QgY29weSA9IG5ldyBJbnQzMkFycmF5KG5ld0xlbmd0aCk7XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KG9yaWdpbmFsLCBmcm9tLCBjb3B5LCAwLCBuZXdMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBvZiB0aGUgZWxlbWVudCBpbiBhIHNvcnRlZCBhcnJheSBvciAoLW4tMSkgd2hlcmUgbiBpcyB0aGUgaW5zZXJ0aW9uIHBvaW50XG4gICAgICAgICogZm9yIHRoZSBuZXcgZWxlbWVudC5cbiAgICAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAgICAqICAgICBhciAtIEEgc29ydGVkIGFycmF5XG4gICAgICAgICogICAgIGVsIC0gQW4gZWxlbWVudCB0byBzZWFyY2ggZm9yXG4gICAgICAgICogICAgIGNvbXBhcmF0b3IgLSBBIGNvbXBhcmF0b3IgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiB0YWtlcyB0d28gYXJndW1lbnRzOiAoYSwgYikgYW5kIHJldHVybnM6XG4gICAgICAgICogICAgICAgIGEgbmVnYXRpdmUgbnVtYmVyICBpZiBhIGlzIGxlc3MgdGhhbiBiO1xuICAgICAgICAqICAgICAgICAwIGlmIGEgaXMgZXF1YWwgdG8gYjtcbiAgICAgICAgKiAgICAgICAgYSBwb3NpdGl2ZSBudW1iZXIgb2YgYSBpcyBncmVhdGVyIHRoYW4gYi5cbiAgICAgICAgKiBUaGUgYXJyYXkgbWF5IGNvbnRhaW4gZHVwbGljYXRlIGVsZW1lbnRzLiBJZiB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uZSBlcXVhbCBlbGVtZW50cyBpbiB0aGUgYXJyYXksXG4gICAgICAgICogdGhlIHJldHVybmVkIHZhbHVlIGNhbiBiZSB0aGUgaW5kZXggb2YgYW55IG9uZSBvZiB0aGUgZXF1YWwgZWxlbWVudHMuXG4gICAgICAgICpcbiAgICAgICAgKiBodHRwOi8vanNmaWRkbGUubmV0L2FyeXpob3YvcGtmc3Q1NTAvXG4gICAgICAgICovXG4gICAgICAgIHN0YXRpYyBiaW5hcnlTZWFyY2goYXIsIGVsLCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY29tcGFyYXRvciA9IEFycmF5cy5udW1iZXJDb21wYXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG0gPSAwO1xuICAgICAgICAgICAgbGV0IG4gPSBhci5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKG0gPD0gbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGsgPSAobiArIG0pID4+IDE7XG4gICAgICAgICAgICAgICAgY29uc3QgY21wID0gY29tcGFyYXRvcihlbCwgYXJba10pO1xuICAgICAgICAgICAgICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG0gPSBrICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBuID0gayAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLW0gLSAxO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBudW1iZXJDb21wYXJhdG9yKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbnlmaWxsIGZvciBKYXZhJ3MgSW50ZWdlciBjbGFzcy5cbiAgICAgKi9cbiAgICBjbGFzcyBJbnRlZ2VyIHtcbiAgICAgICAgc3RhdGljIG51bWJlck9mVHJhaWxpbmdaZXJvcyhpKSB7XG4gICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgIGlmIChpID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgICAgIGxldCBuID0gMzE7XG4gICAgICAgICAgICB5ID0gaSA8PCAxNjtcbiAgICAgICAgICAgIGlmICh5ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbiAtPSAxNjtcbiAgICAgICAgICAgICAgICBpID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHkgPSBpIDw8IDg7XG4gICAgICAgICAgICBpZiAoeSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG4gLT0gODtcbiAgICAgICAgICAgICAgICBpID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHkgPSBpIDw8IDQ7XG4gICAgICAgICAgICBpZiAoeSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG4gLT0gNDtcbiAgICAgICAgICAgICAgICBpID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHkgPSBpIDw8IDI7XG4gICAgICAgICAgICBpZiAoeSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG4gLT0gMjtcbiAgICAgICAgICAgICAgICBpID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuIC0gKChpIDw8IDEpID4+PiAzMSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG51bWJlck9mTGVhZGluZ1plcm9zKGkpIHtcbiAgICAgICAgICAgIC8vIEhELCBGaWd1cmUgNS02XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuID0gMTtcbiAgICAgICAgICAgIGlmIChpID4+PiAxNiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG4gKz0gMTY7XG4gICAgICAgICAgICAgICAgaSA8PD0gMTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+Pj4gMjQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBuICs9IDg7XG4gICAgICAgICAgICAgICAgaSA8PD0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4+PiAyOCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG4gKz0gNDtcbiAgICAgICAgICAgICAgICBpIDw8PSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj4+IDMwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbiArPSAyO1xuICAgICAgICAgICAgICAgIGkgPDw9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuIC09IGkgPj4+IDMxO1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHRvSGV4U3RyaW5nKGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgdG9CaW5hcnlTdHJpbmcoaW50TnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHBhcnNlSW50KFN0cmluZyhpbnROdW1iZXIpLCAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIG9uZS1iaXRzIGluIHRoZSB0d28ncyBjb21wbGVtZW50IGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGludCB2YWx1ZS4gVGhpcyBmdW5jdGlvbiBpcyBzb21ldGltZXMgcmVmZXJyZWQgdG8gYXMgdGhlIHBvcHVsYXRpb24gY291bnQuXG4gICAgICAgIC8vIFJldHVybnM6XG4gICAgICAgIC8vIHRoZSBudW1iZXIgb2Ygb25lLWJpdHMgaW4gdGhlIHR3bydzIGNvbXBsZW1lbnQgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzcGVjaWZpZWQgaW50IHZhbHVlLlxuICAgICAgICBzdGF0aWMgYml0Q291bnQoaSkge1xuICAgICAgICAgICAgLy8gSEQsIEZpZ3VyZSA1LTJcbiAgICAgICAgICAgIGkgPSBpIC0gKChpID4+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICAgICAgICAgICAgaSA9IChpICYgMHgzMzMzMzMzMykgKyAoKGkgPj4+IDIpICYgMHgzMzMzMzMzMyk7XG4gICAgICAgICAgICBpID0gKGkgKyAoaSA+Pj4gNCkpICYgMHgwZjBmMGYwZjtcbiAgICAgICAgICAgIGkgPSBpICsgKGkgPj4+IDgpO1xuICAgICAgICAgICAgaSA9IGkgKyAoaSA+Pj4gMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGkgJiAweDNmO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyB0cnVuY0RpdmlzaW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC50cnVuYyhkaXZpZGVuZCAvIGRpdmlzb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBBIHN0cmluZyB0byBhbiBpbnRlZ2VyLlxuICAgICAgICAgKiBAcGFyYW0gcyBBIHN0cmluZyB0byBjb252ZXJ0IGludG8gYSBudW1iZXIuXG4gICAgICAgICAqIEBwYXJhbSByYWRpeCBBIHZhbHVlIGJldHdlZW4gMiBhbmQgMzYgdGhhdCBzcGVjaWZpZXMgdGhlIGJhc2Ugb2YgdGhlIG51bWJlciBpbiBudW1TdHJpbmcuIElmIHRoaXMgYXJndW1lbnQgaXMgbm90IHN1cHBsaWVkLCBzdHJpbmdzIHdpdGggYSBwcmVmaXggb2YgJzB4JyBhcmUgY29uc2lkZXJlZCBoZXhhZGVjaW1hbC4gQWxsIG90aGVyIHN0cmluZ3MgYXJlIGNvbnNpZGVyZWQgZGVjaW1hbC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBwYXJzZUludChudW0sIHJhZGl4ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLCByYWRpeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSW50ZWdlci5NSU5fVkFMVUVfMzJfQklUUyA9IC0yMTQ3NDgzNjQ4O1xuICAgIEludGVnZXIuTUFYX1ZBTFVFID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cbiAgICAvKipcbiAgICAgKiA8cD5BIHNpbXBsZSwgZmFzdCBhcnJheSBvZiBiaXRzLCByZXByZXNlbnRlZCBjb21wYWN0bHkgYnkgYW4gYXJyYXkgb2YgaW50cyBpbnRlcm5hbGx5LjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgQml0QXJyYXkgLyppbXBsZW1lbnRzIENsb25lYWJsZSovIHtcbiAgICAgICAgLy8gRm9yIHRlc3Rpbmcgb25seVxuICAgICAgICBjb25zdHJ1Y3RvcihzaXplIC8qaW50Ki8sIGJpdHMpIHtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuYml0cyA9IG5ldyBJbnQzMkFycmF5KDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBiaXRzIHx8IG51bGwgPT09IGJpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaXRzID0gQml0QXJyYXkubWFrZUFycmF5KHNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U2l6ZUluQnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigodGhpcy5zaXplICsgNykgLyA4KTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVDYXBhY2l0eShzaXplIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChzaXplID4gdGhpcy5iaXRzLmxlbmd0aCAqIDMyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Qml0cyA9IEJpdEFycmF5Lm1ha2VBcnJheShzaXplKTtcbiAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHRoaXMuYml0cywgMCwgbmV3Qml0cywgMCwgdGhpcy5iaXRzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5iaXRzID0gbmV3Qml0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGkgYml0IHRvIGdldFxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWZmIGJpdCBpIGlzIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0KGkgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmJpdHNbTWF0aC5mbG9vcihpIC8gMzIpXSAmICgxIDw8IChpICYgMHgxRikpKSAhPT0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBiaXQgaS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGkgYml0IHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0KGkgLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy5iaXRzW01hdGguZmxvb3IoaSAvIDMyKV0gfD0gMSA8PCAoaSAmIDB4MUYpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGlwcyBiaXQgaS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGkgYml0IHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZmxpcChpIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuYml0c1tNYXRoLmZsb29yKGkgLyAzMildIF49IDEgPDwgKGkgJiAweDFGKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGZyb20gZmlyc3QgYml0IHRvIGNoZWNrXG4gICAgICAgICAqIEByZXR1cm4gaW5kZXggb2YgZmlyc3QgYml0IHRoYXQgaXMgc2V0LCBzdGFydGluZyBmcm9tIHRoZSBnaXZlbiBpbmRleCwgb3Igc2l6ZSBpZiBub25lIGFyZSBzZXRcbiAgICAgICAgICogIGF0IG9yIGJleW9uZCB0aGlzIGdpdmVuIGluZGV4XG4gICAgICAgICAqIEBzZWUgI2dldE5leHRVbnNldChpbnQpXG4gICAgICAgICAqL1xuICAgICAgICBnZXROZXh0U2V0KGZyb20gLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgICAgIGlmIChmcm9tID49IHNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBsZXQgYml0c09mZnNldCA9IE1hdGguZmxvb3IoZnJvbSAvIDMyKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Qml0cyA9IGJpdHNbYml0c09mZnNldF07XG4gICAgICAgICAgICAvLyBtYXNrIG9mZiBsZXNzZXIgYml0cyBmaXJzdFxuICAgICAgICAgICAgY3VycmVudEJpdHMgJj0gfigoMSA8PCAoZnJvbSAmIDB4MUYpKSAtIDEpO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYml0cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudEJpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoKytiaXRzT2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRCaXRzID0gYml0c1tiaXRzT2Zmc2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChiaXRzT2Zmc2V0ICogMzIpICsgSW50ZWdlci5udW1iZXJPZlRyYWlsaW5nWmVyb3MoY3VycmVudEJpdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA+IHNpemUgPyBzaXplIDogcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gZnJvbSBpbmRleCB0byBzdGFydCBsb29raW5nIGZvciB1bnNldCBiaXRcbiAgICAgICAgICogQHJldHVybiBpbmRleCBvZiBuZXh0IHVuc2V0IGJpdCwgb3Ige0Bjb2RlIHNpemV9IGlmIG5vbmUgYXJlIHVuc2V0IHVudGlsIHRoZSBlbmRcbiAgICAgICAgICogQHNlZSAjZ2V0TmV4dFNldChpbnQpXG4gICAgICAgICAqL1xuICAgICAgICBnZXROZXh0VW5zZXQoZnJvbSAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5zaXplO1xuICAgICAgICAgICAgaWYgKGZyb20gPj0gc2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgICAgIGxldCBiaXRzT2Zmc2V0ID0gTWF0aC5mbG9vcihmcm9tIC8gMzIpO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRCaXRzID0gfmJpdHNbYml0c09mZnNldF07XG4gICAgICAgICAgICAvLyBtYXNrIG9mZiBsZXNzZXIgYml0cyBmaXJzdFxuICAgICAgICAgICAgY3VycmVudEJpdHMgJj0gfigoMSA8PCAoZnJvbSAmIDB4MUYpKSAtIDEpO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYml0cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudEJpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoKytiaXRzT2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRCaXRzID0gfmJpdHNbYml0c09mZnNldF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoYml0c09mZnNldCAqIDMyKSArIEludGVnZXIubnVtYmVyT2ZUcmFpbGluZ1plcm9zKGN1cnJlbnRCaXRzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPiBzaXplID8gc2l6ZSA6IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBhIGJsb2NrIG9mIDMyIGJpdHMsIHN0YXJ0aW5nIGF0IGJpdCBpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaSBmaXJzdCBiaXQgdG8gc2V0XG4gICAgICAgICAqIEBwYXJhbSBuZXdCaXRzIHRoZSBuZXcgdmFsdWUgb2YgdGhlIG5leHQgMzIgYml0cy4gTm90ZSBhZ2FpbiB0aGF0IHRoZSBsZWFzdC1zaWduaWZpY2FudCBiaXRcbiAgICAgICAgICogY29ycmVzcG9uZHMgdG8gYml0IGksIHRoZSBuZXh0LWxlYXN0LXNpZ25pZmljYW50IHRvIGkrMSwgYW5kIHNvIG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QnVsayhpIC8qaW50Ki8sIG5ld0JpdHMgLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy5iaXRzW01hdGguZmxvb3IoaSAvIDMyKV0gPSBuZXdCaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGEgcmFuZ2Ugb2YgYml0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN0YXJ0IHN0YXJ0IG9mIHJhbmdlLCBpbmNsdXNpdmUuXG4gICAgICAgICAqIEBwYXJhbSBlbmQgZW5kIG9mIHJhbmdlLCBleGNsdXNpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNldFJhbmdlKHN0YXJ0IC8qaW50Ki8sIGVuZCAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoZW5kIDwgc3RhcnQgfHwgc3RhcnQgPCAwIHx8IGVuZCA+IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kLS07IC8vIHdpbGwgYmUgZWFzaWVyIHRvIHRyZWF0IHRoaXMgYXMgdGhlIGxhc3QgYWN0dWFsbHkgc2V0IGJpdCAtLSBpbmNsdXNpdmVcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0SW50ID0gTWF0aC5mbG9vcihzdGFydCAvIDMyKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RJbnQgPSBNYXRoLmZsb29yKGVuZCAvIDMyKTtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZmlyc3RJbnQ7IGkgPD0gbGFzdEludDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RCaXQgPSBpID4gZmlyc3RJbnQgPyAwIDogc3RhcnQgJiAweDFGO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RCaXQgPSBpIDwgbGFzdEludCA/IDMxIDogZW5kICYgMHgxRjtcbiAgICAgICAgICAgICAgICAvLyBPbmVzIGZyb20gZmlyc3RCaXQgdG8gbGFzdEJpdCwgaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgY29uc3QgbWFzayA9ICgyIDw8IGxhc3RCaXQpIC0gKDEgPDwgZmlyc3RCaXQpO1xuICAgICAgICAgICAgICAgIGJpdHNbaV0gfD0gbWFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIGFsbCBiaXRzIChzZXRzIHRvIGZhbHNlKS5cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyKCkge1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5iaXRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYml0c1tpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudCBtZXRob2QgdG8gY2hlY2sgaWYgYSByYW5nZSBvZiBiaXRzIGlzIHNldCwgb3Igbm90IHNldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN0YXJ0IHN0YXJ0IG9mIHJhbmdlLCBpbmNsdXNpdmUuXG4gICAgICAgICAqIEBwYXJhbSBlbmQgZW5kIG9mIHJhbmdlLCBleGNsdXNpdmVcbiAgICAgICAgICogQHBhcmFtIHZhbHVlIGlmIHRydWUsIGNoZWNrcyB0aGF0IGJpdHMgaW4gcmFuZ2UgYXJlIHNldCwgb3RoZXJ3aXNlIGNoZWNrcyB0aGF0IHRoZXkgYXJlIG5vdCBzZXRcbiAgICAgICAgICogXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZmYgYWxsIGJpdHMgYXJlIHNldCBvciBub3Qgc2V0IGluIHJhbmdlLCBhY2NvcmRpbmcgdG8gdmFsdWUgYXJndW1lbnRcbiAgICAgICAgICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgZW5kIGlzIGxlc3MgdGhhbiBzdGFydCBvciB0aGUgcmFuZ2UgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIGlzUmFuZ2Uoc3RhcnQgLyppbnQqLywgZW5kIC8qaW50Ki8sIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZW5kIDwgc3RhcnQgfHwgc3RhcnQgPCAwIHx8IGVuZCA+IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIGVtcHR5IHJhbmdlIG1hdGNoZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZC0tOyAvLyB3aWxsIGJlIGVhc2llciB0byB0cmVhdCB0aGlzIGFzIHRoZSBsYXN0IGFjdHVhbGx5IHNldCBiaXQgLS0gaW5jbHVzaXZlXG4gICAgICAgICAgICBjb25zdCBmaXJzdEludCA9IE1hdGguZmxvb3Ioc3RhcnQgLyAzMik7XG4gICAgICAgICAgICBjb25zdCBsYXN0SW50ID0gTWF0aC5mbG9vcihlbmQgLyAzMik7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZpcnN0SW50OyBpIDw9IGxhc3RJbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Qml0ID0gaSA+IGZpcnN0SW50ID8gMCA6IHN0YXJ0ICYgMHgxRjtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0Qml0ID0gaSA8IGxhc3RJbnQgPyAzMSA6IGVuZCAmIDB4MUY7XG4gICAgICAgICAgICAgICAgLy8gT25lcyBmcm9tIGZpcnN0Qml0IHRvIGxhc3RCaXQsIGluY2x1c2l2ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hc2sgPSAoMiA8PCBsYXN0Qml0KSAtICgxIDw8IGZpcnN0Qml0KSAmIDB4RkZGRkZGRkY7XG4gICAgICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6ICYgMHhGRkZGRkZGRiBhZGRlZCB0byBkaXNjYXJkIGFueXRoaW5nIGFmdGVyIDMyIGJpdHMsIGFzIEVTIGhhcyA1MyBiaXRzXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGlmIHdlJ3JlIGxvb2tpbmcgZm9yIDFzIGFuZCB0aGUgbWFza2VkIGJpdHNbaV0gaXNuJ3QgYWxsIDFzIChpczogdGhhdCxcbiAgICAgICAgICAgICAgICAvLyBlcXVhbHMgdGhlIG1hc2ssIG9yIHdlJ3JlIGxvb2tpbmcgZm9yIDBzIGFuZCB0aGUgbWFza2VkIHBvcnRpb24gaXMgbm90IGFsbCAwc1xuICAgICAgICAgICAgICAgIGlmICgoYml0c1tpXSAmIG1hc2spICE9PSAodmFsdWUgPyBtYXNrIDogMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGFwcGVuZEJpdChiaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5zaXplICsgMSk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaXRzW01hdGguZmxvb3IodGhpcy5zaXplIC8gMzIpXSB8PSAxIDw8ICh0aGlzLnNpemUgJiAweDFGKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2l6ZSsrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmRzIHRoZSBsZWFzdC1zaWduaWZpY2FudCBiaXRzLCBmcm9tIHZhbHVlLCBpbiBvcmRlciBmcm9tIG1vc3Qtc2lnbmlmaWNhbnQgdG9cbiAgICAgICAgICogbGVhc3Qtc2lnbmlmaWNhbnQuIEZvciBleGFtcGxlLCBhcHBlbmRpbmcgNiBiaXRzIGZyb20gMHgwMDAwMDFFIHdpbGwgYXBwZW5kIHRoZSBiaXRzXG4gICAgICAgICAqIDAsIDEsIDEsIDEsIDEsIDAgaW4gdGhhdCBvcmRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZhbHVlIHtAY29kZSBpbnR9IGNvbnRhaW5pbmcgYml0cyB0byBhcHBlbmRcbiAgICAgICAgICogQHBhcmFtIG51bUJpdHMgYml0cyBmcm9tIHZhbHVlIHRvIGFwcGVuZFxuICAgICAgICAgKi9cbiAgICAgICAgYXBwZW5kQml0cyh2YWx1ZSAvKmludCovLCBudW1CaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChudW1CaXRzIDwgMCB8fCBudW1CaXRzID4gMzIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdOdW0gYml0cyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMzInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5zaXplICsgbnVtQml0cyk7XG4gICAgICAgICAgICAvLyBjb25zdCBhcHBlbmRCaXQgPSB0aGlzLmFwcGVuZEJpdDtcbiAgICAgICAgICAgIGZvciAobGV0IG51bUJpdHNMZWZ0ID0gbnVtQml0czsgbnVtQml0c0xlZnQgPiAwOyBudW1CaXRzTGVmdC0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRCaXQoKCh2YWx1ZSA+PiAobnVtQml0c0xlZnQgLSAxKSkgJiAweDAxKSA9PT0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kQml0QXJyYXkob3RoZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyU2l6ZSA9IG90aGVyLnNpemU7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuc2l6ZSArIG90aGVyU2l6ZSk7XG4gICAgICAgICAgICAvLyBjb25zdCBhcHBlbmRCaXQgPSB0aGlzLmFwcGVuZEJpdDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3RoZXJTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEJpdChvdGhlci5nZXQoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHhvcihvdGhlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2l6ZSAhPT0gb3RoZXIuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1NpemVzIGRvblxcJ3QgbWF0Y2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gYml0cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBsYXN0IGludCBjb3VsZCBiZSBpbmNvbXBsZXRlIChpLmUuIG5vdCBoYXZlIDMyIGJpdHMgaW5cbiAgICAgICAgICAgICAgICAvLyBpdCkgYnV0IHRoZXJlIGlzIG5vIHByb2JsZW0gc2luY2UgMCBYT1IgMCA9PSAwLlxuICAgICAgICAgICAgICAgIGJpdHNbaV0gXj0gb3RoZXIuYml0c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJpdE9mZnNldCBmaXJzdCBiaXQgdG8gc3RhcnQgd3JpdGluZ1xuICAgICAgICAgKiBAcGFyYW0gYXJyYXkgYXJyYXkgdG8gd3JpdGUgaW50by4gQnl0ZXMgYXJlIHdyaXR0ZW4gbW9zdC1zaWduaWZpY2FudCBieXRlIGZpcnN0LiBUaGlzIGlzIHRoZSBvcHBvc2l0ZVxuICAgICAgICAgKiAgb2YgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uLCB3aGljaCBpcyBleHBvc2VkIGJ5IHtAbGluayAjZ2V0Qml0QXJyYXkoKX1cbiAgICAgICAgICogQHBhcmFtIG9mZnNldCBwb3NpdGlvbiBpbiBhcnJheSB0byBzdGFydCB3cml0aW5nXG4gICAgICAgICAqIEBwYXJhbSBudW1CeXRlcyBob3cgbWFueSBieXRlcyB0byB3cml0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdG9CeXRlcyhiaXRPZmZzZXQgLyppbnQqLywgYXJyYXksIG9mZnNldCAvKmludCovLCBudW1CeXRlcyAvKmludCovKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUJ5dGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdGhlQnl0ZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KGJpdE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZUJ5dGUgfD0gMSA8PCAoNyAtIGopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJpdE9mZnNldCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBpXSA9IC8qKGJ5dGUpKi8gdGhlQnl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB1bmRlcmx5aW5nIGFycmF5IG9mIGludHMuIFRoZSBmaXJzdCBlbGVtZW50IGhvbGRzIHRoZSBmaXJzdCAzMiBiaXRzLCBhbmQgdGhlIGxlYXN0XG4gICAgICAgICAqICAgICAgICAgc2lnbmlmaWNhbnQgYml0IGlzIGJpdCAwLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Qml0QXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXZlcnNlcyBhbGwgYml0cyBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICByZXZlcnNlKCkge1xuICAgICAgICAgICAgY29uc3QgbmV3Qml0cyA9IG5ldyBJbnQzMkFycmF5KHRoaXMuYml0cy5sZW5ndGgpO1xuICAgICAgICAgICAgLy8gcmV2ZXJzZSBhbGwgaW50J3MgZmlyc3RcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IE1hdGguZmxvb3IoKHRoaXMuc2l6ZSAtIDEpIC8gMzIpO1xuICAgICAgICAgICAgY29uc3Qgb2xkQml0c0xlbiA9IGxlbiArIDE7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbGRCaXRzTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeCA9IGJpdHNbaV07XG4gICAgICAgICAgICAgICAgeCA9ICgoeCA+PiAxKSAmIDB4NTU1NTU1NTUpIHwgKCh4ICYgMHg1NTU1NTU1NSkgPDwgMSk7XG4gICAgICAgICAgICAgICAgeCA9ICgoeCA+PiAyKSAmIDB4MzMzMzMzMzMpIHwgKCh4ICYgMHgzMzMzMzMzMykgPDwgMik7XG4gICAgICAgICAgICAgICAgeCA9ICgoeCA+PiA0KSAmIDB4MGYwZjBmMGYpIHwgKCh4ICYgMHgwZjBmMGYwZikgPDwgNCk7XG4gICAgICAgICAgICAgICAgeCA9ICgoeCA+PiA4KSAmIDB4MDBmZjAwZmYpIHwgKCh4ICYgMHgwMGZmMDBmZikgPDwgOCk7XG4gICAgICAgICAgICAgICAgeCA9ICgoeCA+PiAxNikgJiAweDAwMDBmZmZmKSB8ICgoeCAmIDB4MDAwMGZmZmYpIDw8IDE2KTtcbiAgICAgICAgICAgICAgICBuZXdCaXRzW2xlbiAtIGldID0gLyooaW50KSovIHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub3cgY29ycmVjdCB0aGUgaW50J3MgaWYgdGhlIGJpdCBzaXplIGlzbid0IGEgbXVsdGlwbGUgb2YgMzJcbiAgICAgICAgICAgIGlmICh0aGlzLnNpemUgIT09IG9sZEJpdHNMZW4gKiAzMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRPZmZzZXQgPSBvbGRCaXRzTGVuICogMzIgLSB0aGlzLnNpemU7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRJbnQgPSBuZXdCaXRzWzBdID4+PiBsZWZ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb2xkQml0c0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJbnQgPSBuZXdCaXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SW50IHw9IG5leHRJbnQgPDwgKDMyIC0gbGVmdE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0JpdHNbaSAtIDFdID0gY3VycmVudEludDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEludCA9IG5leHRJbnQgPj4+IGxlZnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld0JpdHNbb2xkQml0c0xlbiAtIDFdID0gY3VycmVudEludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYml0cyA9IG5ld0JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG1ha2VBcnJheShzaXplIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShNYXRoLmZsb29yKChzaXplICsgMzEpIC8gMzIpKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGVxdWFscyhvKSB7XG4gICAgICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgQml0QXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gb3RoZXIuc2l6ZSAmJiBBcnJheXMuZXF1YWxzKHRoaXMuYml0cywgb3RoZXIuYml0cyk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBoYXNoQ29kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAzMSAqIHRoaXMuc2l6ZSArIEFycmF5cy5oYXNoQ29kZSh0aGlzLmJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgc2l6ZSA9IHRoaXMuc2l6ZTsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgoaSAmIDB4MDcpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmdldChpKSA/ICdYJyA6ICcuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBjbG9uZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQml0QXJyYXkodGhpcy5zaXplLCB0aGlzLmJpdHMuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovXG4gICAgLyoqXG4gICAgICogRW5jYXBzdWxhdGVzIGEgdHlwZSBvZiBoaW50IHRoYXQgYSBjYWxsZXIgbWF5IHBhc3MgdG8gYSBiYXJjb2RlIHJlYWRlciB0byBoZWxwIGl0XG4gICAgICogbW9yZSBxdWlja2x5IG9yIGFjY3VyYXRlbHkgZGVjb2RlIGl0LiBJdCBpcyB1cCB0byBpbXBsZW1lbnRhdGlvbnMgdG8gZGVjaWRlIHdoYXQsXG4gICAgICogaWYgYW55dGhpbmcsIHRvIGRvIHdpdGggdGhlIGluZm9ybWF0aW9uIHRoYXQgaXMgc3VwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQHNlZSBSZWFkZXIjZGVjb2RlKEJpbmFyeUJpdG1hcCxqYXZhLnV0aWwuTWFwKVxuICAgICAqL1xuICAgIHZhciBEZWNvZGVIaW50VHlwZTtcbiAgICAoZnVuY3Rpb24gKERlY29kZUhpbnRUeXBlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnNwZWNpZmllZCwgYXBwbGljYXRpb24tc3BlY2lmaWMgaGludC4gTWFwcyB0byBhbiB1bnNwZWNpZmllZCB7QGxpbmsgT2JqZWN0fS5cbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiT1RIRVJcIl0gPSAwXSA9IFwiT1RIRVJcIjsgLyooT2JqZWN0LmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbWFnZSBpcyBhIHB1cmUgbW9ub2Nocm9tZSBpbWFnZSBvZiBhIGJhcmNvZGUuIERvZXNuJ3QgbWF0dGVyIHdoYXQgaXQgbWFwcyB0bztcbiAgICAgICAgICogdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJQVVJFX0JBUkNPREVcIl0gPSAxXSA9IFwiUFVSRV9CQVJDT0RFXCI7IC8qKFZvaWQuY2xhc3MpKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltYWdlIGlzIGtub3duIHRvIGJlIG9mIG9uZSBvZiBhIGZldyBwb3NzaWJsZSBmb3JtYXRzLlxuICAgICAgICAgKiBNYXBzIHRvIGEge0BsaW5rIExpc3R9IG9mIHtAbGluayBCYXJjb2RlRm9ybWF0fXMuXG4gICAgICAgICAqL1xuICAgICAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIlBPU1NJQkxFX0ZPUk1BVFNcIl0gPSAyXSA9IFwiUE9TU0lCTEVfRk9STUFUU1wiOyAvKihMaXN0LmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVuZCBtb3JlIHRpbWUgdG8gdHJ5IHRvIGZpbmQgYSBiYXJjb2RlOyBvcHRpbWl6ZSBmb3IgYWNjdXJhY3ksIG5vdCBzcGVlZC5cbiAgICAgICAgICogRG9lc24ndCBtYXR0ZXIgd2hhdCBpdCBtYXBzIHRvOyB1c2Uge0BsaW5rIEJvb2xlYW4jVFJVRX0uXG4gICAgICAgICAqL1xuICAgICAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIlRSWV9IQVJERVJcIl0gPSAzXSA9IFwiVFJZX0hBUkRFUlwiOyAvKihWb2lkLmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hhdCBjaGFyYWN0ZXIgZW5jb2RpbmcgdG8gdXNlIHdoZW4gZGVjb2RpbmcsIHdoZXJlIGFwcGxpY2FibGUgKHR5cGUgU3RyaW5nKVxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJDSEFSQUNURVJfU0VUXCJdID0gNF0gPSBcIkNIQVJBQ1RFUl9TRVRcIjsgLyooU3RyaW5nLmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd2VkIGxlbmd0aHMgb2YgZW5jb2RlZCBkYXRhIC0tIHJlamVjdCBhbnl0aGluZyBlbHNlLiBNYXBzIHRvIGFuIHtAY29kZSBJbnQzMkFycmF5fS5cbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiQUxMT1dFRF9MRU5HVEhTXCJdID0gNV0gPSBcIkFMTE9XRURfTEVOR1RIU1wiOyAvKihJbnQzMkFycmF5LmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3N1bWUgQ29kZSAzOSBjb2RlcyBlbXBsb3kgYSBjaGVjayBkaWdpdC4gRG9lc24ndCBtYXR0ZXIgd2hhdCBpdCBtYXBzIHRvO1xuICAgICAgICAgKiB1c2Uge0BsaW5rIEJvb2xlYW4jVFJVRX0uXG4gICAgICAgICAqL1xuICAgICAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIkFTU1VNRV9DT0RFXzM5X0NIRUNLX0RJR0lUXCJdID0gNl0gPSBcIkFTU1VNRV9DT0RFXzM5X0NIRUNLX0RJR0lUXCI7IC8qKFZvaWQuY2xhc3MpKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc3VtZSB0aGUgYmFyY29kZSBpcyBiZWluZyBwcm9jZXNzZWQgYXMgYSBHUzEgYmFyY29kZSwgYW5kIG1vZGlmeSBiZWhhdmlvciBhcyBuZWVkZWQuXG4gICAgICAgICAqIEZvciBleGFtcGxlIHRoaXMgYWZmZWN0cyBGTkMxIGhhbmRsaW5nIGZvciBDb2RlIDEyOCAoYWthIEdTMS0xMjgpLiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87XG4gICAgICAgICAqIHVzZSB7QGxpbmsgQm9vbGVhbiNUUlVFfS5cbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiQVNTVU1FX0dTMVwiXSA9IDddID0gXCJBU1NVTUVfR1MxXCI7IC8qKFZvaWQuY2xhc3MpKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHJldHVybiB0aGUgc3RhcnQgYW5kIGVuZCBkaWdpdHMgaW4gYSBDb2RhYmFyIGJhcmNvZGUgaW5zdGVhZCBvZiBzdHJpcHBpbmcgdGhlbS4gVGhleVxuICAgICAgICAgKiBhcmUgYWxwaGEsIHdoZXJlYXMgdGhlIHJlc3QgYXJlIG51bWVyaWMuIEJ5IGRlZmF1bHQsIHRoZXkgYXJlIHN0cmlwcGVkLCBidXQgdGhpcyBjYXVzZXMgdGhlbVxuICAgICAgICAgKiB0byBub3QgYmUuIERvZXNuJ3QgbWF0dGVyIHdoYXQgaXQgbWFwcyB0bzsgdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJSRVRVUk5fQ09EQUJBUl9TVEFSVF9FTkRcIl0gPSA4XSA9IFwiUkVUVVJOX0NPREFCQVJfU1RBUlRfRU5EXCI7IC8qKFZvaWQuY2xhc3MpKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYWxsZXIgbmVlZHMgdG8gYmUgbm90aWZpZWQgdmlhIGNhbGxiYWNrIHdoZW4gYSBwb3NzaWJsZSB7QGxpbmsgUmVzdWx0UG9pbnR9XG4gICAgICAgICAqIGlzIGZvdW5kLiBNYXBzIHRvIGEge0BsaW5rIFJlc3VsdFBvaW50Q2FsbGJhY2t9LlxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDS1wiXSA9IDldID0gXCJORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDS1wiOyAvKihSZXN1bHRQb2ludENhbGxiYWNrLmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd2VkIGV4dGVuc2lvbiBsZW5ndGhzIGZvciBFQU4gb3IgVVBDIGJhcmNvZGVzLiBPdGhlciBmb3JtYXRzIHdpbGwgaWdub3JlIHRoaXMuXG4gICAgICAgICAqIE1hcHMgdG8gYW4ge0Bjb2RlIEludDMyQXJyYXl9IG9mIHRoZSBhbGxvd2VkIGV4dGVuc2lvbiBsZW5ndGhzLCBmb3IgZXhhbXBsZSBbMl0sIFs1XSwgb3IgWzIsIDVdLlxuICAgICAgICAgKiBJZiBpdCBpcyBvcHRpb25hbCB0byBoYXZlIGFuIGV4dGVuc2lvbiwgZG8gbm90IHNldCB0aGlzIGhpbnQuIElmIHRoaXMgaXMgc2V0LFxuICAgICAgICAgKiBhbmQgYSBVUEMgb3IgRUFOIGJhcmNvZGUgaXMgZm91bmQgYnV0IGFuIGV4dGVuc2lvbiBpcyBub3QsIHRoZW4gbm8gcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgICAgICogYXQgYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJBTExPV0VEX0VBTl9FWFRFTlNJT05TXCJdID0gMTBdID0gXCJBTExPV0VEX0VBTl9FWFRFTlNJT05TXCI7IC8qKEludDMyQXJyYXkuY2xhc3MpKi9cbiAgICAgICAgLy8gRW5kIG9mIGVudW1lcmF0aW9uIHZhbHVlcy5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGEgdHlwZSB0aGUgaGludCBpcyBleHBlY3RpbmcuXG4gICAgICAgICAqIEFtb25nIHRoZSBwb3NzaWJsZSB2YWx1ZXMgdGhlIHtAbGluayBWb2lkfSBzdGFuZHMgb3V0IGFzIGJlaW5nIHVzZWQgZm9yXG4gICAgICAgICAqIGhpbnRzIHRoYXQgZG8gbm90IGV4cGVjdCBhIHZhbHVlIHRvIGJlIHN1cHBsaWVkIChmbGFnIGhpbnRzKS4gU3VjaCBoaW50c1xuICAgICAgICAgKiB3aWxsIHBvc3NpYmx5IGhhdmUgdGhlaXIgdmFsdWUgaWdub3JlZCwgb3IgcmVwbGFjZWQgYnkgYVxuICAgICAgICAgKiB7QGxpbmsgQm9vbGVhbiNUUlVFfS4gSGludCBzdXBwbGllcnMgc2hvdWxkIHByb2JhYmx5IHVzZVxuICAgICAgICAgKiB7QGxpbmsgQm9vbGVhbiNUUlVFfSBhcyBkaXJlY3RlZCBieSB0aGUgYWN0dWFsIGhpbnQgZG9jdW1lbnRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIC8vIHByaXZhdGUgdmFsdWVUeXBlOiBDbGFzczw/PlxuICAgICAgICAvLyBEZWNvZGVIaW50VHlwZSh2YWx1ZVR5cGU6IENsYXNzPD8+KSB7XG4gICAgICAgIC8vICAgdGhpcy52YWx1ZVR5cGUgPSB2YWx1ZVR5cGVcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBwdWJsaWMgZ2V0VmFsdWVUeXBlKCk6IENsYXNzPD8+IHtcbiAgICAgICAgLy8gICByZXR1cm4gdmFsdWVUeXBlXG4gICAgICAgIC8vIH1cbiAgICB9KShEZWNvZGVIaW50VHlwZSB8fCAoRGVjb2RlSGludFR5cGUgPSB7fSkpO1xuICAgIHZhciBEZWNvZGVIaW50VHlwZSQxID0gRGVjb2RlSGludFR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgRm9ybWF0RXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICAgICAgc3RhdGljIGdldEZvcm1hdEluc3RhbmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBGb3JtYXRFeGNlcHRpb24ua2luZCA9ICdGb3JtYXRFeGNlcHRpb24nO1xuXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkhhc2hNYXA7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4gICAgdmFyIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnM7XG4gICAgKGZ1bmN0aW9uIChDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzKSB7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkNwNDM3XCJdID0gMF0gPSBcIkNwNDM3XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfMVwiXSA9IDFdID0gXCJJU084ODU5XzFcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8yXCJdID0gMl0gPSBcIklTTzg4NTlfMlwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzNcIl0gPSAzXSA9IFwiSVNPODg1OV8zXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfNFwiXSA9IDRdID0gXCJJU084ODU5XzRcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV81XCJdID0gNV0gPSBcIklTTzg4NTlfNVwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzZcIl0gPSA2XSA9IFwiSVNPODg1OV82XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfN1wiXSA9IDddID0gXCJJU084ODU5XzdcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV84XCJdID0gOF0gPSBcIklTTzg4NTlfOFwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzlcIl0gPSA5XSA9IFwiSVNPODg1OV85XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfMTBcIl0gPSAxMF0gPSBcIklTTzg4NTlfMTBcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xMVwiXSA9IDExXSA9IFwiSVNPODg1OV8xMVwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzEzXCJdID0gMTJdID0gXCJJU084ODU5XzEzXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfMTRcIl0gPSAxM10gPSBcIklTTzg4NTlfMTRcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xNVwiXSA9IDE0XSA9IFwiSVNPODg1OV8xNVwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzE2XCJdID0gMTVdID0gXCJJU084ODU5XzE2XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIlNKSVNcIl0gPSAxNl0gPSBcIlNKSVNcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQ3AxMjUwXCJdID0gMTddID0gXCJDcDEyNTBcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQ3AxMjUxXCJdID0gMThdID0gXCJDcDEyNTFcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQ3AxMjUyXCJdID0gMTldID0gXCJDcDEyNTJcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQ3AxMjU2XCJdID0gMjBdID0gXCJDcDEyNTZcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiVW5pY29kZUJpZ1VubWFya2VkXCJdID0gMjFdID0gXCJVbmljb2RlQmlnVW5tYXJrZWRcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiVVRGOFwiXSA9IDIyXSA9IFwiVVRGOFwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJBU0NJSVwiXSA9IDIzXSA9IFwiQVNDSUlcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQmlnNVwiXSA9IDI0XSA9IFwiQmlnNVwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJHQjE4MDMwXCJdID0gMjVdID0gXCJHQjE4MDMwXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkVVQ19LUlwiXSA9IDI2XSA9IFwiRVVDX0tSXCI7XG4gICAgfSkoQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycyB8fCAoQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycyA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogRW5jYXBzdWxhdGVzIGEgQ2hhcmFjdGVyIFNldCBFQ0ksIGFjY29yZGluZyB0byBcIkV4dGVuZGVkIENoYW5uZWwgSW50ZXJwcmV0YXRpb25zXCIgNS4zLjEuMVxuICAgICAqIG9mIElTTyAxODAwNC5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgQ2hhcmFjdGVyU2V0RUNJIHtcbiAgICAgICAgY29uc3RydWN0b3IodmFsdWVJZGVudGlmaWVyLCB2YWx1ZXNQYXJhbSwgbmFtZSwgLi4ub3RoZXJFbmNvZGluZ05hbWVzKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlSWRlbnRpZmllciA9IHZhbHVlSWRlbnRpZmllcjtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlc1BhcmFtID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gSW50MzJBcnJheS5mcm9tKFt2YWx1ZXNQYXJhbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXNQYXJhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3RoZXJFbmNvZGluZ05hbWVzID0gb3RoZXJFbmNvZGluZ05hbWVzO1xuICAgICAgICAgICAgQ2hhcmFjdGVyU2V0RUNJLlZBTFVFX0lERU5USUZJRVJfVE9fRUNJLnNldCh2YWx1ZUlkZW50aWZpZXIsIHRoaXMpO1xuICAgICAgICAgICAgQ2hhcmFjdGVyU2V0RUNJLk5BTUVfVE9fRUNJLnNldChuYW1lLCB0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7IGkgIT09IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICBDaGFyYWN0ZXJTZXRFQ0kuVkFMVUVTX1RPX0VDSS5zZXQodiwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG90aGVyTmFtZSBvZiBvdGhlckVuY29kaW5nTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBDaGFyYWN0ZXJTZXRFQ0kuTkFNRV9UT19FQ0kuc2V0KG90aGVyTmFtZSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hhcmFjdGVyU2V0RUNJKHZhbHVlOiBudW1iZXIgLyppbnQqLykge1xuICAgICAgICAvLyAgIHRoaXMobmV3IEludDMyQXJyYXkge3ZhbHVlfSlcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBDaGFyYWN0ZXJTZXRFQ0kodmFsdWU6IG51bWJlciAvKmludCovLCBTdHJpbmcuLi4gb3RoZXJFbmNvZGluZ05hbWVzKSB7XG4gICAgICAgIC8vICAgdGhpcy52YWx1ZXMgPSBuZXcgSW50MzJBcnJheSB7dmFsdWV9XG4gICAgICAgIC8vICAgdGhpcy5vdGhlckVuY29kaW5nTmFtZXMgPSBvdGhlckVuY29kaW5nTmFtZXNcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBDaGFyYWN0ZXJTZXRFQ0kodmFsdWVzOiBJbnQzMkFycmF5LCBTdHJpbmcuLi4gb3RoZXJFbmNvZGluZ05hbWVzKSB7XG4gICAgICAgIC8vICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXNcbiAgICAgICAgLy8gICB0aGlzLm90aGVyRW5jb2RpbmdOYW1lcyA9IG90aGVyRW5jb2RpbmdOYW1lc1xuICAgICAgICAvLyB9XG4gICAgICAgIGdldFZhbHVlSWRlbnRpZmllcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlSWRlbnRpZmllcjtcbiAgICAgICAgfVxuICAgICAgICBnZXROYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1swXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHZhbHVlIGNoYXJhY3RlciBzZXQgRUNJIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4ge0Bjb2RlIENoYXJhY3RlclNldEVDSX0gcmVwcmVzZW50aW5nIEVDSSBvZiBnaXZlbiB2YWx1ZSwgb3IgbnVsbCBpZiBpdCBpcyBsZWdhbCBidXRcbiAgICAgICAgICogICB1bnN1cHBvcnRlZFxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBFQ0kgdmFsdWUgaXMgaW52YWxpZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldENoYXJhY3RlclNldEVDSUJ5VmFsdWUodmFsdWUgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSA5MDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCdpbmNvcmVjdCB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhcmFjdGVyU2V0ID0gQ2hhcmFjdGVyU2V0RUNJLlZBTFVFU19UT19FQ0kuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNoYXJhY3RlclNldCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oJ2luY29yZWN0IHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhcmFjdGVyU2V0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gbmFtZSBjaGFyYWN0ZXIgc2V0IEVDSSBlbmNvZGluZyBuYW1lXG4gICAgICAgICAqIEByZXR1cm4gQ2hhcmFjdGVyU2V0RUNJIHJlcHJlc2VudGluZyBFQ0kgZm9yIGNoYXJhY3RlciBlbmNvZGluZywgb3IgbnVsbCBpZiBpdCBpcyBsZWdhbFxuICAgICAgICAgKiAgIGJ1dCB1bnN1cHBvcnRlZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldENoYXJhY3RlclNldEVDSUJ5TmFtZShuYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJTZXQgPSBDaGFyYWN0ZXJTZXRFQ0kuTkFNRV9UT19FQ0kuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY2hhcmFjdGVyU2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbignaW5jb3JlY3QgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGFyYWN0ZXJTZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBDaGFyYWN0ZXJTZXRFQ0kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZSgpID09PSBvdGhlci5nZXROYW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2hhcmFjdGVyU2V0RUNJLlZBTFVFX0lERU5USUZJRVJfVE9fRUNJID0gbmV3IE1hcCgpO1xuICAgIENoYXJhY3RlclNldEVDSS5WQUxVRVNfVE9fRUNJID0gbmV3IE1hcCgpO1xuICAgIENoYXJhY3RlclNldEVDSS5OQU1FX1RPX0VDSSA9IG5ldyBNYXAoKTtcbiAgICAvLyBFbnVtIG5hbWUgaXMgYSBKYXZhIGVuY29kaW5nIHZhbGlkIGZvciBqYXZhLmxhbmcgYW5kIGphdmEuaW9cbiAgICAvLyBUWVBFU0NSSVBUUE9SVDogY2hhbmdlZCB0aGUgbWFpbiBsYWJlbCBmb3IgSVNPIGFzIHRoZSBUZXh0RW5jb2RlciBkaWQgbm90IHJlY29nbml6ZWQgdGhlbSBpbiB0aGUgZm9ybSBmcm9tIGphdmFcbiAgICAvLyAoZWcgSVNPODg1OV8xIG11c3QgYmUgSVNPODg1OTEgb3IgSVNPODg1OS0xIG9yIElTTy04ODU5LTEpXG4gICAgLy8gbGF0ZXIgb246IHdlbGwsIGV4Y2VwdCAxNiB3aWNoIGRvZXMgbm90IHdvcmsgd2l0aCBJU084ODU5MTYgc28gdXNlZCBJU08tODg1OS0xIGZvcm0gZm9yIGRlZmF1bHRcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuQ3A0MzcgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQ3A0MzcsIEludDMyQXJyYXkuZnJvbShbMCwgMl0pLCAnQ3A0MzcnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMSwgSW50MzJBcnJheS5mcm9tKFsxLCAzXSksICdJU08tODg1OS0xJywgJ0lTTzg4NTkxJywgJ0lTTzg4NTlfMScpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzIgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8yLCA0LCAnSVNPLTg4NTktMicsICdJU084ODU5MicsICdJU084ODU5XzInKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8zID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMywgNSwgJ0lTTy04ODU5LTMnLCAnSVNPODg1OTMnLCAnSVNPODg1OV8zJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfNCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzQsIDYsICdJU08tODg1OS00JywgJ0lTTzg4NTk0JywgJ0lTTzg4NTlfNCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzUgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV81LCA3LCAnSVNPLTg4NTktNScsICdJU084ODU5NScsICdJU084ODU5XzUnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV82ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfNiwgOCwgJ0lTTy04ODU5LTYnLCAnSVNPODg1OTYnLCAnSVNPODg1OV82Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfNyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzcsIDksICdJU08tODg1OS03JywgJ0lTTzg4NTk3JywgJ0lTTzg4NTlfNycpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzggPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV84LCAxMCwgJ0lTTy04ODU5LTgnLCAnSVNPODg1OTgnLCAnSVNPODg1OV84Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfOSA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzksIDExLCAnSVNPLTg4NTktOScsICdJU084ODU5OScsICdJU084ODU5XzknKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xMCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzEwLCAxMiwgJ0lTTy04ODU5LTEwJywgJ0lTTzg4NTkxMCcsICdJU084ODU5XzEwJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTEgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8xMSwgMTMsICdJU08tODg1OS0xMScsICdJU084ODU5MTEnLCAnSVNPODg1OV8xMScpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzEzID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMTMsIDE1LCAnSVNPLTg4NTktMTMnLCAnSVNPODg1OTEzJywgJ0lTTzg4NTlfMTMnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xNCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzE0LCAxNiwgJ0lTTy04ODU5LTE0JywgJ0lTTzg4NTkxNCcsICdJU084ODU5XzE0Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTUgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8xNSwgMTcsICdJU08tODg1OS0xNScsICdJU084ODU5MTUnLCAnSVNPODg1OV8xNScpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzE2ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMTYsIDE4LCAnSVNPLTg4NTktMTYnLCAnSVNPODg1OTE2JywgJ0lTTzg4NTlfMTYnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuU0pJUyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5TSklTLCAyMCwgJ1NKSVMnLCAnU2hpZnRfSklTJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkNwMTI1MCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5DcDEyNTAsIDIxLCAnQ3AxMjUwJywgJ3dpbmRvd3MtMTI1MCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5DcDEyNTEgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQ3AxMjUxLCAyMiwgJ0NwMTI1MScsICd3aW5kb3dzLTEyNTEnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuQ3AxMjUyID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkNwMTI1MiwgMjMsICdDcDEyNTInLCAnd2luZG93cy0xMjUyJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkNwMTI1NiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5DcDEyNTYsIDI0LCAnQ3AxMjU2JywgJ3dpbmRvd3MtMTI1NicpO1xuICAgIENoYXJhY3RlclNldEVDSS5Vbmljb2RlQmlnVW5tYXJrZWQgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuVW5pY29kZUJpZ1VubWFya2VkLCAyNSwgJ1VuaWNvZGVCaWdVbm1hcmtlZCcsICdVVEYtMTZCRScsICdVbmljb2RlQmlnJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLlVURjggPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuVVRGOCwgMjYsICdVVEY4JywgJ1VURi04Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkFTQ0lJID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkFTQ0lJLCBJbnQzMkFycmF5LmZyb20oWzI3LCAxNzBdKSwgJ0FTQ0lJJywgJ1VTLUFTQ0lJJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkJpZzUgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQmlnNSwgMjgsICdCaWc1Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkdCMTgwMzAgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuR0IxODAzMCwgMjksICdHQjE4MDMwJywgJ0dCMjMxMicsICdFVUNfQ04nLCAnR0JLJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkVVQ19LUiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5FVUNfS1IsIDMwLCAnRVVDX0tSJywgJ0VVQy1LUicpO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICB9XG4gICAgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24ua2luZCA9ICdVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbic7XG5cbiAgICAvKipcbiAgICAgKiBSZXNwb25zaWJsZSBmb3IgZW4vZGVjb2Rpbmcgc3RyaW5ncy5cbiAgICAgKi9cbiAgICBjbGFzcyBTdHJpbmdFbmNvZGluZyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIHNvbWUgVWludDhBcnJheSB0byBhIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlKGJ5dGVzLCBlbmNvZGluZykge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RpbmdOYW1lID0gdGhpcy5lbmNvZGluZ05hbWUoZW5jb2RpbmcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VzdG9tRGVjb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbURlY29kZXIoYnl0ZXMsIGVuY29kaW5nTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbmNyZWFzZXMgYnJvd3NlciBzdXBwb3J0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5zaG91bGREZWNvZGVPbkZhbGxiYWNrKGVuY29kaW5nTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGYWxsYmFjayhieXRlcywgZW5jb2RpbmdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmdOYW1lKS5kZWNvZGUoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGRlY29kaW5nIG1ldGhvZCBzaG91bGQgdXNlIHRoZSBmYWxsYmFjayBmb3IgZGVjb2RpbmdcbiAgICAgICAgICogb25jZSBOb2RlIFRleHREZWNvZGVyIGRvZXNuJ3Qgc3VwcG9ydCBhbGwgZW5jb2RpbmcgZm9ybWF0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVuY29kaW5nTmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHNob3VsZERlY29kZU9uRmFsbGJhY2soZW5jb2RpbmdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gIVN0cmluZ0VuY29kaW5nLmlzQnJvd3NlcigpICYmIGVuY29kaW5nTmFtZSA9PT0gJ0lTTy04ODU5LTEnO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHNvbWUgc3RyaW5nIGludG8gYSBVaW50OEFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGVuY29kZShzLCBlbmNvZGluZykge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RpbmdOYW1lID0gdGhpcy5lbmNvZGluZ05hbWUoZW5jb2RpbmcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VzdG9tRW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbUVuY29kZXIocywgZW5jb2RpbmdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluY3JlYXNlcyBicm93c2VyIHN1cHBvcnQuXG4gICAgICAgICAgICBpZiAodHlwZW9mIFRleHRFbmNvZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZUZhbGxiYWNrKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGV4dEVuY29kZXIgb25seSBlbmNvZGVzIHRvIFVURjggYnkgZGVmYXVsdCBhcyBzcGVjaWZpZWQgYnkgZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpc0Jyb3dzZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwod2luZG93KSA9PT0gJ1tvYmplY3QgV2luZG93XScpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgdmFsdWUgZnJvbSBzb21lIGVuY29kaW5nIGNoYXJhY3RlciBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZW5jb2RpbmdOYW1lKGVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gZW5jb2RpbmdcbiAgICAgICAgICAgICAgICA6IGVuY29kaW5nLmdldE5hbWUoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBjaGFyYWN0ZXIgc2V0IGZyb20gc29tZSBlbmNvZGluZyBjaGFyYWN0ZXIgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGVuY29kaW5nQ2hhcmFjdGVyU2V0KGVuY29kaW5nKSB7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmcgaW5zdGFuY2VvZiBDaGFyYWN0ZXJTZXRFQ0kpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2Rpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ2hhcmFjdGVyU2V0RUNJLmdldENoYXJhY3RlclNldEVDSUJ5TmFtZShlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJ1bnMgYSBmYWxsYmFjayBmb3IgdGhlIG5hdGl2ZSBkZWNvZGluZyBmdW5jaW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZUZhbGxiYWNrKGJ5dGVzLCBlbmNvZGluZykge1xuICAgICAgICAgICAgY29uc3QgY2hhcmFjdGVyU2V0ID0gdGhpcy5lbmNvZGluZ0NoYXJhY3RlclNldChlbmNvZGluZyk7XG4gICAgICAgICAgICBpZiAoU3RyaW5nRW5jb2RpbmcuaXNEZWNvZGVGYWxsYmFja1N1cHBvcnRlZChjaGFyYWN0ZXJTZXQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGggPSBieXRlc1tpXS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHMgKz0gJyUnICsgaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJTZXQuZXF1YWxzKENoYXJhY3RlclNldEVDSS5Vbmljb2RlQmlnVW5tYXJrZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGJ5dGVzLmJ1ZmZlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKGBFbmNvZGluZyAke3RoaXMuZW5jb2RpbmdOYW1lKGVuY29kaW5nKX0gbm90IHN1cHBvcnRlZCBieSBmYWxsYmFjay5gKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXNEZWNvZGVGYWxsYmFja1N1cHBvcnRlZChjaGFyYWN0ZXJTZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFyYWN0ZXJTZXQuZXF1YWxzKENoYXJhY3RlclNldEVDSS5VVEY4KSB8fFxuICAgICAgICAgICAgICAgIGNoYXJhY3RlclNldC5lcXVhbHMoQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMSkgfHxcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJTZXQuZXF1YWxzKENoYXJhY3RlclNldEVDSS5BU0NJSSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJ1bnMgYSBmYWxsYmFjayBmb3IgdGhlIG5hdGl2ZSBlbmNvZGluZyBmdW5jaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzE5Mjg0NS80MzY3NjgzXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZW5jb2RlRmFsbGJhY2socykge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZFVSSXN0cmluZyA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHMpKSk7XG4gICAgICAgICAgICBjb25zdCBjaGFyTGlzdCA9IGVuY29kZWRVUklzdHJpbmcuc3BsaXQoJycpO1xuICAgICAgICAgICAgY29uc3QgdWludEFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdWludEFycmF5LnB1c2goY2hhckxpc3RbaV0uY2hhckNvZGVBdCgwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodWludEFycmF5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IChDKSAyMDEwIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENvbW1vbiBzdHJpbmctcmVsYXRlZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBhdXRob3IgQWxleCBEdXByZVxuICAgICAqL1xuICAgIGNsYXNzIFN0cmluZ1V0aWxzIHtcbiAgICAgICAgLy8gU0hJRlRfSklTLmVxdWFsc0lnbm9yZUNhc2UoUExBVEZPUk1fREVGQVVMVF9FTkNPRElORykgfHxcbiAgICAgICAgLy8gRVVDX0pQLmVxdWFsc0lnbm9yZUNhc2UoUExBVEZPUk1fREVGQVVMVF9FTkNPRElORyk7XG4gICAgICAgIHN0YXRpYyBjYXN0QXNOb25VdGY4Q2hhcihjb2RlLCBlbmNvZGluZyA9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElTTyA4ODU5LTEgaXMgdGhlIEphdmEgZGVmYXVsdCBhcyBVVEYtOCBpcyBKYXZhU2NyaXB0c1xuICAgICAgICAgICAgLy8geW91IGNhbiBzZWUgdGhpcyBtZXRob2QgYXMgYSBKYXZhIHZlcnNpb24gb2YgU3RyaW5nLmZyb21DaGFyQ29kZVxuICAgICAgICAgICAgY29uc3QgZSA9IGVuY29kaW5nID8gZW5jb2RpbmcuZ2V0TmFtZSgpIDogdGhpcy5JU084ODU5MTtcbiAgICAgICAgICAgIC8vIHVzZSBwYXNzZWQgZm9ybWF0IChmcm9tQ2hhckNvZGUgd2lsbCByZXR1cm4gVVRGOCBlbmNvZGluZylcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdFbmNvZGluZy5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoW2NvZGVdKSwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBieXRlcyBieXRlcyBlbmNvZGluZyBhIHN0cmluZywgd2hvc2UgZW5jb2Rpbmcgc2hvdWxkIGJlIGd1ZXNzZWRcbiAgICAgICAgICogQHBhcmFtIGhpbnRzIGRlY29kZSBoaW50cyBpZiBhcHBsaWNhYmxlXG4gICAgICAgICAqIEByZXR1cm4gbmFtZSBvZiBndWVzc2VkIGVuY29kaW5nOyBhdCB0aGUgbW9tZW50IHdpbGwgb25seSBndWVzcyBvbmUgb2Y6XG4gICAgICAgICAqICB7QGxpbmsgI1NISUZUX0pJU30sIHtAbGluayAjVVRGOH0sIHtAbGluayAjSVNPODg1OTF9LCBvciB0aGUgcGxhdGZvcm1cbiAgICAgICAgICogIGRlZmF1bHQgZW5jb2RpbmcgaWYgbm9uZSBvZiB0aGVzZSBjYW4gcG9zc2libHkgYmUgY29ycmVjdFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGd1ZXNzRW5jb2RpbmcoYnl0ZXMsIGhpbnRzKSB7XG4gICAgICAgICAgICBpZiAoaGludHMgIT09IG51bGwgJiYgaGludHMgIT09IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQgIT09IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLkNIQVJBQ1RFUl9TRVQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLkNIQVJBQ1RFUl9TRVQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb3Igbm93LCBtZXJlbHkgdHJpZXMgdG8gZGlzdGluZ3Vpc2ggSVNPLTg4NTktMSwgVVRGLTggYW5kIFNoaWZ0X0pJUyxcbiAgICAgICAgICAgIC8vIHdoaWNoIHNob3VsZCBiZSBieSBmYXIgdGhlIG1vc3QgY29tbW9uIGVuY29kaW5ncy5cbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBjYW5CZUlTTzg4NTkxID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBjYW5CZVNoaWZ0SklTID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBjYW5CZVVURjggPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHV0ZjhCeXRlc0xlZnQgPSAwO1xuICAgICAgICAgICAgLy8gaW50IHV0ZjhMb3dDaGFycyA9IDBcbiAgICAgICAgICAgIGxldCB1dGYyQnl0ZXNDaGFycyA9IDA7XG4gICAgICAgICAgICBsZXQgdXRmM0J5dGVzQ2hhcnMgPSAwO1xuICAgICAgICAgICAgbGV0IHV0ZjRCeXRlc0NoYXJzID0gMDtcbiAgICAgICAgICAgIGxldCBzamlzQnl0ZXNMZWZ0ID0gMDtcbiAgICAgICAgICAgIC8vIGludCBzamlzTG93Q2hhcnMgPSAwXG4gICAgICAgICAgICBsZXQgc2ppc0thdGFrYW5hQ2hhcnMgPSAwO1xuICAgICAgICAgICAgLy8gaW50IHNqaXNEb3VibGVCeXRlc0NoYXJzID0gMFxuICAgICAgICAgICAgbGV0IHNqaXNDdXJLYXRha2FuYVdvcmRMZW5ndGggPSAwO1xuICAgICAgICAgICAgbGV0IHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGggPSAwO1xuICAgICAgICAgICAgbGV0IHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGggPSAwO1xuICAgICAgICAgICAgbGV0IHNqaXNNYXhEb3VibGVCeXRlc1dvcmRMZW5ndGggPSAwO1xuICAgICAgICAgICAgLy8gaW50IGlzb0xvd0NoYXJzID0gMFxuICAgICAgICAgICAgLy8gaW50IGlzb0hpZ2hDaGFycyA9IDBcbiAgICAgICAgICAgIGxldCBpc29IaWdoT3RoZXIgPSAwO1xuICAgICAgICAgICAgY29uc3QgdXRmOGJvbSA9IGJ5dGVzLmxlbmd0aCA+IDMgJiZcbiAgICAgICAgICAgICAgICBieXRlc1swXSA9PT0gLyooYnl0ZSkgKi8gMHhFRiAmJlxuICAgICAgICAgICAgICAgIGJ5dGVzWzFdID09PSAvKihieXRlKSAqLyAweEJCICYmXG4gICAgICAgICAgICAgICAgYnl0ZXNbMl0gPT09IC8qKGJ5dGUpICovIDB4QkY7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aCAmJiAoY2FuQmVJU084ODU5MSB8fCBjYW5CZVNoaWZ0SklTIHx8IGNhbkJlVVRGOCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYnl0ZXNbaV0gJiAweEZGO1xuICAgICAgICAgICAgICAgIC8vIFVURi04IHN0dWZmXG4gICAgICAgICAgICAgICAgaWYgKGNhbkJlVVRGOCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXRmOEJ5dGVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgJiAweDgwKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlVVRGOCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmOEJ5dGVzTGVmdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh2YWx1ZSAmIDB4ODApICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgMHg0MCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5CZVVURjggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhCeXRlc0xlZnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgMHgyMCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmMkJ5dGVzQ2hhcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhCeXRlc0xlZnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4MTApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGYzQnl0ZXNDaGFycysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmOEJ5dGVzTGVmdCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4MDgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmNEJ5dGVzQ2hhcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlVVRGOCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IC8vIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB1dGY4TG93Q2hhcnMrK1xuICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElTTy04ODU5LTEgc3R1ZmZcbiAgICAgICAgICAgICAgICBpZiAoY2FuQmVJU084ODU5MSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAweDdGICYmIHZhbHVlIDwgMHhBMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVJU084ODU5MSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID4gMHg5Rikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHhDMCB8fCB2YWx1ZSA9PT0gMHhENyB8fCB2YWx1ZSA9PT0gMHhGNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzb0hpZ2hPdGhlcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzb0hpZ2hDaGFycysrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzb0xvd0NoYXJzKytcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaGlmdF9KSVMgc3R1ZmZcbiAgICAgICAgICAgICAgICBpZiAoY2FuQmVTaGlmdEpJUykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2ppc0J5dGVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4NDAgfHwgdmFsdWUgPT09IDB4N0YgfHwgdmFsdWUgPiAweEZDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVTaGlmdEpJUyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ppc0J5dGVzTGVmdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAweDgwIHx8IHZhbHVlID09PSAweEEwIHx8IHZhbHVlID4gMHhFRikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVTaGlmdEpJUyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID4gMHhBMCAmJiB2YWx1ZSA8IDB4RTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNLYXRha2FuYUNoYXJzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNDdXJLYXRha2FuYVdvcmRMZW5ndGgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID4gc2ppc01heEthdGFrYW5hV29yZExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGggPSBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID4gMHg3Rikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2ppc0J5dGVzTGVmdCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2ppc0RvdWJsZUJ5dGVzQ2hhcnMrK1xuICAgICAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aCA+IHNqaXNNYXhEb3VibGVCeXRlc1dvcmRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNqaXNMb3dDaGFycysrXG4gICAgICAgICAgICAgICAgICAgICAgICBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbkJlVVRGOCAmJiB1dGY4Qnl0ZXNMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICAgIGNhbkJlVVRGOCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbkJlU2hpZnRKSVMgJiYgc2ppc0J5dGVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICBjYW5CZVNoaWZ0SklTID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFYXN5IC0tIGlmIHRoZXJlIGlzIEJPTSBvciBhdCBsZWFzdCAxIHZhbGlkIG5vdC1zaW5nbGUgYnl0ZSBjaGFyYWN0ZXIgKGFuZCBubyBldmlkZW5jZSBpdCBjYW4ndCBiZSBVVEYtOCksIGRvbmVcbiAgICAgICAgICAgIGlmIChjYW5CZVVURjggJiYgKHV0Zjhib20gfHwgdXRmMkJ5dGVzQ2hhcnMgKyB1dGYzQnl0ZXNDaGFycyArIHV0ZjRCeXRlc0NoYXJzID4gMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuVVRGODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVhc3kgLS0gaWYgYXNzdW1pbmcgU2hpZnRfSklTIG9yIGF0IGxlYXN0IDMgdmFsaWQgY29uc2VjdXRpdmUgbm90LWFzY2lpIGNoYXJhY3RlcnMgKGFuZCBubyBldmlkZW5jZSBpdCBjYW4ndCBiZSksIGRvbmVcbiAgICAgICAgICAgIGlmIChjYW5CZVNoaWZ0SklTICYmIChTdHJpbmdVdGlscy5BU1NVTUVfU0hJRlRfSklTIHx8IHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGggPj0gMyB8fCBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoID49IDMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLlNISUZUX0pJUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERpc3Rpbmd1aXNoaW5nIFNoaWZ0X0pJUyBhbmQgSVNPLTg4NTktMSBjYW4gYmUgYSBsaXR0bGUgdG91Z2ggZm9yIHNob3J0IHdvcmRzLiBUaGUgY3J1ZGUgaGV1cmlzdGljIGlzOlxuICAgICAgICAgICAgLy8gLSBJZiB3ZSBzYXdcbiAgICAgICAgICAgIC8vICAgLSBvbmx5IHR3byBjb25zZWN1dGl2ZSBrYXRha2FuYSBjaGFycyBpbiB0aGUgd2hvbGUgdGV4dCwgb3JcbiAgICAgICAgICAgIC8vICAgLSBhdCBsZWFzdCAxMCUgb2YgYnl0ZXMgdGhhdCBjb3VsZCBiZSBcInVwcGVyXCIgbm90LWFscGhhbnVtZXJpYyBMYXRpbjEsXG4gICAgICAgICAgICAvLyAtIHRoZW4gd2UgY29uY2x1ZGUgU2hpZnRfSklTLCBlbHNlIElTTy04ODU5LTFcbiAgICAgICAgICAgIGlmIChjYW5CZUlTTzg4NTkxICYmIGNhbkJlU2hpZnRKSVMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGggPT09IDIgJiYgc2ppc0thdGFrYW5hQ2hhcnMgPT09IDIpIHx8IGlzb0hpZ2hPdGhlciAqIDEwID49IGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA/IFN0cmluZ1V0aWxzLlNISUZUX0pJUyA6IFN0cmluZ1V0aWxzLklTTzg4NTkxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0cnkgaW4gb3JkZXIgSVNPLTg4NTktMSwgU2hpZnQgSklTLCBVVEYtOCBhbmQgZmFsbCBiYWNrIHRvIGRlZmF1bHQgcGxhdGZvcm0gZW5jb2RpbmdcbiAgICAgICAgICAgIGlmIChjYW5CZUlTTzg4NTkxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLklTTzg4NTkxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbkJlU2hpZnRKSVMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuU0hJRlRfSklTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbkJlVVRGOCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmdVdGlscy5VVEY4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSB0YWtlIGEgd2lsZCBndWVzcyB3aXRoIHBsYXRmb3JtIGVuY29kaW5nXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuUExBVEZPUk1fREVGQVVMVF9FTkNPRElORztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTM0Mzk3MTEvNDM2NzY4M1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYXBwZW5kIFRoZSBuZXcgc3RyaW5nIHRvIGFwcGVuZC5cbiAgICAgICAgICogQHBhcmFtIGFyZ3MgQXJndW1ldHMgdmFsdWVzIHRvIGJlIGZvcm1hdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZvcm1hdChhcHBlbmQsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGxldCBpID0gLTE7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhleHAsIHAwLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgICAgIGlmIChleHAgPT09ICclJScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJSc7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbKytpXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGV4cCA9IHAyID8gcGFyc2VJbnQocDIuc3Vic3RyKDEpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZSA9IHAzID8gcGFyc2VJbnQocDMuc3Vic3RyKDEpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgdmFsO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocDQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcmdzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gYXJnc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQoYXJnc1tpXSkudG9GaXhlZChleHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChhcmdzW2ldKS50b1ByZWNpc2lvbihleHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChhcmdzW2ldKS50b0V4cG9uZW50aWFsKGV4cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUludChhcmdzW2ldKS50b1N0cmluZyhiYXNlID8gYmFzZSA6IDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQocGFyc2VJbnQoYXJnc1tpXSwgYmFzZSA/IGJhc2UgOiAxMCkudG9QcmVjaXNpb24oZXhwKSkudG9GaXhlZCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KHZhbCkgOiAoK3ZhbCkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChwMSk7IC8qIHBhZGRpbmcgc2l6ZSAqL1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IHAxICYmIChwMVswXSArICcnKSA9PT0gJzAnID8gJzAnIDogJyAnOyAvKiBpc251bGw/ICovXG4gICAgICAgICAgICAgICAgd2hpbGUgKHZhbC5sZW5ndGggPCBzaXplKVxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwMCAhPT0gdW5kZWZpbmVkID8gdmFsICsgY2ggOiBjaCArIHZhbDsgLyogaXNtaW51cz8gKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gLyUoLSk/KDA/WzAtOV0rKT8oWy5dWzAtOV0rKT8oWyNdWzAtOV0rKT8oW3NjZnBleGQlXSkvZztcbiAgICAgICAgICAgIHJldHVybiBhcHBlbmQucmVwbGFjZShyZWdleCwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldEJ5dGVzKHN0ciwgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdFbmNvZGluZy5lbmNvZGUoc3RyLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNoYXJjb2RlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb3IgYXQgaW5kZXggemVyby5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRDaGFyQ29kZShzdHIsIGluZGV4ID0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBjaGFyIGZvciBnaXZlbiBjaGFyY29kZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldENoYXJBdChjaGFyQ29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN0cmluZ1V0aWxzLlNISUZUX0pJUyA9IENoYXJhY3RlclNldEVDSS5TSklTLmdldE5hbWUoKTsgLy8gXCJTSklTXCJcbiAgICBTdHJpbmdVdGlscy5HQjIzMTIgPSAnR0IyMzEyJztcbiAgICBTdHJpbmdVdGlscy5JU084ODU5MSA9IENoYXJhY3RlclNldEVDSS5JU084ODU5XzEuZ2V0TmFtZSgpOyAvLyBcIklTTzg4NTlfMVwiXG4gICAgU3RyaW5nVXRpbHMuRVVDX0pQID0gJ0VVQ19KUCc7XG4gICAgU3RyaW5nVXRpbHMuVVRGOCA9IENoYXJhY3RlclNldEVDSS5VVEY4LmdldE5hbWUoKTsgLy8gXCJVVEY4XCJcbiAgICBTdHJpbmdVdGlscy5QTEFURk9STV9ERUZBVUxUX0VOQ09ESU5HID0gU3RyaW5nVXRpbHMuVVRGODsgLy8gXCJVVEY4XCIvL0NoYXJzZXQuZGVmYXVsdENoYXJzZXQoKS5uYW1lKClcbiAgICBTdHJpbmdVdGlscy5BU1NVTUVfU0hJRlRfSklTID0gZmFsc2U7XG5cbiAgICBjbGFzcyBTdHJpbmdCdWlsZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IodmFsdWUgPSAnJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVuYWJsZURlY29kaW5nKGVuY29kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmQocykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgKz0gcy50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5lbmNvZGluZykge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBwYXNzZWQgZm9ybWF0IChmcm9tQ2hhckNvZGUgd2lsbCByZXR1cm4gVVRGOCBlbmNvZGluZylcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlICs9IFN0cmluZ1V0aWxzLmNhc3RBc05vblV0ZjhDaGFyKHMsIHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdGx5IGNvbnZlcnRzIGZyb20gVVRGLTgsIGJ1dCBub3Qgb3RoZXIgZW5jb2RpbmdzXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kQ2hhcnMoc3RyLCBvZmZzZXQsIGxlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgb2Zmc2V0IDwgb2Zmc2V0ICsgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChzdHJbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNoYXJBdChuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5jaGFyQXQobik7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlQ2hhckF0KG4pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLnN1YnN0cigwLCBuKSArIHRoaXMudmFsdWUuc3Vic3RyaW5nKG4gKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRDaGFyQXQobiwgYykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuc3Vic3RyKDAsIG4pICsgYyArIHRoaXMudmFsdWUuc3Vic3RyKG4gKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzdHJpbmcoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbm90ZSBoZWxwZXIgbWV0aG9kIGZvciBSU1MgRXhwYW5kZWRcbiAgICAgICAgICovXG4gICAgICAgIHNldExlbmd0aFRvWmVybygpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChuLCBjKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5zdWJzdHIoMCwgbikgKyBjICsgdGhpcy52YWx1ZS5zdWJzdHIobiArIGMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+UmVwcmVzZW50cyBhIDJEIG1hdHJpeCBvZiBiaXRzLiBJbiBmdW5jdGlvbiBhcmd1bWVudHMgYmVsb3csIGFuZCB0aHJvdWdob3V0IHRoZSBjb21tb25cbiAgICAgKiBtb2R1bGUsIHggaXMgdGhlIGNvbHVtbiBwb3NpdGlvbiwgYW5kIHkgaXMgdGhlIHJvdyBwb3NpdGlvbi4gVGhlIG9yZGVyaW5nIGlzIGFsd2F5cyB4LCB5LlxuICAgICAqIFRoZSBvcmlnaW4gaXMgYXQgdGhlIHRvcC1sZWZ0LjwvcD5cbiAgICAgKlxuICAgICAqIDxwPkludGVybmFsbHkgdGhlIGJpdHMgYXJlIHJlcHJlc2VudGVkIGluIGEgMS1EIGFycmF5IG9mIDMyLWJpdCBpbnRzLiBIb3dldmVyLCBlYWNoIHJvdyBiZWdpbnNcbiAgICAgKiB3aXRoIGEgbmV3IGludC4gVGhpcyBpcyBkb25lIGludGVudGlvbmFsbHkgc28gdGhhdCB3ZSBjYW4gY29weSBvdXQgYSByb3cgaW50byBhIEJpdEFycmF5IHZlcnlcbiAgICAgKiBlZmZpY2llbnRseS48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaGUgb3JkZXJpbmcgb2YgYml0cyBpcyByb3ctbWFqb3IuIFdpdGhpbiBlYWNoIGludCwgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgYXJlIHVzZWQgZmlyc3QsXG4gICAgICogbWVhbmluZyB0aGV5IHJlcHJlc2VudCBsb3dlciB4IHZhbHVlcy4gVGhpcyBpcyBjb21wYXRpYmxlIHdpdGggQml0QXJyYXkncyBpbXBsZW1lbnRhdGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICovXG4gICAgY2xhc3MgQml0TWF0cml4IC8qaW1wbGVtZW50cyBDbG9uZWFibGUqLyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGVtcHR5IHNxdWFyZSB7QGxpbmsgQml0TWF0cml4fS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRpbWVuc2lvbiBoZWlnaHQgYW5kIHdpZHRoXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IoZGltZW5zaW9uOiBudW1iZXIgLyppbnQqLykge1xuICAgICAgICAvLyAgIHRoaXMoZGltZW5zaW9uLCBkaW1lbnNpb24pXG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gZW1wdHkge0BsaW5rIEJpdE1hdHJpeH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB3aWR0aCBiaXQgbWF0cml4IHdpZHRoXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHQgYml0IG1hdHJpeCBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3Rvcih3aWR0aDogbnVtYmVyIC8qaW50Ki8sIGhlaWdodDogbnVtYmVyIC8qaW50Ki8pIHtcbiAgICAgICAgLy8gICBpZiAod2lkdGggPCAxIHx8IGhlaWdodCA8IDEpIHtcbiAgICAgICAgLy8gICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJCb3RoIGRpbWVuc2lvbnMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiKVxuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gICB0aGlzLndpZHRoID0gd2lkdGhcbiAgICAgICAgLy8gICB0aGlzLmhlaWdodCA9IGhlaWdodFxuICAgICAgICAvLyAgIHRoaXMucm93U2l6ZSA9ICh3aWR0aCArIDMxKSAvIDMyXG4gICAgICAgIC8vICAgYml0cyA9IG5ldyBpbnRbcm93U2l6ZSAqIGhlaWdodF07XG4gICAgICAgIC8vIH1cbiAgICAgICAgY29uc3RydWN0b3Iod2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8sIHJvd1NpemUgLyppbnQqLywgYml0cykge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnJvd1NpemUgPSByb3dTaXplO1xuICAgICAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGhlaWdodCB8fCBudWxsID09PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMSB8fCBoZWlnaHQgPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQm90aCBkaW1lbnNpb25zIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHJvd1NpemUgfHwgbnVsbCA9PT0gcm93U2l6ZSkge1xuICAgICAgICAgICAgICAgIHJvd1NpemUgPSBNYXRoLmZsb29yKCh3aWR0aCArIDMxKSAvIDMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucm93U2l6ZSA9IHJvd1NpemU7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBiaXRzIHx8IG51bGwgPT09IGJpdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpdHMgPSBuZXcgSW50MzJBcnJheSh0aGlzLnJvd1NpemUgKiB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVycHJldHMgYSAyRCBhcnJheSBvZiBib29sZWFucyBhcyBhIHtAbGluayBCaXRNYXRyaXh9LCB3aGVyZSBcInRydWVcIiBtZWFucyBhbiBcIm9uXCIgYml0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZnVuY3Rpb24gcGFyc2VcbiAgICAgICAgICogQHBhcmFtIGltYWdlIGJpdHMgb2YgdGhlIGltYWdlLCBhcyBhIHJvdy1tYWpvciAyRCBhcnJheS4gRWxlbWVudHMgYXJlIGFycmF5cyByZXByZXNlbnRpbmcgcm93c1xuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBCaXRNYXRyaXh9IHJlcHJlc2VudGF0aW9uIG9mIGltYWdlXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcGFyc2VGcm9tQm9vbGVhbkFycmF5KGltYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBuZXcgQml0TWF0cml4KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlSSA9IGltYWdlW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VJW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRzLnNldChqLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZnVuY3Rpb24gcGFyc2VcbiAgICAgICAgICogQHBhcmFtIHN0cmluZ1JlcHJlc2VudGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSBzZXRTdHJpbmdcbiAgICAgICAgICogQHBhcmFtIHVuc2V0U3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcGFyc2VGcm9tU3RyaW5nKHN0cmluZ1JlcHJlc2VudGF0aW9uLCBzZXRTdHJpbmcsIHVuc2V0U3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAoc3RyaW5nUmVwcmVzZW50YXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdzdHJpbmdSZXByZXNlbnRhdGlvbiBjYW5ub3QgYmUgbnVsbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYml0cyA9IG5ldyBBcnJheShzdHJpbmdSZXByZXNlbnRhdGlvbi5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGJpdHNQb3MgPSAwO1xuICAgICAgICAgICAgbGV0IHJvd1N0YXJ0UG9zID0gMDtcbiAgICAgICAgICAgIGxldCByb3dMZW5ndGggPSAtMTtcbiAgICAgICAgICAgIGxldCBuUm93cyA9IDA7XG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBzdHJpbmdSZXByZXNlbnRhdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nUmVwcmVzZW50YXRpb24uY2hhckF0KHBvcykgPT09ICdcXG4nIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1JlcHJlc2VudGF0aW9uLmNoYXJBdChwb3MpID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYml0c1BvcyA+IHJvd1N0YXJ0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93TGVuZ3RoID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0xlbmd0aCA9IGJpdHNQb3MgLSByb3dTdGFydFBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJpdHNQb3MgLSByb3dTdGFydFBvcyAhPT0gcm93TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigncm93IGxlbmd0aHMgZG8gbm90IG1hdGNoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dTdGFydFBvcyA9IGJpdHNQb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBuUm93cysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHJpbmdSZXByZXNlbnRhdGlvbi5zdWJzdHJpbmcocG9zLCBwb3MgKyBzZXRTdHJpbmcubGVuZ3RoKSA9PT0gc2V0U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBzZXRTdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBiaXRzW2JpdHNQb3NdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYml0c1BvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHJpbmdSZXByZXNlbnRhdGlvbi5zdWJzdHJpbmcocG9zLCBwb3MgKyB1bnNldFN0cmluZy5sZW5ndGgpID09PSB1bnNldFN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gdW5zZXRTdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBiaXRzW2JpdHNQb3NdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJpdHNQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ2lsbGVnYWwgY2hhcmFjdGVyIGVuY291bnRlcmVkOiAnICsgc3RyaW5nUmVwcmVzZW50YXRpb24uc3Vic3RyaW5nKHBvcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vIEVPTCBhdCBlbmQ/XG4gICAgICAgICAgICBpZiAoYml0c1BvcyA+IHJvd1N0YXJ0UG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0xlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93TGVuZ3RoID0gYml0c1BvcyAtIHJvd1N0YXJ0UG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiaXRzUG9zIC0gcm93U3RhcnRQb3MgIT09IHJvd0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdyb3cgbGVuZ3RocyBkbyBub3QgbWF0Y2gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgblJvd3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBCaXRNYXRyaXgocm93TGVuZ3RoLCBuUm93cyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpdHNQb3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChiaXRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoTWF0aC5mbG9vcihpICUgcm93TGVuZ3RoKSwgTWF0aC5mbG9vcihpIC8gcm93TGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+R2V0cyB0aGUgcmVxdWVzdGVkIGJpdCwgd2hlcmUgdHJ1ZSBtZWFucyBibGFjay48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB4IFRoZSBob3Jpem9udGFsIGNvbXBvbmVudCAoaS5lLiB3aGljaCBjb2x1bW4pXG4gICAgICAgICAqIEBwYXJhbSB5IFRoZSB2ZXJ0aWNhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggcm93KVxuICAgICAgICAgKiBAcmV0dXJuIHZhbHVlIG9mIGdpdmVuIGJpdCBpbiBtYXRyaXhcbiAgICAgICAgICovXG4gICAgICAgIGdldCh4IC8qaW50Ki8sIHkgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHRoaXMucm93U2l6ZSArIE1hdGguZmxvb3IoeCAvIDMyKTtcbiAgICAgICAgICAgIHJldHVybiAoKHRoaXMuYml0c1tvZmZzZXRdID4+PiAoeCAmIDB4MWYpKSAmIDEpICE9PSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5TZXRzIHRoZSBnaXZlbiBiaXQgdG8gdHJ1ZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB4IFRoZSBob3Jpem9udGFsIGNvbXBvbmVudCAoaS5lLiB3aGljaCBjb2x1bW4pXG4gICAgICAgICAqIEBwYXJhbSB5IFRoZSB2ZXJ0aWNhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggcm93KVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0KHggLyppbnQqLywgeSAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB5ICogdGhpcy5yb3dTaXplICsgTWF0aC5mbG9vcih4IC8gMzIpO1xuICAgICAgICAgICAgdGhpcy5iaXRzW29mZnNldF0gfD0gKDEgPDwgKHggJiAweDFmKSkgJiAweEZGRkZGRkZGO1xuICAgICAgICB9XG4gICAgICAgIHVuc2V0KHggLyppbnQqLywgeSAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB5ICogdGhpcy5yb3dTaXplICsgTWF0aC5mbG9vcih4IC8gMzIpO1xuICAgICAgICAgICAgdGhpcy5iaXRzW29mZnNldF0gJj0gfigoMSA8PCAoeCAmIDB4MWYpKSAmIDB4RkZGRkZGRkYpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5GbGlwcyB0aGUgZ2l2ZW4gYml0LjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHggVGhlIGhvcml6b250YWwgY29tcG9uZW50IChpLmUuIHdoaWNoIGNvbHVtbilcbiAgICAgICAgICogQHBhcmFtIHkgVGhlIHZlcnRpY2FsIGNvbXBvbmVudCAoaS5lLiB3aGljaCByb3cpXG4gICAgICAgICAqL1xuICAgICAgICBmbGlwKHggLyppbnQqLywgeSAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB5ICogdGhpcy5yb3dTaXplICsgTWF0aC5mbG9vcih4IC8gMzIpO1xuICAgICAgICAgICAgdGhpcy5iaXRzW29mZnNldF0gXj0gKCgxIDw8ICh4ICYgMHgxZikpICYgMHhGRkZGRkZGRik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4Y2x1c2l2ZS1vciAoWE9SKTogRmxpcCB0aGUgYml0IGluIHRoaXMge0Bjb2RlIEJpdE1hdHJpeH0gaWYgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgICogbWFzayBiaXQgaXMgc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbWFzayBYT1IgbWFza1xuICAgICAgICAgKi9cbiAgICAgICAgeG9yKG1hc2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoICE9PSBtYXNrLmdldFdpZHRoKCkgfHwgdGhpcy5oZWlnaHQgIT09IG1hc2suZ2V0SGVpZ2h0KClcbiAgICAgICAgICAgICAgICB8fCB0aGlzLnJvd1NpemUgIT09IG1hc2suZ2V0Um93U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignaW5wdXQgbWF0cml4IGRpbWVuc2lvbnMgZG8gbm90IG1hdGNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3dBcnJheSA9IG5ldyBCaXRBcnJheShNYXRoLmZsb29yKHRoaXMud2lkdGggLyAzMikgKyAxKTtcbiAgICAgICAgICAgIGNvbnN0IHJvd1NpemUgPSB0aGlzLnJvd1NpemU7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDAsIGhlaWdodCA9IHRoaXMuaGVpZ2h0OyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB5ICogcm93U2l6ZTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3cgPSBtYXNrLmdldFJvdyh5LCByb3dBcnJheSkuZ2V0Qml0QXJyYXkoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHJvd1NpemU7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBiaXRzW29mZnNldCArIHhdIF49IHJvd1t4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBhbGwgYml0cyAoc2V0cyB0byBmYWxzZSkuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcigpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBjb25zdCBtYXggPSBiaXRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBiaXRzW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+U2V0cyBhIHNxdWFyZSByZWdpb24gb2YgdGhlIGJpdCBtYXRyaXggdG8gdHJ1ZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBob3Jpem9udGFsIHBvc2l0aW9uIHRvIGJlZ2luIGF0IChpbmNsdXNpdmUpXG4gICAgICAgICAqIEBwYXJhbSB0b3AgVGhlIHZlcnRpY2FsIHBvc2l0aW9uIHRvIGJlZ2luIGF0IChpbmNsdXNpdmUpXG4gICAgICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHJlZ2lvblxuICAgICAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHJlZ2lvblxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UmVnaW9uKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAodG9wIDwgMCB8fCBsZWZ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0xlZnQgYW5kIHRvcCBtdXN0IGJlIG5vbm5lZ2F0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgMSB8fCB3aWR0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdIZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgYXQgbGVhc3QgMScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgICAgICAgICBpZiAoYm90dG9tID4gdGhpcy5oZWlnaHQgfHwgcmlnaHQgPiB0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVGhlIHJlZ2lvbiBtdXN0IGZpdCBpbnNpZGUgdGhlIG1hdHJpeCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm93U2l6ZSA9IHRoaXMucm93U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gdG9wOyB5IDwgYm90dG9tOyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB5ICogcm93U2l6ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gbGVmdDsgeCA8IHJpZ2h0OyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYml0c1tvZmZzZXQgKyBNYXRoLmZsb29yKHggLyAzMildIHw9ICgoMSA8PCAoeCAmIDB4MWYpKSAmIDB4RkZGRkZGRkYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQSBmYXN0IG1ldGhvZCB0byByZXRyaWV2ZSBvbmUgcm93IG9mIGRhdGEgZnJvbSB0aGUgbWF0cml4IGFzIGEgQml0QXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB5IFRoZSByb3cgdG8gcmV0cmlldmVcbiAgICAgICAgICogQHBhcmFtIHJvdyBBbiBvcHRpb25hbCBjYWxsZXItYWxsb2NhdGVkIEJpdEFycmF5LCB3aWxsIGJlIGFsbG9jYXRlZCBpZiBudWxsIG9yIHRvbyBzbWFsbFxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgQml0QXJyYXkgLSB0aGlzIHJlZmVyZW5jZSBzaG91bGQgYWx3YXlzIGJlIHVzZWQgZXZlbiB3aGVuIHBhc3NpbmdcbiAgICAgICAgICogICAgICAgICB5b3VyIG93biByb3dcbiAgICAgICAgICovXG4gICAgICAgIGdldFJvdyh5IC8qaW50Ki8sIHJvdykge1xuICAgICAgICAgICAgaWYgKHJvdyA9PT0gbnVsbCB8fCByb3cgPT09IHVuZGVmaW5lZCB8fCByb3cuZ2V0U2l6ZSgpIDwgdGhpcy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHJvdyA9IG5ldyBCaXRBcnJheSh0aGlzLndpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdy5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm93U2l6ZSA9IHRoaXMucm93U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB5ICogcm93U2l6ZTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgcm93U2l6ZTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgcm93LnNldEJ1bGsoeCAqIDMyLCBiaXRzW29mZnNldCArIHhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB5IHJvdyB0byBzZXRcbiAgICAgICAgICogQHBhcmFtIHJvdyB7QGxpbmsgQml0QXJyYXl9IHRvIGNvcHkgZnJvbVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0Um93KHkgLyppbnQqLywgcm93KSB7XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHJvdy5nZXRCaXRBcnJheSgpLCAwLCB0aGlzLmJpdHMsIHkgKiB0aGlzLnJvd1NpemUsIHRoaXMucm93U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGlmaWVzIHRoaXMge0Bjb2RlIEJpdE1hdHJpeH0gdG8gcmVwcmVzZW50IHRoZSBzYW1lIGJ1dCByb3RhdGVkIDE4MCBkZWdyZWVzXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGUxODAoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBsZXQgdG9wUm93ID0gbmV3IEJpdEFycmF5KHdpZHRoKTtcbiAgICAgICAgICAgIGxldCBib3R0b21Sb3cgPSBuZXcgQml0QXJyYXkod2lkdGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IE1hdGguZmxvb3IoKGhlaWdodCArIDEpIC8gMik7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRvcFJvdyA9IHRoaXMuZ2V0Um93KGksIHRvcFJvdyk7XG4gICAgICAgICAgICAgICAgYm90dG9tUm93ID0gdGhpcy5nZXRSb3coaGVpZ2h0IC0gMSAtIGksIGJvdHRvbVJvdyk7XG4gICAgICAgICAgICAgICAgdG9wUm93LnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICBib3R0b21Sb3cucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Um93KGksIGJvdHRvbVJvdyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSb3coaGVpZ2h0IC0gMSAtIGksIHRvcFJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZnVsIGluIGRldGVjdGluZyB0aGUgZW5jbG9zaW5nIHJlY3RhbmdsZSBvZiBhICdwdXJlJyBiYXJjb2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtAY29kZSBsZWZ0LHRvcCx3aWR0aCxoZWlnaHR9IGVuY2xvc2luZyByZWN0YW5nbGUgb2YgYWxsIDEgYml0cywgb3IgbnVsbCBpZiBpdCBpcyBhbGwgd2hpdGVcbiAgICAgICAgICovXG4gICAgICAgIGdldEVuY2xvc2luZ1JlY3RhbmdsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgcm93U2l6ZSA9IHRoaXMucm93U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IHdpZHRoO1xuICAgICAgICAgICAgbGV0IHRvcCA9IGhlaWdodDtcbiAgICAgICAgICAgIGxldCByaWdodCA9IC0xO1xuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IC0xO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHgzMiA9IDA7IHgzMiA8IHJvd1NpemU7IHgzMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoZUJpdHMgPSBiaXRzW3kgKiByb3dTaXplICsgeDMyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoZUJpdHMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5IDwgdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5ID4gYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4MzIgKiAzMiA8IGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYml0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKCh0aGVCaXRzIDw8ICgzMSAtIGJpdCkpICYgMHhGRkZGRkZGRikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoeDMyICogMzIgKyBiaXQpIDwgbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0geDMyICogMzIgKyBiaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHgzMiAqIDMyICsgMzEgPiByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXQgPSAzMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKHRoZUJpdHMgPj4+IGJpdCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoeDMyICogMzIgKyBiaXQpID4gcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB4MzIgKiAzMiArIGJpdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmlnaHQgPCBsZWZ0IHx8IGJvdHRvbSA8IHRvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbbGVmdCwgdG9wLCByaWdodCAtIGxlZnQgKyAxLCBib3R0b20gLSB0b3AgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZnVsIGluIGRldGVjdGluZyBhIGNvcm5lciBvZiBhICdwdXJlJyBiYXJjb2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtAY29kZSB4LHl9IGNvb3JkaW5hdGUgb2YgdG9wLWxlZnQtbW9zdCAxIGJpdCwgb3IgbnVsbCBpZiBpdCBpcyBhbGwgd2hpdGVcbiAgICAgICAgICovXG4gICAgICAgIGdldFRvcExlZnRPbkJpdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvd1NpemUgPSB0aGlzLnJvd1NpemU7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgbGV0IGJpdHNPZmZzZXQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGJpdHNPZmZzZXQgPCBiaXRzLmxlbmd0aCAmJiBiaXRzW2JpdHNPZmZzZXRdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYml0c09mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpdHNPZmZzZXQgPT09IGJpdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB5ID0gYml0c09mZnNldCAvIHJvd1NpemU7XG4gICAgICAgICAgICBsZXQgeCA9IChiaXRzT2Zmc2V0ICUgcm93U2l6ZSkgKiAzMjtcbiAgICAgICAgICAgIGNvbnN0IHRoZUJpdHMgPSBiaXRzW2JpdHNPZmZzZXRdO1xuICAgICAgICAgICAgbGV0IGJpdCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoKCh0aGVCaXRzIDw8ICgzMSAtIGJpdCkpICYgMHhGRkZGRkZGRikgPT09IDApIHtcbiAgICAgICAgICAgICAgICBiaXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggKz0gYml0O1xuICAgICAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbeCwgeV0pO1xuICAgICAgICB9XG4gICAgICAgIGdldEJvdHRvbVJpZ2h0T25CaXQoKSB7XG4gICAgICAgICAgICBjb25zdCByb3dTaXplID0gdGhpcy5yb3dTaXplO1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgICAgIGxldCBiaXRzT2Zmc2V0ID0gYml0cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGJpdHNPZmZzZXQgPj0gMCAmJiBiaXRzW2JpdHNPZmZzZXRdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYml0c09mZnNldC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpdHNPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihiaXRzT2Zmc2V0IC8gcm93U2l6ZSk7XG4gICAgICAgICAgICBsZXQgeCA9IE1hdGguZmxvb3IoYml0c09mZnNldCAlIHJvd1NpemUpICogMzI7XG4gICAgICAgICAgICBjb25zdCB0aGVCaXRzID0gYml0c1tiaXRzT2Zmc2V0XTtcbiAgICAgICAgICAgIGxldCBiaXQgPSAzMTtcbiAgICAgICAgICAgIHdoaWxlICgodGhlQml0cyA+Pj4gYml0KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJpdC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCArPSBiaXQ7XG4gICAgICAgICAgICByZXR1cm4gSW50MzJBcnJheS5mcm9tKFt4LCB5XSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHdpZHRoIG9mIHRoZSBtYXRyaXhcbiAgICAgICAgICovXG4gICAgICAgIGdldFdpZHRoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGhlaWdodCBvZiB0aGUgbWF0cml4XG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJvdyBzaXplIG9mIHRoZSBtYXRyaXhcbiAgICAgICAgICovXG4gICAgICAgIGdldFJvd1NpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dTaXplO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBCaXRNYXRyaXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPT09IG90aGVyLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBvdGhlci5oZWlnaHQgJiYgdGhpcy5yb3dTaXplID09PSBvdGhlci5yb3dTaXplICYmXG4gICAgICAgICAgICAgICAgQXJyYXlzLmVxdWFscyh0aGlzLmJpdHMsIG90aGVyLmJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgaGFzaENvZGUoKSB7XG4gICAgICAgICAgICBsZXQgaGFzaCA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICBoYXNoID0gMzEgKiBoYXNoICsgdGhpcy53aWR0aDtcbiAgICAgICAgICAgIGhhc2ggPSAzMSAqIGhhc2ggKyB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIGhhc2ggPSAzMSAqIGhhc2ggKyB0aGlzLnJvd1NpemU7XG4gICAgICAgICAgICBoYXNoID0gMzEgKiBoYXNoICsgQXJyYXlzLmhhc2hDb2RlKHRoaXMuYml0cyk7XG4gICAgICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gdXNpbmcgXCJYXCIgZm9yIHNldCBhbmQgXCIgXCIgZm9yIHVuc2V0IGJpdHNcbiAgICAgICAgICovXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgLy8gcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIC8vICAgcmV0dXJuIHRvU3RyaW5nKFwiOiBcIlgsIFwiICBcIilcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHNldFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHNldCBiaXRcbiAgICAgICAgICogQHBhcmFtIHVuc2V0U3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIHVuc2V0IGJpdFxuICAgICAgICAgKiBAcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBlbnRpcmUgbWF0cml4IHV0aWxpemluZyBnaXZlbiBzdHJpbmdzXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgdG9TdHJpbmcoc2V0U3RyaW5nOiBzdHJpbmcgPSBcIlggXCIsIHVuc2V0U3RyaW5nOiBzdHJpbmcgPSBcIiAgXCIpOiBzdHJpbmcge1xuICAgICAgICAvLyAgIHJldHVybiB0aGlzLmJ1aWxkVG9TdHJpbmcoc2V0U3RyaW5nLCB1bnNldFN0cmluZywgXCJcXG5cIilcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHNldFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHNldCBiaXRcbiAgICAgICAgICogQHBhcmFtIHVuc2V0U3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIHVuc2V0IGJpdFxuICAgICAgICAgKiBAcGFyYW0gbGluZVNlcGFyYXRvciBuZXdsaW5lIGNoYXJhY3RlciBpbiBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICogQHJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZW50aXJlIG1hdHJpeCB1dGlsaXppbmcgZ2l2ZW4gc3RyaW5ncyBhbmQgbGluZSBzZXBhcmF0b3JcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgY2FsbCB7QGxpbmsgI3RvU3RyaW5nKFN0cmluZyxTdHJpbmcpfSBvbmx5LCB3aGljaCB1c2VzIFxcbiBsaW5lIHNlcGFyYXRvciBhbHdheXNcbiAgICAgICAgICovXG4gICAgICAgIC8vIEBEZXByZWNhdGVkXG4gICAgICAgIHRvU3RyaW5nKHNldFN0cmluZyA9ICdYICcsIHVuc2V0U3RyaW5nID0gJyAgJywgbGluZVNlcGFyYXRvciA9ICdcXG4nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZFRvU3RyaW5nKHNldFN0cmluZywgdW5zZXRTdHJpbmcsIGxpbmVTZXBhcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkVG9TdHJpbmcoc2V0U3RyaW5nLCB1bnNldFN0cmluZywgbGluZVNlcGFyYXRvcikge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICAvLyByZXN1bHQuYXBwZW5kKGxpbmVTZXBhcmF0b3IpO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDAsIGhlaWdodCA9IHRoaXMuaGVpZ2h0OyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMCwgd2lkdGggPSB0aGlzLndpZHRoOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKHRoaXMuZ2V0KHgsIHkpID8gc2V0U3RyaW5nIDogdW5zZXRTdHJpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGxpbmVTZXBhcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgY2xvbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpdE1hdHJpeCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5yb3dTaXplLCB0aGlzLmJpdHMuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgTm90Rm91bmRFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgICAgICBzdGF0aWMgZ2V0Tm90Rm91bmRJbnN0YW5jZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBOb3RGb3VuZEV4Y2VwdGlvbi5raW5kID0gJ05vdEZvdW5kRXhjZXB0aW9uJztcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBCaW5hcml6ZXIgaW1wbGVtZW50YXRpb24gdXNlcyB0aGUgb2xkIFpYaW5nIGdsb2JhbCBoaXN0b2dyYW0gYXBwcm9hY2guIEl0IGlzIHN1aXRhYmxlXG4gICAgICogZm9yIGxvdy1lbmQgbW9iaWxlIGRldmljZXMgd2hpY2ggZG9uJ3QgaGF2ZSBlbm91Z2ggQ1BVIG9yIG1lbW9yeSB0byB1c2UgYSBsb2NhbCB0aHJlc2hvbGRpbmdcbiAgICAgKiBhbGdvcml0aG0uIEhvd2V2ZXIsIGJlY2F1c2UgaXQgcGlja3MgYSBnbG9iYWwgYmxhY2sgcG9pbnQsIGl0IGNhbm5vdCBoYW5kbGUgZGlmZmljdWx0IHNoYWRvd3NcbiAgICAgKiBhbmQgZ3JhZGllbnRzLlxuICAgICAqXG4gICAgICogRmFzdGVyIG1vYmlsZSBkZXZpY2VzIGFuZCBhbGwgZGVza3RvcCBhcHBsaWNhdGlvbnMgc2hvdWxkIHByb2JhYmx5IHVzZSBIeWJyaWRCaW5hcml6ZXIgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIgZXh0ZW5kcyBCaW5hcml6ZXIge1xuICAgICAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgICAgIHN1cGVyKHNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLmx1bWluYW5jZXMgPSBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuRU1QVFk7XG4gICAgICAgICAgICB0aGlzLmJ1Y2tldHMgPSBuZXcgSW50MzJBcnJheShHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX0JVQ0tFVFMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFwcGxpZXMgc2ltcGxlIHNoYXJwZW5pbmcgdG8gdGhlIHJvdyBkYXRhIHRvIGltcHJvdmUgcGVyZm9ybWFuY2Ugb2YgdGhlIDFEIFJlYWRlcnMuXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0QmxhY2tSb3coeSAvKmludCovLCByb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuZ2V0THVtaW5hbmNlU291cmNlKCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHNvdXJjZS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgaWYgKHJvdyA9PT0gdW5kZWZpbmVkIHx8IHJvdyA9PT0gbnVsbCB8fCByb3cuZ2V0U2l6ZSgpIDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICByb3cgPSBuZXcgQml0QXJyYXkod2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm93LmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluaXRBcnJheXMod2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxMdW1pbmFuY2VzID0gc291cmNlLmdldFJvdyh5LCB0aGlzLmx1bWluYW5jZXMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxCdWNrZXRzID0gdGhpcy5idWNrZXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxCdWNrZXRzWyhsb2NhbEx1bWluYW5jZXNbeF0gJiAweGZmKSA+PiBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX1NISUZUXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmxhY2tQb2ludCA9IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5lc3RpbWF0ZUJsYWNrUG9pbnQobG9jYWxCdWNrZXRzKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHZlcnkgc21hbGwgaW1hZ2VzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgobG9jYWxMdW1pbmFuY2VzW3hdICYgMHhmZikgPCBibGFja1BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cuc2V0KHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQgPSBsb2NhbEx1bWluYW5jZXNbMF0gJiAweGZmO1xuICAgICAgICAgICAgICAgIGxldCBjZW50ZXIgPSBsb2NhbEx1bWluYW5jZXNbMV0gJiAweGZmO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAxOyB4IDwgd2lkdGggLSAxOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBsb2NhbEx1bWluYW5jZXNbeCArIDFdICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBzaW1wbGUgLTEgNCAtMSBib3ggZmlsdGVyIHdpdGggYSB3ZWlnaHQgb2YgMi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoY2VudGVyICogNCkgLSBsZWZ0IC0gcmlnaHQpIC8gMiA8IGJsYWNrUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5zZXQoeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGNlbnRlcjtcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2VzIG5vdCBzaGFycGVuIHRoZSBkYXRhLCBhcyB0aGlzIGNhbGwgaXMgaW50ZW5kZWQgdG8gb25seSBiZSB1c2VkIGJ5IDJEIFJlYWRlcnMuXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0QmxhY2tNYXRyaXgoKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmdldEx1bWluYW5jZVNvdXJjZSgpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBzb3VyY2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHNvdXJjZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBCaXRNYXRyaXgod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAvLyBRdWlja2x5IGNhbGN1bGF0ZXMgdGhlIGhpc3RvZ3JhbSBieSBzYW1wbGluZyBmb3VyIHJvd3MgZnJvbSB0aGUgaW1hZ2UuIFRoaXMgcHJvdmVkIHRvIGJlXG4gICAgICAgICAgICAvLyBtb3JlIHJvYnVzdCBvbiB0aGUgYmxhY2tib3ggdGVzdHMgdGhhbiBzYW1wbGluZyBhIGRpYWdvbmFsIGFzIHdlIHVzZWQgdG8gZG8uXG4gICAgICAgICAgICB0aGlzLmluaXRBcnJheXMod2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxCdWNrZXRzID0gdGhpcy5idWNrZXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDE7IHkgPCA1OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKChoZWlnaHQgKiB5KSAvIDUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsTHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRSb3cocm93LCB0aGlzLmx1bWluYW5jZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5mbG9vcigod2lkdGggKiA0KSAvIDUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSBNYXRoLmZsb29yKHdpZHRoIC8gNSk7IHggPCByaWdodDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0gbG9jYWxMdW1pbmFuY2VzW3hdICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxCdWNrZXRzW3BpeGVsID4+IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfU0hJRlRdKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmxhY2tQb2ludCA9IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5lc3RpbWF0ZUJsYWNrUG9pbnQobG9jYWxCdWNrZXRzKTtcbiAgICAgICAgICAgIC8vIFdlIGRlbGF5IHJlYWRpbmcgdGhlIGVudGlyZSBpbWFnZSBsdW1pbmFuY2UgdW50aWwgdGhlIGJsYWNrIHBvaW50IGVzdGltYXRpb24gc3VjY2VlZHMuXG4gICAgICAgICAgICAvLyBBbHRob3VnaCB3ZSBlbmQgdXAgcmVhZGluZyBmb3VyIHJvd3MgdHdpY2UsIGl0IGlzIGNvbnNpc3RlbnQgd2l0aCBvdXIgbW90dG8gb2ZcbiAgICAgICAgICAgIC8vIFwiZmFpbCBxdWlja2x5XCIgd2hpY2ggaXMgbmVjZXNzYXJ5IGZvciBjb250aW51b3VzIHNjYW5uaW5nLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxMdW1pbmFuY2VzID0gc291cmNlLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiB3aWR0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGl4ZWwgPSBsb2NhbEx1bWluYW5jZXNbb2Zmc2V0ICsgeF0gJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGl4ZWwgPCBibGFja1BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGNyZWF0ZUJpbmFyaXplcihzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdEFycmF5cyhsdW1pbmFuY2VTaXplIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmx1bWluYW5jZXMubGVuZ3RoIDwgbHVtaW5hbmNlU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubHVtaW5hbmNlcyA9IG5ldyBVaW50OENsYW1wZWRBcnJheShsdW1pbmFuY2VTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ1Y2tldHMgPSB0aGlzLmJ1Y2tldHM7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQlVDS0VUUzsgeCsrKSB7XG4gICAgICAgICAgICAgICAgYnVja2V0c1t4XSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVzdGltYXRlQmxhY2tQb2ludChidWNrZXRzKSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSB0YWxsZXN0IHBlYWsgaW4gdGhlIGhpc3RvZ3JhbS5cbiAgICAgICAgICAgIGNvbnN0IG51bUJ1Y2tldHMgPSBidWNrZXRzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBtYXhCdWNrZXRDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgZmlyc3RQZWFrID0gMDtcbiAgICAgICAgICAgIGxldCBmaXJzdFBlYWtTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbnVtQnVja2V0czsgeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1Y2tldHNbeF0gPiBmaXJzdFBlYWtTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UGVhayA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UGVha1NpemUgPSBidWNrZXRzW3hdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYnVja2V0c1t4XSA+IG1heEJ1Y2tldENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1heEJ1Y2tldENvdW50ID0gYnVja2V0c1t4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBzZWNvbmQtdGFsbGVzdCBwZWFrIHdoaWNoIGlzIHNvbWV3aGF0IGZhciBmcm9tIHRoZSB0YWxsZXN0IHBlYWsuXG4gICAgICAgICAgICBsZXQgc2Vjb25kUGVhayA9IDA7XG4gICAgICAgICAgICBsZXQgc2Vjb25kUGVha1Njb3JlID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbnVtQnVja2V0czsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VUb0JpZ2dlc3QgPSB4IC0gZmlyc3RQZWFrO1xuICAgICAgICAgICAgICAgIC8vIEVuY291cmFnZSBtb3JlIGRpc3RhbnQgc2Vjb25kIHBlYWtzIGJ5IG11bHRpcGx5aW5nIGJ5IHNxdWFyZSBvZiBkaXN0YW5jZS5cbiAgICAgICAgICAgICAgICBjb25zdCBzY29yZSA9IGJ1Y2tldHNbeF0gKiBkaXN0YW5jZVRvQmlnZ2VzdCAqIGRpc3RhbmNlVG9CaWdnZXN0O1xuICAgICAgICAgICAgICAgIGlmIChzY29yZSA+IHNlY29uZFBlYWtTY29yZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWNvbmRQZWFrID0geDtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kUGVha1Njb3JlID0gc2NvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGZpcnN0UGVhayBjb3JyZXNwb25kcyB0byB0aGUgYmxhY2sgcGVhay5cbiAgICAgICAgICAgIGlmIChmaXJzdFBlYWsgPiBzZWNvbmRQZWFrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcCA9IGZpcnN0UGVhaztcbiAgICAgICAgICAgICAgICBmaXJzdFBlYWsgPSBzZWNvbmRQZWFrO1xuICAgICAgICAgICAgICAgIHNlY29uZFBlYWsgPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgdG9vIGxpdHRsZSBjb250cmFzdCBpbiB0aGUgaW1hZ2UgdG8gcGljayBhIG1lYW5pbmdmdWwgYmxhY2sgcG9pbnQsIHRocm93IHJhdGhlclxuICAgICAgICAgICAgLy8gdGhhbiB3YXN0ZSB0aW1lIHRyeWluZyB0byBkZWNvZGUgdGhlIGltYWdlLCBhbmQgcmlzayBmYWxzZSBwb3NpdGl2ZXMuXG4gICAgICAgICAgICBpZiAoc2Vjb25kUGVhayAtIGZpcnN0UGVhayA8PSBudW1CdWNrZXRzIC8gMTYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmQgYSB2YWxsZXkgYmV0d2VlbiB0aGVtIHRoYXQgaXMgbG93IGFuZCBjbG9zZXIgdG8gdGhlIHdoaXRlIHBlYWsuXG4gICAgICAgICAgICBsZXQgYmVzdFZhbGxleSA9IHNlY29uZFBlYWsgLSAxO1xuICAgICAgICAgICAgbGV0IGJlc3RWYWxsZXlTY29yZSA9IC0xO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IHNlY29uZFBlYWsgLSAxOyB4ID4gZmlyc3RQZWFrOyB4LS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tRmlyc3QgPSB4IC0gZmlyc3RQZWFrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjb3JlID0gZnJvbUZpcnN0ICogZnJvbUZpcnN0ICogKHNlY29uZFBlYWsgLSB4KSAqIChtYXhCdWNrZXRDb3VudCAtIGJ1Y2tldHNbeF0pO1xuICAgICAgICAgICAgICAgIGlmIChzY29yZSA+IGJlc3RWYWxsZXlTY29yZSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0VmFsbGV5ID0geDtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFZhbGxleVNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJlc3RWYWxsZXkgPDwgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9TSElGVDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX0JJVFMgPSA1O1xuICAgIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfU0hJRlQgPSA4IC0gR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9CSVRTO1xuICAgIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQlVDS0VUUyA9IDEgPDwgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9CSVRTO1xuICAgIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5FTVBUWSA9IFVpbnQ4Q2xhbXBlZEFycmF5LmZyb20oWzBdKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBjbGFzcyBpbXBsZW1lbnRzIGEgbG9jYWwgdGhyZXNob2xkaW5nIGFsZ29yaXRobSwgd2hpY2ggd2hpbGUgc2xvd2VyIHRoYW4gdGhlXG4gICAgICogR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLCBpcyBmYWlybHkgZWZmaWNpZW50IGZvciB3aGF0IGl0IGRvZXMuIEl0IGlzIGRlc2lnbmVkIGZvclxuICAgICAqIGhpZ2ggZnJlcXVlbmN5IGltYWdlcyBvZiBiYXJjb2RlcyB3aXRoIGJsYWNrIGRhdGEgb24gd2hpdGUgYmFja2dyb3VuZHMuIEZvciB0aGlzIGFwcGxpY2F0aW9uLFxuICAgICAqIGl0IGRvZXMgYSBtdWNoIGJldHRlciBqb2IgdGhhbiBhIGdsb2JhbCBibGFja3BvaW50IHdpdGggc2V2ZXJlIHNoYWRvd3MgYW5kIGdyYWRpZW50cy5cbiAgICAgKiBIb3dldmVyIGl0IHRlbmRzIHRvIHByb2R1Y2UgYXJ0aWZhY3RzIG9uIGxvd2VyIGZyZXF1ZW5jeSBpbWFnZXMgYW5kIGlzIHRoZXJlZm9yZSBub3RcbiAgICAgKiBhIGdvb2QgZ2VuZXJhbCBwdXJwb3NlIGJpbmFyaXplciBmb3IgdXNlcyBvdXRzaWRlIFpYaW5nLlxuICAgICAqXG4gICAgICogVGhpcyBjbGFzcyBleHRlbmRzIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplciwgdXNpbmcgdGhlIG9sZGVyIGhpc3RvZ3JhbSBhcHByb2FjaCBmb3IgMUQgcmVhZGVycyxcbiAgICAgKiBhbmQgdGhlIG5ld2VyIGxvY2FsIGFwcHJvYWNoIGZvciAyRCByZWFkZXJzLiAxRCBkZWNvZGluZyB1c2luZyBhIHBlci1yb3cgaGlzdG9ncmFtIGlzIGFscmVhZHlcbiAgICAgKiBpbmhlcmVudGx5IGxvY2FsLCBhbmQgb25seSBmYWlscyBmb3IgaG9yaXpvbnRhbCBncmFkaWVudHMuIFdlIGNhbiByZXZpc2l0IHRoYXQgcHJvYmxlbSBsYXRlcixcbiAgICAgKiBidXQgZm9yIG5vdyBpdCB3YXMgbm90IGEgd2luIHRvIHVzZSBsb2NhbCBibG9ja3MgZm9yIDFELlxuICAgICAqXG4gICAgICogVGhpcyBCaW5hcml6ZXIgaXMgdGhlIGRlZmF1bHQgZm9yIHRoZSB1bml0IHRlc3RzIGFuZCB0aGUgcmVjb21tZW5kZWQgY2xhc3MgZm9yIGxpYnJhcnkgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIEh5YnJpZEJpbmFyaXplciBleHRlbmRzIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICAgICAgc3VwZXIoc291cmNlKTtcbiAgICAgICAgICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgZmluYWwgQml0TWF0cml4IG9uY2UgZm9yIGFsbCByZXF1ZXN0cy4gVGhpcyBjb3VsZCBiZSBjYWxsZWQgb25jZSBmcm9tIHRoZVxuICAgICAgICAgKiBjb25zdHJ1Y3RvciBpbnN0ZWFkLCBidXQgdGhlcmUgYXJlIHNvbWUgYWR2YW50YWdlcyB0byBkb2luZyBpdCBsYXppbHksIHN1Y2ggYXMgbWFraW5nXG4gICAgICAgICAqIHByb2ZpbGluZyBlYXNpZXIsIGFuZCBub3QgZG9pbmcgaGVhdnkgbGlmdGluZyB3aGVuIGNhbGxlcnMgZG9uJ3QgZXhwZWN0IGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBnZXRCbGFja01hdHJpeCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hdHJpeCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdHJpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuZ2V0THVtaW5hbmNlU291cmNlKCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHNvdXJjZS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gc291cmNlLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgaWYgKHdpZHRoID49IEh5YnJpZEJpbmFyaXplci5NSU5JTVVNX0RJTUVOU0lPTiAmJiBoZWlnaHQgPj0gSHlicmlkQmluYXJpemVyLk1JTklNVU1fRElNRU5TSU9OKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgICAgICBsZXQgc3ViV2lkdGggPSB3aWR0aCA+PiBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9QT1dFUjtcbiAgICAgICAgICAgICAgICBpZiAoKHdpZHRoICYgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfTUFTSykgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViV2lkdGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHN1YkhlaWdodCA9IGhlaWdodCA+PiBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9QT1dFUjtcbiAgICAgICAgICAgICAgICBpZiAoKGhlaWdodCAmIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX01BU0spICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YkhlaWdodCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBibGFja1BvaW50cyA9IEh5YnJpZEJpbmFyaXplci5jYWxjdWxhdGVCbGFja1BvaW50cyhsdW1pbmFuY2VzLCBzdWJXaWR0aCwgc3ViSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgQml0TWF0cml4KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIEh5YnJpZEJpbmFyaXplci5jYWxjdWxhdGVUaHJlc2hvbGRGb3JCbG9jayhsdW1pbmFuY2VzLCBzdWJXaWR0aCwgc3ViSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBibGFja1BvaW50cywgbmV3TWF0cml4KTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeCA9IG5ld01hdHJpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbWFnZSBpcyB0b28gc21hbGwsIGZhbGwgYmFjayB0byB0aGUgZ2xvYmFsIGhpc3RvZ3JhbSBhcHByb2FjaC5cbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeCA9IHN1cGVyLmdldEJsYWNrTWF0cml4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBjcmVhdGVCaW5hcml6ZXIoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEh5YnJpZEJpbmFyaXplcihzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgZWFjaCBibG9jayBpbiB0aGUgaW1hZ2UsIGNhbGN1bGF0ZSB0aGUgYXZlcmFnZSBibGFjayBwb2ludCB1c2luZyBhIDV4NSBncmlkXG4gICAgICAgICAqIG9mIHRoZSBibG9ja3MgYXJvdW5kIGl0LiBBbHNvIGhhbmRsZXMgdGhlIGNvcm5lciBjYXNlcyAoZnJhY3Rpb25hbCBibG9ja3MgYXJlIGNvbXB1dGVkIGJhc2VkXG4gICAgICAgICAqIG9uIHRoZSBsYXN0IHBpeGVscyBpbiB0aGUgcm93L2NvbHVtbiB3aGljaCBhcmUgYWxzbyB1c2VkIGluIHRoZSBwcmV2aW91cyBibG9jaykuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY2FsY3VsYXRlVGhyZXNob2xkRm9yQmxvY2sobHVtaW5hbmNlcywgc3ViV2lkdGggLyppbnQqLywgc3ViSGVpZ2h0IC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBibGFja1BvaW50cywgbWF0cml4KSB7XG4gICAgICAgICAgICBjb25zdCBtYXhZT2Zmc2V0ID0gaGVpZ2h0IC0gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7XG4gICAgICAgICAgICBjb25zdCBtYXhYT2Zmc2V0ID0gd2lkdGggLSBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc3ViSGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeW9mZnNldCA9IHkgPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICAgICAgICAgICAgaWYgKHlvZmZzZXQgPiBtYXhZT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHlvZmZzZXQgPSBtYXhZT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0b3AgPSBIeWJyaWRCaW5hcml6ZXIuY2FwKHksIDIsIHN1YkhlaWdodCAtIDMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc3ViV2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeG9mZnNldCA9IHggPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4b2Zmc2V0ID4gbWF4WE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeG9mZnNldCA9IG1heFhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IEh5YnJpZEJpbmFyaXplci5jYXAoeCwgMiwgc3ViV2lkdGggLSAzKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHogPSAtMjsgeiA8PSAyOyB6KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsYWNrUm93ID0gYmxhY2tQb2ludHNbdG9wICsgel07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gYmxhY2tSb3dbbGVmdCAtIDJdICsgYmxhY2tSb3dbbGVmdCAtIDFdICsgYmxhY2tSb3dbbGVmdF0gKyBibGFja1Jvd1tsZWZ0ICsgMV0gKyBibGFja1Jvd1tsZWZ0ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXZlcmFnZSA9IHN1bSAvIDI1O1xuICAgICAgICAgICAgICAgICAgICBIeWJyaWRCaW5hcml6ZXIudGhyZXNob2xkQmxvY2sobHVtaW5hbmNlcywgeG9mZnNldCwgeW9mZnNldCwgYXZlcmFnZSwgd2lkdGgsIG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjYXAodmFsdWUgLyppbnQqLywgbWluIC8qaW50Ki8sIG1heCAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIGEgc2luZ2xlIHRocmVzaG9sZCB0byBhIGJsb2NrIG9mIHBpeGVscy5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyB0aHJlc2hvbGRCbG9jayhsdW1pbmFuY2VzLCB4b2Zmc2V0IC8qaW50Ki8sIHlvZmZzZXQgLyppbnQqLywgdGhyZXNob2xkIC8qaW50Ki8sIHN0cmlkZSAvKmludCovLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwLCBvZmZzZXQgPSB5b2Zmc2V0ICogc3RyaWRlICsgeG9mZnNldDsgeSA8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFOyB5KyssIG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFyaXNvbiBuZWVkcyB0byBiZSA8PSBzbyB0aGF0IGJsYWNrID09IDAgcGl4ZWxzIGFyZSBibGFjayBldmVuIGlmIHRoZSB0aHJlc2hvbGQgaXMgMC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChsdW1pbmFuY2VzW29mZnNldCArIHhdICYgMHhGRikgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KHhvZmZzZXQgKyB4LCB5b2Zmc2V0ICsgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZXMgYSBzaW5nbGUgYmxhY2sgcG9pbnQgZm9yIGVhY2ggYmxvY2sgb2YgcGl4ZWxzIGFuZCBzYXZlcyBpdCBhd2F5LlxuICAgICAgICAgKiBTZWUgdGhlIGZvbGxvd2luZyB0aHJlYWQgZm9yIGEgZGlzY3Vzc2lvbiBvZiB0aGlzIGFsZ29yaXRobTpcbiAgICAgICAgICogIGh0dHA6Ly9ncm91cHMuZ29vZ2xlLmNvbS9ncm91cC96eGluZy9icm93c2VfdGhyZWFkL3RocmVhZC9kMDZlZmEyYzM1YTdkZGMwXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY2FsY3VsYXRlQmxhY2tQb2ludHMobHVtaW5hbmNlcywgc3ViV2lkdGggLyppbnQqLywgc3ViSGVpZ2h0IC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBtYXhZT2Zmc2V0ID0gaGVpZ2h0IC0gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7XG4gICAgICAgICAgICBjb25zdCBtYXhYT2Zmc2V0ID0gd2lkdGggLSBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp3aGl0ZXNwYWNlXG4gICAgICAgICAgICBjb25zdCBibGFja1BvaW50cyA9IG5ldyBBcnJheShzdWJIZWlnaHQpOyAvLyBzdWJXaWR0aFxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzdWJIZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGJsYWNrUG9pbnRzW3ldID0gbmV3IEludDMyQXJyYXkoc3ViV2lkdGgpO1xuICAgICAgICAgICAgICAgIGxldCB5b2Zmc2V0ID0geSA8PCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9QT1dFUjtcbiAgICAgICAgICAgICAgICBpZiAoeW9mZnNldCA+IG1heFlPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgeW9mZnNldCA9IG1heFlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc3ViV2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeG9mZnNldCA9IHggPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4b2Zmc2V0ID4gbWF4WE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeG9mZnNldCA9IG1heFhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtaW4gPSAweEZGO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeXkgPSAwLCBvZmZzZXQgPSB5b2Zmc2V0ICogd2lkdGggKyB4b2Zmc2V0OyB5eSA8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFOyB5eSsrLCBvZmZzZXQgKz0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHh4ID0gMDsgeHggPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0gbHVtaW5hbmNlc1tvZmZzZXQgKyB4eF0gJiAweEZGO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSBwaXhlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGlsbCBsb29raW5nIGZvciBnb29kIGNvbnRyYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBpeGVsIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGl4ZWwgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBtaW4vbWF4IHRlc3RzIG9uY2UgZHluYW1pYyByYW5nZSBpcyBtZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXggLSBtaW4gPiBIeWJyaWRCaW5hcml6ZXIuTUlOX0RZTkFNSUNfUkFOR0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5pc2ggdGhlIHJlc3Qgb2YgdGhlIHJvd3MgcXVpY2tseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoeXkrKywgb2Zmc2V0ICs9IHdpZHRoOyB5eSA8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFOyB5eSsrLCBvZmZzZXQgKz0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeHggPSAwOyB4eCA8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFOyB4eCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gbHVtaW5hbmNlc1tvZmZzZXQgKyB4eF0gJiAweEZGO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGVzdGltYXRlIGlzIHRoZSBhdmVyYWdlIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIGJsb2NrLlxuICAgICAgICAgICAgICAgICAgICBsZXQgYXZlcmFnZSA9IHN1bSA+PiAoSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVIgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heCAtIG1pbiA8PSBIeWJyaWRCaW5hcml6ZXIuTUlOX0RZTkFNSUNfUkFOR0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHZhcmlhdGlvbiB3aXRoaW4gdGhlIGJsb2NrIGlzIGxvdywgYXNzdW1lIHRoaXMgaXMgYSBibG9jayB3aXRoIG9ubHkgbGlnaHQgb3Igb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGFyayBwaXhlbHMuIEluIHRoYXQgY2FzZSB3ZSBkbyBub3Qgd2FudCB0byB1c2UgdGhlIGF2ZXJhZ2UsIGFzIGl0IHdvdWxkIGRpdmlkZSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb3cgY29udHJhc3QgYXJlYSBpbnRvIGJsYWNrIGFuZCB3aGl0ZSBwaXhlbHMsIGVzc2VudGlhbGx5IGNyZWF0aW5nIGRhdGEgb3V0IG9mIG5vaXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGFzc3VtcHRpb24gaXMgdGhhdCB0aGUgYmxvY2sgaXMgbGlnaHQvYmFja2dyb3VuZC4gU2luY2Ugbm8gZXN0aW1hdGUgZm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbGV2ZWwgb2YgZGFyayBwaXhlbHMgZXhpc3RzIGxvY2FsbHksIHVzZSBoYWxmIHRoZSBtaW4gZm9yIHRoZSBibG9jay5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF2ZXJhZ2UgPSBtaW4gLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHkgPiAwICYmIHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29ycmVjdCB0aGUgXCJ3aGl0ZSBiYWNrZ3JvdW5kXCIgYXNzdW1wdGlvbiBmb3IgYmxvY2tzIHRoYXQgaGF2ZSBuZWlnaGJvcnMgYnkgY29tcGFyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBpeGVscyBpbiB0aGlzIGJsb2NrIHRvIHRoZSBwcmV2aW91c2x5IGNhbGN1bGF0ZWQgYmxhY2sgcG9pbnRzLiBUaGlzIGlzIGJhc2VkIG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZhY3QgdGhhdCBkYXJrIGJhcmNvZGUgc3ltYm9sb2d5IGlzIGFsd2F5cyBzdXJyb3VuZGVkIGJ5IHNvbWUgYW1vdW50IG9mIGxpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFja2dyb3VuZCBmb3Igd2hpY2ggcmVhc29uYWJsZSBibGFjayBwb2ludCBlc3RpbWF0ZXMgd2VyZSBtYWRlLiBUaGUgYnAgZXN0aW1hdGVkIGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGJvdW5kYXJpZXMgaXMgdXNlZCBmb3IgdGhlIGludGVyaW9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSAobWluIDwgYnApIGlzIGFyYml0cmFyeSBidXQgd29ya3MgYmV0dGVyIHRoYW4gb3RoZXIgaGV1cmlzdGljcyB0aGF0IHdlcmUgdHJpZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXZlcmFnZU5laWdoYm9yQmxhY2tQb2ludCA9IChibGFja1BvaW50c1t5IC0gMV1beF0gKyAoMiAqIGJsYWNrUG9pbnRzW3ldW3ggLSAxXSkgKyBibGFja1BvaW50c1t5IC0gMV1beCAtIDFdKSAvIDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA8IGF2ZXJhZ2VOZWlnaGJvckJsYWNrUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZlcmFnZSA9IGF2ZXJhZ2VOZWlnaGJvckJsYWNrUG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJsYWNrUG9pbnRzW3ldW3hdID0gYXZlcmFnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmxhY2tQb2ludHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhpcyBjbGFzcyB1c2VzIDV4NSBibG9ja3MgdG8gY29tcHV0ZSBsb2NhbCBsdW1pbmFuY2UsIHdoZXJlIGVhY2ggYmxvY2sgaXMgOHg4IHBpeGVscy5cbiAgICAvLyBTbyB0aGlzIGlzIHRoZSBzbWFsbGVzdCBkaW1lbnNpb24gaW4gZWFjaCBheGlzIHdlIGNhbiBhY2NlcHQuXG4gICAgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVIgPSAzO1xuICAgIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFID0gMSA8PCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9QT1dFUjsgLy8gLi4uMDEwMC4uLjAwXG4gICAgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfTUFTSyA9IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFIC0gMTsgLy8gLi4uMDAxMS4uLjExXG4gICAgSHlicmlkQmluYXJpemVyLk1JTklNVU1fRElNRU5TSU9OID0gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkUgKiA1O1xuICAgIEh5YnJpZEJpbmFyaXplci5NSU5fRFlOQU1JQ19SQU5HRSA9IDI0O1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xuICAgIC8qKlxuICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgY2xhc3MgaGllcmFyY2h5IGlzIHRvIGFic3RyYWN0IGRpZmZlcmVudCBiaXRtYXAgaW1wbGVtZW50YXRpb25zIGFjcm9zc1xuICAgICAqIHBsYXRmb3JtcyBpbnRvIGEgc3RhbmRhcmQgaW50ZXJmYWNlIGZvciByZXF1ZXN0aW5nIGdyZXlzY2FsZSBsdW1pbmFuY2UgdmFsdWVzLiBUaGUgaW50ZXJmYWNlXG4gICAgICogb25seSBwcm92aWRlcyBpbW11dGFibGUgbWV0aG9kczsgdGhlcmVmb3JlIGNyb3AgYW5kIHJvdGF0aW9uIGNyZWF0ZSBjb3BpZXMuIFRoaXMgaXMgdG8gZW5zdXJlXG4gICAgICogdGhhdCBvbmUgUmVhZGVyIGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwgbHVtaW5hbmNlIHNvdXJjZSBhbmQgbGVhdmUgaXQgaW4gYW4gdW5rbm93biBzdGF0ZVxuICAgICAqIGZvciBvdGhlciBSZWFkZXJzIGluIHRoZSBjaGFpbi5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICovXG4gICAgY2xhc3MgTHVtaW5hbmNlU291cmNlIHtcbiAgICAgICAgY29uc3RydWN0b3Iod2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSB3aWR0aCBvZiB0aGUgYml0bWFwLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBUaGUgaGVpZ2h0IG9mIHRoZSBiaXRtYXAuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gV2hldGhlciB0aGlzIHN1YmNsYXNzIHN1cHBvcnRzIGNyb3BwaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNDcm9wU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIGNyb3BwZWQgaW1hZ2UgZGF0YS4gSW1wbGVtZW50YXRpb25zIG1heSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZVxuICAgICAgICAgKiBvcmlnaW5hbCBkYXRhIHJhdGhlciB0aGFuIGEgY29weS4gT25seSBjYWxsYWJsZSBpZiBpc0Nyb3BTdXBwb3J0ZWQoKSBpcyB0cnVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbGVmdCBjb29yZGluYXRlLCB3aGljaCBtdXN0IGJlIGluIFswLGdldFdpZHRoKCkpXG4gICAgICAgICAqIEBwYXJhbSB0b3AgVGhlIHRvcCBjb29yZGluYXRlLCB3aGljaCBtdXN0IGJlIGluIFswLGdldEhlaWdodCgpKVxuICAgICAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgdG8gY3JvcC5cbiAgICAgICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUgdG8gY3JvcC5cbiAgICAgICAgICogQHJldHVybiBBIGNyb3BwZWQgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGNyb3AobGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbignVGhpcyBsdW1pbmFuY2Ugc291cmNlIGRvZXMgbm90IHN1cHBvcnQgY3JvcHBpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gV2hldGhlciB0aGlzIHN1YmNsYXNzIHN1cHBvcnRzIGNvdW50ZXItY2xvY2t3aXNlIHJvdGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNSb3RhdGVTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggcm90YXRlZCBpbWFnZSBkYXRhIGJ5IDkwIGRlZ3JlZXMgY291bnRlcmNsb2Nrd2lzZS5cbiAgICAgICAgICogT25seSBjYWxsYWJsZSBpZiB7QGxpbmsgI2lzUm90YXRlU3VwcG9ydGVkKCl9IGlzIHRydWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gQSByb3RhdGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGVDb3VudGVyQ2xvY2t3aXNlKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKCdUaGlzIGx1bWluYW5jZSBzb3VyY2UgZG9lcyBub3Qgc3VwcG9ydCByb3RhdGlvbiBieSA5MCBkZWdyZWVzLicpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHJvdGF0ZWQgaW1hZ2UgZGF0YSBieSA0NSBkZWdyZWVzIGNvdW50ZXJjbG9ja3dpc2UuXG4gICAgICAgICAqIE9ubHkgY2FsbGFibGUgaWYge0BsaW5rICNpc1JvdGF0ZVN1cHBvcnRlZCgpfSBpcyB0cnVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIEEgcm90YXRlZCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1KCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKCdUaGlzIGx1bWluYW5jZSBzb3VyY2UgZG9lcyBub3Qgc3VwcG9ydCByb3RhdGlvbiBieSA0NSBkZWdyZWVzLicpO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkodGhpcy53aWR0aCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVJvdyA9IHRoaXMuZ2V0Um93KHksIHJvdyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbHVtaW5hbmNlID0gc291cmNlUm93W3hdICYgMHhGRjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsdW1pbmFuY2UgPCAweDQwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJyMnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGx1bWluYW5jZSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnKyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobHVtaW5hbmNlIDwgMHhDMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICcuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovXG4gICAgLyoqXG4gICAgICogQSB3cmFwcGVyIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBMdW1pbmFuY2VTb3VyY2V9IHdoaWNoIGludmVydHMgdGhlIGx1bWluYW5jZXMgaXQgcmV0dXJucyAtLSBibGFjayBiZWNvbWVzXG4gICAgICogd2hpdGUgYW5kIHZpY2UgdmVyc2EsIGFuZCBlYWNoIHZhbHVlIGJlY29tZXMgKDI1NS12YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEludmVydGVkTHVtaW5hbmNlU291cmNlIGV4dGVuZHMgTHVtaW5hbmNlU291cmNlIHtcbiAgICAgICAgY29uc3RydWN0b3IoZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIHN1cGVyKGRlbGVnYXRlLmdldFdpZHRoKCksIGRlbGVnYXRlLmdldEhlaWdodCgpKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGdldFJvdyh5IC8qaW50Ki8sIHJvdykge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlUm93ID0gdGhpcy5kZWxlZ2F0ZS5nZXRSb3coeSwgcm93KTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc291cmNlUm93W2ldID0gLyooYnl0ZSkqLyAoMjU1IC0gKHNvdXJjZVJvd1tpXSAmIDB4RkYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VSb3c7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBnZXRNYXRyaXgoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRyaXggPSB0aGlzLmRlbGVnYXRlLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5nZXRXaWR0aCgpICogdGhpcy5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGludmVydGVkTWF0cml4ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW52ZXJ0ZWRNYXRyaXhbaV0gPSAvKihieXRlKSovICgyNTUgLSAobWF0cml4W2ldICYgMHhGRikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGludmVydGVkTWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgaXNDcm9wU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuaXNDcm9wU3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBjcm9wKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMuZGVsZWdhdGUuY3JvcChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGlzUm90YXRlU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuaXNSb3RhdGVTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBvcmlnaW5hbCBkZWxlZ2F0ZSB7QGxpbmsgTHVtaW5hbmNlU291cmNlfSBzaW5jZSBpbnZlcnQgdW5kb2VzIGl0c2VsZlxuICAgICAgICAgKi9cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBpbnZlcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMuZGVsZWdhdGUucm90YXRlQ291bnRlckNsb2Nrd2lzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHJvdGF0ZUNvdW50ZXJDbG9ja3dpc2U0NSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UodGhpcy5kZWxlZ2F0ZS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlNDUoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBNb3ZpbmcgdG8gQHp4aW5nL2Jyb3dzZXJcbiAgICAgKi9cbiAgICBjbGFzcyBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZSBleHRlbmRzIEx1bWluYW5jZVNvdXJjZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGNhbnZhcykge1xuICAgICAgICAgICAgc3VwZXIoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICAgICAgdGhpcy50ZW1wQ2FudmFzRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLm1ha2VCdWZmZXJGcm9tQ2FudmFzSW1hZ2VEYXRhKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG1ha2VCdWZmZXJGcm9tQ2FudmFzSW1hZ2VEYXRhKGNhbnZhcykge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY2FudmFzLmdldENvbnRleHQoJzJkJykuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UudG9HcmF5c2NhbGVCdWZmZXIoaW1hZ2VEYXRhLmRhdGEsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHRvR3JheXNjYWxlQnVmZmVyKGltYWdlQnVmZmVyLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBncmF5c2NhbGVCdWZmZXIgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwLCBsZW5ndGggPSBpbWFnZUJ1ZmZlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gNCwgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdyYXk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxwaGEgPSBpbWFnZUJ1ZmZlcltpICsgM107XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbG9yIG9mIGZ1bGx5LXRyYW5zcGFyZW50IHBpeGVscyBpcyBpcnJlbGV2YW50LiBUaGV5IGFyZSBvZnRlbiwgdGVjaG5pY2FsbHksIGZ1bGx5LXRyYW5zcGFyZW50XG4gICAgICAgICAgICAgICAgLy8gYmxhY2sgKDAgYWxwaGEsIGFuZCB0aGVuIDAgUkdCKS4gVGhleSBhcmUgb2Z0ZW4gdXNlZCwgb2YgY291cnNlIGFzIHRoZSBcIndoaXRlXCIgYXJlYSBpbiBhXG4gICAgICAgICAgICAgICAgLy8gYmFyY29kZSBpbWFnZS4gRm9yY2UgYW55IHN1Y2ggcGl4ZWwgdG8gYmUgd2hpdGU6XG4gICAgICAgICAgICAgICAgaWYgKGFscGhhID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXkgPSAweEZGO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGl4ZWxSID0gaW1hZ2VCdWZmZXJbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsRyA9IGltYWdlQnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGl4ZWxCID0gaW1hZ2VCdWZmZXJbaSArIDJdO1xuICAgICAgICAgICAgICAgICAgICAvLyAuMjk5UiArIDAuNTg3RyArIDAuMTE0QiAoWVVWL1lJUSBmb3IgUEFMIGFuZCBOVFNDKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gKDMwNipSKSA+PiAxMCBpcyBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIFIqMC4yOTksIGFuZCBzbyBvbi5cbiAgICAgICAgICAgICAgICAgICAgLy8gMHgyMDAgPj4gMTAgaXMgMC41LCBpdCBpbXBsZW1lbnRzIHJvdW5kaW5nLlxuICAgICAgICAgICAgICAgICAgICBncmF5ID0gKDMwNiAqIHBpeGVsUiArXG4gICAgICAgICAgICAgICAgICAgICAgICA2MDEgKiBwaXhlbEcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgMTE3ICogcGl4ZWxCICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDB4MjAwKSA+PiAxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ3JheXNjYWxlQnVmZmVyW2pdID0gZ3JheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBncmF5c2NhbGVCdWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Um93KHkgLyppbnQqLywgcm93KSB7XG4gICAgICAgICAgICBpZiAoeSA8IDAgfHwgeSA+PSB0aGlzLmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUmVxdWVzdGVkIHJvdyBpcyBvdXRzaWRlIHRoZSBpbWFnZTogJyArIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHkgKiB3aWR0aDtcbiAgICAgICAgICAgIGlmIChyb3cgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByb3cgPSB0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgc3RhcnQgKyB3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocm93Lmxlbmd0aCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZSB1bmRlcmx5aW5nIHJhc3RlciBvZiBpbWFnZSBjb25zaXN0cyBvZiBieXRlcyB3aXRoIHRoZSBsdW1pbmFuY2UgdmFsdWVzXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogY2FuIGF2b2lkIHNldC9zbGljZT9cbiAgICAgICAgICAgICAgICByb3cuc2V0KHRoaXMuYnVmZmVyLnNsaWNlKHN0YXJ0LCBzdGFydCArIHdpZHRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9XG4gICAgICAgIGdldE1hdHJpeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBpc0Nyb3BTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjcm9wKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICBzdXBlci5jcm9wKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyBhbHdheXMgdHJ1ZSwgc2luY2UgdGhlIGltYWdlIGlzIGEgZ3JheS1zY2FsZSBpbWFnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICBpc1JvdGF0ZVN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UoKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZSgtOTApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1KCkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGUoLTQ1KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGdldFRlbXBDYW52YXNFbGVtZW50KCkge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IHRoaXMudGVtcENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wQ2FudmFzRWxlbWVudCA9IHRoaXMuY2FudmFzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgdGVtcENhbnZhc0VsZW1lbnQud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgICAgICB0ZW1wQ2FudmFzRWxlbWVudC5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy50ZW1wQ2FudmFzRWxlbWVudCA9IHRlbXBDYW52YXNFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGVtcENhbnZhc0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcm90YXRlKGFuZ2xlKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wQ2FudmFzRWxlbWVudCA9IHRoaXMuZ2V0VGVtcENhbnZhc0VsZW1lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBDb250ZXh0ID0gdGVtcENhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IGFuZ2xlICogSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UuREVHUkVFX1RPX1JBRElBTlM7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgYW5kIHNldCBuZXcgZGltZW5zaW9ucyBmb3IgdGVtcCBjYW52YXNcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBuZXdXaWR0aCA9IE1hdGguY2VpbChNYXRoLmFicyhNYXRoLmNvcyhhbmdsZVJhZGlhbnMpKSAqIHdpZHRoICsgTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGVSYWRpYW5zKSkgKiBoZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGguYWJzKE1hdGguc2luKGFuZ2xlUmFkaWFucykpICogd2lkdGggKyBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZVJhZGlhbnMpKSAqIGhlaWdodCk7XG4gICAgICAgICAgICB0ZW1wQ2FudmFzRWxlbWVudC53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICAgICAgdGVtcENhbnZhc0VsZW1lbnQuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgLy8gRHJhdyBhdCBjZW50ZXIgb2YgdGVtcCBjYW52YXMgdG8gcHJldmVudCBjbGlwcGluZyBvZiBpbWFnZSBkYXRhXG4gICAgICAgICAgICB0ZW1wQ29udGV4dC50cmFuc2xhdGUobmV3V2lkdGggLyAyLCBuZXdIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIHRlbXBDb250ZXh0LnJvdGF0ZShhbmdsZVJhZGlhbnMpO1xuICAgICAgICAgICAgdGVtcENvbnRleHQuZHJhd0ltYWdlKHRoaXMuY2FudmFzLCB3aWR0aCAvIC0yLCBoZWlnaHQgLyAtMik7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLm1ha2VCdWZmZXJGcm9tQ2FudmFzSW1hZ2VEYXRhKHRlbXBDYW52YXNFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGludmVydCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UuREVHUkVFX1RPX1JBRElBTlMgPSBNYXRoLlBJIC8gMTgwO1xuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICpcbiAgICAgKiBWaWRlbyBpbnB1dCBkZXZpY2UgbWV0YWRhdGEgY29udGFpbmluZyB0aGUgaWQgYW5kIGxhYmVsIG9mIHRoZSBkZXZpY2UgaWYgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIGNsYXNzIFZpZGVvSW5wdXREZXZpY2Uge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBWaWRlb0lucHV0RGV2aWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGV2aWNlSWQgdGhlIHZpZGVvIGlucHV0IGRldmljZSBpZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgdGhlIGxhYmVsIG9mIHRoZSBkZXZpY2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihkZXZpY2VJZCwgbGFiZWwsIGdyb3VwSWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGV2aWNlSWQgPSBkZXZpY2VJZDtcbiAgICAgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgICAgICAgICAgdGhpcy5raW5kID0gJ3ZpZGVvaW5wdXQnO1xuICAgICAgICAgICAgdGhpcy5ncm91cElkID0gZ3JvdXBJZCB8fCB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgICAgICAgICAgIGdyb3VwSWQ6IHRoaXMuZ3JvdXBJZCxcbiAgICAgICAgICAgICAgICBkZXZpY2VJZDogdGhpcy5kZXZpY2VJZCxcbiAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5sYWJlbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX19hd2FpdGVyID0gKChnbG9iYWxUaGlzIHx8IGdsb2JhbCB8fCBzZWxmIHx8IHdpbmRvdyB8fCB1bmRlZmluZWQpICYmIChnbG9iYWxUaGlzIHx8IGdsb2JhbCB8fCBzZWxmIHx8IHdpbmRvdyB8fCB1bmRlZmluZWQpLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICpcbiAgICAgKiBCYXNlIGNsYXNzIGZvciBicm93c2VyIGNvZGUgcmVhZGVyLlxuICAgICAqL1xuICAgIGNsYXNzIEJyb3dzZXJDb2RlUmVhZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQnJvd3NlckNvZGVSZWFkZXIuXG4gICAgICAgICAqIEBwYXJhbSB7UmVhZGVyfSByZWFkZXIgVGhlIHJlYWRlciBpbnN0YW5jZSB0byBkZWNvZGUgdGhlIGJhcmNvZGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lQmV0d2VlblNjYW5zTWlsbGlzPTUwMF0gdGhlIHRpbWUgZGVsYXkgYmV0d2VlbiBzdWJzZXF1ZW50IHN1Y2Nlc3NmdWwgZGVjb2RlIHRyaWVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IocmVhZGVyLCB0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwLCBfaGludHMpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyO1xuICAgICAgICAgICAgdGhpcy50aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gdGltZUJldHdlZW5TY2Fuc01pbGxpcztcbiAgICAgICAgICAgIHRoaXMuX2hpbnRzID0gX2hpbnRzO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIHdpbGwgYnJlYWsgdGhlIGxvb3AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3N0b3BDb250aW51b3VzRGVjb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgd2lsbCBicmVhayB0aGUgbG9vcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fc3RvcEFzeW5jRGVjb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlbGF5IHRpbWUgYmV0d2VlbiBkZWNvZGUgYXR0ZW1wdHMgbWFkZSBieSB0aGUgc2Nhbm5lci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fdGltZUJldHdlZW5EZWNvZGluZ0F0dGVtcHRzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbmF2aWdhdG9yIGlzIHByZXNlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgaGFzTmF2aWdhdG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBtZWRpYURldmljZXMgdW5kZXIgbmF2aWdhdG9yIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBpc01lZGlhRGV2aWNlc1N1cG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzTmF2aWdhdG9yICYmICEhbmF2aWdhdG9yLm1lZGlhRGV2aWNlcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZW51bWVyYXRlRGV2aWNlcyB1bmRlciBuYXZpZ2F0b3IgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGNhbkVudW1lcmF0ZURldmljZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gISEodGhpcy5pc01lZGlhRGV2aWNlc1N1cG9ydGVkICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIFRpbWUgYmV0d2VlbiB0d28gZGVjb2RpbmcgdHJpZXMgaW4gbWlsbGkgc2Vjb25kcy4gKi9cbiAgICAgICAgZ2V0IHRpbWVCZXR3ZWVuRGVjb2RpbmdBdHRlbXB0cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYW5nZSB0aGUgdGltZSBzcGFuIHRoZSBkZWNvZGVyIHdhaXRzIGJldHdlZW4gdHdvIGRlY29kaW5nIHRyaWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzIFRpbWUgYmV0d2VlbiB0d28gZGVjb2RpbmcgdHJpZXMgaW4gbWlsbGkgc2Vjb25kcy5cbiAgICAgICAgICovXG4gICAgICAgIHNldCB0aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHMobWlsbGlzKSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHMgPSBtaWxsaXMgPCAwID8gMCA6IG1pbGxpcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgaGludHMuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQgaGludHMoaGludHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpbnRzID0gaGludHMgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgaGludHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgaGludHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGludHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGFsbCB0aGUgYXZhaWxhYmxlIHZpZGVvIGlucHV0IGRldmljZXMuXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0VmlkZW9JbnB1dERldmljZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNOYXZpZ2F0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGVudW1lcmF0ZSBkZXZpY2VzLCBuYXZpZ2F0b3IgaXMgbm90IHByZXNlbnQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jYW5FbnVtZXJhdGVEZXZpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBlbnVtZXJhdGUgZGV2aWNlcywgbWV0aG9kIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZXMgPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWRlb0RldmljZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRldmljZSBvZiBkZXZpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSBkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvJyA/ICd2aWRlb2lucHV0JyA6IGRldmljZS5raW5kO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2luZCAhPT0gJ3ZpZGVvaW5wdXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2VJZCA9IGRldmljZS5kZXZpY2VJZCB8fCBkZXZpY2UuaWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZGV2aWNlLmxhYmVsIHx8IGBWaWRlbyBkZXZpY2UgJHt2aWRlb0RldmljZXMubGVuZ3RoICsgMX1gO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBncm91cElkID0gZGV2aWNlLmdyb3VwSWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZGVvRGV2aWNlID0geyBkZXZpY2VJZCwgbGFiZWwsIGtpbmQsIGdyb3VwSWQgfTtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9EZXZpY2VzLnB1c2godmlkZW9EZXZpY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW9EZXZpY2VzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9idGFpbiB0aGUgbGlzdCBvZiBhdmFpbGFibGUgZGV2aWNlcyB3aXRoIHR5cGUgJ3ZpZGVvaW5wdXQnLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxWaWRlb0lucHV0RGV2aWNlW10+fSBhbiBhcnJheSBvZiBhdmFpbGFibGUgdmlkZW8gaW5wdXQgZGV2aWNlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGBsaXN0VmlkZW9JbnB1dERldmljZXNgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRWaWRlb0lucHV0RGV2aWNlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlcyA9IHlpZWxkIHRoaXMubGlzdFZpZGVvSW5wdXREZXZpY2VzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZXMubWFwKGQgPT4gbmV3IFZpZGVvSW5wdXREZXZpY2UoZC5kZXZpY2VJZCwgZC5sYWJlbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExldCdzIHlvdSBmaW5kIGEgZGV2aWNlIHVzaW5nIGl0J3MgSWQuXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kRGV2aWNlQnlJZChkZXZpY2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2VzID0geWllbGQgdGhpcy5saXN0VmlkZW9JbnB1dERldmljZXMoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRldmljZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXZpY2VzLmZpbmQoeCA9PiB4LmRldmljZUlkID09PSBkZXZpY2VJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyB0aGUgYmFyY29kZSBmcm9tIHRoZSBkZXZpY2Ugc3BlY2lmaWVkIGJ5IGRldmljZUlkIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRldmljZUlkIHRoZSBpZCBvZiBvbmUgb2YgdGhlIGRldmljZXMgb2J0YWluZWQgYWZ0ZXIgY2FsbGluZyBnZXRWaWRlb0lucHV0RGV2aWNlcy4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gdGhpcyBjYXNlIGl0IHdpbGwgZGVjb2RlIGZyb20gb25lIG9mIHRoZSBhdmFpbGFibGUgZGV2aWNlcywgcHJlZmZlcmluZyB0aGUgbWFpbiBjYW1lcmEgKGVudmlyb25tZW50IGZhY2luZykgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgKiBAcGFyYW0gdmlkZW8gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQHJldHVybnMgVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZGVjb2RlT25jZUZyb21WaWRlb0RldmljZWAgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21JbnB1dFZpZGVvRGV2aWNlKGRldmljZUlkLCB2aWRlb1NvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5kZWNvZGVPbmNlRnJvbVZpZGVvRGV2aWNlKGRldmljZUlkLCB2aWRlb1NvdXJjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW4gb25lIGF0dGVtcHQsIHRyaWVzIHRvIGRlY29kZSB0aGUgYmFyY29kZSBmcm9tIHRoZSBkZXZpY2Ugc3BlY2lmaWVkIGJ5IGRldmljZUlkIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRldmljZUlkIHRoZSBpZCBvZiBvbmUgb2YgdGhlIGRldmljZXMgb2J0YWluZWQgYWZ0ZXIgY2FsbGluZyBnZXRWaWRlb0lucHV0RGV2aWNlcy4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gdGhpcyBjYXNlIGl0IHdpbGwgZGVjb2RlIGZyb20gb25lIG9mIHRoZSBhdmFpbGFibGUgZGV2aWNlcywgcHJlZmZlcmluZyB0aGUgbWFpbiBjYW1lcmEgKGVudmlyb25tZW50IGZhY2luZykgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgKiBAcGFyYW0gdmlkZW8gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQHJldHVybnMgVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVPbmNlRnJvbVZpZGVvRGV2aWNlKGRldmljZUlkLCB2aWRlb1NvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgbGV0IHZpZGVvQ29uc3RyYWludHM7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXZpY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICB2aWRlb0NvbnN0cmFpbnRzID0geyBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2aWRlb0NvbnN0cmFpbnRzID0geyBkZXZpY2VJZDogeyBleGFjdDogZGV2aWNlSWQgfSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHsgdmlkZW86IHZpZGVvQ29uc3RyYWludHMgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5kZWNvZGVPbmNlRnJvbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzLCB2aWRlb1NvdXJjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW4gb25lIGF0dGVtcHQsIHRyaWVzIHRvIGRlY29kZSB0aGUgYmFyY29kZSBmcm9tIGEgc3RyZWFtIG9idGFpbmVkIGZyb20gdGhlIGdpdmVuIGNvbnN0cmFpbnRzIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvbnN0cmFpbnRzIHRoZSBtZWRpYSBzdHJlYW0gY29uc3RyYWludHMgdG8gZ2V0IHMgdmFsaWQgbWVkaWEgc3RyZWFtIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB2aWRlbyB0aGUgdmlkZW8gZWxlbWVudCBpbiBwYWdlIHdoZXJlIHRvIHNob3cgdGhlIHZpZGVvIHdoaWxlIGRlY29kaW5nLiBDYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgZGlyZWN0bHkgYW4gSFRNTFZpZGVvRWxlbWVudC4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gd2hpY2ggY2FzZSBubyB2aWRlbyB3aWxsIGJlIHNob3duLlxuICAgICAgICAgKiBAcmV0dXJucyBUaGUgZGVjb2RpbmcgcmVzdWx0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZU9uY2VGcm9tQ29uc3RyYWludHMoY29uc3RyYWludHMsIHZpZGVvU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5kZWNvZGVPbmNlRnJvbVN0cmVhbShzdHJlYW0sIHZpZGVvU291cmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbiBvbmUgYXR0ZW1wdCwgdHJpZXMgdG8gZGVjb2RlIHRoZSBiYXJjb2RlIGZyb20gYSBzdHJlYW0gb2J0YWluZWQgZnJvbSB0aGUgZ2l2ZW4gY29uc3RyYWludHMgd2hpbGUgc2hvd2luZyB0aGUgdmlkZW8gaW4gdGhlIHNwZWNpZmllZCB2aWRlbyBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBbY29uc3RyYWludHNdIHRoZSBtZWRpYSBzdHJlYW0gY29uc3RyYWludHMgdG8gZ2V0IHMgdmFsaWQgbWVkaWEgc3RyZWFtIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxWaWRlb0VsZW1lbnR9IFt2aWRlb10gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0Pn0gVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVPbmNlRnJvbVN0cmVhbShzdHJlYW0sIHZpZGVvU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWRlbyA9IHlpZWxkIHRoaXMuYXR0YWNoU3RyZWFtVG9WaWRlbyhzdHJlYW0sIHZpZGVvU291cmNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLmRlY29kZU9uY2UodmlkZW8pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGludW91c2x5IGRlY29kZXMgdGhlIGJhcmNvZGUgZnJvbSB0aGUgZGV2aWNlIHNwZWNpZmllZCBieSBkZXZpY2Ugd2hpbGUgc2hvd2luZyB0aGUgdmlkZW8gaW4gdGhlIHNwZWNpZmllZCB2aWRlbyBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBbZGV2aWNlSWRdIHRoZSBpZCBvZiBvbmUgb2YgdGhlIGRldmljZXMgb2J0YWluZWQgYWZ0ZXIgY2FsbGluZyBnZXRWaWRlb0lucHV0RGV2aWNlcy4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gdGhpcyBjYXNlIGl0IHdpbGwgZGVjb2RlIGZyb20gb25lIG9mIHRoZSBhdmFpbGFibGUgZGV2aWNlcywgcHJlZmZlcmluZyB0aGUgbWFpbiBjYW1lcmEgKGVudmlyb25tZW50IGZhY2luZykgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MVmlkZW9FbGVtZW50fG51bGx9IFt2aWRlb10gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGRlY29kZUZyb21WaWRlb0RldmljZWAgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21JbnB1dFZpZGVvRGV2aWNlQ29udGludW91c2x5KGRldmljZUlkLCB2aWRlb1NvdXJjZSwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5kZWNvZGVGcm9tVmlkZW9EZXZpY2UoZGV2aWNlSWQsIHZpZGVvU291cmNlLCBjYWxsYmFja0ZuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250aW51b3VzbHkgdHJpZXMgdG8gZGVjb2RlIHRoZSBiYXJjb2RlIGZyb20gdGhlIGRldmljZSBzcGVjaWZpZWQgYnkgZGV2aWNlIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gW2RldmljZUlkXSB0aGUgaWQgb2Ygb25lIG9mIHRoZSBkZXZpY2VzIG9idGFpbmVkIGFmdGVyIGNhbGxpbmcgZ2V0VmlkZW9JbnB1dERldmljZXMuIENhbiBiZSB1bmRlZmluZWQsIGluIHRoaXMgY2FzZSBpdCB3aWxsIGRlY29kZSBmcm9tIG9uZSBvZiB0aGUgYXZhaWxhYmxlIGRldmljZXMsIHByZWZmZXJpbmcgdGhlIG1haW4gY2FtZXJhIChlbnZpcm9ubWVudCBmYWNpbmcpIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTFZpZGVvRWxlbWVudHxudWxsfSBbdmlkZW9dIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21WaWRlb0RldmljZShkZXZpY2VJZCwgdmlkZW9Tb3VyY2UsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZpZGVvQ29uc3RyYWludHM7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXZpY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICB2aWRlb0NvbnN0cmFpbnRzID0geyBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2aWRlb0NvbnN0cmFpbnRzID0geyBkZXZpY2VJZDogeyBleGFjdDogZGV2aWNlSWQgfSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHsgdmlkZW86IHZpZGVvQ29uc3RyYWludHMgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5kZWNvZGVGcm9tQ29uc3RyYWludHMoY29uc3RyYWludHMsIHZpZGVvU291cmNlLCBjYWxsYmFja0ZuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250aW51b3VzbHkgdHJpZXMgdG8gZGVjb2RlIHRoZSBiYXJjb2RlIGZyb20gYSBzdHJlYW0gb2J0YWluZWQgZnJvbSB0aGUgZ2l2ZW4gY29uc3RyYWludHMgd2hpbGUgc2hvd2luZyB0aGUgdmlkZW8gaW4gdGhlIHNwZWNpZmllZCB2aWRlbyBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBbY29uc3RyYWludHNdIHRoZSBtZWRpYSBzdHJlYW0gY29uc3RyYWludHMgdG8gZ2V0IHMgdmFsaWQgbWVkaWEgc3RyZWFtIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxWaWRlb0VsZW1lbnR9IFt2aWRlb10gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0Pn0gVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tQ29uc3RyYWludHMoY29uc3RyYWludHMsIHZpZGVvU291cmNlLCBjYWxsYmFja0ZuKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5kZWNvZGVGcm9tU3RyZWFtKHN0cmVhbSwgdmlkZW9Tb3VyY2UsIGNhbGxiYWNrRm4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIG9uZSBhdHRlbXB0LCB0cmllcyB0byBkZWNvZGUgdGhlIGJhcmNvZGUgZnJvbSBhIHN0cmVhbSBvYnRhaW5lZCBmcm9tIHRoZSBnaXZlbiBjb25zdHJhaW50cyB3aGlsZSBzaG93aW5nIHRoZSB2aWRlbyBpbiB0aGUgc3BlY2lmaWVkIHZpZGVvIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IFtjb25zdHJhaW50c10gdGhlIG1lZGlhIHN0cmVhbSBjb25zdHJhaW50cyB0byBnZXQgcyB2YWxpZCBtZWRpYSBzdHJlYW0gdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTFZpZGVvRWxlbWVudH0gW3ZpZGVvXSB0aGUgdmlkZW8gZWxlbWVudCBpbiBwYWdlIHdoZXJlIHRvIHNob3cgdGhlIHZpZGVvIHdoaWxlIGRlY29kaW5nLiBDYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgZGlyZWN0bHkgYW4gSFRNTFZpZGVvRWxlbWVudC4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gd2hpY2ggY2FzZSBubyB2aWRlbyB3aWxsIGJlIHNob3duLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ+fSBUaGUgZGVjb2RpbmcgcmVzdWx0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21TdHJlYW0oc3RyZWFtLCB2aWRlb1NvdXJjZSwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlkZW8gPSB5aWVsZCB0aGlzLmF0dGFjaFN0cmVhbVRvVmlkZW8oc3RyZWFtLCB2aWRlb1NvdXJjZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlQ29udGludW91c2x5KHZpZGVvLCBjYWxsYmFja0ZuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcmVha3MgdGhlIGRlY29kaW5nIGxvb3AuXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wQXN5bmNEZWNvZGUoKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wQXN5bmNEZWNvZGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcmVha3MgdGhlIGRlY29kaW5nIGxvb3AuXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wQ29udGludW91c0RlY29kZSgpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BDb250aW51b3VzRGVjb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgbmV3IHN0cmVhbSBhbmQgcmVxdWVzdCBhIG5ldyBkZWNvZGluZy13aXRoLWRlbGF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3RyZWFtIFRoZSBzdHJlYW0gdG8gYmUgc2hvd24gaW4gdGhlIHZpZGVvIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSBkZWNvZGVGbiBBIGNhbGxiYWNrIGZvciB0aGUgZGVjb2RlIG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIGF0dGFjaFN0cmVhbVRvVmlkZW8oc3RyZWFtLCB2aWRlb1NvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWRlb0VsZW1lbnQgPSB0aGlzLnByZXBhcmVWaWRlb0VsZW1lbnQodmlkZW9Tb3VyY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVmlkZW9Tb3VyY2UodmlkZW9FbGVtZW50LCBzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9FbGVtZW50ID0gdmlkZW9FbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGxheVZpZGVvT25Mb2FkQXN5bmModmlkZW9FbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW9FbGVtZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB2aWRlb0VsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHBsYXlWaWRlb09uTG9hZEFzeW5jKHZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHRoaXMucGxheVZpZGVvT25Mb2FkKHZpZGVvRWxlbWVudCwgKCkgPT4gcmVzb2x2ZSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmRzIGxpc3RlbmVycyBhbmQgY2FsbGJhY2tzIHRvIHRoZSB2aWRlb0VsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFja0ZuXG4gICAgICAgICAqL1xuICAgICAgICBwbGF5VmlkZW9PbkxvYWQoZWxlbWVudCwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgdGhpcy52aWRlb0VuZGVkTGlzdGVuZXIgPSAoKSA9PiB0aGlzLnN0b3BTdHJlYW1zKCk7XG4gICAgICAgICAgICB0aGlzLnZpZGVvQ2FuUGxheUxpc3RlbmVyID0gKCkgPT4gdGhpcy50cnlQbGF5VmlkZW8oZWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy52aWRlb0VuZGVkTGlzdGVuZXIpO1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5JywgdGhpcy52aWRlb0NhblBsYXlMaXN0ZW5lcik7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCBjYWxsYmFja0ZuKTtcbiAgICAgICAgICAgIC8vIGlmIGNhbnBsYXkgd2FzIGFscmVhZHkgZmlyZWQsIHdlIHdvbid0IGtub3cgd2hlbiB0byBwbGF5LCBzbyBqdXN0IGdpdmUgaXQgYSB0cnlcbiAgICAgICAgICAgIHRoaXMudHJ5UGxheVZpZGVvKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZpZGVvIGVsZW1lbnQgaXMgY3VycmVudGx5IHBsYXlpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBpc1ZpZGVvUGxheWluZyh2aWRlbykge1xuICAgICAgICAgICAgcmV0dXJuIHZpZGVvLmN1cnJlbnRUaW1lID4gMCAmJiAhdmlkZW8ucGF1c2VkICYmICF2aWRlby5lbmRlZCAmJiB2aWRlby5yZWFkeVN0YXRlID4gMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSnVzdCB0cmllcyB0byBwbGF5IHRoZSB2aWRlbyBhbmQgbG9ncyBhbnkgZXJyb3JzLlxuICAgICAgICAgKiBUaGUgcGxheSBjYWxsIGlzIG9ubHkgbWFkZSBpcyB0aGUgdmlkZW8gaXMgbm90IGFscmVhZHkgcGxheWluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRyeVBsYXlWaWRlbyh2aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXlpbmcodmlkZW9FbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RyeWluZyB0byBwbGF5IHZpZGVvIHRoYXQgaXMgYWxyZWFkeSBwbGF5aW5nLicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHZpZGVvRWxlbWVudC5wbGF5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0l0IHdhcyBub3QgcG9zc2libGUgdG8gcGxheSB0aGUgdmlkZW8uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlYXJjaGVzIGFuZCB2YWxpZGF0ZXMgYSBtZWRpYSBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TWVkaWFFbGVtZW50KG1lZGlhRWxlbWVudElkLCB0eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBtZWRpYUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtZWRpYUVsZW1lbnRJZCk7XG4gICAgICAgICAgICBpZiAoIW1lZGlhRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihgZWxlbWVudCB3aXRoIGlkICcke21lZGlhRWxlbWVudElkfScgbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVkaWFFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihgZWxlbWVudCB3aXRoIGlkICcke21lZGlhRWxlbWVudElkfScgbXVzdCBiZSBhbiAke3R5cGV9IGVsZW1lbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZWRpYUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgdGhlIGJhcmNvZGUgZnJvbSBhbiBpbWFnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsoc3RyaW5nfEhUTUxJbWFnZUVsZW1lbnQpfSBbc291cmNlXSBUaGUgaW1hZ2UgZWxlbWVudCB0aGF0IGNhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciB0aGUgZWxlbWVudCBpdHNlbGYuIENhbiBiZSB1bmRlZmluZWQgaW4gd2hpY2ggY2FzZSB0aGUgZGVjb2Rpbmcgd2lsbCBiZSBkb25lIGZyb20gdGhlIGltYWdlVXJsIHBhcmFtZXRlci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt1cmxdXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3VsdD59IFRoZSBkZWNvZGluZyByZXN1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlRnJvbUltYWdlKHNvdXJjZSwgdXJsKSB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZSAmJiAhdXJsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKCdlaXRoZXIgaW1hZ2VFbGVtZW50IHdpdGggYSBzcmMgc2V0IG9yIGFuIHVybCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXJsICYmICFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGcm9tSW1hZ2VVcmwodXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZyb21JbWFnZUVsZW1lbnQoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyB0aGUgYmFyY29kZSBmcm9tIGEgdmlkZW8uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3xIVE1MSW1hZ2VFbGVtZW50KX0gW3NvdXJjZV0gVGhlIGltYWdlIGVsZW1lbnQgdGhhdCBjYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgdGhlIGVsZW1lbnQgaXRzZWxmLiBDYW4gYmUgdW5kZWZpbmVkIGluIHdoaWNoIGNhc2UgdGhlIGRlY29kaW5nIHdpbGwgYmUgZG9uZSBmcm9tIHRoZSBpbWFnZVVybCBwYXJhbWV0ZXIuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXJsXVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ+fSBUaGUgZGVjb2RpbmcgcmVzdWx0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21WaWRlbyhzb3VyY2UsIHVybCkge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UgJiYgIXVybCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbignRWl0aGVyIGFuIGVsZW1lbnQgd2l0aCBhIHNyYyBzZXQgb3IgYW4gVVJMIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cmwgJiYgIXNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZyb21WaWRlb1VybCh1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRnJvbVZpZGVvRWxlbWVudChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGNvbnRpbnVvdXNseSB0aGUgYmFyY29kZSBmcm9tIGEgdmlkZW8uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3xIVE1MSW1hZ2VFbGVtZW50KX0gW3NvdXJjZV0gVGhlIGltYWdlIGVsZW1lbnQgdGhhdCBjYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgdGhlIGVsZW1lbnQgaXRzZWxmLiBDYW4gYmUgdW5kZWZpbmVkIGluIHdoaWNoIGNhc2UgdGhlIGRlY29kaW5nIHdpbGwgYmUgZG9uZSBmcm9tIHRoZSBpbWFnZVVybCBwYXJhbWV0ZXIuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXJsXVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ+fSBUaGUgZGVjb2RpbmcgcmVzdWx0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlRnJvbVZpZGVvQ29udGludW91c2x5KHNvdXJjZSwgdXJsLCBjYWxsYmFja0ZuKSB7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBzb3VyY2UgJiYgdW5kZWZpbmVkID09PSB1cmwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oJ0VpdGhlciBhbiBlbGVtZW50IHdpdGggYSBzcmMgc2V0IG9yIGFuIFVSTCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXJsICYmICFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGcm9tVmlkZW9VcmxDb250aW51b3VzbHkodXJsLCBjYWxsYmFja0ZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZyb21WaWRlb0VsZW1lbnRDb250aW51b3VzbHkoc291cmNlLCBjYWxsYmFja0ZuKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBzb21ldGhpbmcgZnJvbSBhbiBpbWFnZSBIVE1MIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tSW1hZ2VFbGVtZW50KHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oJ0FuIGltYWdlIGVsZW1lbnQgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnByZXBhcmVJbWFnZUVsZW1lbnQoc291cmNlKTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbWFnZUxvYWRlZChlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHRhc2sgPSB0aGlzLmRlY29kZU9uY2UoZWxlbWVudCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFzayA9IHRoaXMuX2RlY29kZU9uTG9hZEltYWdlKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgc29tZXRoaW5nIGZyb20gYW4gaW1hZ2UgSFRNTCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlRnJvbVZpZGVvRWxlbWVudChzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9kZWNvZGVGcm9tVmlkZW9FbGVtZW50U2V0dXAoc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVPbkxvYWRWaWRlbyhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBzb21ldGhpbmcgZnJvbSBhbiBpbWFnZSBIVE1MIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tVmlkZW9FbGVtZW50Q29udGludW91c2x5KHNvdXJjZSwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2RlY29kZUZyb21WaWRlb0VsZW1lbnRTZXR1cChzb3VyY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZU9uTG9hZFZpZGVvQ29udGludW91c2x5KGVsZW1lbnQsIGNhbGxiYWNrRm4pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHVwIHRoZSB2aWRlbyBzb3VyY2Ugc28gaXQgY2FuIGJlIGRlY29kZWQgd2hlbiBsb2FkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzb3VyY2UgVGhlIHZpZGVvIHNvdXJjZSBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgX2RlY29kZUZyb21WaWRlb0VsZW1lbnRTZXR1cChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKCdBIHZpZGVvIGVsZW1lbnQgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnByZXBhcmVWaWRlb0VsZW1lbnQoc291cmNlKTtcbiAgICAgICAgICAgIC8vIGRlZmluZXMgdGhlIHZpZGVvIGVsZW1lbnQgYmVmb3JlIHN0YXJ0cyBkZWNvZGluZ1xuICAgICAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYW4gaW1hZ2UgZnJvbSBhIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21JbWFnZVVybCh1cmwpIHtcbiAgICAgICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKCdBbiBVUkwgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnByZXBhcmVJbWFnZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZVRhc2sgPSB0aGlzLl9kZWNvZGVPbkxvYWRJbWFnZShlbGVtZW50KTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3JjID0gdXJsO1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYW4gaW1hZ2UgZnJvbSBhIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21WaWRlb1VybCh1cmwpIHtcbiAgICAgICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKCdBbiBVUkwgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZXMgYSBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMucHJlcGFyZVZpZGVvRWxlbWVudCgpO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlVGFzayA9IHRoaXMuZGVjb2RlRnJvbVZpZGVvRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3JjID0gdXJsO1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYW4gaW1hZ2UgZnJvbSBhIFVSTC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlRnJvbVZpZGVvVXJsQ29udGludW91c2x5KHVybCwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oJ0FuIFVSTCBtdXN0IGJlIHByb3ZpZGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgLy8gY3JlYXRlcyBhIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5wcmVwYXJlVmlkZW9FbGVtZW50KCk7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVUYXNrID0gdGhpcy5kZWNvZGVGcm9tVmlkZW9FbGVtZW50Q29udGludW91c2x5KGVsZW1lbnQsIGNhbGxiYWNrRm4pO1xuICAgICAgICAgICAgZWxlbWVudC5zcmMgPSB1cmw7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlVGFzaztcbiAgICAgICAgfVxuICAgICAgICBfZGVjb2RlT25Mb2FkSW1hZ2UoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlTG9hZGVkTGlzdGVuZXIgPSAoKSA9PiB0aGlzLmRlY29kZU9uY2UoZWxlbWVudCwgZmFsc2UsIHRydWUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLmltYWdlTG9hZGVkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX2RlY29kZU9uTG9hZFZpZGVvKHZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAvLyBwbGF5cyB0aGUgdmlkZW9cbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBsYXlWaWRlb09uTG9hZEFzeW5jKHZpZGVvRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnRzIGRlY29kaW5nIGFmdGVyIHBsYXllZCB0aGUgdmlkZW9cbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5kZWNvZGVPbmNlKHZpZGVvRWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfZGVjb2RlT25Mb2FkVmlkZW9Db250aW51b3VzbHkodmlkZW9FbGVtZW50LCBjYWxsYmFja0ZuKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIC8vIHBsYXlzIHRoZSB2aWRlb1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGxheVZpZGVvT25Mb2FkQXN5bmModmlkZW9FbGVtZW50KTtcbiAgICAgICAgICAgICAgICAvLyBzdGFydHMgZGVjb2RpbmcgYWZ0ZXIgcGxheWVkIHRoZSB2aWRlb1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlQ29udGludW91c2x5KHZpZGVvRWxlbWVudCwgY2FsbGJhY2tGbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpc0ltYWdlTG9hZGVkKGltZykge1xuICAgICAgICAgICAgLy8gRHVyaW5nIHRoZSBvbmxvYWQgZXZlbnQsIElFIGNvcnJlY3RseSBpZGVudGlmaWVzIGFueSBpbWFnZXMgdGhhdFxuICAgICAgICAgICAgLy8gd2VyZW7igJl0IGRvd25sb2FkZWQgYXMgbm90IGNvbXBsZXRlLiBPdGhlcnMgc2hvdWxkIHRvby4gR2Vja28tYmFzZWRcbiAgICAgICAgICAgIC8vIGJyb3dzZXJzIGFjdCBsaWtlIE5TNCBpbiB0aGF0IHRoZXkgcmVwb3J0IHRoaXMgaW5jb3JyZWN0bHkuXG4gICAgICAgICAgICBpZiAoIWltZy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoZXkgZG8gaGF2ZSB0d28gdmVyeSB1c2VmdWwgcHJvcGVydGllczogbmF0dXJhbFdpZHRoIGFuZFxuICAgICAgICAgICAgLy8gbmF0dXJhbEhlaWdodC4gVGhlc2UgZ2l2ZSB0aGUgdHJ1ZSBzaXplIG9mIHRoZSBpbWFnZS4gSWYgaXQgZmFpbGVkXG4gICAgICAgICAgICAvLyB0byBsb2FkLCBlaXRoZXIgb2YgdGhlc2Ugc2hvdWxkIGJlIHplcm8uXG4gICAgICAgICAgICBpZiAoaW1nLm5hdHVyYWxXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vIG90aGVyIHdheSBvZiBjaGVja2luZzogYXNzdW1lIGl04oCZcyBvay5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHByZXBhcmVJbWFnZUVsZW1lbnQoaW1hZ2VTb3VyY2UpIHtcbiAgICAgICAgICAgIGxldCBpbWFnZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGltYWdlU291cmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudC53aWR0aCA9IDIwMDtcbiAgICAgICAgICAgICAgICBpbWFnZUVsZW1lbnQuaGVpZ2h0ID0gMjAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbWFnZVNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbWFnZUVsZW1lbnQgPSB0aGlzLmdldE1lZGlhRWxlbWVudChpbWFnZVNvdXJjZSwgJ2ltZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltYWdlU291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudCA9IGltYWdlU291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGltYWdlRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBhIEhUTUxWaWRlb0VsZW1lbnQgZm9yIHNjYW5uaW5nIG9yIGNyZWF0ZXMgYSBuZXcgb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdmlkZW9Tb3VyY2UgVGhlIEhUTUxWaWRlb0VsZW1lbnQgdG8gYmUgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJlcGFyZVZpZGVvRWxlbWVudCh2aWRlb1NvdXJjZSkge1xuICAgICAgICAgICAgbGV0IHZpZGVvRWxlbWVudDtcbiAgICAgICAgICAgIGlmICghdmlkZW9Tb3VyY2UgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LndpZHRoID0gMjAwO1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5oZWlnaHQgPSAyMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZpZGVvU291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudCA9IHRoaXMuZ2V0TWVkaWFFbGVtZW50KHZpZGVvU291cmNlLCAndmlkZW8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWRlb1NvdXJjZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQgPSB2aWRlb1NvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5lZWRlZCBmb3IgaU9TIDExXG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKCdhdXRvcGxheScsICd0cnVlJyk7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKCdtdXRlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICd0cnVlJyk7XG4gICAgICAgICAgICByZXR1cm4gdmlkZW9FbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmllcyB0byBkZWNvZGUgZnJvbSB0aGUgdmlkZW8gaW5wdXQgdW50aWwgaXQgZmluZHMgc29tZSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZU9uY2UoZWxlbWVudCwgcmV0cnlJZk5vdEZvdW5kID0gdHJ1ZSwgcmV0cnlJZkNoZWNrc3VtT3JGb3JtYXRFcnJvciA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BBc3luY0RlY29kZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgbG9vcCA9IChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RvcEFzeW5jRGVjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgTm90Rm91bmRFeGNlcHRpb24oJ1ZpZGVvIHN0cmVhbSBoYXMgZW5kZWQgYmVmb3JlIGFueSBjb2RlIGNvdWxkIGJlIGRldGVjdGVkLicpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcEFzeW5jRGVjb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZGVjb2RlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlmTm90Rm91bmQgPSByZXRyeUlmTm90Rm91bmQgJiYgZSBpbnN0YW5jZW9mIE5vdEZvdW5kRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0NoZWNrc3VtT3JGb3JtYXRFcnJvciA9IGUgaW5zdGFuY2VvZiBDaGVja3N1bUV4Y2VwdGlvbiB8fCBlIGluc3RhbmNlb2YgRm9ybWF0RXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZkNoZWNrc3VtT3JGb3JtYXQgPSBpc0NoZWNrc3VtT3JGb3JtYXRFcnJvciAmJiByZXRyeUlmQ2hlY2tzdW1PckZvcm1hdEVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWZOb3RGb3VuZCB8fCBpZkNoZWNrc3VtT3JGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeWluZyBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQobG9vcCwgdGhpcy5fdGltZUJldHdlZW5EZWNvZGluZ0F0dGVtcHRzLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGxvb3AocmVzb2x2ZSwgcmVqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRpbnVvdXNseSBkZWNvZGVzIGZyb20gdmlkZW8gaW5wdXQuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVDb250aW51b3VzbHkoZWxlbWVudCwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgdGhpcy5fc3RvcENvbnRpbnVvdXNEZWNvZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGxvb3AgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BDb250aW51b3VzRGVjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BDb250aW51b3VzRGVjb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZGVjb2RlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0ZuKHJlc3VsdCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcCwgdGhpcy50aW1lQmV0d2VlblNjYW5zTWlsbGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tGbihudWxsLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDaGVja3N1bU9yRm9ybWF0RXJyb3IgPSBlIGluc3RhbmNlb2YgQ2hlY2tzdW1FeGNlcHRpb24gfHwgZSBpbnN0YW5jZW9mIEZvcm1hdEV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNOb3RGb3VuZCA9IGUgaW5zdGFuY2VvZiBOb3RGb3VuZEV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hlY2tzdW1PckZvcm1hdEVycm9yIHx8IGlzTm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeWluZyBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wLCB0aGlzLl90aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxvb3AoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgQmluYXJ5Qml0bWFwIGZvciB5YSEgKGFuZCBkZWNvZGVzIGl0KVxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGdldCBiaW5hcnkgYml0bWFwIGZvciBkZWNvZGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IGJpbmFyeUJpdG1hcCA9IHRoaXMuY3JlYXRlQmluYXJ5Qml0bWFwKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlQml0bWFwKGJpbmFyeUJpdG1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiBtZWRpYSBlbGVtZW50IGlzIGluZGVlZCBhIHtAbGluayBIdG1sVmlkZW9FbGVtZW50fS5cbiAgICAgICAgICovXG4gICAgICAgIF9pc0hUTUxWaWRlb0VsZW1lbnQobWVkaWFFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwb3RlbnRpYWxWaWRlbyA9IG1lZGlhRWxlbWVudDtcbiAgICAgICAgICAgIHJldHVybiBwb3RlbnRpYWxWaWRlby52aWRlb1dpZHRoICE9PSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVyd3JpdGluZyB0aGlzIGFsbG93cyB5b3UgdG8gbWFuaXB1bGF0ZSB0aGUgbmV4dCBmcmFtZSBpbiBhbnl3YXlcbiAgICAgICAgICogeW91IHdhbnQgYmVmb3JlIGRlY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIGRyYXdGcmFtZU9uQ2FudmFzKFxuICAgICAgICAgICAgc3JjRWxlbWVudCwgZGltZW5zaW9ucywgY2FudmFzRWxlbWVudENvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICghZGltZW5zaW9ucykge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN4OiAwLFxuICAgICAgICAgICAgICAgICAgICBzeTogMCxcbiAgICAgICAgICAgICAgICAgICAgc1dpZHRoOiBzcmNFbGVtZW50LnZpZGVvV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHNIZWlnaHQ6IHNyY0VsZW1lbnQudmlkZW9IZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGR4OiAwLFxuICAgICAgICAgICAgICAgICAgICBkeTogMCxcbiAgICAgICAgICAgICAgICAgICAgZFdpZHRoOiBzcmNFbGVtZW50LnZpZGVvV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGRIZWlnaHQ6IHNyY0VsZW1lbnQudmlkZW9IZWlnaHR9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYW52YXNFbGVtZW50Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNhbnZhc0VsZW1lbnRDb250ZXh0ID0gdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbnZhc0VsZW1lbnRDb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICBzcmNFbGVtZW50LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuc3gsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5zeSxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnNXaWR0aCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnNIZWlnaHQsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5keCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmR5LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuZFdpZHRoLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuZEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXdyaXRpbmcgdGhpcyBhbGxvd3MgeW91IHRvIG1hbmlwdWxhdGUgdGhlIHNuYXBzaG90IGltYWdlIGluIGFueXdheVxuICAgICAgICAgKiAgeW91IHdhbnQgYmVmb3JlIGRlY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIGRyYXdJbWFnZU9uQ2FudmFzKFxuICAgICAgICAgICAgc3JjRWxlbWVudCxcbiAgICAgICAgICAgIGRpbWVuc2lvbnMsXG4gICAgICAgICAgICBjYW52YXNFbGVtZW50Q29udGV4dCA9IHRoaXMuY2FwdHVyZUNhbnZhc0NvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICghZGltZW5zaW9ucykge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN4OiAwLFxuICAgICAgICAgICAgICAgICAgICBzeTogMCxcbiAgICAgICAgICAgICAgICAgICAgc1dpZHRoOiBzcmNFbGVtZW50Lm5hdHVyYWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgc0hlaWdodDogc3JjRWxlbWVudC5uYXR1cmFsSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBkeDogMCxcbiAgICAgICAgICAgICAgICAgICAgZHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIGRXaWR0aDogc3JjRWxlbWVudC5uYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGRIZWlnaHQ6IHNyY0VsZW1lbnQubmF0dXJhbEhlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNhbnZhc0VsZW1lbnRDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FudmFzRWxlbWVudENvbnRleHQgPSB0aGlzLmNhcHR1cmVDYW52YXNDb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FudmFzRWxlbWVudENvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgIHNyY0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5zeCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnN5LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuc1dpZHRoLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuc0hlaWdodCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmR4LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuZHksXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5kV2lkdGgsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5kSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGJpbmFyeUJpdG1hcCBiYXNlZCBpbiBzb21lIGltYWdlIHNvdXJjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1lZGlhRWxlbWVudCBIVE1MIGVsZW1lbnQgY29udGFpbmluZyBkcmF3YWJsZSBpbWFnZSBzb3VyY2UuXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVCaW5hcnlCaXRtYXAobWVkaWFFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLmdldENhcHR1cmVDYW52YXNDb250ZXh0KG1lZGlhRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNIVE1MVmlkZW9FbGVtZW50KG1lZGlhRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdGcmFtZU9uQ2FudmFzKG1lZGlhRWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0ltYWdlT25DYW52YXMobWVkaWFFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuZ2V0Q2FwdHVyZUNhbnZhcyhtZWRpYUVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgbHVtaW5hbmNlU291cmNlID0gbmV3IEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlKGNhbnZhcyk7XG4gICAgICAgICAgICBjb25zdCBoeWJyaWRCaW5hcml6ZXIgPSBuZXcgSHlicmlkQmluYXJpemVyKGx1bWluYW5jZVNvdXJjZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5Qml0bWFwKGh5YnJpZEJpbmFyaXplcik7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRDYXB0dXJlQ2FudmFzQ29udGV4dChtZWRpYUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW0gPSB0aGlzLmdldENhcHR1cmVDYW52YXMobWVkaWFFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBlbGVtLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dCA9IGN0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhcHR1cmVDYW52YXNDb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGdldENhcHR1cmVDYW52YXMobWVkaWFFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FwdHVyZUNhbnZhcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW0gPSB0aGlzLmNyZWF0ZUNhcHR1cmVDYW52YXMobWVkaWFFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmVDYW52YXMgPSBlbGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FwdHVyZUNhbnZhcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbCB0aGUgZW5jYXBzdWxhdGVkIHJlYWRlcnMgZGVjb2RlXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVCaXRtYXAoYmluYXJ5Qml0bWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkZXIuZGVjb2RlKGJpbmFyeUJpdG1hcCwgdGhpcy5faGludHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDwn5aMIFByZXBhcmVzIHRoZSBjYW52YXMgZm9yIGNhcHR1cmUgYW5kIHNjYW4gZnJhbWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlQ2FwdHVyZUNhbnZhcyhtZWRpYUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveUNhcHR1cmVDYW52YXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGxldCB3aWR0aDtcbiAgICAgICAgICAgIGxldCBoZWlnaHQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lZGlhRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVkaWFFbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IG1lZGlhRWxlbWVudC52aWRlb1dpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBtZWRpYUVsZW1lbnQudmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lZGlhRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBtZWRpYUVsZW1lbnQubmF0dXJhbFdpZHRoIHx8IG1lZGlhRWxlbWVudC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gbWVkaWFFbGVtZW50Lm5hdHVyYWxIZWlnaHQgfHwgbWVkaWFFbGVtZW50LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW52YXNFbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgY2FudmFzRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgY2FudmFzRWxlbWVudC53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgY2FudmFzRWxlbWVudC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcHMgdGhlIGNvbnRpbnVvdXMgc2NhbiBhbmQgY2xlYW5zIHRoZSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wU3RyZWFtcygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaCh0ID0+IHQuc3RvcCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wQXN5bmNEZWNvZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wQXN5bmNEZWNvZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wQ29udGludW91c0RlY29kZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BDb250aW51b3VzRGVjb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUgY29kZSByZWFkZXIgdG8gdGhlIGluaXRpYWwgc3RhdGUuIENhbmNlbHMgYW55IG9uZ29pbmcgYmFyY29kZSBzY2FubmluZyBmcm9tIHZpZGVvIG9yIGNhbWVyYS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIC8vIHN0b3BzIHRoZSBjYW1lcmEsIHByZXZpZXcgYW5kIHNjYW4g8J+UtFxuICAgICAgICAgICAgdGhpcy5zdG9wU3RyZWFtcygpO1xuICAgICAgICAgICAgLy8gY2xlYW4gYW5kIGZvcmdldCBhYm91dCBIVE1MIGVsZW1lbnRzXG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95VmlkZW9FbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95SW1hZ2VFbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95Q2FwdHVyZUNhbnZhcygpO1xuICAgICAgICB9XG4gICAgICAgIF9kZXN0cm95VmlkZW9FbGVtZW50KCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZpcnN0IGdpdmVzIGZyZWVkb24gdG8gdGhlIGVsZW1lbnQg8J+VilxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnZpZGVvRW5kZWRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMudmlkZW9FbmRlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy52aWRlb1BsYXlpbmdFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLnZpZGVvUGxheWluZ0V2ZW50TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnZpZGVvQ2FuUGxheUxpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgdGhpcy52aWRlb0NhblBsYXlMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGVuIGZvcmdldHMgYWJvdXQgdGhhdCBlbGVtZW50IPCfmKJcbiAgICAgICAgICAgIHRoaXMuY2xlYW5WaWRlb1NvdXJjZSh0aGlzLnZpZGVvRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBfZGVzdHJveUltYWdlRWxlbWVudCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaXJzdCBnaXZlcyBmcmVlZG9uIHRvIHRoZSBlbGVtZW50IPCflYpcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IHRoaXMuaW1hZ2VMb2FkZWRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLmltYWdlTG9hZGVkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlbiBmb3JnZXQgYWJvdXQgdGhhdCBlbGVtZW50IPCfmKJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50LnNyYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYW5zIGNhbnZhcyByZWZlcmVuY2VzIPCfloxcbiAgICAgICAgICovXG4gICAgICAgIF9kZXN0cm95Q2FwdHVyZUNhbnZhcygpIHtcbiAgICAgICAgICAgIC8vIHRoZW4gZm9yZ2V0IGFib3V0IHRoYXQgZWxlbWVudCDwn5iiXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVDYW52YXNDb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlQ2FudmFzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHdoYXQgdGhlIHZpZGVvRWxlbWVudCBzcmMgd2lsbCBiZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZpZGVvRWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gc3RyZWFtXG4gICAgICAgICAqL1xuICAgICAgICBhZGRWaWRlb1NvdXJjZSh2aWRlb0VsZW1lbnQsIHN0cmVhbSkge1xuICAgICAgICAgICAgLy8gT2xkZXIgYnJvd3NlcnMgbWF5IG5vdCBoYXZlIGBzcmNPYmplY3RgXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEBub3RlIFRocm93cyBFeGNlcHRpb24gaWYgaW50ZXJydXB0ZWQgYnkgYSBuZXcgbG9hZGVkIHJlcXVlc3RcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIEBub3RlIEF2b2lkIHVzaW5nIHRoaXMgaW4gbmV3IGJyb3dzZXJzLCBhcyBpdCBpcyBnb2luZyBhd2F5LlxuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuYmluZHMgYSBIVE1MIHZpZGVvIHNyYyBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZpZGVvRWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYW5WaWRlb1NvdXJjZSh2aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNyYyA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIHRoZSByZXN1bHQgb2YgZGVjb2RpbmcgYSBiYXJjb2RlIHdpdGhpbiBhbiBpbWFnZS48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIFJlc3VsdCB7XG4gICAgICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIHRleHQ6IHN0cmluZyxcbiAgICAgICAgLy8gICAgICAgICAgICAgICBVaW50OEFycmF5IHJhd0J5dGVzLFxuICAgICAgICAvLyAgICAgICAgICAgICAgIFJlc3VsdFBvY29uc3QgcmVzdWx0UG9pbnRzOiBJbnQzMkFycmF5LFxuICAgICAgICAvLyAgICAgICAgICAgICAgIEJhcmNvZGVGb3JtYXQgZm9ybWF0KSB7XG4gICAgICAgIC8vICAgdGhpcyh0ZXh0LCByYXdCeXRlcywgcmVzdWx0UG9pbnRzLCBmb3JtYXQsIFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3Rvcih0ZXh0OiBzdHJpbmcsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgVWludDhBcnJheSByYXdCeXRlcyxcbiAgICAgICAgLy8gICAgICAgICAgICAgICBSZXN1bHRQb2NvbnN0IHJlc3VsdFBvaW50czogSW50MzJBcnJheSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICBCYXJjb2RlRm9ybWF0IGZvcm1hdCxcbiAgICAgICAgLy8gICAgICAgICAgICAgICBsb25nIHRpbWVzdGFtcCkge1xuICAgICAgICAvLyAgIHRoaXModGV4dCwgcmF3Qnl0ZXMsIHJhd0J5dGVzID09IG51bGwgPyAwIDogOCAqIHJhd0J5dGVzLmxlbmd0aCxcbiAgICAgICAgLy8gICAgICAgIHJlc3VsdFBvaW50cywgZm9ybWF0LCB0aW1lc3RhbXApXG4gICAgICAgIC8vIH1cbiAgICAgICAgY29uc3RydWN0b3IodGV4dCwgcmF3Qnl0ZXMsIG51bUJpdHMgPSByYXdCeXRlcyA9PSBudWxsID8gMCA6IDggKiByYXdCeXRlcy5sZW5ndGgsIHJlc3VsdFBvaW50cywgZm9ybWF0LCB0aW1lc3RhbXAgPSBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIHRoaXMucmF3Qnl0ZXMgPSByYXdCeXRlcztcbiAgICAgICAgICAgIHRoaXMubnVtQml0cyA9IG51bUJpdHM7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50cyA9IHJlc3VsdFBvaW50cztcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgdGhpcy5yYXdCeXRlcyA9IHJhd0J5dGVzO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gbnVtQml0cyB8fCBudWxsID09PSBudW1CaXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5udW1CaXRzID0gKHJhd0J5dGVzID09PSBudWxsIHx8IHJhd0J5dGVzID09PSB1bmRlZmluZWQpID8gMCA6IDggKiByYXdCeXRlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm51bUJpdHMgPSBudW1CaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludHMgPSByZXN1bHRQb2ludHM7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0TWV0YWRhdGEgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gdGltZXN0YW1wIHx8IG51bGwgPT09IHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gU3lzdGVtLmN1cnJlbnRUaW1lTWlsbGlzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiByYXcgdGV4dCBlbmNvZGVkIGJ5IHRoZSBiYXJjb2RlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRUZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiByYXcgYnl0ZXMgZW5jb2RlZCBieSB0aGUgYmFyY29kZSwgaWYgYXBwbGljYWJsZSwgb3RoZXJ3aXNlIHtAY29kZSBudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYXdCeXRlcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBob3cgbWFueSBiaXRzIG9mIHtAbGluayAjZ2V0UmF3Qnl0ZXMoKX0gYXJlIHZhbGlkOyB0eXBpY2FsbHkgOCB0aW1lcyBpdHMgbGVuZ3RoXG4gICAgICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TnVtQml0cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bUJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gcG9pbnRzIHJlbGF0ZWQgdG8gdGhlIGJhcmNvZGUgaW4gdGhlIGltYWdlLiBUaGVzZSBhcmUgdHlwaWNhbGx5IHBvaW50c1xuICAgICAgICAgKiAgICAgICAgIGlkZW50aWZ5aW5nIGZpbmRlciBwYXR0ZXJucyBvciB0aGUgY29ybmVycyBvZiB0aGUgYmFyY29kZS4gVGhlIGV4YWN0IG1lYW5pbmcgaXNcbiAgICAgICAgICogICAgICAgICBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiBiYXJjb2RlIHRoYXQgd2FzIGRlY29kZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSZXN1bHRQb2ludHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRQb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIEJhcmNvZGVGb3JtYXR9IHJlcHJlc2VudGluZyB0aGUgZm9ybWF0IG9mIHRoZSBiYXJjb2RlIHRoYXQgd2FzIGRlY29kZWRcbiAgICAgICAgICovXG4gICAgICAgIGdldEJhcmNvZGVGb3JtYXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIE1hcH0gbWFwcGluZyB7QGxpbmsgUmVzdWx0TWV0YWRhdGFUeXBlfSBrZXlzIHRvIHZhbHVlcy4gTWF5IGJlXG4gICAgICAgICAqICAge0Bjb2RlIG51bGx9LiBUaGlzIGNvbnRhaW5zIG9wdGlvbmFsIG1ldGFkYXRhIGFib3V0IHdoYXQgd2FzIGRldGVjdGVkIGFib3V0IHRoZSBiYXJjb2RlLFxuICAgICAgICAgKiAgIGxpa2Ugb3JpZW50YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSZXN1bHRNZXRhZGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdE1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHB1dE1ldGFkYXRhKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bHRNZXRhZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0TWV0YWRhdGEgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc3VsdE1ldGFkYXRhLnNldCh0eXBlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHV0QWxsTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdE1ldGFkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0TWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0TWV0YWRhdGEgPSBuZXcgTWFwKG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkUmVzdWx0UG9pbnRzKG5ld1BvaW50cykge1xuICAgICAgICAgICAgY29uc3Qgb2xkUG9pbnRzID0gdGhpcy5yZXN1bHRQb2ludHM7XG4gICAgICAgICAgICBpZiAob2xkUG9pbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludHMgPSBuZXdQb2ludHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdQb2ludHMgIT09IG51bGwgJiYgbmV3UG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxQb2ludHMgPSBuZXcgQXJyYXkob2xkUG9pbnRzLmxlbmd0aCArIG5ld1BvaW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkob2xkUG9pbnRzLCAwLCBhbGxQb2ludHMsIDAsIG9sZFBvaW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkobmV3UG9pbnRzLCAwLCBhbGxQb2ludHMsIG9sZFBvaW50cy5sZW5ndGgsIG5ld1BvaW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRzID0gYWxsUG9pbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldFRpbWVzdGFtcCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogRGlyZWN0IHBvcnQgdG8gVHlwZVNjcmlwdCBvZiBaWGluZyBieSBBZHJpYW4gVG/ImWPEg1xuICAgICAqL1xuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cbiAgICAvKipcbiAgICAgKiBFbnVtZXJhdGVzIGJhcmNvZGUgZm9ybWF0cyBrbm93biB0byB0aGlzIHBhY2thZ2UuIFBsZWFzZSBrZWVwIGFscGhhYmV0aXplZC5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgdmFyIEJhcmNvZGVGb3JtYXQ7XG4gICAgKGZ1bmN0aW9uIChCYXJjb2RlRm9ybWF0KSB7XG4gICAgICAgIC8qKiBBenRlYyAyRCBiYXJjb2RlIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiQVpURUNcIl0gPSAwXSA9IFwiQVpURUNcIjtcbiAgICAgICAgLyoqIENPREFCQVIgMUQgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJDT0RBQkFSXCJdID0gMV0gPSBcIkNPREFCQVJcIjtcbiAgICAgICAgLyoqIENvZGUgMzkgMUQgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJDT0RFXzM5XCJdID0gMl0gPSBcIkNPREVfMzlcIjtcbiAgICAgICAgLyoqIENvZGUgOTMgMUQgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJDT0RFXzkzXCJdID0gM10gPSBcIkNPREVfOTNcIjtcbiAgICAgICAgLyoqIENvZGUgMTI4IDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiQ09ERV8xMjhcIl0gPSA0XSA9IFwiQ09ERV8xMjhcIjtcbiAgICAgICAgLyoqIERhdGEgTWF0cml4IDJEIGJhcmNvZGUgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJEQVRBX01BVFJJWFwiXSA9IDVdID0gXCJEQVRBX01BVFJJWFwiO1xuICAgICAgICAvKiogRUFOLTggMUQgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJFQU5fOFwiXSA9IDZdID0gXCJFQU5fOFwiO1xuICAgICAgICAvKiogRUFOLTEzIDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiRUFOXzEzXCJdID0gN10gPSBcIkVBTl8xM1wiO1xuICAgICAgICAvKiogSVRGIChJbnRlcmxlYXZlZCBUd28gb2YgRml2ZSkgMUQgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJJVEZcIl0gPSA4XSA9IFwiSVRGXCI7XG4gICAgICAgIC8qKiBNYXhpQ29kZSAyRCBiYXJjb2RlIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiTUFYSUNPREVcIl0gPSA5XSA9IFwiTUFYSUNPREVcIjtcbiAgICAgICAgLyoqIFBERjQxNyBmb3JtYXQuICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIlBERl80MTdcIl0gPSAxMF0gPSBcIlBERl80MTdcIjtcbiAgICAgICAgLyoqIFFSIENvZGUgMkQgYmFyY29kZSBmb3JtYXQuICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIlFSX0NPREVcIl0gPSAxMV0gPSBcIlFSX0NPREVcIjtcbiAgICAgICAgLyoqIFJTUyAxNCAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJSU1NfMTRcIl0gPSAxMl0gPSBcIlJTU18xNFwiO1xuICAgICAgICAvKiogUlNTIEVYUEFOREVEICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIlJTU19FWFBBTkRFRFwiXSA9IDEzXSA9IFwiUlNTX0VYUEFOREVEXCI7XG4gICAgICAgIC8qKiBVUEMtQSAxRCBmb3JtYXQuICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIlVQQ19BXCJdID0gMTRdID0gXCJVUENfQVwiO1xuICAgICAgICAvKiogVVBDLUUgMUQgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJVUENfRVwiXSA9IDE1XSA9IFwiVVBDX0VcIjtcbiAgICAgICAgLyoqIFVQQy9FQU4gZXh0ZW5zaW9uIGZvcm1hdC4gTm90IGEgc3RhbmQtYWxvbmUgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJVUENfRUFOX0VYVEVOU0lPTlwiXSA9IDE2XSA9IFwiVVBDX0VBTl9FWFRFTlNJT05cIjtcbiAgICB9KShCYXJjb2RlRm9ybWF0IHx8IChCYXJjb2RlRm9ybWF0ID0ge30pKTtcbiAgICB2YXIgQmFyY29kZUZvcm1hdCQxID0gQmFyY29kZUZvcm1hdDtcblxuICAgIC8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBzb21lIHR5cGUgb2YgbWV0YWRhdGEgYWJvdXQgdGhlIHJlc3VsdCBvZiB0aGUgZGVjb2RpbmcgdGhhdCB0aGUgZGVjb2RlclxuICAgICAqIHdpc2hlcyB0byBjb21tdW5pY2F0ZSBiYWNrIHRvIHRoZSBjYWxsZXIuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIHZhciBSZXN1bHRNZXRhZGF0YVR5cGU7XG4gICAgKGZ1bmN0aW9uIChSZXN1bHRNZXRhZGF0YVR5cGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuc3BlY2lmaWVkLCBhcHBsaWNhdGlvbi1zcGVjaWZpYyBtZXRhZGF0YS4gTWFwcyB0byBhbiB1bnNwZWNpZmllZCB7QGxpbmsgT2JqZWN0fS5cbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJPVEhFUlwiXSA9IDBdID0gXCJPVEhFUlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVub3RlcyB0aGUgbGlrZWx5IGFwcHJveGltYXRlIG9yaWVudGF0aW9uIG9mIHRoZSBiYXJjb2RlIGluIHRoZSBpbWFnZS4gVGhpcyB2YWx1ZVxuICAgICAgICAgKiBpcyBnaXZlbiBhcyBkZWdyZWVzIHJvdGF0ZWQgY2xvY2t3aXNlIGZyb20gdGhlIG5vcm1hbCwgdXByaWdodCBvcmllbnRhdGlvbi5cbiAgICAgICAgICogRm9yIGV4YW1wbGUgYSAxRCBiYXJjb2RlIHdoaWNoIHdhcyBmb3VuZCBieSByZWFkaW5nIHRvcC10by1ib3R0b20gd291bGQgYmVcbiAgICAgICAgICogc2FpZCB0byBoYXZlIG9yaWVudGF0aW9uIFwiOTBcIi4gVGhpcyBrZXkgbWFwcyB0byBhbiB7QGxpbmsgSW50ZWdlcn0gd2hvc2VcbiAgICAgICAgICogdmFsdWUgaXMgaW4gdGhlIHJhbmdlIFswLDM2MCkuXG4gICAgICAgICAqL1xuICAgICAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiT1JJRU5UQVRJT05cIl0gPSAxXSA9IFwiT1JJRU5UQVRJT05cIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPjJEIGJhcmNvZGUgZm9ybWF0cyB0eXBpY2FsbHkgZW5jb2RlIHRleHQsIGJ1dCBhbGxvdyBmb3IgYSBzb3J0IG9mICdieXRlIG1vZGUnXG4gICAgICAgICAqIHdoaWNoIGlzIHNvbWV0aW1lcyB1c2VkIHRvIGVuY29kZSBiaW5hcnkgZGF0YS4gV2hpbGUge0BsaW5rIFJlc3VsdH0gbWFrZXMgYXZhaWxhYmxlXG4gICAgICAgICAqIHRoZSBjb21wbGV0ZSByYXcgYnl0ZXMgaW4gdGhlIGJhcmNvZGUgZm9yIHRoZXNlIGZvcm1hdHMsIGl0IGRvZXMgbm90IG9mZmVyIHRoZSBieXRlc1xuICAgICAgICAgKiBmcm9tIHRoZSBieXRlIHNlZ21lbnRzIGFsb25lLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+VGhpcyBtYXBzIHRvIGEge0BsaW5rIGphdmEudXRpbC5MaXN0fSBvZiBieXRlIGFycmF5cyBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICAgICAgICAgKiByYXcgYnl0ZXMgaW4gdGhlIGJ5dGUgc2VnbWVudHMgaW4gdGhlIGJhcmNvZGUsIGluIG9yZGVyLjwvcD5cbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJCWVRFX1NFR01FTlRTXCJdID0gMl0gPSBcIkJZVEVfU0VHTUVOVFNcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVycm9yIGNvcnJlY3Rpb24gbGV2ZWwgdXNlZCwgaWYgYXBwbGljYWJsZS4gVGhlIHZhbHVlIHR5cGUgZGVwZW5kcyBvbiB0aGVcbiAgICAgICAgICogZm9ybWF0LCBidXQgaXMgdHlwaWNhbGx5IGEgU3RyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIkVSUk9SX0NPUlJFQ1RJT05fTEVWRUxcIl0gPSAzXSA9IFwiRVJST1JfQ09SUkVDVElPTl9MRVZFTFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIHNvbWUgcGVyaW9kaWNhbHMsIGluZGljYXRlcyB0aGUgaXNzdWUgbnVtYmVyIGFzIGFuIHtAbGluayBJbnRlZ2VyfS5cbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJJU1NVRV9OVU1CRVJcIl0gPSA0XSA9IFwiSVNTVUVfTlVNQkVSXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3Igc29tZSBwcm9kdWN0cywgaW5kaWNhdGVzIHRoZSBzdWdnZXN0ZWQgcmV0YWlsIHByaWNlIGluIHRoZSBiYXJjb2RlIGFzIGFcbiAgICAgICAgICogZm9ybWF0dGVkIHtAbGluayBTdHJpbmd9LlxuICAgICAgICAgKi9cbiAgICAgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIlNVR0dFU1RFRF9QUklDRVwiXSA9IDVdID0gXCJTVUdHRVNURURfUFJJQ0VcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciBzb21lIHByb2R1Y3RzLCB0aGUgcG9zc2libGUgY291bnRyeSBvZiBtYW51ZmFjdHVyZSBhcyBhIHtAbGluayBTdHJpbmd9IGRlbm90aW5nIHRoZVxuICAgICAgICAgKiBJU08gY291bnRyeSBjb2RlLiBTb21lIG1hcCB0byBtdWx0aXBsZSBwb3NzaWJsZSBjb3VudHJpZXMsIGxpa2UgXCJVUy9DQVwiLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIlBPU1NJQkxFX0NPVU5UUllcIl0gPSA2XSA9IFwiUE9TU0lCTEVfQ09VTlRSWVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIHNvbWUgcHJvZHVjdHMsIHRoZSBleHRlbnNpb24gdGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIlVQQ19FQU5fRVhURU5TSU9OXCJdID0gN10gPSBcIlVQQ19FQU5fRVhURU5TSU9OXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQREY0MTctc3BlY2lmaWMgbWV0YWRhdGFcbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJQREY0MTdfRVhUUkFfTUVUQURBVEFcIl0gPSA4XSA9IFwiUERGNDE3X0VYVFJBX01FVEFEQVRBXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgY29kZSBmb3JtYXQgc3VwcG9ydHMgc3RydWN0dXJlZCBhcHBlbmQgYW5kIHRoZSBjdXJyZW50IHNjYW5uZWQgY29kZSBpcyBwYXJ0IG9mIG9uZSB0aGVuIHRoZVxuICAgICAgICAgKiBzZXF1ZW5jZSBudW1iZXIgaXMgZ2l2ZW4gd2l0aCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJTVFJVQ1RVUkVEX0FQUEVORF9TRVFVRU5DRVwiXSA9IDldID0gXCJTVFJVQ1RVUkVEX0FQUEVORF9TRVFVRU5DRVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGNvZGUgZm9ybWF0IHN1cHBvcnRzIHN0cnVjdHVyZWQgYXBwZW5kIGFuZCB0aGUgY3VycmVudCBzY2FubmVkIGNvZGUgaXMgcGFydCBvZiBvbmUgdGhlbiB0aGVcbiAgICAgICAgICogcGFyaXR5IGlzIGdpdmVuIHdpdGggaXQuXG4gICAgICAgICAqL1xuICAgICAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiU1RSVUNUVVJFRF9BUFBFTkRfUEFSSVRZXCJdID0gMTBdID0gXCJTVFJVQ1RVUkVEX0FQUEVORF9QQVJJVFlcIjtcbiAgICB9KShSZXN1bHRNZXRhZGF0YVR5cGUgfHwgKFJlc3VsdE1ldGFkYXRhVHlwZSA9IHt9KSk7XG4gICAgdmFyIFJlc3VsdE1ldGFkYXRhVHlwZSQxID0gUmVzdWx0TWV0YWRhdGFUeXBlO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbiB7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTGlzdDsqL1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyB0aGUgcmVzdWx0IG9mIGRlY29kaW5nIGEgbWF0cml4IG9mIGJpdHMuIFRoaXMgdHlwaWNhbGx5XG4gICAgICogYXBwbGllcyB0byAyRCBiYXJjb2RlIGZvcm1hdHMuIEZvciBub3cgaXQgY29udGFpbnMgdGhlIHJhdyBieXRlcyBvYnRhaW5lZCxcbiAgICAgKiBhcyB3ZWxsIGFzIGEgU3RyaW5nIGludGVycHJldGF0aW9uIG9mIHRob3NlIGJ5dGVzLCBpZiBhcHBsaWNhYmxlLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGVjb2RlclJlc3VsdCB7XG4gICAgICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3RvcihyYXdCeXRlczogVWludDhBcnJheSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGV4dDogc3RyaW5nLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICBMaXN0PFVpbnQ4QXJyYXk+IGJ5dGVTZWdtZW50cyxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgU3RyaW5nIGVjTGV2ZWwpIHtcbiAgICAgICAgLy8gICB0aGlzKHJhd0J5dGVzLCB0ZXh0LCBieXRlU2VnbWVudHMsIGVjTGV2ZWwsIC0xLCAtMSlcbiAgICAgICAgLy8gfVxuICAgICAgICBjb25zdHJ1Y3RvcihyYXdCeXRlcywgdGV4dCwgYnl0ZVNlZ21lbnRzLCBlY0xldmVsLCBzdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXIgPSAtMSwgc3RydWN0dXJlZEFwcGVuZFBhcml0eSA9IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJhd0J5dGVzID0gcmF3Qnl0ZXM7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgdGhpcy5ieXRlU2VnbWVudHMgPSBieXRlU2VnbWVudHM7XG4gICAgICAgICAgICB0aGlzLmVjTGV2ZWwgPSBlY0xldmVsO1xuICAgICAgICAgICAgdGhpcy5zdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXIgPSBzdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICB0aGlzLnN0cnVjdHVyZWRBcHBlbmRQYXJpdHkgPSBzdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5O1xuICAgICAgICAgICAgdGhpcy5udW1CaXRzID0gKHJhd0J5dGVzID09PSB1bmRlZmluZWQgfHwgcmF3Qnl0ZXMgPT09IG51bGwpID8gMCA6IDggKiByYXdCeXRlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gcmF3IGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LCBvciB7QGNvZGUgbnVsbH0gaWYgbm90IGFwcGxpY2FibGVcbiAgICAgICAgICovXG4gICAgICAgIGdldFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3Qnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gaG93IG1hbnkgYml0cyBvZiB7QGxpbmsgI2dldFJhd0J5dGVzKCl9IGFyZSB2YWxpZDsgdHlwaWNhbGx5IDggdGltZXMgaXRzIGxlbmd0aFxuICAgICAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgICAgICovXG4gICAgICAgIGdldE51bUJpdHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW1CaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gbnVtQml0cyBvdmVycmlkZXMgdGhlIG51bWJlciBvZiBiaXRzIHRoYXQgYXJlIHZhbGlkIGluIHtAbGluayAjZ2V0UmF3Qnl0ZXMoKX1cbiAgICAgICAgICogQHNpbmNlIDMuMy4wXG4gICAgICAgICAqL1xuICAgICAgICBzZXROdW1CaXRzKG51bUJpdHMgLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy5udW1CaXRzID0gbnVtQml0cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXN1bHRcbiAgICAgICAgICovXG4gICAgICAgIGdldFRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGxpc3Qgb2YgYnl0ZSBzZWdtZW50cyBpbiB0aGUgcmVzdWx0LCBvciB7QGNvZGUgbnVsbH0gaWYgbm90IGFwcGxpY2FibGVcbiAgICAgICAgICovXG4gICAgICAgIGdldEJ5dGVTZWdtZW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVTZWdtZW50cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBuYW1lIG9mIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwgdXNlZCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFQ0xldmVsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWNMZXZlbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBudW1iZXIgb2YgZXJyb3JzIGNvcnJlY3RlZCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFcnJvcnNDb3JyZWN0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcnNDb3JyZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RXJyb3JzQ29ycmVjdGVkKGVycm9yc0NvcnJlY3RlZCAvKkludGVnZXIqLykge1xuICAgICAgICAgICAgdGhpcy5lcnJvcnNDb3JyZWN0ZWQgPSBlcnJvcnNDb3JyZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGVyYXN1cmVzIGNvcnJlY3RlZCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFcmFzdXJlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVyYXN1cmVzO1xuICAgICAgICB9XG4gICAgICAgIHNldEVyYXN1cmVzKGVyYXN1cmVzIC8qSW50ZWdlciovKSB7XG4gICAgICAgICAgICB0aGlzLmVyYXN1cmVzID0gZXJhc3VyZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gYXJiaXRyYXJ5IGFkZGl0aW9uYWwgbWV0YWRhdGFcbiAgICAgICAgICovXG4gICAgICAgIGdldE90aGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3RoZXI7XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3RoZXIob3RoZXIpIHtcbiAgICAgICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBoYXNTdHJ1Y3R1cmVkQXBwZW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RydWN0dXJlZEFwcGVuZFBhcml0eSA+PSAwICYmIHRoaXMuc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyID49IDA7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U3RydWN0dXJlZEFwcGVuZFBhcml0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cnVjdHVyZWRBcHBlbmRQYXJpdHk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5UaGlzIGNsYXNzIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyBmb3IgcGVyZm9ybWluZyBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucyBvdmVyXG4gICAgICogdGhlIEdhbG9pcyBGaWVsZHMuIE9wZXJhdGlvbnMgdXNlIGEgZ2l2ZW4gcHJpbWl0aXZlIHBvbHlub21pYWwgaW4gY2FsY3VsYXRpb25zLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRocm91Z2hvdXQgdGhpcyBwYWNrYWdlLCBlbGVtZW50cyBvZiB0aGUgR0YgYXJlIHJlcHJlc2VudGVkIGFzIGFuIHtAY29kZSBpbnR9XG4gICAgICogZm9yIGNvbnZlbmllbmNlIGFuZCBzcGVlZCAoYnV0IGF0IHRoZSBjb3N0IG9mIG1lbW9yeSkuXG4gICAgICogPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIERhdmlkIE9saXZpZXJcbiAgICAgKi9cbiAgICBjbGFzcyBBYnN0cmFjdEdlbmVyaWNHRiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIDIgdG8gdGhlIHBvd2VyIG9mIGEgaW4gR0Yoc2l6ZSlcbiAgICAgICAgICovXG4gICAgICAgIGV4cChhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVthXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBiYXNlIDIgbG9nIG9mIGEgaW4gR0Yoc2l6ZSlcbiAgICAgICAgICovXG4gICAgICAgIGxvZyhhIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9nVGFibGVbYV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgYm90aCBhZGRpdGlvbiBhbmQgc3VidHJhY3Rpb24gLS0gdGhleSBhcmUgdGhlIHNhbWUgaW4gR0Yoc2l6ZSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gc3VtL2RpZmZlcmVuY2Ugb2YgYSBhbmQgYlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGFkZE9yU3VidHJhY3QoYSAvKmludCovLCBiIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHJldHVybiBhIF4gYjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+UmVwcmVzZW50cyBhIHBvbHlub21pYWwgd2hvc2UgY29lZmZpY2llbnRzIGFyZSBlbGVtZW50cyBvZiBhIEdGLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBpbW11dGFibGUuPC9wPlxuICAgICAqXG4gICAgICogPHA+TXVjaCBjcmVkaXQgaXMgZHVlIHRvIFdpbGxpYW0gUnVja2xpZGdlIHNpbmNlIHBvcnRpb25zIG9mIHRoaXMgY29kZSBhcmUgYW4gaW5kaXJlY3RcbiAgICAgKiBwb3J0IG9mIGhpcyBDKysgUmVlZC1Tb2xvbW9uIGltcGxlbWVudGF0aW9uLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgR2VuZXJpY0dGUG9seSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gZmllbGQgdGhlIHtAbGluayBHZW5lcmljR0Z9IGluc3RhbmNlIHJlcHJlc2VudGluZyB0aGUgZmllbGQgdG8gdXNlXG4gICAgICAgICAqIHRvIHBlcmZvcm0gY29tcHV0YXRpb25zXG4gICAgICAgICAqIEBwYXJhbSBjb2VmZmljaWVudHMgY29lZmZpY2llbnRzIGFzIGludHMgcmVwcmVzZW50aW5nIGVsZW1lbnRzIG9mIEdGKHNpemUpLCBhcnJhbmdlZFxuICAgICAgICAgKiBmcm9tIG1vc3Qgc2lnbmlmaWNhbnQgKGhpZ2hlc3QtcG93ZXIgdGVybSkgY29lZmZpY2llbnQgdG8gbGVhc3Qgc2lnbmlmaWNhbnRcbiAgICAgICAgICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgYXJndW1lbnQgaXMgbnVsbCBvciBlbXB0eSxcbiAgICAgICAgICogb3IgaWYgbGVhZGluZyBjb2VmZmljaWVudCBpcyAwIGFuZCB0aGlzIGlzIG5vdCBhXG4gICAgICAgICAqIGNvbnN0YW50IHBvbHlub21pYWwgKHRoYXQgaXMsIGl0IGlzIG5vdCB0aGUgbW9ub21pYWwgXCIwXCIpXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihmaWVsZCwgY29lZmZpY2llbnRzKSB7XG4gICAgICAgICAgICBpZiAoY29lZmZpY2llbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgICAgIGNvbnN0IGNvZWZmaWNpZW50c0xlbmd0aCA9IGNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY29lZmZpY2llbnRzTGVuZ3RoID4gMSAmJiBjb2VmZmljaWVudHNbMF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHRlcm0gbXVzdCBiZSBub24temVybyBmb3IgYW55dGhpbmcgZXhjZXB0IHRoZSBjb25zdGFudCBwb2x5bm9taWFsIFwiMFwiXG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0Tm9uWmVybyA9IDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGZpcnN0Tm9uWmVybyA8IGNvZWZmaWNpZW50c0xlbmd0aCAmJiBjb2VmZmljaWVudHNbZmlyc3ROb25aZXJvXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Tm9uWmVybyA9PT0gY29lZmZpY2llbnRzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gSW50MzJBcnJheS5mcm9tKFswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IG5ldyBJbnQzMkFycmF5KGNvZWZmaWNpZW50c0xlbmd0aCAtIGZpcnN0Tm9uWmVybyk7XG4gICAgICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoY29lZmZpY2llbnRzLCBmaXJzdE5vblplcm8sIHRoaXMuY29lZmZpY2llbnRzLCAwLCB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldENvZWZmaWNpZW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBkZWdyZWUgb2YgdGhpcyBwb2x5bm9taWFsXG4gICAgICAgICAqL1xuICAgICAgICBnZXREZWdyZWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmZiB0aGlzIHBvbHlub21pYWwgaXMgdGhlIG1vbm9taWFsIFwiMFwiXG4gICAgICAgICAqL1xuICAgICAgICBpc1plcm8oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHNbMF0gPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gY29lZmZpY2llbnQgb2YgeF5kZWdyZWUgdGVybSBpbiB0aGlzIHBvbHlub21pYWxcbiAgICAgICAgICovXG4gICAgICAgIGdldENvZWZmaWNpZW50KGRlZ3JlZSAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHNbdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoIC0gMSAtIGRlZ3JlZV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gZXZhbHVhdGlvbiBvZiB0aGlzIHBvbHlub21pYWwgYXQgYSBnaXZlbiBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgZXZhbHVhdGVBdChhIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIHheMCBjb2VmZmljaWVudFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvZWZmaWNpZW50KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBKdXN0IHRoZSBzdW0gb2YgdGhlIGNvZWZmaWNpZW50c1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGNvZWZmaWNpZW50cy5sZW5ndGg7IGkgIT09IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZWZmaWNpZW50ID0gY29lZmZpY2llbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBBYnN0cmFjdEdlbmVyaWNHRi5hZGRPclN1YnRyYWN0KHJlc3VsdCwgY29lZmZpY2llbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gY29lZmZpY2llbnRzWzBdO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEFic3RyYWN0R2VuZXJpY0dGLmFkZE9yU3VidHJhY3QoZmllbGQubXVsdGlwbHkoYSwgcmVzdWx0KSwgY29lZmZpY2llbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgYWRkT3JTdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdHZW5lcmljR0ZQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIEdlbmVyaWNHRiBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzbWFsbGVyQ29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBsZXQgbGFyZ2VyQ29lZmZpY2llbnRzID0gb3RoZXIuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgaWYgKHNtYWxsZXJDb2VmZmljaWVudHMubGVuZ3RoID4gbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBzbWFsbGVyQ29lZmZpY2llbnRzO1xuICAgICAgICAgICAgICAgIHNtYWxsZXJDb2VmZmljaWVudHMgPSBsYXJnZXJDb2VmZmljaWVudHM7XG4gICAgICAgICAgICAgICAgbGFyZ2VyQ29lZmZpY2llbnRzID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdW1EaWZmID0gbmV3IEludDMyQXJyYXkobGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGhEaWZmID0gbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCAtIHNtYWxsZXJDb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgLy8gQ29weSBoaWdoLW9yZGVyIHRlcm1zIG9ubHkgZm91bmQgaW4gaGlnaGVyLWRlZ3JlZSBwb2x5bm9taWFsJ3MgY29lZmZpY2llbnRzXG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGxhcmdlckNvZWZmaWNpZW50cywgMCwgc3VtRGlmZiwgMCwgbGVuZ3RoRGlmZik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoRGlmZjsgaSA8IGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1bURpZmZbaV0gPSBBYnN0cmFjdEdlbmVyaWNHRi5hZGRPclN1YnRyYWN0KHNtYWxsZXJDb2VmZmljaWVudHNbaSAtIGxlbmd0aERpZmZdLCBsYXJnZXJDb2VmZmljaWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljR0ZQb2x5KHRoaXMuZmllbGQsIHN1bURpZmYpO1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5KG90aGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmllbGQuZXF1YWxzKG90aGVyLmZpZWxkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0dlbmVyaWNHRlBvbHlzIGRvIG5vdCBoYXZlIHNhbWUgR2VuZXJpY0dGIGZpZWxkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc1plcm8oKSB8fCBvdGhlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFDb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIGNvbnN0IGFMZW5ndGggPSBhQ29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJDb2VmZmljaWVudHMgPSBvdGhlci5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBjb25zdCBiTGVuZ3RoID0gYkNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0ID0gbmV3IEludDMyQXJyYXkoYUxlbmd0aCArIGJMZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYUNvZWZmID0gYUNvZWZmaWNpZW50c1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0W2kgKyBqXSA9IEFic3RyYWN0R2VuZXJpY0dGLmFkZE9yU3VidHJhY3QocHJvZHVjdFtpICsgal0sIGZpZWxkLm11bHRpcGx5KGFDb2VmZiwgYkNvZWZmaWNpZW50c1tqXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0dGUG9seShmaWVsZCwgcHJvZHVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHlTY2FsYXIoc2NhbGFyIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChzY2FsYXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NhbGFyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgICAgICAgICAgY29uc3QgY29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb2R1Y3RbaV0gPSBmaWVsZC5tdWx0aXBseShjb2VmZmljaWVudHNbaV0sIHNjYWxhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIHByb2R1Y3QpO1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5QnlNb25vbWlhbChkZWdyZWUgLyppbnQqLywgY29lZmZpY2llbnQgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBjb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KHNpemUgKyBkZWdyZWUpO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9kdWN0W2ldID0gZmllbGQubXVsdGlwbHkoY29lZmZpY2llbnRzW2ldLCBjb2VmZmljaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIHByb2R1Y3QpO1xuICAgICAgICB9XG4gICAgICAgIGRpdmlkZShvdGhlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdHZW5lcmljR0ZQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIEdlbmVyaWNHRiBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignRGl2aWRlIGJ5IDAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGxldCBxdW90aWVudCA9IGZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgICAgIGxldCByZW1haW5kZXIgPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgZGVub21pbmF0b3JMZWFkaW5nVGVybSA9IG90aGVyLmdldENvZWZmaWNpZW50KG90aGVyLmdldERlZ3JlZSgpKTtcbiAgICAgICAgICAgIGNvbnN0IGludmVyc2VEZW5vbWluYXRvckxlYWRpbmdUZXJtID0gZmllbGQuaW52ZXJzZShkZW5vbWluYXRvckxlYWRpbmdUZXJtKTtcbiAgICAgICAgICAgIHdoaWxlIChyZW1haW5kZXIuZ2V0RGVncmVlKCkgPj0gb3RoZXIuZ2V0RGVncmVlKCkgJiYgIXJlbWFpbmRlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZ3JlZURpZmZlcmVuY2UgPSByZW1haW5kZXIuZ2V0RGVncmVlKCkgLSBvdGhlci5nZXREZWdyZWUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZSA9IGZpZWxkLm11bHRpcGx5KHJlbWFpbmRlci5nZXRDb2VmZmljaWVudChyZW1haW5kZXIuZ2V0RGVncmVlKCkpLCBpbnZlcnNlRGVub21pbmF0b3JMZWFkaW5nVGVybSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVybSA9IG90aGVyLm11bHRpcGx5QnlNb25vbWlhbChkZWdyZWVEaWZmZXJlbmNlLCBzY2FsZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlcmF0aW9uUXVvdGllbnQgPSBmaWVsZC5idWlsZE1vbm9taWFsKGRlZ3JlZURpZmZlcmVuY2UsIHNjYWxlKTtcbiAgICAgICAgICAgICAgICBxdW90aWVudCA9IHF1b3RpZW50LmFkZE9yU3VidHJhY3QoaXRlcmF0aW9uUXVvdGllbnQpO1xuICAgICAgICAgICAgICAgIHJlbWFpbmRlciA9IHJlbWFpbmRlci5hZGRPclN1YnRyYWN0KHRlcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtxdW90aWVudCwgcmVtYWluZGVyXTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgZGVncmVlID0gdGhpcy5nZXREZWdyZWUoKTsgZGVncmVlID49IDA7IGRlZ3JlZS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvZWZmaWNpZW50ID0gdGhpcy5nZXRDb2VmZmljaWVudChkZWdyZWUpO1xuICAgICAgICAgICAgICAgIGlmIChjb2VmZmljaWVudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyAtICc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmZmljaWVudCA9IC1jb2VmZmljaWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnICsgJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVncmVlID09PSAwIHx8IGNvZWZmaWNpZW50ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbHBoYVBvd2VyID0gdGhpcy5maWVsZC5sb2coY29lZmZpY2llbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhUG93ZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzEnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxwaGFQb3dlciA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnYSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2FeJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gYWxwaGFQb3dlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVncmVlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVncmVlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICd4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAneF4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBkZWdyZWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIEFyaXRobWV0aWNFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIH1cbiAgICBBcml0aG1ldGljRXhjZXB0aW9uLmtpbmQgPSAnQXJpdGhtZXRpY0V4Y2VwdGlvbic7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPlRoaXMgY2xhc3MgY29udGFpbnMgdXRpbGl0eSBtZXRob2RzIGZvciBwZXJmb3JtaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRpb25zIG92ZXJcbiAgICAgKiB0aGUgR2Fsb2lzIEZpZWxkcy4gT3BlcmF0aW9ucyB1c2UgYSBnaXZlbiBwcmltaXRpdmUgcG9seW5vbWlhbCBpbiBjYWxjdWxhdGlvbnMuPC9wPlxuICAgICAqXG4gICAgICogPHA+VGhyb3VnaG91dCB0aGlzIHBhY2thZ2UsIGVsZW1lbnRzIG9mIHRoZSBHRiBhcmUgcmVwcmVzZW50ZWQgYXMgYW4ge0Bjb2RlIGludH1cbiAgICAgKiBmb3IgY29udmVuaWVuY2UgYW5kIHNwZWVkIChidXQgYXQgdGhlIGNvc3Qgb2YgbWVtb3J5KS5cbiAgICAgKiA8L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBhdXRob3IgRGF2aWQgT2xpdmllclxuICAgICAqL1xuICAgIGNsYXNzIEdlbmVyaWNHRiBleHRlbmRzIEFic3RyYWN0R2VuZXJpY0dGIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHJlcHJlc2VudGF0aW9uIG9mIEdGKHNpemUpIHVzaW5nIHRoZSBnaXZlbiBwcmltaXRpdmUgcG9seW5vbWlhbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHByaW1pdGl2ZSBpcnJlZHVjaWJsZSBwb2x5bm9taWFsIHdob3NlIGNvZWZmaWNpZW50cyBhcmUgcmVwcmVzZW50ZWQgYnlcbiAgICAgICAgICogIHRoZSBiaXRzIG9mIGFuIGludCwgd2hlcmUgdGhlIGxlYXN0LXNpZ25pZmljYW50IGJpdCByZXByZXNlbnRzIHRoZSBjb25zdGFudFxuICAgICAgICAgKiAgY29lZmZpY2llbnRcbiAgICAgICAgICogQHBhcmFtIHNpemUgdGhlIHNpemUgb2YgdGhlIGZpZWxkXG4gICAgICAgICAqIEBwYXJhbSBiIHRoZSBmYWN0b3IgYiBpbiB0aGUgZ2VuZXJhdG9yIHBvbHlub21pYWwgY2FuIGJlIDAtIG9yIDEtYmFzZWRcbiAgICAgICAgICogIChnKHgpID0gKHgrYV5iKSh4K2FeKGIrMSkpLi4uKHgrYV4oYisydC0xKSkpLlxuICAgICAgICAgKiAgSW4gbW9zdCBjYXNlcyBpdCBzaG91bGQgYmUgMSwgYnV0IGZvciBRUiBjb2RlIGl0IGlzIDAuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihwcmltaXRpdmUgLyppbnQqLywgc2l6ZSAvKmludCovLCBnZW5lcmF0b3JCYXNlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLnByaW1pdGl2ZSA9IHByaW1pdGl2ZTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRvckJhc2UgPSBnZW5lcmF0b3JCYXNlO1xuICAgICAgICAgICAgY29uc3QgZXhwVGFibGUgPSBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgICAgICAgIGxldCB4ID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZXhwVGFibGVbaV0gPSB4O1xuICAgICAgICAgICAgICAgIHggKj0gMjsgLy8gd2UncmUgYXNzdW1pbmcgdGhlIGdlbmVyYXRvciBhbHBoYSBpcyAyXG4gICAgICAgICAgICAgICAgaWYgKHggPj0gc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB4IF49IHByaW1pdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgeCAmPSBzaXplIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV4cFRhYmxlID0gZXhwVGFibGU7XG4gICAgICAgICAgICBjb25zdCBsb2dUYWJsZSA9IG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbG9nVGFibGVbZXhwVGFibGVbaV1dID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nVGFibGUgPSBsb2dUYWJsZTtcbiAgICAgICAgICAgIC8vIGxvZ1RhYmxlWzBdID09IDAgYnV0IHRoaXMgc2hvdWxkIG5ldmVyIGJlIHVzZWRcbiAgICAgICAgICAgIHRoaXMuemVybyA9IG5ldyBHZW5lcmljR0ZQb2x5KHRoaXMsIEludDMyQXJyYXkuZnJvbShbMF0pKTtcbiAgICAgICAgICAgIHRoaXMub25lID0gbmV3IEdlbmVyaWNHRlBvbHkodGhpcywgSW50MzJBcnJheS5mcm9tKFsxXSkpO1xuICAgICAgICB9XG4gICAgICAgIGdldFplcm8oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56ZXJvO1xuICAgICAgICB9XG4gICAgICAgIGdldE9uZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0aGUgbW9ub21pYWwgcmVwcmVzZW50aW5nIGNvZWZmaWNpZW50ICogeF5kZWdyZWVcbiAgICAgICAgICovXG4gICAgICAgIGJ1aWxkTW9ub21pYWwoZGVncmVlIC8qaW50Ki8sIGNvZWZmaWNpZW50IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChkZWdyZWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvZWZmaWNpZW50cyA9IG5ldyBJbnQzMkFycmF5KGRlZ3JlZSArIDEpO1xuICAgICAgICAgICAgY29lZmZpY2llbnRzWzBdID0gY29lZmZpY2llbnQ7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNHRlBvbHkodGhpcywgY29lZmZpY2llbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIG9mIGFcbiAgICAgICAgICovXG4gICAgICAgIGludmVyc2UoYSAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcml0aG1ldGljRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVt0aGlzLnNpemUgLSB0aGlzLmxvZ1RhYmxlW2FdIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gcHJvZHVjdCBvZiBhIGFuZCBiIGluIEdGKHNpemUpXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShhIC8qaW50Ki8sIGIgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKGEgPT09IDAgfHwgYiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbKHRoaXMubG9nVGFibGVbYV0gKyB0aGlzLmxvZ1RhYmxlW2JdKSAlICh0aGlzLnNpemUgLSAxKV07XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0R2VuZXJhdG9yQmFzZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvckJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAoJ0dGKDB4JyArIEludGVnZXIudG9IZXhTdHJpbmcodGhpcy5wcmltaXRpdmUpICsgJywnICsgdGhpcy5zaXplICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgICBlcXVhbHMobykge1xuICAgICAgICAgICAgcmV0dXJuIG8gPT09IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgR2VuZXJpY0dGLkFaVEVDX0RBVEFfMTIgPSBuZXcgR2VuZXJpY0dGKDB4MTA2OSwgNDA5NiwgMSk7IC8vIHheMTIgKyB4XjYgKyB4XjUgKyB4XjMgKyAxXG4gICAgR2VuZXJpY0dGLkFaVEVDX0RBVEFfMTAgPSBuZXcgR2VuZXJpY0dGKDB4NDA5LCAxMDI0LCAxKTsgLy8geF4xMCArIHheMyArIDFcbiAgICBHZW5lcmljR0YuQVpURUNfREFUQV82ID0gbmV3IEdlbmVyaWNHRigweDQzLCA2NCwgMSk7IC8vIHheNiArIHggKyAxXG4gICAgR2VuZXJpY0dGLkFaVEVDX1BBUkFNID0gbmV3IEdlbmVyaWNHRigweDEzLCAxNiwgMSk7IC8vIHheNCArIHggKyAxXG4gICAgR2VuZXJpY0dGLlFSX0NPREVfRklFTERfMjU2ID0gbmV3IEdlbmVyaWNHRigweDAxMWQsIDI1NiwgMCk7IC8vIHheOCArIHheNCArIHheMyArIHheMiArIDFcbiAgICBHZW5lcmljR0YuREFUQV9NQVRSSVhfRklFTERfMjU2ID0gbmV3IEdlbmVyaWNHRigweDAxMmQsIDI1NiwgMSk7IC8vIHheOCArIHheNSArIHheMyArIHheMiArIDFcbiAgICBHZW5lcmljR0YuQVpURUNfREFUQV84ID0gR2VuZXJpY0dGLkRBVEFfTUFUUklYX0ZJRUxEXzI1NjtcbiAgICBHZW5lcmljR0YuTUFYSUNPREVfRklFTERfNjQgPSBHZW5lcmljR0YuQVpURUNfREFUQV82O1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFJlZWRTb2xvbW9uRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICB9XG4gICAgUmVlZFNvbG9tb25FeGNlcHRpb24ua2luZCA9ICdSZWVkU29sb21vbkV4Y2VwdGlvbic7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgSWxsZWdhbFN0YXRlRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICB9XG4gICAgSWxsZWdhbFN0YXRlRXhjZXB0aW9uLmtpbmQgPSAnSWxsZWdhbFN0YXRlRXhjZXB0aW9uJztcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+SW1wbGVtZW50cyBSZWVkLVNvbG9tb24gZGVjb2RpbmcsIGFzIHRoZSBuYW1lIGltcGxpZXMuPC9wPlxuICAgICAqXG4gICAgICogPHA+VGhlIGFsZ29yaXRobSB3aWxsIG5vdCBiZSBleHBsYWluZWQgaGVyZSwgYnV0IHRoZSBmb2xsb3dpbmcgcmVmZXJlbmNlcyB3ZXJlIGhlbHBmdWxcbiAgICAgKiBpbiBjcmVhdGluZyB0aGlzIGltcGxlbWVudGF0aW9uOjwvcD5cbiAgICAgKlxuICAgICAqIDx1bD5cbiAgICAgKiA8bGk+QnJ1Y2UgTWFnZ3MuXG4gICAgICogPGEgaHJlZj1cImh0dHA6Ly93d3cuY3MuY211LmVkdS9hZnMvY3MuY211LmVkdS9wcm9qZWN0L3BzY2ljby1ndXliL3JlYWx3b3JsZC93d3cvcnNfZGVjb2RlLnBzXCI+XG4gICAgICogXCJEZWNvZGluZyBSZWVkLVNvbG9tb24gQ29kZXNcIjwvYT4gKHNlZSBkaXNjdXNzaW9uIG9mIEZvcm5leSdzIEZvcm11bGEpPC9saT5cbiAgICAgKiA8bGk+Si5JLiBIYWxsLiA8YSBocmVmPVwid3d3Lm10aC5tc3UuZWR1L35qaGFsbC9jbGFzc2VzL2NvZGVub3Rlcy9HUlMucGRmXCI+XG4gICAgICogXCJDaGFwdGVyIDUuIEdlbmVyYWxpemVkIFJlZWQtU29sb21vbiBDb2Rlc1wiPC9hPlxuICAgICAqIChzZWUgZGlzY3Vzc2lvbiBvZiBFdWNsaWRlYW4gYWxnb3JpdGhtKTwvbGk+XG4gICAgICogPC91bD5cbiAgICAgKlxuICAgICAqIDxwPk11Y2ggY3JlZGl0IGlzIGR1ZSB0byBXaWxsaWFtIFJ1Y2tsaWRnZSBzaW5jZSBwb3J0aW9ucyBvZiB0aGlzIGNvZGUgYXJlIGFuIGluZGlyZWN0XG4gICAgICogcG9ydCBvZiBoaXMgQysrIFJlZWQtU29sb21vbiBpbXBsZW1lbnRhdGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBhdXRob3IgV2lsbGlhbSBSdWNrbGlkZ2VcbiAgICAgKiBAYXV0aG9yIHNhbmZvcmRzcXVpcmVzXG4gICAgICovXG4gICAgY2xhc3MgUmVlZFNvbG9tb25EZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoZmllbGQpIHtcbiAgICAgICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RGVjb2RlcyBnaXZlbiBzZXQgb2YgcmVjZWl2ZWQgY29kZXdvcmRzLCB3aGljaCBpbmNsdWRlIGJvdGggZGF0YSBhbmQgZXJyb3ItY29ycmVjdGlvblxuICAgICAgICAgKiBjb2Rld29yZHMuIFJlYWxseSwgdGhpcyBtZWFucyBpdCB1c2VzIFJlZWQtU29sb21vbiB0byBkZXRlY3QgYW5kIGNvcnJlY3QgZXJyb3JzLCBpbi1wbGFjZSxcbiAgICAgICAgICogaW4gdGhlIGlucHV0LjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJlY2VpdmVkIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzXG4gICAgICAgICAqIEBwYXJhbSB0d29TIG51bWJlciBvZiBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcyBhdmFpbGFibGVcbiAgICAgICAgICogQHRocm93cyBSZWVkU29sb21vbkV4Y2VwdGlvbiBpZiBkZWNvZGluZyBmYWlscyBmb3IgYW55IHJlYXNvblxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlKHJlY2VpdmVkLCB0d29TIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGNvbnN0IHBvbHkgPSBuZXcgR2VuZXJpY0dGUG9seShmaWVsZCwgcmVjZWl2ZWQpO1xuICAgICAgICAgICAgY29uc3Qgc3luZHJvbWVDb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheSh0d29TKTtcbiAgICAgICAgICAgIGxldCBub0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHdvUzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZhbFJlc3VsdCA9IHBvbHkuZXZhbHVhdGVBdChmaWVsZC5leHAoaSArIGZpZWxkLmdldEdlbmVyYXRvckJhc2UoKSkpO1xuICAgICAgICAgICAgICAgIHN5bmRyb21lQ29lZmZpY2llbnRzW3N5bmRyb21lQ29lZmZpY2llbnRzLmxlbmd0aCAtIDEgLSBpXSA9IGV2YWxSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGV2YWxSZXN1bHQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9FcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3luZHJvbWUgPSBuZXcgR2VuZXJpY0dGUG9seShmaWVsZCwgc3luZHJvbWVDb2VmZmljaWVudHMpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWFPbWVnYSA9IHRoaXMucnVuRXVjbGlkZWFuQWxnb3JpdGhtKGZpZWxkLmJ1aWxkTW9ub21pYWwodHdvUywgMSksIHN5bmRyb21lLCB0d29TKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hID0gc2lnbWFPbWVnYVswXTtcbiAgICAgICAgICAgIGNvbnN0IG9tZWdhID0gc2lnbWFPbWVnYVsxXTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTG9jYXRpb25zID0gdGhpcy5maW5kRXJyb3JMb2NhdGlvbnMoc2lnbWEpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNYWduaXR1ZGVzID0gdGhpcy5maW5kRXJyb3JNYWduaXR1ZGVzKG9tZWdhLCBlcnJvckxvY2F0aW9ucyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9yTG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSByZWNlaXZlZC5sZW5ndGggLSAxIC0gZmllbGQubG9nKGVycm9yTG9jYXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkV4Y2VwdGlvbignQmFkIGVycm9yIGxvY2F0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkW3Bvc2l0aW9uXSA9IEdlbmVyaWNHRi5hZGRPclN1YnRyYWN0KHJlY2VpdmVkW3Bvc2l0aW9uXSwgZXJyb3JNYWduaXR1ZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBydW5FdWNsaWRlYW5BbGdvcml0aG0oYSwgYiwgUiAvKmludCovKSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgYSdzIGRlZ3JlZSBpcyA+PSBiJ3NcbiAgICAgICAgICAgIGlmIChhLmdldERlZ3JlZSgpIDwgYi5nZXREZWdyZWUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBhO1xuICAgICAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgICAgIGIgPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICAgICAgbGV0IHJMYXN0ID0gYTtcbiAgICAgICAgICAgIGxldCByID0gYjtcbiAgICAgICAgICAgIGxldCB0TGFzdCA9IGZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgICAgIGxldCB0ID0gZmllbGQuZ2V0T25lKCk7XG4gICAgICAgICAgICAvLyBSdW4gRXVjbGlkZWFuIGFsZ29yaXRobSB1bnRpbCByJ3MgZGVncmVlIGlzIGxlc3MgdGhhbiBSLzJcbiAgICAgICAgICAgIHdoaWxlIChyLmdldERlZ3JlZSgpID49IChSIC8gMiB8IDApKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJMYXN0TGFzdCA9IHJMYXN0O1xuICAgICAgICAgICAgICAgIGxldCB0TGFzdExhc3QgPSB0TGFzdDtcbiAgICAgICAgICAgICAgICByTGFzdCA9IHI7XG4gICAgICAgICAgICAgICAgdExhc3QgPSB0O1xuICAgICAgICAgICAgICAgIC8vIERpdmlkZSByTGFzdExhc3QgYnkgckxhc3QsIHdpdGggcXVvdGllbnQgaW4gcSBhbmQgcmVtYWluZGVyIGluIHJcbiAgICAgICAgICAgICAgICBpZiAockxhc3QuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT29wcywgRXVjbGlkZWFuIGFsZ29yaXRobSBhbHJlYWR5IHRlcm1pbmF0ZWQ/XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkV4Y2VwdGlvbigncl97aS0xfSB3YXMgemVybycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByID0gckxhc3RMYXN0O1xuICAgICAgICAgICAgICAgIGxldCBxID0gZmllbGQuZ2V0WmVybygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0gPSByTGFzdC5nZXRDb2VmZmljaWVudChyTGFzdC5nZXREZWdyZWUoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGx0SW52ZXJzZSA9IGZpZWxkLmludmVyc2UoZGVub21pbmF0b3JMZWFkaW5nVGVybSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHIuZ2V0RGVncmVlKCkgPj0gckxhc3QuZ2V0RGVncmVlKCkgJiYgIXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVncmVlRGlmZiA9IHIuZ2V0RGVncmVlKCkgLSByTGFzdC5nZXREZWdyZWUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBmaWVsZC5tdWx0aXBseShyLmdldENvZWZmaWNpZW50KHIuZ2V0RGVncmVlKCkpLCBkbHRJbnZlcnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEuYWRkT3JTdWJ0cmFjdChmaWVsZC5idWlsZE1vbm9taWFsKGRlZ3JlZURpZmYsIHNjYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByLmFkZE9yU3VidHJhY3Qockxhc3QubXVsdGlwbHlCeU1vbm9taWFsKGRlZ3JlZURpZmYsIHNjYWxlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgPSBxLm11bHRpcGx5KHRMYXN0KS5hZGRPclN1YnRyYWN0KHRMYXN0TGFzdCk7XG4gICAgICAgICAgICAgICAgaWYgKHIuZ2V0RGVncmVlKCkgPj0gckxhc3QuZ2V0RGVncmVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbignRGl2aXNpb24gYWxnb3JpdGhtIGZhaWxlZCB0byByZWR1Y2UgcG9seW5vbWlhbD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaWdtYVRpbGRlQXRaZXJvID0gdC5nZXRDb2VmZmljaWVudCgwKTtcbiAgICAgICAgICAgIGlmIChzaWdtYVRpbGRlQXRaZXJvID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZWRTb2xvbW9uRXhjZXB0aW9uKCdzaWdtYVRpbGRlKDApIHdhcyB6ZXJvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnZlcnNlID0gZmllbGQuaW52ZXJzZShzaWdtYVRpbGRlQXRaZXJvKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hID0gdC5tdWx0aXBseVNjYWxhcihpbnZlcnNlKTtcbiAgICAgICAgICAgIGNvbnN0IG9tZWdhID0gci5tdWx0aXBseVNjYWxhcihpbnZlcnNlKTtcbiAgICAgICAgICAgIHJldHVybiBbc2lnbWEsIG9tZWdhXTtcbiAgICAgICAgfVxuICAgICAgICBmaW5kRXJyb3JMb2NhdGlvbnMoZXJyb3JMb2NhdG9yKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgZGlyZWN0IGFwcGxpY2F0aW9uIG9mIENoaWVuJ3Mgc2VhcmNoXG4gICAgICAgICAgICBjb25zdCBudW1FcnJvcnMgPSBlcnJvckxvY2F0b3IuZ2V0RGVncmVlKCk7XG4gICAgICAgICAgICBpZiAobnVtRXJyb3JzID09PSAxKSB7IC8vIHNob3J0Y3V0XG4gICAgICAgICAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbZXJyb3JMb2NhdG9yLmdldENvZWZmaWNpZW50KDEpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgSW50MzJBcnJheShudW1FcnJvcnMpO1xuICAgICAgICAgICAgbGV0IGUgPSAwO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBmaWVsZC5nZXRTaXplKCkgJiYgZSA8IG51bUVycm9yczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yTG9jYXRvci5ldmFsdWF0ZUF0KGkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtlXSA9IGZpZWxkLmludmVyc2UoaSk7XG4gICAgICAgICAgICAgICAgICAgIGUrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSAhPT0gbnVtRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZWRTb2xvbW9uRXhjZXB0aW9uKCdFcnJvciBsb2NhdG9yIGRlZ3JlZSBkb2VzIG5vdCBtYXRjaCBudW1iZXIgb2Ygcm9vdHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZmluZEVycm9yTWFnbml0dWRlcyhlcnJvckV2YWx1YXRvciwgZXJyb3JMb2NhdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgZGlyZWN0bHkgYXBwbHlpbmcgRm9ybmV5J3MgRm9ybXVsYVxuICAgICAgICAgICAgY29uc3QgcyA9IGVycm9yTG9jYXRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KHMpO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4aUludmVyc2UgPSBmaWVsZC5pbnZlcnNlKGVycm9yTG9jYXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVub21pbmF0b3IgPSAxO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZW5vbWluYXRvciA9IGZpZWxkLm11bHRpcGx5KGRlbm9taW5hdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgR2VuZXJpY0dGLmFkZE9yU3VidHJhY3QoMSwgZmllbGQubXVsdGlwbHkoZXJyb3JMb2NhdGlvbnNbal0sIHhpSW52ZXJzZSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWJvdmUgc2hvdWxkIHdvcmsgYnV0IGZhaWxzIG9uIHNvbWUgQXBwbGUgYW5kIExpbnV4IEpES3MgZHVlIHRvIGEgSG90c3BvdCBidWcuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCZWxvdyBpcyBhIGZ1bm55LWxvb2tpbmcgd29ya2Fyb3VuZCBmcm9tIFN0ZXZlbiBQYXJrZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm0gPSBmaWVsZC5tdWx0aXBseShlcnJvckxvY2F0aW9uc1tqXSwgeGlJbnZlcnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1QbHVzMSA9ICh0ZXJtICYgMHgxKSA9PT0gMCA/IHRlcm0gfCAxIDogdGVybSAmIH4xO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVub21pbmF0b3IgPSBmaWVsZC5tdWx0aXBseShkZW5vbWluYXRvciwgdGVybVBsdXMxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBmaWVsZC5tdWx0aXBseShlcnJvckV2YWx1YXRvci5ldmFsdWF0ZUF0KHhpSW52ZXJzZSksIGZpZWxkLmludmVyc2UoZGVub21pbmF0b3IpKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQuZ2V0R2VuZXJhdG9yQmFzZSgpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGZpZWxkLm11bHRpcGx5KHJlc3VsdFtpXSwgeGlJbnZlcnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMCBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkFycmF5cztcbiAgICB2YXIgVGFibGU7XG4gICAgKGZ1bmN0aW9uIChUYWJsZSkge1xuICAgICAgICBUYWJsZVtUYWJsZVtcIlVQUEVSXCJdID0gMF0gPSBcIlVQUEVSXCI7XG4gICAgICAgIFRhYmxlW1RhYmxlW1wiTE9XRVJcIl0gPSAxXSA9IFwiTE9XRVJcIjtcbiAgICAgICAgVGFibGVbVGFibGVbXCJNSVhFRFwiXSA9IDJdID0gXCJNSVhFRFwiO1xuICAgICAgICBUYWJsZVtUYWJsZVtcIkRJR0lUXCJdID0gM10gPSBcIkRJR0lUXCI7XG4gICAgICAgIFRhYmxlW1RhYmxlW1wiUFVOQ1RcIl0gPSA0XSA9IFwiUFVOQ1RcIjtcbiAgICAgICAgVGFibGVbVGFibGVbXCJCSU5BUllcIl0gPSA1XSA9IFwiQklOQVJZXCI7XG4gICAgfSkoVGFibGUgfHwgKFRhYmxlID0ge30pKTtcbiAgICAvKipcbiAgICAgKiA8cD5UaGUgbWFpbiBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIEF6dGVjIENvZGUgZGVjb2RpbmcgLS0gYXMgb3Bwb3NlZCB0byBsb2NhdGluZyBhbmQgZXh0cmFjdGluZ1xuICAgICAqIHRoZSBBenRlYyBDb2RlIGZyb20gYW4gaW1hZ2UuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBEYXZpZCBPbGl2aWVyXG4gICAgICovXG4gICAgY2xhc3MgRGVjb2RlciB7XG4gICAgICAgIGRlY29kZShkZXRlY3RvclJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5kZGF0YSA9IGRldGVjdG9yUmVzdWx0O1xuICAgICAgICAgICAgbGV0IG1hdHJpeCA9IGRldGVjdG9yUmVzdWx0LmdldEJpdHMoKTtcbiAgICAgICAgICAgIGxldCByYXdiaXRzID0gdGhpcy5leHRyYWN0Qml0cyhtYXRyaXgpO1xuICAgICAgICAgICAgbGV0IGNvcnJlY3RlZEJpdHMgPSB0aGlzLmNvcnJlY3RCaXRzKHJhd2JpdHMpO1xuICAgICAgICAgICAgbGV0IHJhd0J5dGVzID0gRGVjb2Rlci5jb252ZXJ0Qm9vbEFycmF5VG9CeXRlQXJyYXkoY29ycmVjdGVkQml0cyk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gRGVjb2Rlci5nZXRFbmNvZGVkRGF0YShjb3JyZWN0ZWRCaXRzKTtcbiAgICAgICAgICAgIGxldCBkZWNvZGVyUmVzdWx0ID0gbmV3IERlY29kZXJSZXN1bHQocmF3Qnl0ZXMsIHJlc3VsdCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICBkZWNvZGVyUmVzdWx0LnNldE51bUJpdHMoY29ycmVjdGVkQml0cy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgdGVzdGluZyB0aGUgaGlnaC1sZXZlbCBlbmNvZGVyXG4gICAgICAgIHN0YXRpYyBoaWdoTGV2ZWxEZWNvZGUoY29ycmVjdGVkQml0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2RlZERhdGEoY29ycmVjdGVkQml0cyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHN0cmluZyBlbmNvZGVkIGluIHRoZSBhenRlYyBjb2RlIGJpdHNcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGUgZGVjb2RlZCBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRFbmNvZGVkRGF0YShjb3JyZWN0ZWRCaXRzKSB7XG4gICAgICAgICAgICBsZXQgZW5kSW5kZXggPSBjb3JyZWN0ZWRCaXRzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBsYXRjaFRhYmxlID0gVGFibGUuVVBQRVI7IC8vIHRhYmxlIG1vc3QgcmVjZW50bHkgbGF0Y2hlZCB0b1xuICAgICAgICAgICAgbGV0IHNoaWZ0VGFibGUgPSBUYWJsZS5VUFBFUjsgLy8gdGFibGUgdG8gdXNlIGZvciB0aGUgbmV4dCByZWFkXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hpZnRUYWJsZSA9PT0gVGFibGUuQklOQVJZKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRJbmRleCAtIGluZGV4IDwgNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGxlbmd0aCA9IERlY29kZXIucmVhZENvZGUoY29ycmVjdGVkQml0cywgaW5kZXgsIDUpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5kZXggLSBpbmRleCA8IDExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBEZWNvZGVyLnJlYWRDb2RlKGNvcnJlY3RlZEJpdHMsIGluZGV4LCAxMSkgKyAzMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDExO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNoYXJDb3VudCA9IDA7IGNoYXJDb3VudCA8IGxlbmd0aDsgY2hhckNvdW50KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRJbmRleCAtIGluZGV4IDwgOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZW5kSW5kZXg7IC8vIEZvcmNlIG91dGVyIGxvb3AgdG8gZXhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IERlY29kZXIucmVhZENvZGUoY29ycmVjdGVkQml0cywgaW5kZXgsIDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IC8qKGNoYXIpKi8gU3RyaW5nVXRpbHMuY2FzdEFzTm9uVXRmOENoYXIoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArPSA4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEdvIGJhY2sgdG8gd2hhdGV2ZXIgbW9kZSB3ZSBoYWQgYmVlbiBpblxuICAgICAgICAgICAgICAgICAgICBzaGlmdFRhYmxlID0gbGF0Y2hUYWJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gc2hpZnRUYWJsZSA9PT0gVGFibGUuRElHSVQgPyA0IDogNTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEluZGV4IC0gaW5kZXggPCBzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IERlY29kZXIucmVhZENvZGUoY29ycmVjdGVkQml0cywgaW5kZXgsIHNpemUpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RyID0gRGVjb2Rlci5nZXRDaGFyYWN0ZXIoc2hpZnRUYWJsZSwgY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIuc3RhcnRzV2l0aCgnQ1RSTF8nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFibGUgY2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSVNPL0lFQyAyNDc3ODoyMDA4IHByZXNjcmliZXMgZW5kaW5nIGEgc2hpZnQgc2VxdWVuY2UgaW4gdGhlIG1vZGUgZnJvbSB3aGljaCBpdCB3YXMgaW52b2tlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoYXQncyBpbmNsdWRpbmcgd2hlbiB0aGF0IG1vZGUgaXMgYSBzaGlmdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE91ciB0ZXN0IGNhc2UgZGx1c2JzLnBuZyBmb3IgaXNzdWUgIzY0MiBleGVyY2lzZXMgdGhhdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhdGNoVGFibGUgPSBzaGlmdFRhYmxlOyAvLyBMYXRjaCB0aGUgY3VycmVudCBtb2RlLCBzbyBhcyB0byByZXR1cm4gdG8gVXBwZXIgYWZ0ZXIgVS9TIEIvU1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRUYWJsZSA9IERlY29kZXIuZ2V0VGFibGUoc3RyLmNoYXJBdCg1KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyLmNoYXJBdCg2KSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0Y2hUYWJsZSA9IHNoaWZ0VGFibGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR28gYmFjayB0byB3aGF0ZXZlciBtb2RlIHdlIGhhZCBiZWVuIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFRhYmxlID0gbGF0Y2hUYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldHMgdGhlIHRhYmxlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNoYXIgcGFzc2VkXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0VGFibGUodCkge1xuICAgICAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUYWJsZS5MT1dFUjtcbiAgICAgICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLlBVTkNUO1xuICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGFibGUuTUlYRUQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUYWJsZS5ESUdJVDtcbiAgICAgICAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLkJJTkFSWTtcbiAgICAgICAgICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGFibGUuVVBQRVI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGNoYXJhY3RlciAob3Igc3RyaW5nKSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwYXNzZWQgY29kZSBpbiB0aGUgZ2l2ZW4gdGFibGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRhYmxlIHRoZSB0YWJsZSB1c2VkXG4gICAgICAgICAqIEBwYXJhbSBjb2RlIHRoZSBjb2RlIG9mIHRoZSBjaGFyYWN0ZXJcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRDaGFyYWN0ZXIodGFibGUsIGNvZGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGFibGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRhYmxlLlVQUEVSOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5VUFBFUl9UQUJMRVtjb2RlXTtcbiAgICAgICAgICAgICAgICBjYXNlIFRhYmxlLkxPV0VSOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5MT1dFUl9UQUJMRVtjb2RlXTtcbiAgICAgICAgICAgICAgICBjYXNlIFRhYmxlLk1JWEVEOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5NSVhFRF9UQUJMRVtjb2RlXTtcbiAgICAgICAgICAgICAgICBjYXNlIFRhYmxlLlBVTkNUOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5QVU5DVF9UQUJMRVtjb2RlXTtcbiAgICAgICAgICAgICAgICBjYXNlIFRhYmxlLkRJR0lUOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5ESUdJVF9UQUJMRVtjb2RlXTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgbm90IHJlYWNoIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oJ0JhZCB0YWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5QZXJmb3JtcyBSUyBlcnJvciBjb3JyZWN0aW9uIG9uIGFuIGFycmF5IG9mIGJpdHMuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBjb3JyZWN0ZWQgYXJyYXlcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIGlucHV0IGNvbnRhaW5zIHRvbyBtYW55IGVycm9yc1xuICAgICAgICAgKi9cbiAgICAgICAgY29ycmVjdEJpdHMocmF3Yml0cykge1xuICAgICAgICAgICAgbGV0IGdmO1xuICAgICAgICAgICAgbGV0IGNvZGV3b3JkU2l6ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRkYXRhLmdldE5iTGF5ZXJzKCkgPD0gMikge1xuICAgICAgICAgICAgICAgIGNvZGV3b3JkU2l6ZSA9IDY7XG4gICAgICAgICAgICAgICAgZ2YgPSBHZW5lcmljR0YuQVpURUNfREFUQV82O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5kZGF0YS5nZXROYkxheWVycygpIDw9IDgpIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZFNpemUgPSA4O1xuICAgICAgICAgICAgICAgIGdmID0gR2VuZXJpY0dGLkFaVEVDX0RBVEFfODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZGRhdGEuZ2V0TmJMYXllcnMoKSA8PSAyMikge1xuICAgICAgICAgICAgICAgIGNvZGV3b3JkU2l6ZSA9IDEwO1xuICAgICAgICAgICAgICAgIGdmID0gR2VuZXJpY0dGLkFaVEVDX0RBVEFfMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZFNpemUgPSAxMjtcbiAgICAgICAgICAgICAgICBnZiA9IEdlbmVyaWNHRi5BWlRFQ19EQVRBXzEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG51bURhdGFDb2Rld29yZHMgPSB0aGlzLmRkYXRhLmdldE5iRGF0YWJsb2NrcygpO1xuICAgICAgICAgICAgbGV0IG51bUNvZGV3b3JkcyA9IHJhd2JpdHMubGVuZ3RoIC8gY29kZXdvcmRTaXplO1xuICAgICAgICAgICAgaWYgKG51bUNvZGV3b3JkcyA8IG51bURhdGFDb2Rld29yZHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcmF3Yml0cy5sZW5ndGggJSBjb2Rld29yZFNpemU7XG4gICAgICAgICAgICBsZXQgZGF0YVdvcmRzID0gbmV3IEludDMyQXJyYXkobnVtQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29kZXdvcmRzOyBpKyssIG9mZnNldCArPSBjb2Rld29yZFNpemUpIHtcbiAgICAgICAgICAgICAgICBkYXRhV29yZHNbaV0gPSBEZWNvZGVyLnJlYWRDb2RlKHJhd2JpdHMsIG9mZnNldCwgY29kZXdvcmRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHJzRGVjb2RlciA9IG5ldyBSZWVkU29sb21vbkRlY29kZXIoZ2YpO1xuICAgICAgICAgICAgICAgIHJzRGVjb2Rlci5kZWNvZGUoZGF0YVdvcmRzLCBudW1Db2Rld29yZHMgLSBudW1EYXRhQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IHBlcmZvcm0gdGhlIHVuc3R1ZmZpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgICAgLy8gRmlyc3QsIGNvdW50IGhvdyBtYW55IGJpdHMgYXJlIGdvaW5nIHRvIGJlIHRocm93biBvdXQgYXMgc3R1ZmZpbmdcbiAgICAgICAgICAgIGxldCBtYXNrID0gKDEgPDwgY29kZXdvcmRTaXplKSAtIDE7XG4gICAgICAgICAgICBsZXQgc3R1ZmZlZEJpdHMgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YVdvcmQgPSBkYXRhV29yZHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFXb3JkID09PSAwIHx8IGRhdGFXb3JkID09PSBtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVdvcmQgPT09IDEgfHwgZGF0YVdvcmQgPT09IG1hc2sgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0dWZmZWRCaXRzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93LCBhY3R1YWxseSB1bnBhY2sgdGhlIGJpdHMgYW5kIHJlbW92ZSB0aGUgc3R1ZmZpbmdcbiAgICAgICAgICAgIGxldCBjb3JyZWN0ZWRCaXRzID0gbmV3IEFycmF5KG51bURhdGFDb2Rld29yZHMgKiBjb2Rld29yZFNpemUgLSBzdHVmZmVkQml0cyk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YVdvcmQgPSBkYXRhV29yZHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFXb3JkID09PSAxIHx8IGRhdGFXb3JkID09PSBtYXNrIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGNvZGV3b3JkU2l6ZS0xIGJpdHMgYXJlIGFsbCB6ZXJvcyBvciBhbGwgb25lc1xuICAgICAgICAgICAgICAgICAgICBjb3JyZWN0ZWRCaXRzLmZpbGwoZGF0YVdvcmQgPiAxLCBpbmRleCwgaW5kZXggKyBjb2Rld29yZFNpemUgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXlzLmZpbGwoY29ycmVjdGVkQml0cywgaW5kZXgsIGluZGV4ICsgY29kZXdvcmRTaXplIC0gMSwgZGF0YVdvcmQgPiAxKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gY29kZXdvcmRTaXplIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGJpdCA9IGNvZGV3b3JkU2l6ZSAtIDE7IGJpdCA+PSAwOyAtLWJpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVjdGVkQml0c1tpbmRleCsrXSA9IChkYXRhV29yZCAmICgxIDw8IGJpdCkpICE9PSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvcnJlY3RlZEJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGFycmF5IG9mIGJpdHMgZnJvbSBhbiBBenRlYyBDb2RlIG1hdHJpeFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBhcnJheSBvZiBiaXRzXG4gICAgICAgICAqL1xuICAgICAgICBleHRyYWN0Qml0cyhtYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCBjb21wYWN0ID0gdGhpcy5kZGF0YS5pc0NvbXBhY3QoKTtcbiAgICAgICAgICAgIGxldCBsYXllcnMgPSB0aGlzLmRkYXRhLmdldE5iTGF5ZXJzKCk7XG4gICAgICAgICAgICBsZXQgYmFzZU1hdHJpeFNpemUgPSAoY29tcGFjdCA/IDExIDogMTQpICsgbGF5ZXJzICogNDsgLy8gbm90IGluY2x1ZGluZyBhbGlnbm1lbnQgbGluZXNcbiAgICAgICAgICAgIGxldCBhbGlnbm1lbnRNYXAgPSBuZXcgSW50MzJBcnJheShiYXNlTWF0cml4U2l6ZSk7XG4gICAgICAgICAgICBsZXQgcmF3Yml0cyA9IG5ldyBBcnJheSh0aGlzLnRvdGFsQml0c0luTGF5ZXIobGF5ZXJzLCBjb21wYWN0KSk7XG4gICAgICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxpZ25tZW50TWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudE1hcFtpXSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdHJpeFNpemUgPSBiYXNlTWF0cml4U2l6ZSArIDEgKyAyICogSW50ZWdlci50cnVuY0RpdmlzaW9uKChJbnRlZ2VyLnRydW5jRGl2aXNpb24oYmFzZU1hdHJpeFNpemUsIDIpIC0gMSksIDE1KTtcbiAgICAgICAgICAgICAgICBsZXQgb3JpZ0NlbnRlciA9IGJhc2VNYXRyaXhTaXplIC8gMjtcbiAgICAgICAgICAgICAgICBsZXQgY2VudGVyID0gSW50ZWdlci50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ0NlbnRlcjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdPZmZzZXQgPSBpICsgSW50ZWdlci50cnVuY0RpdmlzaW9uKGksIDE1KTtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50TWFwW29yaWdDZW50ZXIgLSBpIC0gMV0gPSBjZW50ZXIgLSBuZXdPZmZzZXQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRNYXBbb3JpZ0NlbnRlciArIGldID0gY2VudGVyICsgbmV3T2Zmc2V0ICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcm93T2Zmc2V0ID0gMDsgaSA8IGxheWVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvd1NpemUgPSAobGF5ZXJzIC0gaSkgKiA0ICsgKGNvbXBhY3QgPyA5IDogMTIpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSB0b3AtbGVmdCBtb3N0IHBvaW50IG9mIHRoaXMgbGF5ZXIgaXMgPGxvdywgbG93PiAobm90IGluY2x1ZGluZyBhbGlnbm1lbnQgbGluZXMpXG4gICAgICAgICAgICAgICAgbGV0IGxvdyA9IGkgKiAyO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBib3R0b20tcmlnaHQgbW9zdCBwb2ludCBvZiB0aGlzIGxheWVyIGlzIDxoaWdoLCBoaWdoPiAobm90IGluY2x1ZGluZyBhbGlnbm1lbnQgbGluZXMpXG4gICAgICAgICAgICAgICAgbGV0IGhpZ2ggPSBiYXNlTWF0cml4U2l6ZSAtIDEgLSBsb3c7XG4gICAgICAgICAgICAgICAgLy8gV2UgcHVsbCBiaXRzIGZyb20gdGhlIHR3byAyIHggcm93U2l6ZSBjb2x1bW5zIGFuZCB0d28gcm93U2l6ZSB4IDIgcm93c1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93U2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2x1bW5PZmZzZXQgPSBqICogMjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCAyOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlZnQgY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdiaXRzW3Jvd09mZnNldCArIGNvbHVtbk9mZnNldCArIGtdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguZ2V0KGFsaWdubWVudE1hcFtsb3cgKyBrXSwgYWxpZ25tZW50TWFwW2xvdyArIGpdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvdHRvbSByb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd2JpdHNbcm93T2Zmc2V0ICsgMiAqIHJvd1NpemUgKyBjb2x1bW5PZmZzZXQgKyBrXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LmdldChhbGlnbm1lbnRNYXBbbG93ICsgal0sIGFsaWdubWVudE1hcFtoaWdoIC0ga10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmlnaHQgY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdiaXRzW3Jvd09mZnNldCArIDQgKiByb3dTaXplICsgY29sdW1uT2Zmc2V0ICsga10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5nZXQoYWxpZ25tZW50TWFwW2hpZ2ggLSBrXSwgYWxpZ25tZW50TWFwW2hpZ2ggLSBqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0b3Agcm93XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdiaXRzW3Jvd09mZnNldCArIDYgKiByb3dTaXplICsgY29sdW1uT2Zmc2V0ICsga10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5nZXQoYWxpZ25tZW50TWFwW2hpZ2ggLSBqXSwgYWxpZ25tZW50TWFwW2xvdyArIGtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb3dPZmZzZXQgKz0gcm93U2l6ZSAqIDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmF3Yml0cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZHMgYSBjb2RlIG9mIGdpdmVuIGxlbmd0aCBhbmQgYXQgZ2l2ZW4gaW5kZXggaW4gYW4gYXJyYXkgb2YgYml0c1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHJlYWRDb2RlKHJhd2JpdHMsIHN0YXJ0SW5kZXgsIGxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJlcyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IHN0YXJ0SW5kZXggKyBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlcyA8PD0gMTtcbiAgICAgICAgICAgICAgICBpZiAocmF3Yml0c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXMgfD0gMHgwMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkcyBhIGNvZGUgb2YgbGVuZ3RoIDggaW4gYW4gYXJyYXkgb2YgYml0cywgcGFkZGluZyB3aXRoIHplcm9zXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcmVhZEJ5dGUocmF3Yml0cywgc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgbGV0IG4gPSByYXdiaXRzLmxlbmd0aCAtIHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBpZiAobiA+PSA4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIucmVhZENvZGUocmF3Yml0cywgc3RhcnRJbmRleCwgOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5yZWFkQ29kZShyYXdiaXRzLCBzdGFydEluZGV4LCBuKSA8PCAoOCAtIG4pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYWNrcyBhIGJpdCBhcnJheSBpbnRvIGJ5dGVzLCBtb3N0IHNpZ25pZmljYW50IGJpdCBmaXJzdFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNvbnZlcnRCb29sQXJyYXlUb0J5dGVBcnJheShib29sQXJyKSB7XG4gICAgICAgICAgICBsZXQgYnl0ZUFyciA9IG5ldyBVaW50OEFycmF5KChib29sQXJyLmxlbmd0aCArIDcpIC8gOCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBieXRlQXJyW2ldID0gRGVjb2Rlci5yZWFkQnl0ZShib29sQXJyLCA4ICogaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnl0ZUFycjtcbiAgICAgICAgfVxuICAgICAgICB0b3RhbEJpdHNJbkxheWVyKGxheWVycywgY29tcGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuICgoY29tcGFjdCA/IDg4IDogMTEyKSArIDE2ICogbGF5ZXJzKSAqIGxheWVycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBEZWNvZGVyLlVQUEVSX1RBQkxFID0gW1xuICAgICAgICAnQ1RSTF9QUycsICcgJywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLFxuICAgICAgICAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdDVFJMX0xMJywgJ0NUUkxfTUwnLCAnQ1RSTF9ETCcsICdDVFJMX0JTJ1xuICAgIF07XG4gICAgRGVjb2Rlci5MT1dFUl9UQUJMRSA9IFtcbiAgICAgICAgJ0NUUkxfUFMnLCAnICcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJyxcbiAgICAgICAgJ3EnLCAncicsICdzJywgJ3QnLCAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onLCAnQ1RSTF9VUycsICdDVFJMX01MJywgJ0NUUkxfREwnLCAnQ1RSTF9CUydcbiAgICBdO1xuICAgIERlY29kZXIuTUlYRURfVEFCTEUgPSBbXG4gICAgICAgIC8vIE1vZHVsZSBwYXJzZSBmYWlsZWQ6IE9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGUgKDUwOjI5KVxuICAgICAgICAvLyBzbyBudW1iZXIgc3RyaW5nIHdlcmUgc2NhcGVkXG4gICAgICAgICdDVFJMX1BTJywgJyAnLCAnXFxcXDEnLCAnXFxcXDInLCAnXFxcXDMnLCAnXFxcXDQnLCAnXFxcXDUnLCAnXFxcXDYnLCAnXFxcXDcnLCAnXFxiJywgJ1xcdCcsICdcXG4nLFxuICAgICAgICAnXFxcXDEzJywgJ1xcZicsICdcXHInLCAnXFxcXDMzJywgJ1xcXFwzNCcsICdcXFxcMzUnLCAnXFxcXDM2JywgJ1xcXFwzNycsICdAJywgJ1xcXFwnLCAnXicsICdfJyxcbiAgICAgICAgJ2AnLCAnfCcsICd+JywgJ1xcXFwxNzcnLCAnQ1RSTF9MTCcsICdDVFJMX1VMJywgJ0NUUkxfUEwnLCAnQ1RSTF9CUydcbiAgICBdO1xuICAgIERlY29kZXIuUFVOQ1RfVEFCTEUgPSBbXG4gICAgICAgICcnLCAnXFxyJywgJ1xcclxcbicsICcuICcsICcsICcsICc6ICcsICchJywgJ1wiJywgJyMnLCAnJCcsICclJywgJyYnLCAnXFwnJywgJygnLCAnKScsXG4gICAgICAgICcqJywgJysnLCAnLCcsICctJywgJy4nLCAnLycsICc6JywgJzsnLCAnPCcsICc9JywgJz4nLCAnPycsICdbJywgJ10nLCAneycsICd9JywgJ0NUUkxfVUwnXG4gICAgXTtcbiAgICBEZWNvZGVyLkRJR0lUX1RBQkxFID0gW1xuICAgICAgICAnQ1RSTF9QUycsICcgJywgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLCAnLCcsICcuJywgJ0NUUkxfVUwnLCAnQ1RSTF9VUydcbiAgICBdO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMiBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5kZXRlY3RvciB7Ki9cbiAgICAvKipcbiAgICAgKiBHZW5lcmFsIG1hdGgtcmVsYXRlZCBhbmQgbnVtZXJpYyB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBNYXRoVXRpbHMge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRW5kcyB1cCBiZWluZyBhIGJpdCBmYXN0ZXIgdGhhbiB7QGxpbmsgTWF0aCNyb3VuZChmbG9hdCl9LiBUaGlzIG1lcmVseSByb3VuZHMgaXRzXG4gICAgICAgICAqIGFyZ3VtZW50IHRvIHRoZSBuZWFyZXN0IGludCwgd2hlcmUgeC41IHJvdW5kcyB1cCB0byB4KzEuIFNlbWFudGljcyBvZiB0aGlzIHNob3J0Y3V0XG4gICAgICAgICAqIGRpZmZlciBzbGlnaHRseSBmcm9tIHtAbGluayBNYXRoI3JvdW5kKGZsb2F0KX0gaW4gdGhhdCBoYWxmIHJvdW5kcyBkb3duIGZvciBuZWdhdGl2ZVxuICAgICAgICAgKiB2YWx1ZXMuIC0yLjUgcm91bmRzIHRvIC0zLCBub3QgLTIuIEZvciBwdXJwb3NlcyBoZXJlIGl0IG1ha2VzIG5vIGRpZmZlcmVuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkIHJlYWwgdmFsdWUgdG8gcm91bmRcbiAgICAgICAgICogQHJldHVybiBuZWFyZXN0IHtAY29kZSBpbnR9XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcm91bmQoZCAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIGlmIChOYU4gPT09IGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBpZiAoZCA8PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUilcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICBpZiAoZCA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICByZXR1cm4gLyooaW50KSAqLyAoZCArIChkIDwgMC4wID8gLTAuNSA6IDAuNSkpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogbWF5YmUgcmVtb3ZlIHJvdW5kIG1ldGhvZCBhbmQgY2FsbCBkaXJlY3RseSBNYXRoLnJvdW5kLCBpdCBsb29rcyBsaWtlIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3IganNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBhWCBwb2ludCBBIHggY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gYVkgcG9pbnQgQSB5IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIGJYIHBvaW50IEIgeCBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSBiWSBwb2ludCBCIHkgY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcmV0dXJuIEV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50cyBBIGFuZCBCXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGlzdGFuY2UoYVggLypmbG9hdHxpbnQqLywgYVkgLypmbG9hdHxpbnQqLywgYlggLypmbG9hdHxpbnQqLywgYlkgLypmbG9hdHxpbnQqLykge1xuICAgICAgICAgICAgY29uc3QgeERpZmYgPSBhWCAtIGJYO1xuICAgICAgICAgICAgY29uc3QgeURpZmYgPSBhWSAtIGJZO1xuICAgICAgICAgICAgcmV0dXJuIC8qKGZsb2F0KSAqLyBNYXRoLnNxcnQoeERpZmYgKiB4RGlmZiArIHlEaWZmICogeURpZmYpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYVggcG9pbnQgQSB4IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIGFZIHBvaW50IEEgeSBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSBiWCBwb2ludCBCIHggY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gYlkgcG9pbnQgQiB5IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHJldHVybiBFdWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgQSBhbmQgQlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gcHVibGljIHN0YXRpYyBkaXN0YW5jZShhWDogbnVtYmVyIC8qaW50Ki8sIGFZOiBudW1iZXIgLyppbnQqLywgYlg6IG51bWJlciAvKmludCovLCBiWTogbnVtYmVyIC8qaW50Ki8pOiBmbG9hdCB7XG4gICAgICAgIC8vICAgY29uc3QgeERpZmYgPSBhWCAtIGJYXG4gICAgICAgIC8vICAgY29uc3QgeURpZmYgPSBhWSAtIGJZXG4gICAgICAgIC8vICAgcmV0dXJuIChmbG9hdCkgTWF0aC5zcXJ0KHhEaWZmICogeERpZmYgKyB5RGlmZiAqIHlEaWZmKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGFycmF5IHZhbHVlcyB0byBzdW1cbiAgICAgICAgICogQHJldHVybiBzdW0gb2YgdmFsdWVzIGluIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgc3VtKGFycmF5KSB7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSAhPT0gbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgY291bnQgKz0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbnlmaWxsIGZvciBKYXZhJ3MgRmxvYXQgY2xhc3MuXG4gICAgICovXG4gICAgY2xhc3MgRmxvYXQge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2luY1RTIGhhcyBubyBkaWZmZXJlbmNlIGJldHdlZW4gaW50IGFuZCBmbG9hdCwgdGhlcmUncyBhbGwgbnVtYmVycyxcbiAgICAgICAgICogdGhpcyBpcyB1c2VkIG9ubHkgdG8gcG9seWZpbGwgSmF2YSBjb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZsb2F0VG9JbnRCaXRzKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmbG9hdCBtYXggdmFsdWUgaW4gSlMgaXMgdGhlIG51bWJlciBtYXggdmFsdWUuXG4gICAgICovXG4gICAgRmxvYXQuTUFYX1ZBTFVFID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBhIHBvaW50IG9mIGludGVyZXN0IGluIGFuIGltYWdlIGNvbnRhaW5pbmcgYSBiYXJjb2RlLiBUeXBpY2FsbHksIHRoaXNcbiAgICAgKiB3b3VsZCBiZSB0aGUgbG9jYXRpb24gb2YgYSBmaW5kZXIgcGF0dGVybiBvciB0aGUgY29ybmVyIG9mIHRoZSBiYXJjb2RlLCBmb3IgZXhhbXBsZS48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIFJlc3VsdFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0WCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0WSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFJlc3VsdFBvaW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJQb2ludCA9IG90aGVyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnggPT09IG90aGVyUG9pbnQueCAmJiB0aGlzLnkgPT09IG90aGVyUG9pbnQueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGhhc2hDb2RlKCkge1xuICAgICAgICAgICAgcmV0dXJuIDMxICogRmxvYXQuZmxvYXRUb0ludEJpdHModGhpcy54KSArIEZsb2F0LmZsb2F0VG9JbnRCaXRzKHRoaXMueSk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnKCcgKyB0aGlzLnggKyAnLCcgKyB0aGlzLnkgKyAnKSc7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9yZGVycyBhbiBhcnJheSBvZiB0aHJlZSBSZXN1bHRQb2ludHMgaW4gYW4gb3JkZXIgW0EsQixDXSBzdWNoIHRoYXQgQUIgaXMgbGVzcyB0aGFuIEFDXG4gICAgICAgICAqIGFuZCBCQyBpcyBsZXNzIHRoYW4gQUMsIGFuZCB0aGUgYW5nbGUgYmV0d2VlbiBCQyBhbmQgQkEgaXMgbGVzcyB0aGFuIDE4MCBkZWdyZWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGF0dGVybnMgYXJyYXkgb2YgdGhyZWUge0Bjb2RlIFJlc3VsdFBvaW50fSB0byBvcmRlclxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG9yZGVyQmVzdFBhdHRlcm5zKHBhdHRlcm5zKSB7XG4gICAgICAgICAgICAvLyBGaW5kIGRpc3RhbmNlcyBiZXR3ZWVuIHBhdHRlcm4gY2VudGVyc1xuICAgICAgICAgICAgY29uc3QgemVyb09uZURpc3RhbmNlID0gdGhpcy5kaXN0YW5jZShwYXR0ZXJuc1swXSwgcGF0dGVybnNbMV0pO1xuICAgICAgICAgICAgY29uc3Qgb25lVHdvRGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlKHBhdHRlcm5zWzFdLCBwYXR0ZXJuc1syXSk7XG4gICAgICAgICAgICBjb25zdCB6ZXJvVHdvRGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlKHBhdHRlcm5zWzBdLCBwYXR0ZXJuc1syXSk7XG4gICAgICAgICAgICBsZXQgcG9pbnRBO1xuICAgICAgICAgICAgbGV0IHBvaW50QjtcbiAgICAgICAgICAgIGxldCBwb2ludEM7XG4gICAgICAgICAgICAvLyBBc3N1bWUgb25lIGNsb3Nlc3QgdG8gb3RoZXIgdHdvIGlzIEI7IEEgYW5kIEMgd2lsbCBqdXN0IGJlIGd1ZXNzZXMgYXQgZmlyc3RcbiAgICAgICAgICAgIGlmIChvbmVUd29EaXN0YW5jZSA+PSB6ZXJvT25lRGlzdGFuY2UgJiYgb25lVHdvRGlzdGFuY2UgPj0gemVyb1R3b0Rpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRCID0gcGF0dGVybnNbMF07XG4gICAgICAgICAgICAgICAgcG9pbnRBID0gcGF0dGVybnNbMV07XG4gICAgICAgICAgICAgICAgcG9pbnRDID0gcGF0dGVybnNbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh6ZXJvVHdvRGlzdGFuY2UgPj0gb25lVHdvRGlzdGFuY2UgJiYgemVyb1R3b0Rpc3RhbmNlID49IHplcm9PbmVEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHBvaW50QiA9IHBhdHRlcm5zWzFdO1xuICAgICAgICAgICAgICAgIHBvaW50QSA9IHBhdHRlcm5zWzBdO1xuICAgICAgICAgICAgICAgIHBvaW50QyA9IHBhdHRlcm5zWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnRCID0gcGF0dGVybnNbMl07XG4gICAgICAgICAgICAgICAgcG9pbnRBID0gcGF0dGVybnNbMF07XG4gICAgICAgICAgICAgICAgcG9pbnRDID0gcGF0dGVybnNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2UgY3Jvc3MgcHJvZHVjdCB0byBmaWd1cmUgb3V0IHdoZXRoZXIgQSBhbmQgQyBhcmUgY29ycmVjdCBvciBmbGlwcGVkLlxuICAgICAgICAgICAgLy8gVGhpcyBhc2tzIHdoZXRoZXIgQkMgeCBCQSBoYXMgYSBwb3NpdGl2ZSB6IGNvbXBvbmVudCwgd2hpY2ggaXMgdGhlIGFycmFuZ2VtZW50XG4gICAgICAgICAgICAvLyB3ZSB3YW50IGZvciBBLCBCLCBDLiBJZiBpdCdzIG5lZ2F0aXZlLCB0aGVuIHdlJ3ZlIGdvdCBpdCBmbGlwcGVkIGFyb3VuZCBhbmRcbiAgICAgICAgICAgIC8vIHNob3VsZCBzd2FwIEEgYW5kIEMuXG4gICAgICAgICAgICBpZiAodGhpcy5jcm9zc1Byb2R1Y3RaKHBvaW50QSwgcG9pbnRCLCBwb2ludEMpIDwgMC4wKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcCA9IHBvaW50QTtcbiAgICAgICAgICAgICAgICBwb2ludEEgPSBwb2ludEM7XG4gICAgICAgICAgICAgICAgcG9pbnRDID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdHRlcm5zWzBdID0gcG9pbnRBO1xuICAgICAgICAgICAgcGF0dGVybnNbMV0gPSBwb2ludEI7XG4gICAgICAgICAgICBwYXR0ZXJuc1syXSA9IHBvaW50QztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHBhdHRlcm4xIGZpcnN0IHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIHBhdHRlcm4yIHNlY29uZCBwYXR0ZXJuXG4gICAgICAgICAqIEByZXR1cm4gZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGlzdGFuY2UocGF0dGVybjEsIHBhdHRlcm4yKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzLmRpc3RhbmNlKHBhdHRlcm4xLngsIHBhdHRlcm4xLnksIHBhdHRlcm4yLngsIHBhdHRlcm4yLnkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB6IGNvbXBvbmVudCBvZiB0aGUgY3Jvc3MgcHJvZHVjdCBiZXR3ZWVuIHZlY3RvcnMgQkMgYW5kIEJBLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNyb3NzUHJvZHVjdFoocG9pbnRBLCBwb2ludEIsIHBvaW50Qykge1xuICAgICAgICAgICAgY29uc3QgYlggPSBwb2ludEIueDtcbiAgICAgICAgICAgIGNvbnN0IGJZID0gcG9pbnRCLnk7XG4gICAgICAgICAgICByZXR1cm4gKChwb2ludEMueCAtIGJYKSAqIChwb2ludEEueSAtIGJZKSkgLSAoKHBvaW50Qy55IC0gYlkpICogKHBvaW50QS54IC0gYlgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIHRoZSByZXN1bHQgb2YgZGV0ZWN0aW5nIGEgYmFyY29kZSBpbiBhbiBpbWFnZS4gVGhpcyBpbmNsdWRlcyB0aGUgcmF3XG4gICAgICogbWF0cml4IG9mIGJsYWNrL3doaXRlIHBpeGVscyBjb3JyZXNwb25kaW5nIHRvIHRoZSBiYXJjb2RlLCBhbmQgcG9zc2libHkgcG9pbnRzIG9mIGludGVyZXN0XG4gICAgICogaW4gdGhlIGltYWdlLCBsaWtlIHRoZSBsb2NhdGlvbiBvZiBmaW5kZXIgcGF0dGVybnMgb3IgY29ybmVycyBvZiB0aGUgYmFyY29kZSBpbiB0aGUgaW1hZ2UuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBEZXRlY3RvclJlc3VsdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGJpdHMsIHBvaW50cykge1xuICAgICAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICB9XG4gICAgICAgIGdldEJpdHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaXRzO1xuICAgICAgICB9XG4gICAgICAgIGdldFBvaW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvaW50cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTAgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+RXh0ZW5kcyB7QGxpbmsgRGV0ZWN0b3JSZXN1bHR9IHdpdGggbW9yZSBpbmZvcm1hdGlvbiBzcGVjaWZpYyB0byB0aGUgQXp0ZWMgZm9ybWF0LFxuICAgICAqIGxpa2UgdGhlIG51bWJlciBvZiBsYXllcnMgYW5kIHdoZXRoZXIgaXQncyBjb21wYWN0LjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgQXp0ZWNEZXRlY3RvclJlc3VsdCBleHRlbmRzIERldGVjdG9yUmVzdWx0IHtcbiAgICAgICAgY29uc3RydWN0b3IoYml0cywgcG9pbnRzLCBjb21wYWN0LCBuYkRhdGFibG9ja3MsIG5iTGF5ZXJzKSB7XG4gICAgICAgICAgICBzdXBlcihiaXRzLCBwb2ludHMpO1xuICAgICAgICAgICAgdGhpcy5jb21wYWN0ID0gY29tcGFjdDtcbiAgICAgICAgICAgIHRoaXMubmJEYXRhYmxvY2tzID0gbmJEYXRhYmxvY2tzO1xuICAgICAgICAgICAgdGhpcy5uYkxheWVycyA9IG5iTGF5ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGdldE5iTGF5ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmJMYXllcnM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TmJEYXRhYmxvY2tzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmJEYXRhYmxvY2tzO1xuICAgICAgICB9XG4gICAgICAgIGlzQ29tcGFjdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBhY3Q7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEwIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPlxuICAgICAqIERldGVjdHMgYSBjYW5kaWRhdGUgYmFyY29kZS1saWtlIHJlY3Rhbmd1bGFyIHJlZ2lvbiB3aXRoaW4gYW4gaW1hZ2UuIEl0XG4gICAgICogc3RhcnRzIGFyb3VuZCB0aGUgY2VudGVyIG9mIHRoZSBpbWFnZSwgaW5jcmVhc2VzIHRoZSBzaXplIG9mIHRoZSBjYW5kaWRhdGVcbiAgICAgKiByZWdpb24gdW50aWwgaXQgZmluZHMgYSB3aGl0ZSByZWN0YW5ndWxhciByZWdpb24uIEJ5IGtlZXBpbmcgdHJhY2sgb2YgdGhlXG4gICAgICogbGFzdCBibGFjayBwb2ludHMgaXQgZW5jb3VudGVyZWQsIGl0IGRldGVybWluZXMgdGhlIGNvcm5lcnMgb2YgdGhlIGJhcmNvZGUuXG4gICAgICogPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBEYXZpZCBPbGl2aWVyXG4gICAgICovXG4gICAgY2xhc3MgV2hpdGVSZWN0YW5nbGVEZXRlY3RvciB7XG4gICAgICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIGltYWdlOiBCaXRNYXRyaXgpIC8qdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uKi8ge1xuICAgICAgICAvLyAgIHRoaXMoaW1hZ2UsIElOSVRfU0laRSwgaW1hZ2UuZ2V0V2lkdGgoKSAvIDIsIGltYWdlLmdldEhlaWdodCgpIC8gMilcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGltYWdlIGJhcmNvZGUgaW1hZ2UgdG8gZmluZCBhIHJlY3RhbmdsZSBpblxuICAgICAgICAgKiBAcGFyYW0gaW5pdFNpemUgaW5pdGlhbCBzaXplIG9mIHNlYXJjaCBhcmVhIGFyb3VuZCBjZW50ZXJcbiAgICAgICAgICogQHBhcmFtIHggeCBwb3NpdGlvbiBvZiBzZWFyY2ggY2VudGVyXG4gICAgICAgICAqIEBwYXJhbSB5IHkgcG9zaXRpb24gb2Ygc2VhcmNoIGNlbnRlclxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGltYWdlIGlzIHRvbyBzbWFsbCB0byBhY2NvbW1vZGF0ZSB7QGNvZGUgaW5pdFNpemV9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihpbWFnZSwgaW5pdFNpemUgLyppbnQqLywgeCAvKmludCovLCB5IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGluaXRTaXplIHx8IG51bGwgPT09IGluaXRTaXplKSB7XG4gICAgICAgICAgICAgICAgaW5pdFNpemUgPSBXaGl0ZVJlY3RhbmdsZURldGVjdG9yLklOSVRfU0laRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHggfHwgbnVsbCA9PT0geCkge1xuICAgICAgICAgICAgICAgIHggPSBpbWFnZS5nZXRXaWR0aCgpIC8gMiB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSB5IHx8IG51bGwgPT09IHkpIHtcbiAgICAgICAgICAgICAgICB5ID0gaW1hZ2UuZ2V0SGVpZ2h0KCkgLyAyIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhbGZzaXplID0gaW5pdFNpemUgLyAyIHwgMDtcbiAgICAgICAgICAgIHRoaXMubGVmdEluaXQgPSB4IC0gaGFsZnNpemU7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0SW5pdCA9IHggKyBoYWxmc2l6ZTtcbiAgICAgICAgICAgIHRoaXMudXBJbml0ID0geSAtIGhhbGZzaXplO1xuICAgICAgICAgICAgdGhpcy5kb3duSW5pdCA9IHkgKyBoYWxmc2l6ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnVwSW5pdCA8IDAgfHwgdGhpcy5sZWZ0SW5pdCA8IDAgfHwgdGhpcy5kb3duSW5pdCA+PSB0aGlzLmhlaWdodCB8fCB0aGlzLnJpZ2h0SW5pdCA+PSB0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKiBEZXRlY3RzIGEgY2FuZGlkYXRlIGJhcmNvZGUtbGlrZSByZWN0YW5ndWxhciByZWdpb24gd2l0aGluIGFuIGltYWdlLiBJdFxuICAgICAgICAgKiBzdGFydHMgYXJvdW5kIHRoZSBjZW50ZXIgb2YgdGhlIGltYWdlLCBpbmNyZWFzZXMgdGhlIHNpemUgb2YgdGhlIGNhbmRpZGF0ZVxuICAgICAgICAgKiByZWdpb24gdW50aWwgaXQgZmluZHMgYSB3aGl0ZSByZWN0YW5ndWxhciByZWdpb24uXG4gICAgICAgICAqIDwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgUmVzdWx0UG9pbnR9W10gZGVzY3JpYmluZyB0aGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ3VsYXJcbiAgICAgICAgICogICAgICAgICByZWdpb24uIFRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgYXJlIG9wcG9zZWQgb24gdGhlIGRpYWdvbmFsLCBhc1xuICAgICAgICAgKiAgICAgICAgIGFyZSB0aGUgc2Vjb25kIGFuZCB0aGlyZC4gVGhlIGZpcnN0IHBvaW50IHdpbGwgYmUgdGhlIHRvcG1vc3RcbiAgICAgICAgICogICAgICAgICBwb2ludCBhbmQgdGhlIGxhc3QsIHRoZSBib3R0b21tb3N0LiBUaGUgc2Vjb25kIHBvaW50IHdpbGwgYmVcbiAgICAgICAgICogICAgICAgICBsZWZ0bW9zdCBhbmQgdGhlIHRoaXJkLCB0aGUgcmlnaHRtb3N0XG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgbm8gRGF0YSBNYXRyaXggQ29kZSBjYW4gYmUgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIGRldGVjdCgpIHtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0SW5pdDtcbiAgICAgICAgICAgIGxldCByaWdodCA9IHRoaXMucmlnaHRJbml0O1xuICAgICAgICAgICAgbGV0IHVwID0gdGhpcy51cEluaXQ7XG4gICAgICAgICAgICBsZXQgZG93biA9IHRoaXMuZG93bkluaXQ7XG4gICAgICAgICAgICBsZXQgc2l6ZUV4Y2VlZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgYUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25SaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkJvdHRvbSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkxlZnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Ub3AgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgd2hpbGUgKGFCbGFja1BvaW50Rm91bmRPbkJvcmRlcikge1xuICAgICAgICAgICAgICAgIGFCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIC4uLi4uXG4gICAgICAgICAgICAgICAgLy8gLiAgIHxcbiAgICAgICAgICAgICAgICAvLyAuLi4uLlxuICAgICAgICAgICAgICAgIGxldCByaWdodEJvcmRlck5vdFdoaXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHJpZ2h0Qm9yZGVyTm90V2hpdGUgfHwgIWF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPblJpZ2h0KSAmJiByaWdodCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Qm9yZGVyTm90V2hpdGUgPSB0aGlzLmNvbnRhaW5zQmxhY2tQb2ludCh1cCwgZG93biwgcmlnaHQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0Qm9yZGVyTm90V2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uUmlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25SaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmlnaHQgPj0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZUV4Y2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIC4uLi4uXG4gICAgICAgICAgICAgICAgLy8gLiAgIC5cbiAgICAgICAgICAgICAgICAvLyAuX19fLlxuICAgICAgICAgICAgICAgIGxldCBib3R0b21Cb3JkZXJOb3RXaGl0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChib3R0b21Cb3JkZXJOb3RXaGl0ZSB8fCAhYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uQm90dG9tKSAmJiBkb3duIDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbUJvcmRlck5vdFdoaXRlID0gdGhpcy5jb250YWluc0JsYWNrUG9pbnQobGVmdCwgcmlnaHQsIGRvd24sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm90dG9tQm9yZGVyTm90V2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvd24rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGFCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3R0b20gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvd24rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZG93biA+PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZUV4Y2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIC4uLi4uXG4gICAgICAgICAgICAgICAgLy8gfCAgIC5cbiAgICAgICAgICAgICAgICAvLyAuLi4uLlxuICAgICAgICAgICAgICAgIGxldCBsZWZ0Qm9yZGVyTm90V2hpdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdoaWxlICgobGVmdEJvcmRlck5vdFdoaXRlIHx8ICFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25MZWZ0KSAmJiBsZWZ0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdEJvcmRlck5vdFdoaXRlID0gdGhpcy5jb250YWluc0JsYWNrUG9pbnQodXAsIGRvd24sIGxlZnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRCb3JkZXJOb3RXaGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgYUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkxlZnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25MZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemVFeGNlZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAuX19fLlxuICAgICAgICAgICAgICAgIC8vIC4gICAuXG4gICAgICAgICAgICAgICAgLy8gLi4uLi5cbiAgICAgICAgICAgICAgICBsZXQgdG9wQm9yZGVyTm90V2hpdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdoaWxlICgodG9wQm9yZGVyTm90V2hpdGUgfHwgIWF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPblRvcCkgJiYgdXAgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0b3BCb3JkZXJOb3RXaGl0ZSA9IHRoaXMuY29udGFpbnNCbGFja1BvaW50KGxlZnQsIHJpZ2h0LCB1cCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3BCb3JkZXJOb3RXaGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXAtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Ub3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Ub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVwIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzaXplRXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFCbGFja1BvaW50Rm91bmRPbkJvcmRlcikge1xuICAgICAgICAgICAgICAgICAgICBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2l6ZUV4Y2VlZGVkICYmIGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkJvcmRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heFNpemUgPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgICAgICAgbGV0IHogPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyB6ID09PSBudWxsICYmIGkgPCBtYXhTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeiA9IHRoaXMuZ2V0QmxhY2tQb2ludE9uU2VnbWVudChsZWZ0LCBkb3duIC0gaSwgbGVmdCArIGksIGRvd24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gZ28gZG93biByaWdodFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyB0ID09PSBudWxsICYmIGkgPCBtYXhTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IHRoaXMuZ2V0QmxhY2tQb2ludE9uU2VnbWVudChsZWZ0LCB1cCArIGksIGxlZnQgKyBpLCB1cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBnbyBkb3duIGxlZnRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgeCA9PT0gbnVsbCAmJiBpIDwgbWF4U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSB0aGlzLmdldEJsYWNrUG9pbnRPblNlZ21lbnQocmlnaHQsIHVwICsgaSwgcmlnaHQgLSBpLCB1cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBnbyB1cCBsZWZ0XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IHkgPT09IG51bGwgJiYgaSA8IG1heFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRCbGFja1BvaW50T25TZWdtZW50KHJpZ2h0LCBkb3duIC0gaSwgcmlnaHQgLSBpLCBkb3duKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyRWRnZXMoeSwgeiwgeCwgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXRCbGFja1BvaW50T25TZWdtZW50KGFYIC8qZmxvYXQqLywgYVkgLypmbG9hdCovLCBiWCAvKmZsb2F0Ki8sIGJZIC8qZmxvYXQqLykge1xuICAgICAgICAgICAgY29uc3QgZGlzdCA9IE1hdGhVdGlscy5yb3VuZChNYXRoVXRpbHMuZGlzdGFuY2UoYVgsIGFZLCBiWCwgYlkpKTtcbiAgICAgICAgICAgIGNvbnN0IHhTdGVwID0gKGJYIC0gYVgpIC8gZGlzdDtcbiAgICAgICAgICAgIGNvbnN0IHlTdGVwID0gKGJZIC0gYVkpIC8gZGlzdDtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlzdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGhVdGlscy5yb3VuZChhWCArIGkgKiB4U3RlcCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGhVdGlscy5yb3VuZChhWSArIGkgKiB5U3RlcCk7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldCh4LCB5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdFBvaW50KHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZWNlbnRlcnMgdGhlIHBvaW50cyBvZiBhIGNvbnN0YW50IGRpc3RhbmNlIHRvd2FyZHMgdGhlIGNlbnRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geSBib3R0b20gbW9zdCBwb2ludFxuICAgICAgICAgKiBAcGFyYW0geiBsZWZ0IG1vc3QgcG9pbnRcbiAgICAgICAgICogQHBhcmFtIHggcmlnaHQgbW9zdCBwb2ludFxuICAgICAgICAgKiBAcGFyYW0gdCB0b3AgbW9zdCBwb2ludFxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBSZXN1bHRQb2ludH1bXSBkZXNjcmliaW5nIHRoZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5ndWxhclxuICAgICAgICAgKiAgICAgICAgIHJlZ2lvbi4gVGhlIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBhcmUgb3Bwb3NlZCBvbiB0aGUgZGlhZ29uYWwsIGFzXG4gICAgICAgICAqICAgICAgICAgYXJlIHRoZSBzZWNvbmQgYW5kIHRoaXJkLiBUaGUgZmlyc3QgcG9pbnQgd2lsbCBiZSB0aGUgdG9wbW9zdFxuICAgICAgICAgKiAgICAgICAgIHBvaW50IGFuZCB0aGUgbGFzdCwgdGhlIGJvdHRvbW1vc3QuIFRoZSBzZWNvbmQgcG9pbnQgd2lsbCBiZVxuICAgICAgICAgKiAgICAgICAgIGxlZnRtb3N0IGFuZCB0aGUgdGhpcmQsIHRoZSByaWdodG1vc3RcbiAgICAgICAgICovXG4gICAgICAgIGNlbnRlckVkZ2VzKHksIHosIHgsIHQpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgICB0ICAgICAgICAgICAgdFxuICAgICAgICAgICAgLy8gIHogICAgICAgICAgICAgICAgICAgICAgeFxuICAgICAgICAgICAgLy8gICAgICAgIHggICAgT1IgICAgelxuICAgICAgICAgICAgLy8gICB5ICAgICAgICAgICAgICAgICAgICB5XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgY29uc3QgeWkgPSB5LmdldFgoKTtcbiAgICAgICAgICAgIGNvbnN0IHlqID0geS5nZXRZKCk7XG4gICAgICAgICAgICBjb25zdCB6aSA9IHouZ2V0WCgpO1xuICAgICAgICAgICAgY29uc3QgemogPSB6LmdldFkoKTtcbiAgICAgICAgICAgIGNvbnN0IHhpID0geC5nZXRYKCk7XG4gICAgICAgICAgICBjb25zdCB4aiA9IHguZ2V0WSgpO1xuICAgICAgICAgICAgY29uc3QgdGkgPSB0LmdldFgoKTtcbiAgICAgICAgICAgIGNvbnN0IHRqID0gdC5nZXRZKCk7XG4gICAgICAgICAgICBjb25zdCBDT1JSID0gV2hpdGVSZWN0YW5nbGVEZXRlY3Rvci5DT1JSO1xuICAgICAgICAgICAgaWYgKHlpIDwgdGhpcy53aWR0aCAvIDIuMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh0aSAtIENPUlIsIHRqICsgQ09SUiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh6aSArIENPUlIsIHpqICsgQ09SUiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh4aSAtIENPUlIsIHhqIC0gQ09SUiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh5aSArIENPUlIsIHlqIC0gQ09SUilcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJlc3VsdFBvaW50KHRpICsgQ09SUiwgdGogKyBDT1JSKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJlc3VsdFBvaW50KHppICsgQ09SUiwgemogLSBDT1JSKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJlc3VsdFBvaW50KHhpIC0gQ09SUiwgeGogKyBDT1JSKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJlc3VsdFBvaW50KHlpIC0gQ09SUiwgeWogLSBDT1JSKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciBhIHNlZ21lbnQgY29udGFpbnMgYSBibGFjayBwb2ludFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYSAgICAgICAgICBtaW4gdmFsdWUgb2YgdGhlIHNjYW5uZWQgY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gYiAgICAgICAgICBtYXggdmFsdWUgb2YgdGhlIHNjYW5uZWQgY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gZml4ZWQgICAgICB2YWx1ZSBvZiBmaXhlZCBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSBob3Jpem9udGFsIHNldCB0byB0cnVlIGlmIHNjYW4gbXVzdCBiZSBob3Jpem9udGFsLCBmYWxzZSBpZiB2ZXJ0aWNhbFxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgYSBibGFjayBwb2ludCBoYXMgYmVlbiBmb3VuZCwgZWxzZSBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5zQmxhY2tQb2ludChhIC8qaW50Ki8sIGIgLyppbnQqLywgZml4ZWQgLyppbnQqLywgaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gYTsgeCA8PSBiOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldCh4LCBmaXhlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IGE7IHkgPD0gYjsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoZml4ZWQsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBXaGl0ZVJlY3RhbmdsZURldGVjdG9yLklOSVRfU0laRSA9IDEwO1xuICAgIFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IuQ09SUiA9IDE7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGF0aW9ucyBvZiB0aGlzIGNsYXNzIGNhbiwgZ2l2ZW4gbG9jYXRpb25zIG9mIGZpbmRlciBwYXR0ZXJucyBmb3IgYSBRUiBjb2RlIGluIGFuXG4gICAgICogaW1hZ2UsIHNhbXBsZSB0aGUgcmlnaHQgcG9pbnRzIGluIHRoZSBpbWFnZSB0byByZWNvbnN0cnVjdCB0aGUgUVIgY29kZSwgYWNjb3VudGluZyBmb3JcbiAgICAgKiBwZXJzcGVjdGl2ZSBkaXN0b3J0aW9uLiBJdCBpcyBhYnN0cmFjdGVkIHNpbmNlIGl0IGlzIHJlbGF0aXZlbHkgZXhwZW5zaXZlIGFuZCBzaG91bGQgYmUgYWxsb3dlZFxuICAgICAqIHRvIHRha2UgYWR2YW50YWdlIG9mIHBsYXRmb3JtLXNwZWNpZmljIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbnMsIGxpa2UgU3VuJ3MgSmF2YSBBZHZhbmNlZFxuICAgICAqIEltYWdpbmcgbGlicmFyeSwgYnV0IHdoaWNoIG1heSBub3QgYmUgYXZhaWxhYmxlIGluIG90aGVyIGVudmlyb25tZW50cyBzdWNoIGFzIEoyTUUsIGFuZCB2aWNlXG4gICAgICogdmVyc2EuXG4gICAgICpcbiAgICAgKiBUaGUgaW1wbGVtZW50YXRpb24gdXNlZCBjYW4gYmUgY29udHJvbGxlZCBieSBjYWxsaW5nIHtAbGluayAjc2V0R3JpZFNhbXBsZXIoR3JpZFNhbXBsZXIpfVxuICAgICAqIHdpdGggYW4gaW5zdGFuY2Ugb2YgYSBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIHRoaXMgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBHcmlkU2FtcGxlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5DaGVja3MgYSBzZXQgb2YgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIHRyYW5zZm9ybWVkIHRvIHNhbXBsZSBwb2ludHMgb24gYW4gaW1hZ2UgYWdhaW5zdFxuICAgICAgICAgKiB0aGUgaW1hZ2UncyBkaW1lbnNpb25zIHRvIHNlZSBpZiB0aGUgcG9pbnQgYXJlIGV2ZW4gd2l0aGluIHRoZSBpbWFnZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlRoaXMgbWV0aG9kIHdpbGwgYWN0dWFsbHkgXCJudWRnZVwiIHRoZSBlbmRwb2ludHMgYmFjayBvbnRvIHRoZSBpbWFnZSBpZiB0aGV5IGFyZSBmb3VuZCB0byBiZVxuICAgICAgICAgKiBiYXJlbHkgKGxlc3MgdGhhbiAxIHBpeGVsKSBvZmYgdGhlIGltYWdlLiBUaGlzIGFjY291bnRzIGZvciBpbXBlcmZlY3QgZGV0ZWN0aW9uIG9mIGZpbmRlclxuICAgICAgICAgKiBwYXR0ZXJucyBpbiBhbiBpbWFnZSB3aGVyZSB0aGUgUVIgQ29kZSBydW5zIGFsbCB0aGUgd2F5IHRvIHRoZSBpbWFnZSBib3JkZXIuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5Gb3IgZWZmaWNpZW5jeSwgdGhlIG1ldGhvZCB3aWxsIGNoZWNrIHBvaW50cyBmcm9tIGVpdGhlciBlbmQgb2YgdGhlIGxpbmUgdW50aWwgb25lIGlzIGZvdW5kXG4gICAgICAgICAqIHRvIGJlIHdpdGhpbiB0aGUgaW1hZ2UuIEJlY2F1c2UgdGhlIHNldCBvZiBwb2ludHMgYXJlIGFzc3VtZWQgdG8gYmUgbGluZWFyLCB0aGlzIGlzIHZhbGlkLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltYWdlIGltYWdlIGludG8gd2hpY2ggdGhlIHBvaW50cyBzaG91bGQgbWFwXG4gICAgICAgICAqIEBwYXJhbSBwb2ludHMgYWN0dWFsIHBvaW50cyBpbiB4MSx5MSwuLi4seG4seW4gZm9ybVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGFuIGVuZHBvaW50IGlzIGxpZXMgb3V0c2lkZSB0aGUgaW1hZ2UgYm91bmRhcmllc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNoZWNrQW5kTnVkZ2VQb2ludHMoaW1hZ2UsIHBvaW50cykge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICAvLyBDaGVjayBhbmQgbnVkZ2UgcG9pbnRzIGZyb20gc3RhcnQgdW50aWwgd2Ugc2VlIHNvbWUgdGhhdCBhcmUgT0s6XG4gICAgICAgICAgICBsZXQgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IHBvaW50cy5sZW5ndGggJiYgbnVkZ2VkOyBvZmZzZXQgKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKHBvaW50c1tvZmZzZXRdKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihwb2ludHNbb2Zmc2V0ICsgMV0pO1xuICAgICAgICAgICAgICAgIGlmICh4IDwgLTEgfHwgeCA+IHdpZHRoIHx8IHkgPCAtMSB8fCB5ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudWRnZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldF0gPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHggPT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXRdID0gd2lkdGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldCArIDFdID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5ID09PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldCArIDFdID0gaGVpZ2h0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBhbmQgbnVkZ2UgcG9pbnRzIGZyb20gZW5kOlxuICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IG9mZnNldCA9IHBvaW50cy5sZW5ndGggLSAyOyBvZmZzZXQgPj0gMCAmJiBudWRnZWQ7IG9mZnNldCAtPSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGguZmxvb3IocG9pbnRzW29mZnNldF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLmZsb29yKHBvaW50c1tvZmZzZXQgKyAxXSk7XG4gICAgICAgICAgICAgICAgaWYgKHggPCAtMSB8fCB4ID4gd2lkdGggfHwgeSA8IC0xIHx8IHkgPiBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG51ZGdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0XSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeCA9PT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldF0gPSB3aWR0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh5ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0ICsgMV0gPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHkgPT09IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0ICsgMV0gPSBoZWlnaHQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24geyovXG4gICAgLyoqXG4gICAgICogPHA+VGhpcyBjbGFzcyBpbXBsZW1lbnRzIGEgcGVyc3BlY3RpdmUgdHJhbnNmb3JtIGluIHR3byBkaW1lbnNpb25zLiBHaXZlbiBmb3VyIHNvdXJjZSBhbmQgZm91clxuICAgICAqIGRlc3RpbmF0aW9uIHBvaW50cywgaXQgd2lsbCBjb21wdXRlIHRoZSB0cmFuc2Zvcm1hdGlvbiBpbXBsaWVkIGJldHdlZW4gdGhlbS4gVGhlIGNvZGUgaXMgYmFzZWRcbiAgICAgKiBkaXJlY3RseSB1cG9uIHNlY3Rpb24gMy40LjIgb2YgR2VvcmdlIFdvbGJlcmcncyBcIkRpZ2l0YWwgSW1hZ2UgV2FycGluZ1wiOyBzZWUgcGFnZXMgNTQtNTYuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBQZXJzcGVjdGl2ZVRyYW5zZm9ybSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGExMSAvKmZsb2F0Ki8sIGEyMSAvKmZsb2F0Ki8sIGEzMSAvKmZsb2F0Ki8sIGExMiAvKmZsb2F0Ki8sIGEyMiAvKmZsb2F0Ki8sIGEzMiAvKmZsb2F0Ki8sIGExMyAvKmZsb2F0Ki8sIGEyMyAvKmZsb2F0Ki8sIGEzMyAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuYTExID0gYTExO1xuICAgICAgICAgICAgdGhpcy5hMjEgPSBhMjE7XG4gICAgICAgICAgICB0aGlzLmEzMSA9IGEzMTtcbiAgICAgICAgICAgIHRoaXMuYTEyID0gYTEyO1xuICAgICAgICAgICAgdGhpcy5hMjIgPSBhMjI7XG4gICAgICAgICAgICB0aGlzLmEzMiA9IGEzMjtcbiAgICAgICAgICAgIHRoaXMuYTEzID0gYTEzO1xuICAgICAgICAgICAgdGhpcy5hMjMgPSBhMjM7XG4gICAgICAgICAgICB0aGlzLmEzMyA9IGEzMztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcXVhZHJpbGF0ZXJhbFRvUXVhZHJpbGF0ZXJhbCh4MCAvKmZsb2F0Ki8sIHkwIC8qZmxvYXQqLywgeDEgLypmbG9hdCovLCB5MSAvKmZsb2F0Ki8sIHgyIC8qZmxvYXQqLywgeTIgLypmbG9hdCovLCB4MyAvKmZsb2F0Ki8sIHkzIC8qZmxvYXQqLywgeDBwIC8qZmxvYXQqLywgeTBwIC8qZmxvYXQqLywgeDFwIC8qZmxvYXQqLywgeTFwIC8qZmxvYXQqLywgeDJwIC8qZmxvYXQqLywgeTJwIC8qZmxvYXQqLywgeDNwIC8qZmxvYXQqLywgeTNwIC8qZmxvYXQqLykge1xuICAgICAgICAgICAgY29uc3QgcVRvUyA9IFBlcnNwZWN0aXZlVHJhbnNmb3JtLnF1YWRyaWxhdGVyYWxUb1NxdWFyZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICAgICAgY29uc3Qgc1RvUSA9IFBlcnNwZWN0aXZlVHJhbnNmb3JtLnNxdWFyZVRvUXVhZHJpbGF0ZXJhbCh4MHAsIHkwcCwgeDFwLCB5MXAsIHgycCwgeTJwLCB4M3AsIHkzcCk7XG4gICAgICAgICAgICByZXR1cm4gc1RvUS50aW1lcyhxVG9TKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2Zvcm1Qb2ludHMocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBtYXggPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYTExID0gdGhpcy5hMTE7XG4gICAgICAgICAgICBjb25zdCBhMTIgPSB0aGlzLmExMjtcbiAgICAgICAgICAgIGNvbnN0IGExMyA9IHRoaXMuYTEzO1xuICAgICAgICAgICAgY29uc3QgYTIxID0gdGhpcy5hMjE7XG4gICAgICAgICAgICBjb25zdCBhMjIgPSB0aGlzLmEyMjtcbiAgICAgICAgICAgIGNvbnN0IGEyMyA9IHRoaXMuYTIzO1xuICAgICAgICAgICAgY29uc3QgYTMxID0gdGhpcy5hMzE7XG4gICAgICAgICAgICBjb25zdCBhMzIgPSB0aGlzLmEzMjtcbiAgICAgICAgICAgIGNvbnN0IGEzMyA9IHRoaXMuYTMzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBwb2ludHNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVub21pbmF0b3IgPSBhMTMgKiB4ICsgYTIzICogeSArIGEzMztcbiAgICAgICAgICAgICAgICBwb2ludHNbaV0gPSAoYTExICogeCArIGEyMSAqIHkgKyBhMzEpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IChhMTIgKiB4ICsgYTIyICogeSArIGEzMikgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmFuc2Zvcm1Qb2ludHNXaXRoVmFsdWVzKHhWYWx1ZXMsIHlWYWx1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGExMSA9IHRoaXMuYTExO1xuICAgICAgICAgICAgY29uc3QgYTEyID0gdGhpcy5hMTI7XG4gICAgICAgICAgICBjb25zdCBhMTMgPSB0aGlzLmExMztcbiAgICAgICAgICAgIGNvbnN0IGEyMSA9IHRoaXMuYTIxO1xuICAgICAgICAgICAgY29uc3QgYTIyID0gdGhpcy5hMjI7XG4gICAgICAgICAgICBjb25zdCBhMjMgPSB0aGlzLmEyMztcbiAgICAgICAgICAgIGNvbnN0IGEzMSA9IHRoaXMuYTMxO1xuICAgICAgICAgICAgY29uc3QgYTMyID0gdGhpcy5hMzI7XG4gICAgICAgICAgICBjb25zdCBhMzMgPSB0aGlzLmEzMztcbiAgICAgICAgICAgIGNvbnN0IG4gPSB4VmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHhWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHlWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVub21pbmF0b3IgPSBhMTMgKiB4ICsgYTIzICogeSArIGEzMztcbiAgICAgICAgICAgICAgICB4VmFsdWVzW2ldID0gKGExMSAqIHggKyBhMjEgKiB5ICsgYTMxKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgICAgIHlWYWx1ZXNbaV0gPSAoYTEyICogeCArIGEyMiAqIHkgKyBhMzIpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHNxdWFyZVRvUXVhZHJpbGF0ZXJhbCh4MCAvKmZsb2F0Ki8sIHkwIC8qZmxvYXQqLywgeDEgLypmbG9hdCovLCB5MSAvKmZsb2F0Ki8sIHgyIC8qZmxvYXQqLywgeTIgLypmbG9hdCovLCB4MyAvKmZsb2F0Ki8sIHkzIC8qZmxvYXQqLykge1xuICAgICAgICAgICAgY29uc3QgZHgzID0geDAgLSB4MSArIHgyIC0geDM7XG4gICAgICAgICAgICBjb25zdCBkeTMgPSB5MCAtIHkxICsgeTIgLSB5MztcbiAgICAgICAgICAgIGlmIChkeDMgPT09IDAuMCAmJiBkeTMgPT09IDAuMCkge1xuICAgICAgICAgICAgICAgIC8vIEFmZmluZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVUcmFuc2Zvcm0oeDEgLSB4MCwgeDIgLSB4MSwgeDAsIHkxIC0geTAsIHkyIC0geTEsIHkwLCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR4MSA9IHgxIC0geDI7XG4gICAgICAgICAgICAgICAgY29uc3QgZHgyID0geDMgLSB4MjtcbiAgICAgICAgICAgICAgICBjb25zdCBkeTEgPSB5MSAtIHkyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR5MiA9IHkzIC0geTI7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVub21pbmF0b3IgPSBkeDEgKiBkeTIgLSBkeDIgKiBkeTE7XG4gICAgICAgICAgICAgICAgY29uc3QgYTEzID0gKGR4MyAqIGR5MiAtIGR4MiAqIGR5MykgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBhMjMgPSAoZHgxICogZHkzIC0gZHgzICogZHkxKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVUcmFuc2Zvcm0oeDEgLSB4MCArIGExMyAqIHgxLCB4MyAtIHgwICsgYTIzICogeDMsIHgwLCB5MSAtIHkwICsgYTEzICogeTEsIHkzIC0geTAgKyBhMjMgKiB5MywgeTAsIGExMywgYTIzLCAxLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBxdWFkcmlsYXRlcmFsVG9TcXVhcmUoeDAgLypmbG9hdCovLCB5MCAvKmZsb2F0Ki8sIHgxIC8qZmxvYXQqLywgeTEgLypmbG9hdCovLCB4MiAvKmZsb2F0Ki8sIHkyIC8qZmxvYXQqLywgeDMgLypmbG9hdCovLCB5MyAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIC8vIEhlcmUsIHRoZSBhZGpvaW50IHNlcnZlcyBhcyB0aGUgaW52ZXJzZTpcbiAgICAgICAgICAgIHJldHVybiBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5zcXVhcmVUb1F1YWRyaWxhdGVyYWwoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKS5idWlsZEFkam9pbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZEFkam9pbnQoKSB7XG4gICAgICAgICAgICAvLyBBZGpvaW50IGlzIHRoZSB0cmFuc3Bvc2Ugb2YgdGhlIGNvZmFjdG9yIG1hdHJpeDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVUcmFuc2Zvcm0odGhpcy5hMjIgKiB0aGlzLmEzMyAtIHRoaXMuYTIzICogdGhpcy5hMzIsIHRoaXMuYTIzICogdGhpcy5hMzEgLSB0aGlzLmEyMSAqIHRoaXMuYTMzLCB0aGlzLmEyMSAqIHRoaXMuYTMyIC0gdGhpcy5hMjIgKiB0aGlzLmEzMSwgdGhpcy5hMTMgKiB0aGlzLmEzMiAtIHRoaXMuYTEyICogdGhpcy5hMzMsIHRoaXMuYTExICogdGhpcy5hMzMgLSB0aGlzLmExMyAqIHRoaXMuYTMxLCB0aGlzLmExMiAqIHRoaXMuYTMxIC0gdGhpcy5hMTEgKiB0aGlzLmEzMiwgdGhpcy5hMTIgKiB0aGlzLmEyMyAtIHRoaXMuYTEzICogdGhpcy5hMjIsIHRoaXMuYTEzICogdGhpcy5hMjEgLSB0aGlzLmExMSAqIHRoaXMuYTIzLCB0aGlzLmExMSAqIHRoaXMuYTIyIC0gdGhpcy5hMTIgKiB0aGlzLmEyMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZXMob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVUcmFuc2Zvcm0odGhpcy5hMTEgKiBvdGhlci5hMTEgKyB0aGlzLmEyMSAqIG90aGVyLmExMiArIHRoaXMuYTMxICogb3RoZXIuYTEzLCB0aGlzLmExMSAqIG90aGVyLmEyMSArIHRoaXMuYTIxICogb3RoZXIuYTIyICsgdGhpcy5hMzEgKiBvdGhlci5hMjMsIHRoaXMuYTExICogb3RoZXIuYTMxICsgdGhpcy5hMjEgKiBvdGhlci5hMzIgKyB0aGlzLmEzMSAqIG90aGVyLmEzMywgdGhpcy5hMTIgKiBvdGhlci5hMTEgKyB0aGlzLmEyMiAqIG90aGVyLmExMiArIHRoaXMuYTMyICogb3RoZXIuYTEzLCB0aGlzLmExMiAqIG90aGVyLmEyMSArIHRoaXMuYTIyICogb3RoZXIuYTIyICsgdGhpcy5hMzIgKiBvdGhlci5hMjMsIHRoaXMuYTEyICogb3RoZXIuYTMxICsgdGhpcy5hMjIgKiBvdGhlci5hMzIgKyB0aGlzLmEzMiAqIG90aGVyLmEzMywgdGhpcy5hMTMgKiBvdGhlci5hMTEgKyB0aGlzLmEyMyAqIG90aGVyLmExMiArIHRoaXMuYTMzICogb3RoZXIuYTEzLCB0aGlzLmExMyAqIG90aGVyLmEyMSArIHRoaXMuYTIzICogb3RoZXIuYTIyICsgdGhpcy5hMzMgKiBvdGhlci5hMjMsIHRoaXMuYTEzICogb3RoZXIuYTMxICsgdGhpcy5hMjMgKiBvdGhlci5hMzIgKyB0aGlzLmEzMyAqIG90aGVyLmEzMyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGVmYXVsdEdyaWRTYW1wbGVyIGV4dGVuZHMgR3JpZFNhbXBsZXIge1xuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHNhbXBsZUdyaWQoaW1hZ2UsIGRpbWVuc2lvblggLyppbnQqLywgZGltZW5zaW9uWSAvKmludCovLCBwMVRvWCAvKmZsb2F0Ki8sIHAxVG9ZIC8qZmxvYXQqLywgcDJUb1ggLypmbG9hdCovLCBwMlRvWSAvKmZsb2F0Ki8sIHAzVG9YIC8qZmxvYXQqLywgcDNUb1kgLypmbG9hdCovLCBwNFRvWCAvKmZsb2F0Ki8sIHA0VG9ZIC8qZmxvYXQqLywgcDFGcm9tWCAvKmZsb2F0Ki8sIHAxRnJvbVkgLypmbG9hdCovLCBwMkZyb21YIC8qZmxvYXQqLywgcDJGcm9tWSAvKmZsb2F0Ki8sIHAzRnJvbVggLypmbG9hdCovLCBwM0Zyb21ZIC8qZmxvYXQqLywgcDRGcm9tWCAvKmZsb2F0Ki8sIHA0RnJvbVkgLypmbG9hdCovKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5xdWFkcmlsYXRlcmFsVG9RdWFkcmlsYXRlcmFsKHAxVG9YLCBwMVRvWSwgcDJUb1gsIHAyVG9ZLCBwM1RvWCwgcDNUb1ksIHA0VG9YLCBwNFRvWSwgcDFGcm9tWCwgcDFGcm9tWSwgcDJGcm9tWCwgcDJGcm9tWSwgcDNGcm9tWCwgcDNGcm9tWSwgcDRGcm9tWCwgcDRGcm9tWSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zYW1wbGVHcmlkV2l0aFRyYW5zZm9ybShpbWFnZSwgZGltZW5zaW9uWCwgZGltZW5zaW9uWSwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHNhbXBsZUdyaWRXaXRoVHJhbnNmb3JtKGltYWdlLCBkaW1lbnNpb25YIC8qaW50Ki8sIGRpbWVuc2lvblkgLyppbnQqLywgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uWCA8PSAwIHx8IGRpbWVuc2lvblkgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYml0cyA9IG5ldyBCaXRNYXRyaXgoZGltZW5zaW9uWCwgZGltZW5zaW9uWSk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KDIgKiBkaW1lbnNpb25YKTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgZGltZW5zaW9uWTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4ID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBpVmFsdWUgPSB5ICsgMC41O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbWF4OyB4ICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW3hdID0gKHggLyAyKSArIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW3ggKyAxXSA9IGlWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLnRyYW5zZm9ybVBvaW50cyhwb2ludHMpO1xuICAgICAgICAgICAgICAgIC8vIFF1aWNrIGNoZWNrIHRvIHNlZSBpZiBwb2ludHMgdHJhbnNmb3JtZWQgdG8gc29tZXRoaW5nIGluc2lkZSB0aGUgaW1hZ2VcbiAgICAgICAgICAgICAgICAvLyBzdWZmaWNpZW50IHRvIGNoZWNrIHRoZSBlbmRwb2ludHNcbiAgICAgICAgICAgICAgICBHcmlkU2FtcGxlci5jaGVja0FuZE51ZGdlUG9pbnRzKGltYWdlLCBwb2ludHMpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbWF4OyB4ICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoTWF0aC5mbG9vcihwb2ludHNbeF0pLCBNYXRoLmZsb29yKHBvaW50c1t4ICsgMV0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrKC1pc2gpIHBpeGVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0cy5zZXQoeCAvIDIsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChhaW9vYmUgLyo6IEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZmVlbHMgd3JvbmcsIGJ1dCwgc29tZXRpbWVzIGlmIHRoZSBmaW5kZXIgcGF0dGVybnMgYXJlIG1pc2lkZW50aWZpZWQsIHRoZSByZXN1bHRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtIGdldHMgXCJ0d2lzdGVkXCIgc3VjaCB0aGF0IGl0IG1hcHMgYSBzdHJhaWdodCBsaW5lIG9mIHBvaW50cyB0byBhIHNldCBvZiBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hvc2UgZW5kcG9pbnRzIGFyZSBpbiBib3VuZHMsIGJ1dCBvdGhlcnMgYXJlIG5vdC4gVGhlcmUgaXMgcHJvYmFibHkgc29tZSBtYXRoZW1hdGljYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2F5IHRvIGRldGVjdCB0aGlzIGFib3V0IHRoZSB0cmFuc2Zvcm1hdGlvbiB0aGF0IEkgZG9uJ3Qga25vdyB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVzdWx0cyBpbiBhbiB1Z2x5IHJ1bnRpbWUgZXhjZXB0aW9uIGRlc3BpdGUgb3VyIGNsZXZlciBjaGVja3MgYWJvdmUgLS0gY2FuJ3QgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0LiBXZSBjb3VsZCBjaGVjayBlYWNoIHBvaW50J3MgY29vcmRpbmF0ZXMgYnV0IHRoYXQgZmVlbHMgZHVwbGljYXRpdmUuIFdlIHNldHRsZSBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gY2F0Y2hpbmcgYW5kIHdyYXBwaW5nIEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBHcmlkU2FtcGxlckluc3RhbmNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGltcGxlbWVudGF0aW9uIG9mIEdyaWRTYW1wbGVyIHVzZWQgYnkgdGhlIGxpYnJhcnkuIE9uZSBnbG9iYWxcbiAgICAgICAgICogaW5zdGFuY2UgaXMgc3RvcmVkLCB3aGljaCBtYXkgc291bmQgcHJvYmxlbWF0aWMuIEJ1dCwgdGhlIGltcGxlbWVudGF0aW9uIHByb3ZpZGVkXG4gICAgICAgICAqIG91Z2h0IHRvIGJlIGFwcHJvcHJpYXRlIGZvciB0aGUgZW50aXJlIHBsYXRmb3JtLCBhbmQgYWxsIHVzZXMgb2YgdGhpcyBsaWJyYXJ5XG4gICAgICAgICAqIGluIHRoZSB3aG9sZSBsaWZldGltZSBvZiB0aGUgSlZNLiBGb3IgaW5zdGFuY2UsIGFuIEFuZHJvaWQgYWN0aXZpdHkgY2FuIHN3YXAgaW5cbiAgICAgICAgICogYW4gaW1wbGVtZW50YXRpb24gdGhhdCB0YWtlcyBhZHZhbnRhZ2Ugb2YgbmF0aXZlIHBsYXRmb3JtIGxpYnJhcmllcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG5ld0dyaWRTYW1wbGVyIFRoZSBwbGF0Zm9ybS1zcGVjaWZpYyBvYmplY3QgdG8gaW5zdGFsbC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBzZXRHcmlkU2FtcGxlcihuZXdHcmlkU2FtcGxlcikge1xuICAgICAgICAgICAgR3JpZFNhbXBsZXJJbnN0YW5jZS5ncmlkU2FtcGxlciA9IG5ld0dyaWRTYW1wbGVyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIEdyaWRTYW1wbGVyXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gR3JpZFNhbXBsZXJJbnN0YW5jZS5ncmlkU2FtcGxlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBHcmlkU2FtcGxlckluc3RhbmNlLmdyaWRTYW1wbGVyID0gbmV3IERlZmF1bHRHcmlkU2FtcGxlcigpO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMCBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIHRvUmVzdWx0UG9pbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdFBvaW50KHRoaXMuZ2V0WCgpLCB0aGlzLmdldFkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0WCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0WSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jYXBzdWxhdGVzIGxvZ2ljIHRoYXQgY2FuIGRldGVjdCBhbiBBenRlYyBDb2RlIGluIGFuIGltYWdlLCBldmVuIGlmIHRoZSBBenRlYyBDb2RlXG4gICAgICogaXMgcm90YXRlZCBvciBza2V3ZWQsIG9yIHBhcnRpYWxseSBvYnNjdXJlZC5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgRGF2aWQgT2xpdmllclxuICAgICAqIEBhdXRob3IgRnJhbmsgWWVsbGluXG4gICAgICovXG4gICAgY2xhc3MgRGV0ZWN0b3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihpbWFnZSkge1xuICAgICAgICAgICAgdGhpcy5FWFBFQ1RFRF9DT1JORVJfQklUUyA9IG5ldyBJbnQzMkFycmF5KFtcbiAgICAgICAgICAgICAgICAweGVlMCxcbiAgICAgICAgICAgICAgICAweDFkYyxcbiAgICAgICAgICAgICAgICAweDgzYixcbiAgICAgICAgICAgICAgICAweDcwNyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICB9XG4gICAgICAgIGRldGVjdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRldGVjdE1pcnJvcihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVjdHMgYW4gQXp0ZWMgQ29kZSBpbiBhbiBpbWFnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGlzTWlycm9yIGlmIHRydWUsIGltYWdlIGlzIGEgbWlycm9yLWltYWdlIG9mIG9yaWdpbmFsXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIEF6dGVjRGV0ZWN0b3JSZXN1bHR9IGVuY2Fwc3VsYXRpbmcgcmVzdWx0cyBvZiBkZXRlY3RpbmcgYW4gQXp0ZWMgQ29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIG5vIEF6dGVjIENvZGUgY2FuIGJlIGZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICBkZXRlY3RNaXJyb3IoaXNNaXJyb3IpIHtcbiAgICAgICAgICAgIC8vIDEuIEdldCB0aGUgY2VudGVyIG9mIHRoZSBhenRlYyBtYXRyaXhcbiAgICAgICAgICAgIGxldCBwQ2VudGVyID0gdGhpcy5nZXRNYXRyaXhDZW50ZXIoKTtcbiAgICAgICAgICAgIC8vIDIuIEdldCB0aGUgY2VudGVyIHBvaW50cyBvZiB0aGUgZm91ciBkaWFnb25hbCBwb2ludHMganVzdCBvdXRzaWRlIHRoZSBidWxsJ3MgZXllXG4gICAgICAgICAgICAvLyAgW3RvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdCwgdG9wTGVmdF1cbiAgICAgICAgICAgIGxldCBidWxsc0V5ZUNvcm5lcnMgPSB0aGlzLmdldEJ1bGxzRXllQ29ybmVycyhwQ2VudGVyKTtcbiAgICAgICAgICAgIGlmIChpc01pcnJvcikge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gYnVsbHNFeWVDb3JuZXJzWzBdO1xuICAgICAgICAgICAgICAgIGJ1bGxzRXllQ29ybmVyc1swXSA9IGJ1bGxzRXllQ29ybmVyc1syXTtcbiAgICAgICAgICAgICAgICBidWxsc0V5ZUNvcm5lcnNbMl0gPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMy4gR2V0IHRoZSBzaXplIG9mIHRoZSBtYXRyaXggYW5kIG90aGVyIHBhcmFtZXRlcnMgZnJvbSB0aGUgYnVsbCdzIGV5ZVxuICAgICAgICAgICAgdGhpcy5leHRyYWN0UGFyYW1ldGVycyhidWxsc0V5ZUNvcm5lcnMpO1xuICAgICAgICAgICAgLy8gNC4gU2FtcGxlIHRoZSBncmlkXG4gICAgICAgICAgICBsZXQgYml0cyA9IHRoaXMuc2FtcGxlR3JpZCh0aGlzLmltYWdlLCBidWxsc0V5ZUNvcm5lcnNbdGhpcy5zaGlmdCAlIDRdLCBidWxsc0V5ZUNvcm5lcnNbKHRoaXMuc2hpZnQgKyAxKSAlIDRdLCBidWxsc0V5ZUNvcm5lcnNbKHRoaXMuc2hpZnQgKyAyKSAlIDRdLCBidWxsc0V5ZUNvcm5lcnNbKHRoaXMuc2hpZnQgKyAzKSAlIDRdKTtcbiAgICAgICAgICAgIC8vIDUuIEdldCB0aGUgY29ybmVycyBvZiB0aGUgbWF0cml4LlxuICAgICAgICAgICAgbGV0IGNvcm5lcnMgPSB0aGlzLmdldE1hdHJpeENvcm5lclBvaW50cyhidWxsc0V5ZUNvcm5lcnMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBenRlY0RldGVjdG9yUmVzdWx0KGJpdHMsIGNvcm5lcnMsIHRoaXMuY29tcGFjdCwgdGhpcy5uYkRhdGFCbG9ja3MsIHRoaXMubmJMYXllcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRyYWN0cyB0aGUgbnVtYmVyIG9mIGRhdGEgbGF5ZXJzIGFuZCBkYXRhIGJsb2NrcyBmcm9tIHRoZSBsYXllciBhcm91bmQgdGhlIGJ1bGwncyBleWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBidWxsc0V5ZUNvcm5lcnMgdGhlIGFycmF5IG9mIGJ1bGwncyBleWUgY29ybmVyc1xuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGluIGNhc2Ugb2YgdG9vIG1hbnkgZXJyb3JzIG9yIGludmFsaWQgcGFyYW1ldGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgZXh0cmFjdFBhcmFtZXRlcnMoYnVsbHNFeWVDb3JuZXJzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZFBvaW50KGJ1bGxzRXllQ29ybmVyc1swXSkgfHwgIXRoaXMuaXNWYWxpZFBvaW50KGJ1bGxzRXllQ29ybmVyc1sxXSkgfHxcbiAgICAgICAgICAgICAgICAhdGhpcy5pc1ZhbGlkUG9pbnQoYnVsbHNFeWVDb3JuZXJzWzJdKSB8fCAhdGhpcy5pc1ZhbGlkUG9pbnQoYnVsbHNFeWVDb3JuZXJzWzNdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IDIgKiB0aGlzLm5iQ2VudGVyTGF5ZXJzO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBiaXRzIGFyb3VuZCB0aGUgYnVsbCdzIGV5ZVxuICAgICAgICAgICAgbGV0IHNpZGVzID0gbmV3IEludDMyQXJyYXkoW1xuICAgICAgICAgICAgICAgIHRoaXMuc2FtcGxlTGluZShidWxsc0V5ZUNvcm5lcnNbMF0sIGJ1bGxzRXllQ29ybmVyc1sxXSwgbGVuZ3RoKSxcbiAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZUxpbmUoYnVsbHNFeWVDb3JuZXJzWzFdLCBidWxsc0V5ZUNvcm5lcnNbMl0sIGxlbmd0aCksXG4gICAgICAgICAgICAgICAgdGhpcy5zYW1wbGVMaW5lKGJ1bGxzRXllQ29ybmVyc1syXSwgYnVsbHNFeWVDb3JuZXJzWzNdLCBsZW5ndGgpLFxuICAgICAgICAgICAgICAgIHRoaXMuc2FtcGxlTGluZShidWxsc0V5ZUNvcm5lcnNbM10sIGJ1bGxzRXllQ29ybmVyc1swXSwgbGVuZ3RoKSAvLyBUb3BcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gYnVsbHNFeWVDb3JuZXJzW3NoaWZ0XSBpcyB0aGUgY29ybmVyIG9mIHRoZSBidWxscydleWUgdGhhdCBoYXMgdGhyZWVcbiAgICAgICAgICAgIC8vIG9yaWVudGF0aW9uIG1hcmtzLlxuICAgICAgICAgICAgLy8gc2lkZXNbc2hpZnRdIGlzIHRoZSByb3cvY29sdW1uIHRoYXQgZ29lcyBmcm9tIHRoZSBjb3JuZXIgd2l0aCB0aHJlZVxuICAgICAgICAgICAgLy8gb3JpZW50YXRpb24gbWFya3MgdG8gdGhlIGNvcm5lciB3aXRoIHR3by5cbiAgICAgICAgICAgIHRoaXMuc2hpZnQgPSB0aGlzLmdldFJvdGF0aW9uKHNpZGVzLCBsZW5ndGgpO1xuICAgICAgICAgICAgLy8gRmxhdHRlbiB0aGUgcGFyYW1ldGVyIGJpdHMgaW50byBhIHNpbmdsZSAyOC0gb3IgNDAtYml0IGxvbmdcbiAgICAgICAgICAgIGxldCBwYXJhbWV0ZXJEYXRhID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNpZGUgPSBzaWRlc1sodGhpcy5zaGlmdCArIGkpICUgNF07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFjdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIHNpZGUgb2YgdGhlIGZvcm0gLi5YWFhYWFhYLiB3aGVyZSBYcyBhcmUgcGFyYW1ldGVyIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyRGF0YSA8PD0gNztcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyRGF0YSArPSAoc2lkZSA+PiAxKSAmIDB4N0Y7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIHNpZGUgb2YgdGhlIGZvcm0gLi5YWFhYWC5YWFhYWC4gd2hlcmUgWHMgYXJlIHBhcmFtZXRlciBkYXRhXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlckRhdGEgPDw9IDEwO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJEYXRhICs9ICgoc2lkZSA+PiAyKSAmICgweDFmIDw8IDUpKSArICgoc2lkZSA+PiAxKSAmIDB4MUYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvcnJlY3RzIHBhcmFtZXRlciBkYXRhIHVzaW5nIFJTLiAgUmV0dXJucyBqdXN0IHRoZSBkYXRhIHBvcnRpb25cbiAgICAgICAgICAgIC8vIHdpdGhvdXQgdGhlIGVycm9yIGNvcnJlY3Rpb24uXG4gICAgICAgICAgICBsZXQgY29ycmVjdGVkRGF0YSA9IHRoaXMuZ2V0Q29ycmVjdGVkUGFyYW1ldGVyRGF0YShwYXJhbWV0ZXJEYXRhLCB0aGlzLmNvbXBhY3QpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIC8vIDggYml0czogIDIgYml0cyBsYXllcnMgYW5kIDYgYml0cyBkYXRhIGJsb2Nrc1xuICAgICAgICAgICAgICAgIHRoaXMubmJMYXllcnMgPSAoY29ycmVjdGVkRGF0YSA+PiA2KSArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5uYkRhdGFCbG9ja3MgPSAoY29ycmVjdGVkRGF0YSAmIDB4M0YpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDE2IGJpdHM6ICA1IGJpdHMgbGF5ZXJzIGFuZCAxMSBiaXRzIGRhdGEgYmxvY2tzXG4gICAgICAgICAgICAgICAgdGhpcy5uYkxheWVycyA9IChjb3JyZWN0ZWREYXRhID4+IDExKSArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5uYkRhdGFCbG9ja3MgPSAoY29ycmVjdGVkRGF0YSAmIDB4N0ZGKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Um90YXRpb24oc2lkZXMsIGxlbmd0aCkge1xuICAgICAgICAgICAgLy8gSW4gYSBub3JtYWwgcGF0dGVybiwgd2UgZXhwZWN0IHRvIFNlZVxuICAgICAgICAgICAgLy8gICAqKiAgICAuKiAgICAgICAgICAgICBEICAgICAgIEFcbiAgICAgICAgICAgIC8vICAgKiAgICAgICpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIC4gICAgICAqXG4gICAgICAgICAgICAvLyAgIC4uICAgIC4uICAgICAgICAgICAgIEMgICAgICAgQlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEdyYWIgdGhlIDMgYml0cyBmcm9tIGVhY2ggb2YgdGhlIHNpZGVzIHRoZSBmb3JtIHRoZSBsb2NhdG9yIHBhdHRlcm4gYW5kIGNvbmNhdGVuYXRlXG4gICAgICAgICAgICAvLyBpbnRvIGEgMTItYml0IGludGVnZXIuICBTdGFydCB3aXRoIHRoZSBiaXQgYXQgQVxuICAgICAgICAgICAgbGV0IGNvcm5lckJpdHMgPSAwO1xuICAgICAgICAgICAgc2lkZXMuZm9yRWFjaCgoc2lkZSwgaWR4LCBhcnIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBYWC4uLi4uLlggd2hlcmUgWCdzIGFyZSBvcmllbnRhdGlvbiBtYXJrc1xuICAgICAgICAgICAgICAgIGxldCB0ID0gKChzaWRlID4+IChsZW5ndGggLSAyKSkgPDwgMSkgKyAoc2lkZSAmIDEpO1xuICAgICAgICAgICAgICAgIGNvcm5lckJpdHMgPSAoY29ybmVyQml0cyA8PCAzKSArIHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGZvciAodmFyIHNpZGUgaW4gc2lkZXMpIHtcbiAgICAgICAgICAgIC8vICAgICAvLyBYWC4uLi4uLlggd2hlcmUgWCdzIGFyZSBvcmllbnRhdGlvbiBtYXJrc1xuICAgICAgICAgICAgLy8gICAgIHZhciB0ID0gKChzaWRlID4+IChsZW5ndGggLSAyKSkgPDwgMSkgKyAoc2lkZSAmIDEpO1xuICAgICAgICAgICAgLy8gICAgIGNvcm5lckJpdHMgPSAoY29ybmVyQml0cyA8PCAzKSArIHQ7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBNb3YgdGhlIGJvdHRvbSBiaXQgdG8gdGhlIHRvcCwgc28gdGhhdCB0aGUgdGhyZWUgYml0cyBvZiB0aGUgbG9jYXRvciBwYXR0ZXJuIGF0IEEgYXJlXG4gICAgICAgICAgICAvLyB0b2dldGhlci4gIGNvcm5lckJpdHMgaXMgbm93OlxuICAgICAgICAgICAgLy8gIDMgb3JpZW50YXRpb24gYml0cyBhdCBBIHx8IDMgb3JpZW50YXRpb24gYml0cyBhdCBCIHx8IC4uLiB8fCAzIG9yaWVudGF0aW9uIGJpdHMgYXQgRFxuICAgICAgICAgICAgY29ybmVyQml0cyA9ICgoY29ybmVyQml0cyAmIDEpIDw8IDExKSArIChjb3JuZXJCaXRzID4+IDEpO1xuICAgICAgICAgICAgLy8gVGhlIHJlc3VsdCBzaGlmdCBpbmRpY2F0ZXMgd2hpY2ggZWxlbWVudCBvZiBCdWxsc0V5ZUNvcm5lcnNbXSBnb2VzIGludG8gdGhlIHRvcC1sZWZ0XG4gICAgICAgICAgICAvLyBjb3JuZXIuIFNpbmNlIHRoZSBmb3VyIHJvdGF0aW9uIHZhbHVlcyBoYXZlIGEgSGFtbWluZyBkaXN0YW5jZSBvZiA4LCB3ZVxuICAgICAgICAgICAgLy8gY2FuIGVhc2lseSB0b2xlcmF0ZSB0d28gZXJyb3JzLlxuICAgICAgICAgICAgZm9yIChsZXQgc2hpZnQgPSAwOyBzaGlmdCA8IDQ7IHNoaWZ0KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoSW50ZWdlci5iaXRDb3VudChjb3JuZXJCaXRzIF4gdGhpcy5FWFBFQ1RFRF9DT1JORVJfQklUU1tzaGlmdF0pIDw9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoaWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3JyZWN0cyB0aGUgcGFyYW1ldGVyIGJpdHMgdXNpbmcgUmVlZC1Tb2xvbW9uIGFsZ29yaXRobS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtZXRlckRhdGEgcGFyYW1ldGVyIGJpdHNcbiAgICAgICAgICogQHBhcmFtIGNvbXBhY3QgdHJ1ZSBpZiB0aGlzIGlzIGEgY29tcGFjdCBBenRlYyBjb2RlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgdGhlIGFycmF5IGNvbnRhaW5zIHRvbyBtYW55IGVycm9yc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29ycmVjdGVkUGFyYW1ldGVyRGF0YShwYXJhbWV0ZXJEYXRhLCBjb21wYWN0KSB7XG4gICAgICAgICAgICBsZXQgbnVtQ29kZXdvcmRzO1xuICAgICAgICAgICAgbGV0IG51bURhdGFDb2Rld29yZHM7XG4gICAgICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIG51bUNvZGV3b3JkcyA9IDc7XG4gICAgICAgICAgICAgICAgbnVtRGF0YUNvZGV3b3JkcyA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBudW1Db2Rld29yZHMgPSAxMDtcbiAgICAgICAgICAgICAgICBudW1EYXRhQ29kZXdvcmRzID0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBudW1FQ0NvZGV3b3JkcyA9IG51bUNvZGV3b3JkcyAtIG51bURhdGFDb2Rld29yZHM7XG4gICAgICAgICAgICBsZXQgcGFyYW1ldGVyV29yZHMgPSBuZXcgSW50MzJBcnJheShudW1Db2Rld29yZHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG51bUNvZGV3b3JkcyAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyV29yZHNbaV0gPSBwYXJhbWV0ZXJEYXRhICYgMHhGO1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlckRhdGEgPj49IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByc0RlY29kZXIgPSBuZXcgUmVlZFNvbG9tb25EZWNvZGVyKEdlbmVyaWNHRi5BWlRFQ19QQVJBTSk7XG4gICAgICAgICAgICAgICAgcnNEZWNvZGVyLmRlY29kZShwYXJhbWV0ZXJXb3JkcywgbnVtRUNDb2Rld29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRvc3MgdGhlIGVycm9yIGNvcnJlY3Rpb24uICBKdXN0IHJldHVybiB0aGUgZGF0YSBhcyBhbiBpbnRlZ2VyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCA0KSArIHBhcmFtZXRlcldvcmRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZHMgdGhlIGNvcm5lcnMgb2YgYSBidWxsLWV5ZSBjZW50ZXJlZCBvbiB0aGUgcGFzc2VkIHBvaW50LlxuICAgICAgICAgKiBUaGlzIHJldHVybnMgdGhlIGNlbnRlcnMgb2YgdGhlIGRpYWdvbmFsIHBvaW50cyBqdXN0IG91dHNpZGUgdGhlIGJ1bGwncyBleWVcbiAgICAgICAgICogUmV0dXJucyBbdG9wUmlnaHQsIGJvdHRvbVJpZ2h0LCBib3R0b21MZWZ0LCB0b3BMZWZ0XVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcENlbnRlciBDZW50ZXIgcG9pbnRcbiAgICAgICAgICogQHJldHVybiBUaGUgY29ybmVycyBvZiB0aGUgYnVsbC1leWVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBJZiBubyB2YWxpZCBidWxsLWV5ZSBjYW4gYmUgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIGdldEJ1bGxzRXllQ29ybmVycyhwQ2VudGVyKSB7XG4gICAgICAgICAgICBsZXQgcGluYSA9IHBDZW50ZXI7XG4gICAgICAgICAgICBsZXQgcGluYiA9IHBDZW50ZXI7XG4gICAgICAgICAgICBsZXQgcGluYyA9IHBDZW50ZXI7XG4gICAgICAgICAgICBsZXQgcGluZCA9IHBDZW50ZXI7XG4gICAgICAgICAgICBsZXQgY29sb3IgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh0aGlzLm5iQ2VudGVyTGF5ZXJzID0gMTsgdGhpcy5uYkNlbnRlckxheWVycyA8IDk7IHRoaXMubmJDZW50ZXJMYXllcnMrKykge1xuICAgICAgICAgICAgICAgIGxldCBwb3V0YSA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQocGluYSwgY29sb3IsIDEsIC0xKTtcbiAgICAgICAgICAgICAgICBsZXQgcG91dGIgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KHBpbmIsIGNvbG9yLCAxLCAxKTtcbiAgICAgICAgICAgICAgICBsZXQgcG91dGMgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KHBpbmMsIGNvbG9yLCAtMSwgMSk7XG4gICAgICAgICAgICAgICAgbGV0IHBvdXRkID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChwaW5kLCBjb2xvciwgLTEsIC0xKTtcbiAgICAgICAgICAgICAgICAvLyBkICAgICAgYVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gYyAgICAgIGJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uYkNlbnRlckxheWVycyA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHEgPSAodGhpcy5kaXN0YW5jZVBvaW50KHBvdXRkLCBwb3V0YSkgKiB0aGlzLm5iQ2VudGVyTGF5ZXJzKSAvICh0aGlzLmRpc3RhbmNlUG9pbnQocGluZCwgcGluYSkgKiAodGhpcy5uYkNlbnRlckxheWVycyArIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHEgPCAwLjc1IHx8IHEgPiAxLjI1IHx8ICF0aGlzLmlzV2hpdGVPckJsYWNrUmVjdGFuZ2xlKHBvdXRhLCBwb3V0YiwgcG91dGMsIHBvdXRkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGluYSA9IHBvdXRhO1xuICAgICAgICAgICAgICAgIHBpbmIgPSBwb3V0YjtcbiAgICAgICAgICAgICAgICBwaW5jID0gcG91dGM7XG4gICAgICAgICAgICAgICAgcGluZCA9IHBvdXRkO1xuICAgICAgICAgICAgICAgIGNvbG9yID0gIWNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubmJDZW50ZXJMYXllcnMgIT09IDUgJiYgdGhpcy5uYkNlbnRlckxheWVycyAhPT0gNykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21wYWN0ID0gdGhpcy5uYkNlbnRlckxheWVycyA9PT0gNTtcbiAgICAgICAgICAgIC8vIEV4cGFuZCB0aGUgc3F1YXJlIGJ5IC41IHBpeGVsIGluIGVhY2ggZGlyZWN0aW9uIHNvIHRoYXQgd2UncmUgb24gdGhlIGJvcmRlclxuICAgICAgICAgICAgLy8gYmV0d2VlbiB0aGUgd2hpdGUgc3F1YXJlIGFuZCB0aGUgYmxhY2sgc3F1YXJlXG4gICAgICAgICAgICBsZXQgcGluYXggPSBuZXcgUmVzdWx0UG9pbnQocGluYS5nZXRYKCkgKyAwLjUsIHBpbmEuZ2V0WSgpIC0gMC41KTtcbiAgICAgICAgICAgIGxldCBwaW5ieCA9IG5ldyBSZXN1bHRQb2ludChwaW5iLmdldFgoKSArIDAuNSwgcGluYi5nZXRZKCkgKyAwLjUpO1xuICAgICAgICAgICAgbGV0IHBpbmN4ID0gbmV3IFJlc3VsdFBvaW50KHBpbmMuZ2V0WCgpIC0gMC41LCBwaW5jLmdldFkoKSArIDAuNSk7XG4gICAgICAgICAgICBsZXQgcGluZHggPSBuZXcgUmVzdWx0UG9pbnQocGluZC5nZXRYKCkgLSAwLjUsIHBpbmQuZ2V0WSgpIC0gMC41KTtcbiAgICAgICAgICAgIC8vIEV4cGFuZCB0aGUgc3F1YXJlIHNvIHRoYXQgaXRzIGNvcm5lcnMgYXJlIHRoZSBjZW50ZXJzIG9mIHRoZSBwb2ludHNcbiAgICAgICAgICAgIC8vIGp1c3Qgb3V0c2lkZSB0aGUgYnVsbCdzIGV5ZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZFNxdWFyZShbcGluYXgsIHBpbmJ4LCBwaW5jeCwgcGluZHhdLCAyICogdGhpcy5uYkNlbnRlckxheWVycyAtIDMsIDIgKiB0aGlzLm5iQ2VudGVyTGF5ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZHMgYSBjYW5kaWRhdGUgY2VudGVyIHBvaW50IG9mIGFuIEF6dGVjIGNvZGUgZnJvbSBhbiBpbWFnZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBjZW50ZXIgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIGdldE1hdHJpeENlbnRlcigpIHtcbiAgICAgICAgICAgIGxldCBwb2ludEE7XG4gICAgICAgICAgICBsZXQgcG9pbnRCO1xuICAgICAgICAgICAgbGV0IHBvaW50QztcbiAgICAgICAgICAgIGxldCBwb2ludEQ7XG4gICAgICAgICAgICAvLyBHZXQgYSB3aGl0ZSByZWN0YW5nbGUgdGhhdCBjYW4gYmUgdGhlIGJvcmRlciBvZiB0aGUgbWF0cml4IGluIGNlbnRlciBidWxsJ3MgZXllIG9yXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBjb3JuZXJQb2ludHMgPSBuZXcgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvcih0aGlzLmltYWdlKS5kZXRlY3QoKTtcbiAgICAgICAgICAgICAgICBwb2ludEEgPSBjb3JuZXJQb2ludHNbMF07XG4gICAgICAgICAgICAgICAgcG9pbnRCID0gY29ybmVyUG9pbnRzWzFdO1xuICAgICAgICAgICAgICAgIHBvaW50QyA9IGNvcm5lclBvaW50c1syXTtcbiAgICAgICAgICAgICAgICBwb2ludEQgPSBjb3JuZXJQb2ludHNbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZXhjZXB0aW9uIGNhbiBiZSBpbiBjYXNlIHRoZSBpbml0aWFsIHJlY3RhbmdsZSBpcyB3aGl0ZVxuICAgICAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSwgc3VyZWx5IGluIHRoZSBidWxsJ3MgZXllLCB3ZSB0cnkgdG8gZXhwYW5kIHRoZSByZWN0YW5nbGUuXG4gICAgICAgICAgICAgICAgbGV0IGN4ID0gdGhpcy5pbWFnZS5nZXRXaWR0aCgpIC8gMjtcbiAgICAgICAgICAgICAgICBsZXQgY3kgPSB0aGlzLmltYWdlLmdldEhlaWdodCgpIC8gMjtcbiAgICAgICAgICAgICAgICBwb2ludEEgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCArIDcsIGN5IC0gNyksIGZhbHNlLCAxLCAtMSkudG9SZXN1bHRQb2ludCgpO1xuICAgICAgICAgICAgICAgIHBvaW50QiA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4ICsgNywgY3kgKyA3KSwgZmFsc2UsIDEsIDEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgICAgICBwb2ludEMgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCAtIDcsIGN5ICsgNyksIGZhbHNlLCAtMSwgMSkudG9SZXN1bHRQb2ludCgpO1xuICAgICAgICAgICAgICAgIHBvaW50RCA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4IC0gNywgY3kgLSA3KSwgZmFsc2UsIC0xLCAtMSkudG9SZXN1bHRQb2ludCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY2VudGVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgICAgICAgIGxldCBjeCA9IE1hdGhVdGlscy5yb3VuZCgocG9pbnRBLmdldFgoKSArIHBvaW50RC5nZXRYKCkgKyBwb2ludEIuZ2V0WCgpICsgcG9pbnRDLmdldFgoKSkgLyA0LjApO1xuICAgICAgICAgICAgbGV0IGN5ID0gTWF0aFV0aWxzLnJvdW5kKChwb2ludEEuZ2V0WSgpICsgcG9pbnRELmdldFkoKSArIHBvaW50Qi5nZXRZKCkgKyBwb2ludEMuZ2V0WSgpKSAvIDQuMCk7XG4gICAgICAgICAgICAvLyBSZWRldGVybWluZSB0aGUgd2hpdGUgcmVjdGFuZ2xlIHN0YXJ0aW5nIGZyb20gcHJldmlvdXNseSBjb21wdXRlZCBjZW50ZXIuXG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgd2UgZW5kIHVwIHdpdGggYSB3aGl0ZSByZWN0YW5nbGUgaW4gY2VudGVyIGJ1bGwncyBleWVcbiAgICAgICAgICAgIC8vIGluIG9yZGVyIHRvIGNvbXB1dGUgYSBtb3JlIGFjY3VyYXRlIGNlbnRlci5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvcm5lclBvaW50cyA9IG5ldyBXaGl0ZVJlY3RhbmdsZURldGVjdG9yKHRoaXMuaW1hZ2UsIDE1LCBjeCwgY3kpLmRldGVjdCgpO1xuICAgICAgICAgICAgICAgIHBvaW50QSA9IGNvcm5lclBvaW50c1swXTtcbiAgICAgICAgICAgICAgICBwb2ludEIgPSBjb3JuZXJQb2ludHNbMV07XG4gICAgICAgICAgICAgICAgcG9pbnRDID0gY29ybmVyUG9pbnRzWzJdO1xuICAgICAgICAgICAgICAgIHBvaW50RCA9IGNvcm5lclBvaW50c1szXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBleGNlcHRpb24gY2FuIGJlIGluIGNhc2UgdGhlIGluaXRpYWwgcmVjdGFuZ2xlIGlzIHdoaXRlXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlIHdlIHRyeSB0byBleHBhbmQgdGhlIHJlY3RhbmdsZS5cbiAgICAgICAgICAgICAgICBwb2ludEEgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCArIDcsIGN5IC0gNyksIGZhbHNlLCAxLCAtMSkudG9SZXN1bHRQb2ludCgpO1xuICAgICAgICAgICAgICAgIHBvaW50QiA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4ICsgNywgY3kgKyA3KSwgZmFsc2UsIDEsIDEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgICAgICBwb2ludEMgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCAtIDcsIGN5ICsgNyksIGZhbHNlLCAtMSwgMSkudG9SZXN1bHRQb2ludCgpO1xuICAgICAgICAgICAgICAgIHBvaW50RCA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4IC0gNywgY3kgLSA3KSwgZmFsc2UsIC0xLCAtMSkudG9SZXN1bHRQb2ludCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVjb21wdXRlIHRoZSBjZW50ZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAgICAgICAgY3ggPSBNYXRoVXRpbHMucm91bmQoKHBvaW50QS5nZXRYKCkgKyBwb2ludEQuZ2V0WCgpICsgcG9pbnRCLmdldFgoKSArIHBvaW50Qy5nZXRYKCkpIC8gNC4wKTtcbiAgICAgICAgICAgIGN5ID0gTWF0aFV0aWxzLnJvdW5kKChwb2ludEEuZ2V0WSgpICsgcG9pbnRELmdldFkoKSArIHBvaW50Qi5nZXRZKCkgKyBwb2ludEMuZ2V0WSgpKSAvIDQuMCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KGN4LCBjeSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIEF6dGVjIGNvZGUgY29ybmVycyBmcm9tIHRoZSBidWxsJ3MgZXllIGNvcm5lcnMgYW5kIHRoZSBwYXJhbWV0ZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnVsbHNFeWVDb3JuZXJzIHRoZSBhcnJheSBvZiBidWxsJ3MgZXllIGNvcm5lcnNcbiAgICAgICAgICogQHJldHVybiB0aGUgYXJyYXkgb2YgYXp0ZWMgY29kZSBjb3JuZXJzXG4gICAgICAgICAqL1xuICAgICAgICBnZXRNYXRyaXhDb3JuZXJQb2ludHMoYnVsbHNFeWVDb3JuZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRTcXVhcmUoYnVsbHNFeWVDb3JuZXJzLCAyICogdGhpcy5uYkNlbnRlckxheWVycywgdGhpcy5nZXREaW1lbnNpb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBCaXRNYXRyaXggYnkgc2FtcGxpbmcgdGhlIHByb3ZpZGVkIGltYWdlLlxuICAgICAgICAgKiB0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tUmlnaHQsIGFuZCBib3R0b21MZWZ0IGFyZSB0aGUgY2VudGVycyBvZiB0aGUgc3F1YXJlcyBvbiB0aGVcbiAgICAgICAgICogZGlhZ29uYWwganVzdCBvdXRzaWRlIHRoZSBidWxsJ3MgZXllLlxuICAgICAgICAgKi9cbiAgICAgICAgc2FtcGxlR3JpZChpbWFnZSwgdG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbVJpZ2h0LCBib3R0b21MZWZ0KSB7XG4gICAgICAgICAgICBsZXQgc2FtcGxlciA9IEdyaWRTYW1wbGVySW5zdGFuY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIGxldCBkaW1lbnNpb24gPSB0aGlzLmdldERpbWVuc2lvbigpO1xuICAgICAgICAgICAgbGV0IGxvdyA9IGRpbWVuc2lvbiAvIDIgLSB0aGlzLm5iQ2VudGVyTGF5ZXJzO1xuICAgICAgICAgICAgbGV0IGhpZ2ggPSBkaW1lbnNpb24gLyAyICsgdGhpcy5uYkNlbnRlckxheWVycztcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVyLnNhbXBsZUdyaWQoaW1hZ2UsIGRpbWVuc2lvbiwgZGltZW5zaW9uLCBsb3csIGxvdywgLy8gdG9wbGVmdFxuICAgICAgICAgICAgaGlnaCwgbG93LCAvLyB0b3ByaWdodFxuICAgICAgICAgICAgaGlnaCwgaGlnaCwgLy8gYm90dG9tcmlnaHRcbiAgICAgICAgICAgIGxvdywgaGlnaCwgLy8gYm90dG9tbGVmdFxuICAgICAgICAgICAgdG9wTGVmdC5nZXRYKCksIHRvcExlZnQuZ2V0WSgpLCB0b3BSaWdodC5nZXRYKCksIHRvcFJpZ2h0LmdldFkoKSwgYm90dG9tUmlnaHQuZ2V0WCgpLCBib3R0b21SaWdodC5nZXRZKCksIGJvdHRvbUxlZnQuZ2V0WCgpLCBib3R0b21MZWZ0LmdldFkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhbXBsZXMgYSBsaW5lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcDEgICBzdGFydCBwb2ludCAoaW5jbHVzaXZlKVxuICAgICAgICAgKiBAcGFyYW0gcDIgICBlbmQgcG9pbnQgKGV4Y2x1c2l2ZSlcbiAgICAgICAgICogQHBhcmFtIHNpemUgbnVtYmVyIG9mIGJpdHNcbiAgICAgICAgICogQHJldHVybiB0aGUgYXJyYXkgb2YgYml0cyBhcyBhbiBpbnQgKGZpcnN0IGJpdCBpcyBoaWdoLW9yZGVyIGJpdCBvZiByZXN1bHQpXG4gICAgICAgICAqL1xuICAgICAgICBzYW1wbGVMaW5lKHAxLCBwMiwgc2l6ZSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXMuZGlzdGFuY2VSZXN1bHRQb2ludChwMSwgcDIpO1xuICAgICAgICAgICAgbGV0IG1vZHVsZVNpemUgPSBkIC8gc2l6ZTtcbiAgICAgICAgICAgIGxldCBweCA9IHAxLmdldFgoKTtcbiAgICAgICAgICAgIGxldCBweSA9IHAxLmdldFkoKTtcbiAgICAgICAgICAgIGxldCBkeCA9IG1vZHVsZVNpemUgKiAocDIuZ2V0WCgpIC0gcDEuZ2V0WCgpKSAvIGQ7XG4gICAgICAgICAgICBsZXQgZHkgPSBtb2R1bGVTaXplICogKHAyLmdldFkoKSAtIHAxLmdldFkoKSkgLyBkO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbWFnZS5nZXQoTWF0aFV0aWxzLnJvdW5kKHB4ICsgaSAqIGR4KSwgTWF0aFV0aWxzLnJvdW5kKHB5ICsgaSAqIGR5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0IHw9IDEgPDwgKHNpemUgLSBpIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIHRoZSBib3JkZXIgb2YgdGhlIHJlY3RhbmdsZSBwYXNzZWQgaW4gcGFyYW1ldGVyIGlzIGNvbXBvdW5kIG9mIHdoaXRlIHBvaW50cyBvbmx5XG4gICAgICAgICAqICAgICAgICAgb3IgYmxhY2sgcG9pbnRzIG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGlzV2hpdGVPckJsYWNrUmVjdGFuZ2xlKHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICBsZXQgY29yciA9IDM7XG4gICAgICAgICAgICBwMSA9IG5ldyBQb2ludChwMS5nZXRYKCkgLSBjb3JyLCBwMS5nZXRZKCkgKyBjb3JyKTtcbiAgICAgICAgICAgIHAyID0gbmV3IFBvaW50KHAyLmdldFgoKSAtIGNvcnIsIHAyLmdldFkoKSAtIGNvcnIpO1xuICAgICAgICAgICAgcDMgPSBuZXcgUG9pbnQocDMuZ2V0WCgpICsgY29yciwgcDMuZ2V0WSgpIC0gY29ycik7XG4gICAgICAgICAgICBwNCA9IG5ldyBQb2ludChwNC5nZXRYKCkgKyBjb3JyLCBwNC5nZXRZKCkgKyBjb3JyKTtcbiAgICAgICAgICAgIGxldCBjSW5pdCA9IHRoaXMuZ2V0Q29sb3IocDQsIHAxKTtcbiAgICAgICAgICAgIGlmIChjSW5pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjID0gdGhpcy5nZXRDb2xvcihwMSwgcDIpO1xuICAgICAgICAgICAgaWYgKGMgIT09IGNJbml0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyA9IHRoaXMuZ2V0Q29sb3IocDIsIHAzKTtcbiAgICAgICAgICAgIGlmIChjICE9PSBjSW5pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgPSB0aGlzLmdldENvbG9yKHAzLCBwNCk7XG4gICAgICAgICAgICByZXR1cm4gYyA9PT0gY0luaXQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGNvbG9yIG9mIGEgc2VnbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIDEgaWYgc2VnbWVudCBtb3JlIHRoYW4gOTAlIGJsYWNrLCAtMSBpZiBzZWdtZW50IGlzIG1vcmUgdGhhbiA5MCUgd2hpdGUsIDAgZWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29sb3IocDEsIHAyKSB7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXMuZGlzdGFuY2VQb2ludChwMSwgcDIpO1xuICAgICAgICAgICAgbGV0IGR4ID0gKHAyLmdldFgoKSAtIHAxLmdldFgoKSkgLyBkO1xuICAgICAgICAgICAgbGV0IGR5ID0gKHAyLmdldFkoKSAtIHAxLmdldFkoKSkgLyBkO1xuICAgICAgICAgICAgbGV0IGVycm9yID0gMDtcbiAgICAgICAgICAgIGxldCBweCA9IHAxLmdldFgoKTtcbiAgICAgICAgICAgIGxldCBweSA9IHAxLmdldFkoKTtcbiAgICAgICAgICAgIGxldCBjb2xvck1vZGVsID0gdGhpcy5pbWFnZS5nZXQocDEuZ2V0WCgpLCBwMS5nZXRZKCkpO1xuICAgICAgICAgICAgbGV0IGlNYXggPSBNYXRoLmNlaWwoZCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICAgICAgICAgIHB4ICs9IGR4O1xuICAgICAgICAgICAgICAgIHB5ICs9IGR5O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmltYWdlLmdldChNYXRoVXRpbHMucm91bmQocHgpLCBNYXRoVXRpbHMucm91bmQocHkpKSAhPT0gY29sb3JNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlcnJSYXRpbyA9IGVycm9yIC8gZDtcbiAgICAgICAgICAgIGlmIChlcnJSYXRpbyA+IDAuMSAmJiBlcnJSYXRpbyA8IDAuOSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChlcnJSYXRpbyA8PSAwLjEpID09PSBjb2xvck1vZGVsID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludCB3aXRoIGEgZGlmZmVyZW50IGNvbG9yIGluIHRoZSBnaXZlbiBkaXJlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGdldEZpcnN0RGlmZmVyZW50KGluaXQsIGNvbG9yLCBkeCwgZHkpIHtcbiAgICAgICAgICAgIGxldCB4ID0gaW5pdC5nZXRYKCkgKyBkeDtcbiAgICAgICAgICAgIGxldCB5ID0gaW5pdC5nZXRZKCkgKyBkeTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzVmFsaWQoeCwgeSkgJiYgdGhpcy5pbWFnZS5nZXQoeCwgeSkgPT09IGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgeCArPSBkeDtcbiAgICAgICAgICAgICAgICB5ICs9IGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCAtPSBkeDtcbiAgICAgICAgICAgIHkgLT0gZHk7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc1ZhbGlkKHgsIHkpICYmIHRoaXMuaW1hZ2UuZ2V0KHgsIHkpID09PSBjb2xvcikge1xuICAgICAgICAgICAgICAgIHggKz0gZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4IC09IGR4O1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNWYWxpZCh4LCB5KSAmJiB0aGlzLmltYWdlLmdldCh4LCB5KSA9PT0gY29sb3IpIHtcbiAgICAgICAgICAgICAgICB5ICs9IGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeSAtPSBkeTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cGFuZCB0aGUgc3F1YXJlIHJlcHJlc2VudGVkIGJ5IHRoZSBjb3JuZXIgcG9pbnRzIGJ5IHB1c2hpbmcgb3V0IGVxdWFsbHkgaW4gYWxsIGRpcmVjdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvcm5lclBvaW50cyB0aGUgY29ybmVycyBvZiB0aGUgc3F1YXJlLCB3aGljaCBoYXMgdGhlIGJ1bGwncyBleWUgYXQgaXRzIGNlbnRlclxuICAgICAgICAgKiBAcGFyYW0gb2xkU2lkZSB0aGUgb3JpZ2luYWwgbGVuZ3RoIG9mIHRoZSBzaWRlIG9mIHRoZSBzcXVhcmUgaW4gdGhlIHRhcmdldCBiaXQgbWF0cml4XG4gICAgICAgICAqIEBwYXJhbSBuZXdTaWRlIHRoZSBuZXcgbGVuZ3RoIG9mIHRoZSBzaXplIG9mIHRoZSBzcXVhcmUgaW4gdGhlIHRhcmdldCBiaXQgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4gdGhlIGNvcm5lcnMgb2YgdGhlIGV4cGFuZGVkIHNxdWFyZVxuICAgICAgICAgKi9cbiAgICAgICAgZXhwYW5kU3F1YXJlKGNvcm5lclBvaW50cywgb2xkU2lkZSwgbmV3U2lkZSkge1xuICAgICAgICAgICAgbGV0IHJhdGlvID0gbmV3U2lkZSAvICgyLjAgKiBvbGRTaWRlKTtcbiAgICAgICAgICAgIGxldCBkeCA9IGNvcm5lclBvaW50c1swXS5nZXRYKCkgLSBjb3JuZXJQb2ludHNbMl0uZ2V0WCgpO1xuICAgICAgICAgICAgbGV0IGR5ID0gY29ybmVyUG9pbnRzWzBdLmdldFkoKSAtIGNvcm5lclBvaW50c1syXS5nZXRZKCk7XG4gICAgICAgICAgICBsZXQgY2VudGVyeCA9IChjb3JuZXJQb2ludHNbMF0uZ2V0WCgpICsgY29ybmVyUG9pbnRzWzJdLmdldFgoKSkgLyAyLjA7XG4gICAgICAgICAgICBsZXQgY2VudGVyeSA9IChjb3JuZXJQb2ludHNbMF0uZ2V0WSgpICsgY29ybmVyUG9pbnRzWzJdLmdldFkoKSkgLyAyLjA7XG4gICAgICAgICAgICBsZXQgcmVzdWx0MCA9IG5ldyBSZXN1bHRQb2ludChjZW50ZXJ4ICsgcmF0aW8gKiBkeCwgY2VudGVyeSArIHJhdGlvICogZHkpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDIgPSBuZXcgUmVzdWx0UG9pbnQoY2VudGVyeCAtIHJhdGlvICogZHgsIGNlbnRlcnkgLSByYXRpbyAqIGR5KTtcbiAgICAgICAgICAgIGR4ID0gY29ybmVyUG9pbnRzWzFdLmdldFgoKSAtIGNvcm5lclBvaW50c1szXS5nZXRYKCk7XG4gICAgICAgICAgICBkeSA9IGNvcm5lclBvaW50c1sxXS5nZXRZKCkgLSBjb3JuZXJQb2ludHNbM10uZ2V0WSgpO1xuICAgICAgICAgICAgY2VudGVyeCA9IChjb3JuZXJQb2ludHNbMV0uZ2V0WCgpICsgY29ybmVyUG9pbnRzWzNdLmdldFgoKSkgLyAyLjA7XG4gICAgICAgICAgICBjZW50ZXJ5ID0gKGNvcm5lclBvaW50c1sxXS5nZXRZKCkgKyBjb3JuZXJQb2ludHNbM10uZ2V0WSgpKSAvIDIuMDtcbiAgICAgICAgICAgIGxldCByZXN1bHQxID0gbmV3IFJlc3VsdFBvaW50KGNlbnRlcnggKyByYXRpbyAqIGR4LCBjZW50ZXJ5ICsgcmF0aW8gKiBkeSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0MyA9IG5ldyBSZXN1bHRQb2ludChjZW50ZXJ4IC0gcmF0aW8gKiBkeCwgY2VudGVyeSAtIHJhdGlvICogZHkpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdHMgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0M107XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBpc1ZhbGlkKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB4ID49IDAgJiYgeCA8IHRoaXMuaW1hZ2UuZ2V0V2lkdGgoKSAmJiB5ID4gMCAmJiB5IDwgdGhpcy5pbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpc1ZhbGlkUG9pbnQocG9pbnQpIHtcbiAgICAgICAgICAgIGxldCB4ID0gTWF0aFV0aWxzLnJvdW5kKHBvaW50LmdldFgoKSk7XG4gICAgICAgICAgICBsZXQgeSA9IE1hdGhVdGlscy5yb3VuZChwb2ludC5nZXRZKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICBkaXN0YW5jZVBvaW50KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMuZGlzdGFuY2UoYS5nZXRYKCksIGEuZ2V0WSgpLCBiLmdldFgoKSwgYi5nZXRZKCkpO1xuICAgICAgICB9XG4gICAgICAgIGRpc3RhbmNlUmVzdWx0UG9pbnQoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5kaXN0YW5jZShhLmdldFgoKSwgYS5nZXRZKCksIGIuZ2V0WCgpLCBiLmdldFkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGltZW5zaW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA0ICogdGhpcy5uYkxheWVycyArIDExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubmJMYXllcnMgPD0gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA0ICogdGhpcy5uYkxheWVycyArIDE1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDQgKiB0aGlzLm5iTGF5ZXJzICsgMiAqIChJbnRlZ2VyLnRydW5jRGl2aXNpb24oKHRoaXMubmJMYXllcnMgLSA0KSwgOCkgKyAxKSArIDE1O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMCBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkxpc3Q7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5NYXA7XG4gICAgLyoqXG4gICAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBjYW4gZGV0ZWN0IGFuZCBkZWNvZGUgQXp0ZWMgY29kZXMgaW4gYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIERhdmlkIE9saXZpZXJcbiAgICAgKi9cbiAgICBjbGFzcyBBenRlY1JlYWRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2NhdGVzIGFuZCBkZWNvZGVzIGEgRGF0YSBNYXRyaXggY29kZSBpbiBhbiBpbWFnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBhIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIGNvbnRlbnQgZW5jb2RlZCBieSB0aGUgRGF0YSBNYXRyaXggY29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGEgRGF0YSBNYXRyaXggY29kZSBjYW5ub3QgYmUgZm91bmRcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgYSBEYXRhIE1hdHJpeCBjb2RlIGNhbm5vdCBiZSBkZWNvZGVkXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGUoaW1hZ2UsIGhpbnRzID0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGV4Y2VwdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZGV0ZWN0b3IgPSBuZXcgRGV0ZWN0b3IoaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKSk7XG4gICAgICAgICAgICBsZXQgcG9pbnRzID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBkZWNvZGVyUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGRldGVjdG9yUmVzdWx0ID0gZGV0ZWN0b3IuZGV0ZWN0TWlycm9yKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBkZXRlY3RvclJlc3VsdC5nZXRQb2ludHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEZvdW5kUmVzdWx0UG9pbnRzKGhpbnRzLCBwb2ludHMpO1xuICAgICAgICAgICAgICAgIGRlY29kZXJSZXN1bHQgPSBuZXcgRGVjb2RlcigpLmRlY29kZShkZXRlY3RvclJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjb2RlclJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRldGVjdG9yUmVzdWx0ID0gZGV0ZWN0b3IuZGV0ZWN0TWlycm9yKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBkZXRlY3RvclJlc3VsdC5nZXRQb2ludHMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRGb3VuZFJlc3VsdFBvaW50cyhoaW50cywgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlclJlc3VsdCA9IG5ldyBEZWNvZGVyKCkuZGVjb2RlKGRldGVjdG9yUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2VwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFJlc3VsdChkZWNvZGVyUmVzdWx0LmdldFRleHQoKSwgZGVjb2RlclJlc3VsdC5nZXRSYXdCeXRlcygpLCBkZWNvZGVyUmVzdWx0LmdldE51bUJpdHMoKSwgcG9pbnRzLCBCYXJjb2RlRm9ybWF0JDEuQVpURUMsIFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpKTtcbiAgICAgICAgICAgIGxldCBieXRlU2VnbWVudHMgPSBkZWNvZGVyUmVzdWx0LmdldEJ5dGVTZWdtZW50cygpO1xuICAgICAgICAgICAgaWYgKGJ5dGVTZWdtZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLkJZVEVfU0VHTUVOVFMsIGJ5dGVTZWdtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZWNMZXZlbCA9IGRlY29kZXJSZXN1bHQuZ2V0RUNMZXZlbCgpO1xuICAgICAgICAgICAgaWYgKGVjTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OX0xFVkVMLCBlY0xldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVwb3J0Rm91bmRSZXN1bHRQb2ludHMoaGludHMsIHBvaW50cykge1xuICAgICAgICAgICAgaWYgKGhpbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgcnBjYiA9IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLk5FRURfUkVTVUxUX1BPSU5UX0NBTExCQUNLKTtcbiAgICAgICAgICAgICAgICBpZiAocnBjYiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5mb3JFYWNoKChwb2ludCwgaWR4LCBhcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJwY2IuZm91bmRQb3NzaWJsZVJlc3VsdFBvaW50KHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF6dGVjIENvZGUgcmVhZGVyIHRvIHVzZSBmcm9tIGJyb3dzZXIuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQnJvd3NlckF6dGVjQ29kZVJlYWRlclxuICAgICAqIEBleHRlbmRzIHtCcm93c2VyQ29kZVJlYWRlcn1cbiAgICAgKi9cbiAgICBjbGFzcyBCcm93c2VyQXp0ZWNDb2RlUmVhZGVyIGV4dGVuZHMgQnJvd3NlckNvZGVSZWFkZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCcm93c2VyQXp0ZWNDb2RlUmVhZGVyLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVCZXR3ZWVuU2NhbnNNaWxsaXM9NTAwXSB0aGUgdGltZSBkZWxheSBiZXR3ZWVuIHN1YnNlcXVlbnQgZGVjb2RlIHRyaWVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQXp0ZWNDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcih0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwKSB7XG4gICAgICAgICAgICBzdXBlcihuZXcgQXp0ZWNSZWFkZXIoKSwgdGltZUJldHdlZW5TY2Fuc01pbGxpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNhcHN1bGF0ZXMgZnVuY3Rpb25hbGl0eSBhbmQgaW1wbGVtZW50YXRpb24gdGhhdCBpcyBjb21tb24gdG8gYWxsIGZhbWlsaWVzXG4gICAgICogb2Ygb25lLWRpbWVuc2lvbmFsIGJhcmNvZGVzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIE9uZURSZWFkZXIge1xuICAgICAgICAvKlxuICAgICAgICBAT3ZlcnJpZGVcbiAgICAgICAgcHVibGljIFJlc3VsdCBkZWNvZGUoQmluYXJ5Qml0bWFwIGltYWdlKSB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZShpbWFnZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGRvbid0IHRyeSByb3RhdGlvbiB3aXRob3V0IHRoZSB0cnkgaGFyZGVyIGZsYWcsIGV2ZW4gaWYgcm90YXRpb24gd2FzIHN1cHBvcnRlZC5cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGRlY29kZShpbWFnZSwgaGludHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9EZWNvZGUoaW1hZ2UsIGhpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChuZmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cnlIYXJkZXIgPSBoaW50cyAmJiAoaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuVFJZX0hBUkRFUikgPT09IHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIgJiYgaW1hZ2UuaXNSb3RhdGVTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3RhdGVkSW1hZ2UgPSBpbWFnZS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZG9EZWNvZGUocm90YXRlZEltYWdlLCBoaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY29yZCB0aGF0IHdlIGZvdW5kIGl0IHJvdGF0ZWQgOTAgZGVncmVlcyBDQ1cgLyAyNzAgZGVncmVlcyBDV1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHJlc3VsdC5nZXRSZXN1bHRNZXRhZGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3JpZW50YXRpb24gPSAyNzA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YSAhPT0gbnVsbCAmJiAobWV0YWRhdGEuZ2V0KFJlc3VsdE1ldGFkYXRhVHlwZSQxLk9SSUVOVEFUSU9OKSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBpZiB3ZSBmb3VuZCBpdCByZXZlcnNlZCBpbiBkb0RlY29kZSgpLCBhZGQgaW4gdGhhdCByZXN1bHQgaGVyZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uID0gKG9yaWVudGF0aW9uICsgbWV0YWRhdGEuZ2V0KFJlc3VsdE1ldGFkYXRhVHlwZSQxLk9SSUVOVEFUSU9OKSAlIDM2MCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLk9SSUVOVEFUSU9OLCBvcmllbnRhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSByZXN1bHQgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IHJlc3VsdC5nZXRSZXN1bHRQb2ludHMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gcm90YXRlZEltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbaV0gPSBuZXcgUmVzdWx0UG9pbnQoaGVpZ2h0IC0gcG9pbnRzW2ldLmdldFkoKSAtIDEsIHBvaW50c1tpXS5nZXRYKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSdyZSBnb2luZyB0byBleGFtaW5lIHJvd3MgZnJvbSB0aGUgbWlkZGxlIG91dHdhcmQsIHNlYXJjaGluZyBhbHRlcm5hdGVseSBhYm92ZSBhbmQgYmVsb3cgdGhlXG4gICAgICAgICAqIG1pZGRsZSwgYW5kIGZhcnRoZXIgb3V0IGVhY2ggdGltZS4gcm93U3RlcCBpcyB0aGUgbnVtYmVyIG9mIHJvd3MgYmV0d2VlbiBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgICAgICogYXR0ZW1wdCBhYm92ZSBhbmQgYmVsb3cgdGhlIG1pZGRsZS4gU28gd2UnZCBzY2FuIHJvdyBtaWRkbGUsIHRoZW4gbWlkZGxlIC0gcm93U3RlcCwgdGhlblxuICAgICAgICAgKiBtaWRkbGUgKyByb3dTdGVwLCB0aGVuIG1pZGRsZSAtICgyICogcm93U3RlcCksIGV0Yy5cbiAgICAgICAgICogcm93U3RlcCBpcyBiaWdnZXIgYXMgdGhlIGltYWdlIGlzIHRhbGxlciwgYnV0IGlzIGFsd2F5cyBhdCBsZWFzdCAxLiBXZSd2ZSBzb21ld2hhdCBhcmJpdHJhcmlseVxuICAgICAgICAgKiBkZWNpZGVkIHRoYXQgbW92aW5nIHVwIGFuZCBkb3duIGJ5IGFib3V0IDEvMTYgb2YgdGhlIGltYWdlIGlzIHByZXR0eSBnb29kOyB3ZSB0cnkgbW9yZSBvZiB0aGVcbiAgICAgICAgICogaW1hZ2UgaWYgXCJ0cnlpbmcgaGFyZGVyXCIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBUaGUgaW1hZ2UgdG8gZGVjb2RlXG4gICAgICAgICAqIEBwYXJhbSBoaW50cyBBbnkgaGludHMgdGhhdCB3ZXJlIHJlcXVlc3RlZFxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBjb250ZW50cyBvZiB0aGUgZGVjb2RlZCBiYXJjb2RlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gQW55IHNwb250YW5lb3VzIGVycm9ycyB3aGljaCBvY2N1clxuICAgICAgICAgKi9cbiAgICAgICAgZG9EZWNvZGUoaW1hZ2UsIGhpbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGxldCByb3cgPSBuZXcgQml0QXJyYXkod2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgdHJ5SGFyZGVyID0gaGludHMgJiYgKGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlRSWV9IQVJERVIpID09PSB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHJvd1N0ZXAgPSBNYXRoLm1heCgxLCBoZWlnaHQgPj4gKHRyeUhhcmRlciA/IDggOiA1KSk7XG4gICAgICAgICAgICBsZXQgbWF4TGluZXM7XG4gICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgbWF4TGluZXMgPSBoZWlnaHQ7IC8vIExvb2sgYXQgdGhlIHdob2xlIGltYWdlLCBub3QganVzdCB0aGUgY2VudGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXhMaW5lcyA9IDE1OyAvLyAxNSByb3dzIHNwYWNlZCAxLzMyIGFwYXJ0IGlzIHJvdWdobHkgdGhlIG1pZGRsZSBoYWxmIG9mIHRoZSBpbWFnZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWlkZGxlID0gTWF0aC50cnVuYyhoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbWF4TGluZXM7IHgrKykge1xuICAgICAgICAgICAgICAgIC8vIFNjYW5uaW5nIGZyb20gdGhlIG1pZGRsZSBvdXQuIERldGVybWluZSB3aGljaCByb3cgd2UncmUgbG9va2luZyBhdCBuZXh0OlxuICAgICAgICAgICAgICAgIGNvbnN0IHJvd1N0ZXBzQWJvdmVPckJlbG93ID0gTWF0aC50cnVuYygoeCArIDEpIC8gMik7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBYm92ZSA9ICh4ICYgMHgwMSkgPT09IDA7IC8vIGkuZS4gaXMgeCBldmVuP1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd051bWJlciA9IG1pZGRsZSArIHJvd1N0ZXAgKiAoaXNBYm92ZSA/IHJvd1N0ZXBzQWJvdmVPckJlbG93IDogLXJvd1N0ZXBzQWJvdmVPckJlbG93KTtcbiAgICAgICAgICAgICAgICBpZiAocm93TnVtYmVyIDwgMCB8fCByb3dOdW1iZXIgPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9vcHMsIGlmIHdlIHJ1biBvZmYgdGhlIHRvcCBvciBib3R0b20sIHN0b3BcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVzdGltYXRlIGJsYWNrIHBvaW50IGZvciB0aGlzIHJvdyBhbmQgbG9hZCBpdDpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBpbWFnZS5nZXRCbGFja1Jvdyhyb3dOdW1iZXIsIHJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXaGlsZSB3ZSBoYXZlIHRoZSBpbWFnZSBkYXRhIGluIGEgQml0QXJyYXksIGl0J3MgZmFpcmx5IGNoZWFwIHRvIHJldmVyc2UgaXQgaW4gcGxhY2UgdG9cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZGVjb2RpbmcgdXBzaWRlIGRvd24gYmFyY29kZXMuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCAyOyBhdHRlbXB0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPT09IDEpIHsgLy8gdHJ5aW5nIGFnYWluP1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93LnJldmVyc2UoKTsgLy8gcmV2ZXJzZSB0aGUgcm93IGFuZCBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB3ZSB3aWxsIG9ubHkgZXZlciBkcmF3IHJlc3VsdCBwb2ludHMgKm9uY2UqIGluIHRoZSBsaWZlIG9mIHRoaXMgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSB3YW50IHRvIGF2b2lkIGRyYXdpbmcgdGhlIHdyb25nIHBvaW50cyBhZnRlciBmbGlwcGluZyB0aGUgcm93LCBhbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCB3YW50IHRvIGNsdXR0ZXIgd2l0aCBub2lzZSBmcm9tIGV2ZXJ5IHNpbmdsZSByb3cgc2NhbiAtLSBqdXN0IHRoZSBzY2Fuc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBzdGFydCBvbiB0aGUgY2VudGVyIGxpbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGludHMgJiYgKGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLk5FRURfUkVTVUxUX1BPSU5UX0NBTExCQUNLKSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdIaW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaW50cy5mb3JFYWNoKChoaW50LCBrZXkpID0+IG5ld0hpbnRzLnNldChrZXksIGhpbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdIaW50cy5kZWxldGUoRGVjb2RlSGludFR5cGUkMS5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGludHMgPSBuZXdIaW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYSBiYXJjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgb3VyIGJhcmNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGl0IHdhcyB1cHNpZGUgZG93biwgc28gbm90ZSB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLk9SSUVOVEFUSU9OLCAxODApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuZCByZW1lbWJlciB0byBmbGlwIHRoZSByZXN1bHQgcG9pbnRzIGhvcml6b250YWxseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSByZXN1bHQuZ2V0UmVzdWx0UG9pbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF0gPSBuZXcgUmVzdWx0UG9pbnQod2lkdGggLSBwb2ludHNbMF0uZ2V0WCgpIC0gMSwgcG9pbnRzWzBdLmdldFkoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1sxXSA9IG5ldyBSZXN1bHRQb2ludCh3aWR0aCAtIHBvaW50c1sxXS5nZXRYKCkgLSAxLCBwb2ludHNbMV0uZ2V0WSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWUgLS0ganVzdCBjb3VsZG4ndCBkZWNvZGUgdGhpcyByb3dcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWNvcmRzIHRoZSBzaXplIG9mIHN1Y2Nlc3NpdmUgcnVucyBvZiB3aGl0ZSBhbmQgYmxhY2sgcGl4ZWxzIGluIGEgcm93LCBzdGFydGluZyBhdCBhIGdpdmVuIHBvaW50LlxuICAgICAgICAgKiBUaGUgdmFsdWVzIGFyZSByZWNvcmRlZCBpbiB0aGUgZ2l2ZW4gYXJyYXksIGFuZCB0aGUgbnVtYmVyIG9mIHJ1bnMgcmVjb3JkZWQgaXMgZXF1YWwgdG8gdGhlIHNpemVcbiAgICAgICAgICogb2YgdGhlIGFycmF5LiBJZiB0aGUgcm93IHN0YXJ0cyBvbiBhIHdoaXRlIHBpeGVsIGF0IHRoZSBnaXZlbiBzdGFydCBwb2ludCwgdGhlbiB0aGUgZmlyc3QgY291bnRcbiAgICAgICAgICogcmVjb3JkZWQgaXMgdGhlIHJ1biBvZiB3aGl0ZSBwaXhlbHMgc3RhcnRpbmcgZnJvbSB0aGF0IHBvaW50OyBsaWtld2lzZSBpdCBpcyB0aGUgY291bnQgb2YgYSBydW5cbiAgICAgICAgICogb2YgYmxhY2sgcGl4ZWxzIGlmIHRoZSByb3cgYmVnaW4gb24gYSBibGFjayBwaXhlbHMgYXQgdGhhdCBwb2ludC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvdyByb3cgdG8gY291bnQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gc3RhcnQgb2Zmc2V0IGludG8gcm93IHRvIHN0YXJ0IGF0XG4gICAgICAgICAqIEBwYXJhbSBjb3VudGVycyBhcnJheSBpbnRvIHdoaWNoIHRvIHJlY29yZCBjb3VudHNcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBjb3VudGVycyBjYW5ub3QgYmUgZmlsbGVkIGVudGlyZWx5IGZyb20gcm93IGJlZm9yZSBydW5uaW5nIG91dFxuICAgICAgICAgKiAgb2YgcGl4ZWxzXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcmVjb3JkUGF0dGVybihyb3csIHN0YXJ0LCBjb3VudGVycykge1xuICAgICAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbnVtQ291bnRlcnM7IGluZGV4KyspXG4gICAgICAgICAgICAgICAgY291bnRlcnNbaW5kZXhdID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaXNXaGl0ZSA9ICFyb3cuZ2V0KHN0YXJ0KTtcbiAgICAgICAgICAgIGxldCBjb3VudGVyUG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgbGV0IGkgPSBzdGFydDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXQoaSkgIT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrY291bnRlclBvc2l0aW9uID09PSBudW1Db3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSByZWFkIGZ1bGx5IHRoZSBsYXN0IHNlY3Rpb24gb2YgcGl4ZWxzIGFuZCBmaWxsZWQgdXAgb3VyIGNvdW50ZXJzIC0tIG9yIGZpbGxlZFxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgY291bnRlciBidXQgcmFuIG9mZiB0aGUgc2lkZSBvZiB0aGUgaW1hZ2UsIE9LLiBPdGhlcndpc2UsIGEgcHJvYmxlbS5cbiAgICAgICAgICAgIGlmICghKGNvdW50ZXJQb3NpdGlvbiA9PT0gbnVtQ291bnRlcnMgfHwgKGNvdW50ZXJQb3NpdGlvbiA9PT0gbnVtQ291bnRlcnMgLSAxICYmIGkgPT09IGVuZCkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHJlY29yZFBhdHRlcm5JblJldmVyc2Uocm93LCBzdGFydCwgY291bnRlcnMpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY291bGQgYmUgbW9yZSBlZmZpY2llbnQgSSBndWVzc1xuICAgICAgICAgICAgbGV0IG51bVRyYW5zaXRpb25zTGVmdCA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gcm93LmdldChzdGFydCk7XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnQgPiAwICYmIG51bVRyYW5zaXRpb25zTGVmdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXQoLS1zdGFydCkgIT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtVHJhbnNpdGlvbnNMZWZ0LS07XG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSAhbGFzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVtVHJhbnNpdGlvbnNMZWZ0ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9uZURSZWFkZXIucmVjb3JkUGF0dGVybihyb3csIHN0YXJ0ICsgMSwgY291bnRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGhvdyBjbG9zZWx5IGEgc2V0IG9mIG9ic2VydmVkIGNvdW50cyBvZiBydW5zIG9mIGJsYWNrL3doaXRlIHZhbHVlcyBtYXRjaGVzIGEgZ2l2ZW5cbiAgICAgICAgICogdGFyZ2V0IHBhdHRlcm4uIFRoaXMgaXMgcmVwb3J0ZWQgYXMgdGhlIHJhdGlvIG9mIHRoZSB0b3RhbCB2YXJpYW5jZSBmcm9tIHRoZSBleHBlY3RlZCBwYXR0ZXJuXG4gICAgICAgICAqIHByb3BvcnRpb25zIGFjcm9zcyBhbGwgcGF0dGVybiBlbGVtZW50cywgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcGF0dGVybi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvdW50ZXJzIG9ic2VydmVkIGNvdW50ZXJzXG4gICAgICAgICAqIEBwYXJhbSBwYXR0ZXJuIGV4cGVjdGVkIHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIG1heEluZGl2aWR1YWxWYXJpYW5jZSBUaGUgbW9zdCBhbnkgY291bnRlciBjYW4gZGlmZmVyIGJlZm9yZSB3ZSBnaXZlIHVwXG4gICAgICAgICAqIEByZXR1cm4gcmF0aW8gb2YgdG90YWwgdmFyaWFuY2UgYmV0d2VlbiBjb3VudGVycyBhbmQgcGF0dGVybiBjb21wYXJlZCB0byB0b3RhbCBwYXR0ZXJuIHNpemVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBwYXR0ZXJuTWF0Y2hWYXJpYW5jZShjb3VudGVycywgcGF0dGVybiwgbWF4SW5kaXZpZHVhbFZhcmlhbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgICAgICBsZXQgcGF0dGVybkxlbmd0aCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuTGVuZ3RoICs9IHBhdHRlcm5baV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG90YWwgPCBwYXR0ZXJuTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIG9uZSBwaXhlbCBwZXIgdW5pdCBvZiBiYXIgd2lkdGgsIGFzc3VtZSB0aGlzIGlzIHRvbyBzbWFsbFxuICAgICAgICAgICAgICAgIC8vIHRvIHJlbGlhYmx5IG1hdGNoLCBzbyBmYWlsOlxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1bml0QmFyV2lkdGggPSB0b3RhbCAvIHBhdHRlcm5MZW5ndGg7XG4gICAgICAgICAgICBtYXhJbmRpdmlkdWFsVmFyaWFuY2UgKj0gdW5pdEJhcldpZHRoO1xuICAgICAgICAgICAgbGV0IHRvdGFsVmFyaWFuY2UgPSAwLjA7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG51bUNvdW50ZXJzOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudGVyID0gY291bnRlcnNbeF07XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVkUGF0dGVybiA9IHBhdHRlcm5beF0gKiB1bml0QmFyV2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFyaWFuY2UgPSBjb3VudGVyID4gc2NhbGVkUGF0dGVybiA/IGNvdW50ZXIgLSBzY2FsZWRQYXR0ZXJuIDogc2NhbGVkUGF0dGVybiAtIGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhbmNlID4gbWF4SW5kaXZpZHVhbFZhcmlhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvdGFsVmFyaWFuY2UgKz0gdmFyaWFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG90YWxWYXJpYW5jZSAvIHRvdGFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPHA+RGVjb2RlcyBDb2RlIDEyOCBiYXJjb2Rlcy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIENvZGUxMjhSZWFkZXIgZXh0ZW5kcyBPbmVEUmVhZGVyIHtcbiAgICAgICAgc3RhdGljIGZpbmRTdGFydFBhdHRlcm4ocm93KSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBjb25zdCByb3dPZmZzZXQgPSByb3cuZ2V0TmV4dFNldCgwKTtcbiAgICAgICAgICAgIGxldCBjb3VudGVyUG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJzID0gSW50MzJBcnJheS5mcm9tKFswLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5MZW5ndGggPSA2O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHJvd09mZnNldDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmdldChpKSAhPT0gaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSAocGF0dGVybkxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYmVzdFZhcmlhbmNlID0gQ29kZTEyOFJlYWRlci5NQVhfQVZHX1ZBUklBTkNFO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3RhcnRDb2RlID0gQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0E7IHN0YXJ0Q29kZSA8PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQzsgc3RhcnRDb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YXJpYW5jZSA9IE9uZURSZWFkZXIucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIENvZGUxMjhSZWFkZXIuQ09ERV9QQVRURVJOU1tzdGFydENvZGVdLCBDb2RlMTI4UmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFuY2UgPCBiZXN0VmFyaWFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdFZhcmlhbmNlID0gdmFyaWFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IHN0YXJ0Q29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb29rIGZvciB3aGl0ZXNwYWNlIGJlZm9yZSBzdGFydCBwYXR0ZXJuLCA+PSA1MCUgb2Ygd2lkdGggb2Ygc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93LmlzUmFuZ2UoTWF0aC5tYXgoMCwgcGF0dGVyblN0YXJ0IC0gKGkgLSBwYXR0ZXJuU3RhcnQpIC8gMiksIHBhdHRlcm5TdGFydCwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbcGF0dGVyblN0YXJ0LCBpLCBiZXN0TWF0Y2hdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnMgPSBjb3VudGVycy5zbGljZSgyLCBjb3VudGVycy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbiAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWNvZGVDb2RlKHJvdywgY291bnRlcnMsIHJvd09mZnNldCkge1xuICAgICAgICAgICAgT25lRFJlYWRlci5yZWNvcmRQYXR0ZXJuKHJvdywgcm93T2Zmc2V0LCBjb3VudGVycyk7XG4gICAgICAgICAgICBsZXQgYmVzdFZhcmlhbmNlID0gQ29kZTEyOFJlYWRlci5NQVhfQVZHX1ZBUklBTkNFOyAvLyB3b3JzdCB2YXJpYW5jZSB3ZSdsbCBhY2NlcHRcbiAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgQ29kZTEyOFJlYWRlci5DT0RFX1BBVFRFUk5TLmxlbmd0aDsgZCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IENvZGUxMjhSZWFkZXIuQ09ERV9QQVRURVJOU1tkXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJpYW5jZSA9IHRoaXMucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIENvZGUxMjhSZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYW5jZSA8IGJlc3RWYXJpYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0VmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPIFdlJ3JlIG92ZXJsb29raW5nIHRoZSBmYWN0IHRoYXQgdGhlIFNUT1AgcGF0dGVybiBoYXMgNyB2YWx1ZXMsIG5vdCA2LlxuICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRGTkMxID0gaGludHMgJiYgKGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLkFTU1VNRV9HUzEpID09PSB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UGF0dGVybkluZm8gPSBDb2RlMTI4UmVhZGVyLmZpbmRTdGFydFBhdHRlcm4ocm93KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0Q29kZSA9IHN0YXJ0UGF0dGVybkluZm9bMl07XG4gICAgICAgICAgICBsZXQgY3VycmVudFJhd0NvZGVzSW5kZXggPSAwO1xuICAgICAgICAgICAgY29uc3QgcmF3Q29kZXMgPSBuZXcgVWludDhBcnJheSgyMCk7XG4gICAgICAgICAgICByYXdDb2Rlc1tjdXJyZW50UmF3Q29kZXNJbmRleCsrXSA9IHN0YXJ0Q29kZTtcbiAgICAgICAgICAgIGxldCBjb2RlU2V0O1xuICAgICAgICAgICAgc3dpdGNoIChzdGFydENvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9BOlxuICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQjpcbiAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0M6XG4gICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9DO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGlzTmV4dFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGxldCBsYXN0U3RhcnQgPSBzdGFydFBhdHRlcm5JbmZvWzBdO1xuICAgICAgICAgICAgbGV0IG5leHRTdGFydCA9IHN0YXJ0UGF0dGVybkluZm9bMV07XG4gICAgICAgICAgICBjb25zdCBjb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICAgICAgbGV0IGxhc3RDb2RlID0gMDtcbiAgICAgICAgICAgIGxldCBjb2RlID0gMDtcbiAgICAgICAgICAgIGxldCBjaGVja3N1bVRvdGFsID0gc3RhcnRDb2RlO1xuICAgICAgICAgICAgbGV0IG11bHRpcGxpZXIgPSAwO1xuICAgICAgICAgICAgbGV0IGxhc3RDaGFyYWN0ZXJXYXNQcmludGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bnNoaWZ0ID0gaXNOZXh0U2hpZnRlZDtcbiAgICAgICAgICAgICAgICBpc05leHRTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBvZmYgbGFzdCBjb2RlXG4gICAgICAgICAgICAgICAgbGFzdENvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgIC8vIERlY29kZSBhbm90aGVyIGNvZGUgZnJvbSBpbWFnZVxuICAgICAgICAgICAgICAgIGNvZGUgPSBDb2RlMTI4UmVhZGVyLmRlY29kZUNvZGUocm93LCBjb3VudGVycywgbmV4dFN0YXJ0KTtcbiAgICAgICAgICAgICAgICByYXdDb2Rlc1tjdXJyZW50UmF3Q29kZXNJbmRleCsrXSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgd2hldGhlciB0aGUgbGFzdCBjb2RlIHdhcyBwcmludGFibGUgb3Igbm90IChleGNsdWRpbmcgQ09ERV9TVE9QKVxuICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q2hhcmFjdGVyV2FzUHJpbnRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIGNoZWNrc3VtIGNvbXB1dGF0aW9uIChpZiBub3QgQ09ERV9TVE9QIG9mIGNvdXJzZSlcbiAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gQ29kZTEyOFJlYWRlci5DT0RFX1NUT1ApIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllcisrO1xuICAgICAgICAgICAgICAgICAgICBjaGVja3N1bVRvdGFsICs9IG11bHRpcGxpZXIgKiBjb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHdoZXJlIHRoZSBuZXh0IGNvZGUgd2lsbCB0byBzdGFydFxuICAgICAgICAgICAgICAgIGxhc3RTdGFydCA9IG5leHRTdGFydDtcbiAgICAgICAgICAgICAgICBuZXh0U3RhcnQgKz0gY291bnRlcnMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4gcHJldmlvdXMgKyBjdXJyZW50LCAwKTtcbiAgICAgICAgICAgICAgICAvLyBUYWtlIGNhcmUgb2YgaWxsZWdhbCBzdGFydCBjb2Rlc1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9BOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9COlxuICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGVTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPCA2NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGlmdFVwcGVyTW9kZSA9PT0gdXBwZXJNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnICcuY2hhckNvZGVBdCgwKSArIGNvZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnICcuY2hhckNvZGVBdCgwKSArIGNvZGUgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPCA5Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGlmdFVwcGVyTW9kZSA9PT0gdXBwZXJNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlIC0gNjQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlICsgNjQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGxldCBDT0RFX1NUT1AsIHdoaWNoIGFsd2F5cyBhcHBlYXJzLCBhZmZlY3Qgd2hldGhlciB3aGV0aGVyIHdlIHRoaW5rIHRoZSBsYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29kZSB3YXMgcHJpbnRhYmxlIG9yIG5vdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gQ29kZTEyOFJlYWRlci5DT0RFX1NUT1ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENoYXJhY3Rlcldhc1ByaW50YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udmVydEZOQzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHUzEgc3BlY2lmaWNhdGlvbiA1LjQuMy43LiBhbmQgNS40LjYuNC4gSWYgdGhlIGZpcnN0IGNoYXIgYWZ0ZXIgdGhlIHN0YXJ0IGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgRk5DMSB0aGVuIHRoaXMgaXMgR1MxLTEyOC4gV2UgYWRkIHRoZSBzeW1ib2xvZ3kgaWRlbnRpZmllci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICddQzEnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR1MxIHNwZWNpZmljYXRpb24gNS40LjcuNS4gRXZlcnkgc3Vic2VxdWVudCBGTkMxIGlzIHJldHVybmVkIGFzIEFTQ0lJIDI5IChHUylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ180X0E6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVwcGVyTW9kZSAmJiBzaGlmdFVwcGVyTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVwcGVyTW9kZSAmJiBzaGlmdFVwcGVyTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc05leHRTaGlmdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9DO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUT1A6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA8IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoaWZ0VXBwZXJNb2RlID09PSB1cHBlck1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcgJy5jaGFyQ29kZUF0KDApICsgY29kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcgJy5jaGFyQ29kZUF0KDApICsgY29kZSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGFyYWN0ZXJXYXNQcmludGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18xOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnZlcnRGTkMxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR1MxIHNwZWNpZmljYXRpb24gNS40LjMuNy4gYW5kIDUuNC42LjQuIElmIHRoZSBmaXJzdCBjaGFyIGFmdGVyIHRoZSBzdGFydCBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIEZOQzEgdGhlbiB0aGlzIGlzIEdTMS0xMjguIFdlIGFkZCB0aGUgc3ltYm9sb2d5IGlkZW50aWZpZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXUMxJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdTMSBzcGVjaWZpY2F0aW9uIDUuNC43LjUuIEV2ZXJ5IHN1YnNlcXVlbnQgRk5DMSBpcyByZXR1cm5lZCBhcyBBU0NJSSAyOSAoR1MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfNF9COlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1cHBlck1vZGUgJiYgc2hpZnRVcHBlck1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlck1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh1cHBlck1vZGUgJiYgc2hpZnRVcHBlck1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOZXh0U2hpZnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPCAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGFyYWN0ZXJXYXNQcmludGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18xOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnZlcnRGTkMxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR1MxIHNwZWNpZmljYXRpb24gNS40LjMuNy4gYW5kIDUuNC42LjQuIElmIHRoZSBmaXJzdCBjaGFyIGFmdGVyIHRoZSBzdGFydCBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIEZOQzEgdGhlbiB0aGlzIGlzIEdTMS0xMjguIFdlIGFkZCB0aGUgc3ltYm9sb2d5IGlkZW50aWZpZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXUMxJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdTMSBzcGVjaWZpY2F0aW9uIDUuNC43LjUuIEV2ZXJ5IHN1YnNlcXVlbnQgRk5DMSBpcyByZXR1cm5lZCBhcyBBU0NJSSAyOSAoR1MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVuc2hpZnQgYmFjayB0byBhbm90aGVyIGNvZGUgc2V0IGlmIHdlIHdlcmUgc2hpZnRlZFxuICAgICAgICAgICAgICAgIGlmICh1bnNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBjb2RlU2V0ID09PSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BID8gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQiA6IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGFzdFBhdHRlcm5TaXplID0gbmV4dFN0YXJ0IC0gbGFzdFN0YXJ0O1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGFtcGxlIHdoaXRlc3BhY2UgZm9sbG93aW5nIHBhdHRlcm4sIGJ1dCwgdG8gZG8gdGhpcyB3ZSBmaXJzdCBuZWVkIHRvIHJlbWVtYmVyIHRoYXRcbiAgICAgICAgICAgIC8vIHdlIGZ1ZGdlZCBkZWNvZGluZyBDT0RFX1NUT1Agc2luY2UgaXQgYWN0dWFsbHkgaGFzIDcgYmFycywgbm90IDYuIFRoZXJlIGlzIGEgYmxhY2sgYmFyIGxlZnRcbiAgICAgICAgICAgIC8vIHRvIHJlYWQgb2ZmLiBXb3VsZCBiZSBzbGlnaHRseSBiZXR0ZXIgdG8gcHJvcGVybHkgcmVhZC4gSGVyZSB3ZSBqdXN0IHNraXAgaXQ6XG4gICAgICAgICAgICBuZXh0U3RhcnQgPSByb3cuZ2V0TmV4dFVuc2V0KG5leHRTdGFydCk7XG4gICAgICAgICAgICBpZiAoIXJvdy5pc1JhbmdlKG5leHRTdGFydCwgTWF0aC5taW4ocm93LmdldFNpemUoKSwgbmV4dFN0YXJ0ICsgKG5leHRTdGFydCAtIGxhc3RTdGFydCkgLyAyKSwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQdWxsIG91dCBmcm9tIHN1bSB0aGUgdmFsdWUgb2YgdGhlIHBlbnVsdGltYXRlIGNoZWNrIGNvZGVcbiAgICAgICAgICAgIGNoZWNrc3VtVG90YWwgLT0gbXVsdGlwbGllciAqIGxhc3RDb2RlO1xuICAgICAgICAgICAgLy8gbGFzdENvZGUgaXMgdGhlIGNoZWNrc3VtIHRoZW46XG4gICAgICAgICAgICBpZiAoY2hlY2tzdW1Ub3RhbCAlIDEwMyAhPT0gbGFzdENvZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2hlY2tzdW1FeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5lZWQgdG8gcHVsbCBvdXQgdGhlIGNoZWNrIGRpZ2l0cyBmcm9tIHN0cmluZ1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0TGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChyZXN1bHRMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBmYWxzZSBwb3NpdGl2ZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSBib3RoZXIgaWYgdGhlIHJlc3VsdCBoYWQgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciwgYW5kIGlmIHRoZSBjaGVja3N1bSBkaWdpdCBoYXBwZW5lZCB0b1xuICAgICAgICAgICAgLy8gYmUgYSBwcmludGFibGUgY2hhcmFjdGVyLiBJZiBpdCB3YXMganVzdCBpbnRlcnByZXRlZCBhcyBhIGNvbnRyb2wgY29kZSwgbm90aGluZyB0byByZW1vdmUuXG4gICAgICAgICAgICBpZiAocmVzdWx0TGVuZ3RoID4gMCAmJiBsYXN0Q2hhcmFjdGVyV2FzUHJpbnRhYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVTZXQgPT09IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygwLCByZXN1bHRMZW5ndGggLSAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMCwgcmVzdWx0TGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IChzdGFydFBhdHRlcm5JbmZvWzFdICsgc3RhcnRQYXR0ZXJuSW5mb1swXSkgLyAyLjA7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGxhc3RTdGFydCArIGxhc3RQYXR0ZXJuU2l6ZSAvIDIuMDtcbiAgICAgICAgICAgIGNvbnN0IHJhd0NvZGVzU2l6ZSA9IHJhd0NvZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHJhd0J5dGVzID0gbmV3IFVpbnQ4QXJyYXkocmF3Q29kZXNTaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Q29kZXNTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICByYXdCeXRlc1tpXSA9IHJhd0NvZGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW25ldyBSZXN1bHRQb2ludChsZWZ0LCByb3dOdW1iZXIpLCBuZXcgUmVzdWx0UG9pbnQocmlnaHQsIHJvd051bWJlcildO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQocmVzdWx0LCByYXdCeXRlcywgMCwgcG9pbnRzLCBCYXJjb2RlRm9ybWF0JDEuQ09ERV8xMjgsIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfUEFUVEVSTlMgPSBbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMiwgMiwgMiwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDIsIDEsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAyLCAyLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgMiwgMiwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDMsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAyLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMiwgMiwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDIsIDMsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAyLCAyLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMiwgMSwgMiwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDEsIDMsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCAxLCAyLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMiwgMiwgMywgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDIsIDEsIDMsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAyLCAyLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMywgMiwgMiwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDMsIDEsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAzLCAyLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMiwgMywgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDEsIDEsIDMsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAxLCAyLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMywgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDMsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAxLCAyLCAxLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMSwgMiwgMiwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDIsIDEsIDEsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAyLCAxLCAyLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMiwgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDIsIDIsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAyLCAyLCAyLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMiwgMSwgMiwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDIsIDMsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCAyLCAxLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMywgMiwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDEsIDEsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAzLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMiwgMywgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDIsIDEsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAyLCAzLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMSwgMywgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDMsIDEsIDEsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCAxLCAzLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMiwgMSwgMywgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDMsIDMsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAyLCAxLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMywgMSwgMiwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDMsIDMsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAzLCAxLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMywgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDEsIDMsIDMsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCAxLCAxLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMywgMSwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDMsIDMsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAzLCAxLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMSwgMSwgMiwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDEsIDMsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAzLCAxLCAxLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMiwgMSwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDIsIDMsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAzLCAyLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgNCwgMSwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDEsIDQsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAzLCAxLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMiwgMiwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDQsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAxLCAxLCAyLCA0XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgNCwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDQsIDEsIDEsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCA0LCAxLCAyLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMiwgMiwgMSwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDQsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAyLCAxLCAxLCA0XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMiwgNCwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDQsIDIsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCA0LCAyLCAyLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgNCwgMSwgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDEsIDEsIDEsIDRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAxLCAzLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgNCwgMSwgMSwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDQsIDEsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAyLCA0LCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgMSwgNCwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDIsIDQsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCA0LCAyLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgNCwgMSwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDQsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAxLCAxLCAyLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMiwgMSwgMSwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzQsIDIsIDEsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAyLCAxLCA0LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgNCwgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzQsIDEsIDIsIDEsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCA0LCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMywgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDEsIDEsIDQsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCA0LCAxLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgNCwgMywgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzQsIDEsIDEsIDEsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAxLCAxLCAzLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMywgMSwgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDQsIDEsIDMsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAxLCAxLCAxLCA0LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMSwgMSwgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDEsIDQsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAxLCAyLCAxLCA0XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMSwgMiwgMywgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDMsIDMsIDEsIDEsIDEsIDJdKSxcbiAgICBdO1xuICAgIENvZGUxMjhSZWFkZXIuTUFYX0FWR19WQVJJQU5DRSA9IDAuMjU7XG4gICAgQ29kZTEyOFJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSA9IDAuNztcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfU0hJRlQgPSA5ODtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9DID0gOTk7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQiA9IDEwMDtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BID0gMTAxO1xuICAgIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMSA9IDEwMjtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzIgPSA5NztcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzMgPSA5NjtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzRfQSA9IDEwMTtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzRfQiA9IDEwMDtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQSA9IDEwMztcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQiA9IDEwNDtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQyA9IDEwNTtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUCA9IDEwNjtcblxuICAgIC8qKlxuICAgICAqIDxwPkRlY29kZXMgQ29kZSAzOSBiYXJjb2Rlcy4gU3VwcG9ydHMgXCJGdWxsIEFTQ0lJIENvZGUgMzlcIiBpZiBVU0VfQ09ERV8zOV9FWFRFTkRFRF9NT0RFIGlzIHNldC48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBzZWUgQ29kZTkzUmVhZGVyXG4gICAgICovXG4gICAgY2xhc3MgQ29kZTM5UmVhZGVyIGV4dGVuZHMgT25lRFJlYWRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcmVhZGVyIHRoYXQgYXNzdW1lcyBhbGwgZW5jb2RlZCBkYXRhIGlzIGRhdGEsIGFuZCBkb2VzIG5vdCB0cmVhdCB0aGUgZmluYWxcbiAgICAgICAgICogY2hhcmFjdGVyIGFzIGEgY2hlY2sgZGlnaXQuIEl0IHdpbGwgbm90IGRlY29kZWQgXCJleHRlbmRlZCBDb2RlIDM5XCIgc2VxdWVuY2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gcHVibGljIENvZGUzOVJlYWRlcigpIHtcbiAgICAgICAgLy8gICB0aGlzKGZhbHNlKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHJlYWRlciB0aGF0IGNhbiBiZSBjb25maWd1cmVkIHRvIGNoZWNrIHRoZSBsYXN0IGNoYXJhY3RlciBhcyBhIGNoZWNrIGRpZ2l0LlxuICAgICAgICAgKiBJdCB3aWxsIG5vdCBkZWNvZGVkIFwiZXh0ZW5kZWQgQ29kZSAzOVwiIHNlcXVlbmNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVzaW5nQ2hlY2tEaWdpdCBpZiB0cnVlLCB0cmVhdCB0aGUgbGFzdCBkYXRhIGNoYXJhY3RlciBhcyBhIGNoZWNrIGRpZ2l0LCBub3RcbiAgICAgICAgICogZGF0YSwgYW5kIHZlcmlmeSB0aGF0IHRoZSBjaGVja3N1bSBwYXNzZXMuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgQ29kZTM5UmVhZGVyKGJvb2xlYW4gdXNpbmdDaGVja0RpZ2l0KSB7XG4gICAgICAgIC8vICAgdGhpcyh1c2luZ0NoZWNrRGlnaXQsIGZhbHNlKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHJlYWRlciB0aGF0IGNhbiBiZSBjb25maWd1cmVkIHRvIGNoZWNrIHRoZSBsYXN0IGNoYXJhY3RlciBhcyBhIGNoZWNrIGRpZ2l0LFxuICAgICAgICAgKiBvciBvcHRpb25hbGx5IGF0dGVtcHQgdG8gZGVjb2RlIFwiZXh0ZW5kZWQgQ29kZSAzOVwiIHNlcXVlbmNlcyB0aGF0IGFyZSB1c2VkIHRvIGVuY29kZVxuICAgICAgICAgKiB0aGUgZnVsbCBBU0NJSSBjaGFyYWN0ZXIgc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdXNpbmdDaGVja0RpZ2l0IGlmIHRydWUsIHRyZWF0IHRoZSBsYXN0IGRhdGEgY2hhcmFjdGVyIGFzIGEgY2hlY2sgZGlnaXQsIG5vdFxuICAgICAgICAgKiBkYXRhLCBhbmQgdmVyaWZ5IHRoYXQgdGhlIGNoZWNrc3VtIHBhc3Nlcy5cbiAgICAgICAgICogQHBhcmFtIGV4dGVuZGVkTW9kZSBpZiB0cnVlLCB3aWxsIGF0dGVtcHQgdG8gZGVjb2RlIGV4dGVuZGVkIENvZGUgMzkgc2VxdWVuY2VzIGluIHRoZVxuICAgICAgICAgKiB0ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IodXNpbmdDaGVja0RpZ2l0ID0gZmFsc2UsIGV4dGVuZGVkTW9kZSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy51c2luZ0NoZWNrRGlnaXQgPSB1c2luZ0NoZWNrRGlnaXQ7XG4gICAgICAgICAgICB0aGlzLmV4dGVuZGVkTW9kZSA9IGV4dGVuZGVkTW9kZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlUm93UmVzdWx0ID0gJyc7XG4gICAgICAgICAgICB0aGlzLmNvdW50ZXJzID0gbmV3IEludDMyQXJyYXkoOSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICAgICAgbGV0IHRoZUNvdW50ZXJzID0gdGhpcy5jb3VudGVycztcbiAgICAgICAgICAgIHRoZUNvdW50ZXJzLmZpbGwoMCk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZVJvd1Jlc3VsdCA9ICcnO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gQ29kZTM5UmVhZGVyLmZpbmRBc3Rlcmlza1BhdHRlcm4ocm93LCB0aGVDb3VudGVycyk7XG4gICAgICAgICAgICAvLyBSZWFkIG9mZiB3aGl0ZSBzcGFjZVxuICAgICAgICAgICAgbGV0IG5leHRTdGFydCA9IHJvdy5nZXROZXh0U2V0KHN0YXJ0WzFdKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IGRlY29kZWRDaGFyO1xuICAgICAgICAgICAgbGV0IGxhc3RTdGFydDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBDb2RlMzlSZWFkZXIucmVjb3JkUGF0dGVybihyb3csIG5leHRTdGFydCwgdGhlQ291bnRlcnMpO1xuICAgICAgICAgICAgICAgIGxldCBwYXR0ZXJuID0gQ29kZTM5UmVhZGVyLnRvTmFycm93V2lkZVBhdHRlcm4odGhlQ291bnRlcnMpO1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBDb2RlMzlSZWFkZXIucGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZVJvd1Jlc3VsdCArPSBkZWNvZGVkQ2hhcjtcbiAgICAgICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY291bnRlciBvZiB0aGVDb3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhcnQgKz0gY291bnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVhZCBvZmYgd2hpdGUgc3BhY2VcbiAgICAgICAgICAgICAgICBuZXh0U3RhcnQgPSByb3cuZ2V0TmV4dFNldChuZXh0U3RhcnQpO1xuICAgICAgICAgICAgfSB3aGlsZSAoZGVjb2RlZENoYXIgIT09ICcqJyk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZVJvd1Jlc3VsdCA9IHRoaXMuZGVjb2RlUm93UmVzdWx0LnN1YnN0cmluZygwLCB0aGlzLmRlY29kZVJvd1Jlc3VsdC5sZW5ndGggLSAxKTsgLy8gcmVtb3ZlIGFzdGVyaXNrXG4gICAgICAgICAgICAvLyBMb29rIGZvciB3aGl0ZXNwYWNlIGFmdGVyIHBhdHRlcm46XG4gICAgICAgICAgICBsZXQgbGFzdFBhdHRlcm5TaXplID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgdGhlQ291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICBsYXN0UGF0dGVyblNpemUgKz0gY291bnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB3aGl0ZVNwYWNlQWZ0ZXJFbmQgPSBuZXh0U3RhcnQgLSBsYXN0U3RhcnQgLSBsYXN0UGF0dGVyblNpemU7XG4gICAgICAgICAgICAvLyBJZiA1MCUgb2YgbGFzdCBwYXR0ZXJuIHNpemUsIGZvbGxvd2luZyBsYXN0IHBhdHRlcm4sIGlzIG5vdCB3aGl0ZXNwYWNlLCBmYWlsXG4gICAgICAgICAgICAvLyAoYnV0IGlmIGl0J3Mgd2hpdGVzcGFjZSB0byB0aGUgdmVyeSBlbmQgb2YgdGhlIGltYWdlLCB0aGF0J3MgT0spXG4gICAgICAgICAgICBpZiAobmV4dFN0YXJ0ICE9PSBlbmQgJiYgKHdoaXRlU3BhY2VBZnRlckVuZCAqIDIpIDwgbGFzdFBhdHRlcm5TaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy51c2luZ0NoZWNrRGlnaXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF4ID0gdGhpcy5kZWNvZGVSb3dSZXN1bHQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gQ29kZTM5UmVhZGVyLkFMUEhBQkVUX1NUUklORy5pbmRleE9mKHRoaXMuZGVjb2RlUm93UmVzdWx0LmNoYXJBdChpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlY29kZVJvd1Jlc3VsdC5jaGFyQXQobWF4KSAhPT0gQ29kZTM5UmVhZGVyLkFMUEhBQkVUX1NUUklORy5jaGFyQXQodG90YWwgJSA0MykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENoZWNrc3VtRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlUm93UmVzdWx0ID0gdGhpcy5kZWNvZGVSb3dSZXN1bHQuc3Vic3RyaW5nKDAsIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kZWNvZGVSb3dSZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZmFsc2UgcG9zaXRpdmVcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHRTdHJpbmc7XG4gICAgICAgICAgICBpZiAodGhpcy5leHRlbmRlZE1vZGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgPSBDb2RlMzlSZWFkZXIuZGVjb2RlRXh0ZW5kZWQodGhpcy5kZWNvZGVSb3dSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nID0gdGhpcy5kZWNvZGVSb3dSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGVmdCA9IChzdGFydFsxXSArIHN0YXJ0WzBdKSAvIDIuMDtcbiAgICAgICAgICAgIGxldCByaWdodCA9IGxhc3RTdGFydCArIGxhc3RQYXR0ZXJuU2l6ZSAvIDIuMDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzdWx0KHJlc3VsdFN0cmluZywgbnVsbCwgMCwgW25ldyBSZXN1bHRQb2ludChsZWZ0LCByb3dOdW1iZXIpLCBuZXcgUmVzdWx0UG9pbnQocmlnaHQsIHJvd051bWJlcildLCBCYXJjb2RlRm9ybWF0JDEuQ09ERV8zOSwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmaW5kQXN0ZXJpc2tQYXR0ZXJuKHJvdywgY291bnRlcnMpIHtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgcm93T2Zmc2V0ID0gcm93LmdldE5leHRTZXQoMCk7XG4gICAgICAgICAgICBsZXQgY291bnRlclBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSByb3dPZmZzZXQ7XG4gICAgICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5MZW5ndGggPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcm93T2Zmc2V0OyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChyb3cuZ2V0KGkpICE9PSBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IHBhdHRlcm5MZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb29rIGZvciB3aGl0ZXNwYWNlIGJlZm9yZSBzdGFydCBwYXR0ZXJuLCA+PSA1MCUgb2Ygd2lkdGggb2Ygc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG9OYXJyb3dXaWRlUGF0dGVybihjb3VudGVycykgPT09IENvZGUzOVJlYWRlci5BU1RFUklTS19FTkNPRElORyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5pc1JhbmdlKE1hdGgubWF4KDAsIHBhdHRlcm5TdGFydCAtIE1hdGguZmxvb3IoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gMikpLCBwYXR0ZXJuU3RhcnQsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbcGF0dGVyblN0YXJ0LCBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnMuY29weVdpdGhpbigwLCAyLCAyICsgY291bnRlclBvc2l0aW9uIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb24gLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgZWZmaWNpZW5jeSwgcmV0dXJucyAtMSBvbiBmYWlsdXJlLiBOb3QgdGhyb3dpbmcgaGVyZSBzYXZlZCBhcyBtYW55IGFzIDcwMCBleGNlcHRpb25zXG4gICAgICAgIC8vIHBlciBpbWFnZSB3aGVuIHVzaW5nIHNvbWUgb2Ygb3VyIGJsYWNrYm94IGltYWdlcy5cbiAgICAgICAgc3RhdGljIHRvTmFycm93V2lkZVBhdHRlcm4oY291bnRlcnMpIHtcbiAgICAgICAgICAgIGxldCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBtYXhOYXJyb3dDb3VudGVyID0gMDtcbiAgICAgICAgICAgIGxldCB3aWRlQ291bnRlcnM7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IG1pbkNvdW50ZXIgPSAweDdmZmZmZmZmO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgY291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXIgPCBtaW5Db3VudGVyICYmIGNvdW50ZXIgPiBtYXhOYXJyb3dDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5Db3VudGVyID0gY291bnRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXhOYXJyb3dDb3VudGVyID0gbWluQ291bnRlcjtcbiAgICAgICAgICAgICAgICB3aWRlQ291bnRlcnMgPSAwO1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbFdpZGVDb3VudGVyc1dpZHRoID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb3VudGVyID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyID4gbWF4TmFycm93Q291bnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiB8PSAxIDw8IChudW1Db3VudGVycyAtIDEgLSBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZGVDb3VudGVycysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxXaWRlQ291bnRlcnNXaWR0aCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3aWRlQ291bnRlcnMgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgMyB3aWRlIGNvdW50ZXJzLCBidXQgYXJlIHRoZXkgY2xvc2UgZW5vdWdoIGluIHdpZHRoP1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gcGVyZm9ybSBhIGNoZWFwLCBjb25zZXJ2YXRpdmUgY2hlY2sgdG8gc2VlIGlmIGFueSBpbmRpdmlkdWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvdW50ZXIgaXMgbW9yZSB0aGFuIDEuNSB0aW1lcyB0aGUgYXZlcmFnZTpcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVycyAmJiB3aWRlQ291bnRlcnMgPiAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3VudGVyID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlciA+IG1heE5hcnJvd0NvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRlQ291bnRlcnMtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0b3RhbFdpZGVDb3VudGVyc1dpZHRoID0gMyAqIGF2ZXJhZ2UsIHNvIHRoaXMgY2hlY2tzIGlmIGNvdW50ZXIgPj0gMy8yICogYXZlcmFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY291bnRlciAqIDIpID49IHRvdGFsV2lkZUNvdW50ZXJzV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICh3aWRlQ291bnRlcnMgPiAzKTtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcGF0dGVyblRvQ2hhcihwYXR0ZXJuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENvZGUzOVJlYWRlci5DSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKENvZGUzOVJlYWRlci5DSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb2RlMzlSZWFkZXIuQUxQSEFCRVRfU1RSSU5HLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0dGVybiA9PT0gQ29kZTM5UmVhZGVyLkFTVEVSSVNLX0VOQ09ESU5HKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcqJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWNvZGVFeHRlbmRlZChlbmNvZGVkKSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gZW5jb2RlZC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgZGVjb2RlZCA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjID0gZW5jb2RlZC5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICcrJyB8fCBjID09PSAnJCcgfHwgYyA9PT0gJyUnIHx8IGMgPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGVuY29kZWQuY2hhckF0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlY29kZWRDaGFyID0gJ1xcMCc7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gK0EgdG8gK1ogbWFwIHRvIGEgdG8gelxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49ICdBJyAmJiBuZXh0IDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApICsgMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRBIHRvICRaIG1hcCB0byBjb250cm9sIGNvZGVzIFNIIHRvIFNCXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gJ0EnICYmIG5leHQgPD0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0LmNoYXJDb2RlQXQoMCkgLSA2NCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJUEgdG8gJUUgbWFwIHRvIGNvbnRyb2wgY29kZXMgRVNDIHRvIFVTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gJ0EnICYmIG5leHQgPD0gJ0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0LmNoYXJDb2RlQXQoMCkgLSAzOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gJ0YnICYmIG5leHQgPD0gJ0onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0LmNoYXJDb2RlQXQoMCkgLSAxMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gJ0snICYmIG5leHQgPD0gJ08nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0LmNoYXJDb2RlQXQoMCkgKyAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gJ1AnICYmIG5leHQgPD0gJ1QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0LmNoYXJDb2RlQXQoMCkgKyA0Myk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdVJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9ICdcXDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnVicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnQCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdXJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9ICdgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1gnIHx8IG5leHQgPT09ICdZJyB8fCBuZXh0ID09PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnXFx4N2YnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC9BIHRvIC9PIG1hcCB0byAhIHRvICwgYW5kIC9aIG1hcHMgdG8gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49ICdBJyAmJiBuZXh0IDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApIC0gMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnOic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZWQgKz0gZGVjb2RlZENoYXI7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1bXAgdXAgaSBhZ2FpbiBzaW5jZSB3ZSByZWFkIHR3byBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZWQgKz0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb2RlMzlSZWFkZXIuQUxQSEFCRVRfU1RSSU5HID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi0uICQvKyUnO1xuICAgIC8qKlxuICAgICAqIFRoZXNlIHJlcHJlc2VudCB0aGUgZW5jb2RpbmdzIG9mIGNoYXJhY3RlcnMsIGFzIHBhdHRlcm5zIG9mIHdpZGUgYW5kIG5hcnJvdyBiYXJzLlxuICAgICAqIFRoZSA5IGxlYXN0LXNpZ25pZmljYW50IGJpdHMgb2YgZWFjaCBpbnQgY29ycmVzcG9uZCB0byB0aGUgcGF0dGVybiBvZiB3aWRlIGFuZCBuYXJyb3csXG4gICAgICogd2l0aCAxcyByZXByZXNlbnRpbmcgXCJ3aWRlXCIgYW5kIDBzIHJlcHJlc2VudGluZyBuYXJyb3cuXG4gICAgICovXG4gICAgQ29kZTM5UmVhZGVyLkNIQVJBQ1RFUl9FTkNPRElOR1MgPSBbXG4gICAgICAgIDB4MDM0LCAweDEyMSwgMHgwNjEsIDB4MTYwLCAweDAzMSwgMHgxMzAsIDB4MDcwLCAweDAyNSwgMHgxMjQsIDB4MDY0LFxuICAgICAgICAweDEwOSwgMHgwNDksIDB4MTQ4LCAweDAxOSwgMHgxMTgsIDB4MDU4LCAweDAwRCwgMHgxMEMsIDB4MDRDLCAweDAxQyxcbiAgICAgICAgMHgxMDMsIDB4MDQzLCAweDE0MiwgMHgwMTMsIDB4MTEyLCAweDA1MiwgMHgwMDcsIDB4MTA2LCAweDA0NiwgMHgwMTYsXG4gICAgICAgIDB4MTgxLCAweDBDMSwgMHgxQzAsIDB4MDkxLCAweDE5MCwgMHgwRDAsIDB4MDg1LCAweDE4NCwgMHgwQzQsIDB4MEE4LFxuICAgICAgICAweDBBMiwgMHgwOEEsIDB4MDJBIC8vIC8tJVxuICAgIF07XG4gICAgQ29kZTM5UmVhZGVyLkFTVEVSSVNLX0VOQ09ESU5HID0gMHgwOTQ7XG5cbiAgICAvKipcbiAgICAgKiA8cD5EZWNvZGVzIElURiBiYXJjb2Rlcy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFRqaWVjb1xuICAgICAqL1xuICAgIGNsYXNzIElURlJlYWRlciBleHRlbmRzIE9uZURSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIC8vIHByaXZhdGUgc3RhdGljIFcgPSAzOyAvLyBQaXhlbCB3aWR0aCBvZiBhIDN4IHdpZGUgbGluZVxuICAgICAgICAgICAgLy8gcHJpdmF0ZSBzdGF0aWMgdyA9IDI7IC8vIFBpeGVsIHdpZHRoIG9mIGEgMnggd2lkZSBsaW5lXG4gICAgICAgICAgICAvLyBwcml2YXRlIHN0YXRpYyBOID0gMTsgLy8gUGl4ZWQgd2lkdGggb2YgYSBuYXJyb3cgbGluZVxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIFN0b3JlcyB0aGUgYWN0dWFsIG5hcnJvdyBsaW5lIHdpZHRoIG9mIHRoZSBpbWFnZSBiZWluZyBkZWNvZGVkLlxuICAgICAgICAgICAgdGhpcy5uYXJyb3dMaW5lV2lkdGggPSAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgSVRGV3JpdGVyLlBBVFRFUk5TXG4gICAgICAgIC8qXG4gICAgICBcbiAgICAgICAgLyEqKlxuICAgICAgICAgKiBQYXR0ZXJucyBvZiBXaWRlIC8gTmFycm93IGxpbmVzIHRvIGluZGljYXRlIGVhY2ggZGlnaXRcbiAgICAgICAgICohL1xuICAgICAgICAqL1xuICAgICAgICBkZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgICAgICAvLyBGaW5kIG91dCB3aGVyZSB0aGUgTWlkZGxlIHNlY3Rpb24gKHBheWxvYWQpIHN0YXJ0cyAmIGVuZHNcbiAgICAgICAgICAgIGxldCBzdGFydFJhbmdlID0gdGhpcy5kZWNvZGVTdGFydChyb3cpO1xuICAgICAgICAgICAgbGV0IGVuZFJhbmdlID0gdGhpcy5kZWNvZGVFbmQocm93KTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgSVRGUmVhZGVyLmRlY29kZU1pZGRsZShyb3csIHN0YXJ0UmFuZ2VbMV0sIGVuZFJhbmdlWzBdLCByZXN1bHQpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdFN0cmluZyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICAgICAgbGV0IGFsbG93ZWRMZW5ndGhzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChoaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dlZExlbmd0aHMgPSBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5BTExPV0VEX0xFTkdUSFMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsbG93ZWRMZW5ndGhzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhbGxvd2VkTGVuZ3RocyA9IElURlJlYWRlci5ERUZBVUxUX0FMTE9XRURfTEVOR1RIUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRvIGF2b2lkIGZhbHNlIHBvc2l0aXZlcyB3aXRoIDJEIGJhcmNvZGVzIChhbmQgb3RoZXIgcGF0dGVybnMpLCBtYWtlXG4gICAgICAgICAgICAvLyBhbiBhc3N1bXB0aW9uIHRoYXQgdGhlIGRlY29kZWQgc3RyaW5nIG11c3QgYmUgYSAnc3RhbmRhcmQnIGxlbmd0aCBpZiBpdCdzIHNob3J0XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gcmVzdWx0U3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBsZW5ndGhPSyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG1heEFsbG93ZWRMZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgYWxsb3dlZExlbmd0aHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGhPSyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBtYXhBbGxvd2VkTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heEFsbG93ZWRMZW5ndGggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxlbmd0aE9LICYmIGxlbmd0aCA+IG1heEFsbG93ZWRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGhPSyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxlbmd0aE9LKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW25ldyBSZXN1bHRQb2ludChzdGFydFJhbmdlWzFdLCByb3dOdW1iZXIpLCBuZXcgUmVzdWx0UG9pbnQoZW5kUmFuZ2VbMF0sIHJvd051bWJlcildO1xuICAgICAgICAgICAgbGV0IHJlc3VsdFJldHVybiA9IG5ldyBSZXN1bHQocmVzdWx0U3RyaW5nLCBudWxsLCAvLyBubyBuYXR1cmFsIGJ5dGUgcmVwcmVzZW50YXRpb24gZm9yIHRoZXNlIGJhcmNvZGVzXG4gICAgICAgICAgICAwLCBwb2ludHMsIEJhcmNvZGVGb3JtYXQkMS5JVEYsIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRSZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgLyEqKlxuICAgICAgICAgKiBAcGFyYW0gcm93ICAgICAgICAgIHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgdG8gc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSBwYXlsb2FkU3RhcnQgb2Zmc2V0IG9mIHN0YXJ0IHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIHJlc3VsdFN0cmluZyB7QGxpbmsgU3RyaW5nQnVpbGRlcn0gdG8gYXBwZW5kIGRlY29kZWQgY2hhcnMgdG9cbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBkZWNvZGluZyBjb3VsZCBub3QgY29tcGxldGUgc3VjY2Vzc2Z1bGx5XG4gICAgICAgICAqIS8qL1xuICAgICAgICBzdGF0aWMgZGVjb2RlTWlkZGxlKHJvdywgcGF5bG9hZFN0YXJ0LCBwYXlsb2FkRW5kLCByZXN1bHRTdHJpbmcpIHtcbiAgICAgICAgICAgIC8vIERpZ2l0cyBhcmUgaW50ZXJsZWF2ZWQgaW4gcGFpcnMgLSA1IGJsYWNrIGxpbmVzIGZvciBvbmUgZGlnaXQsIGFuZCB0aGVcbiAgICAgICAgICAgIC8vIDVcbiAgICAgICAgICAgIC8vIGludGVybGVhdmVkIHdoaXRlIGxpbmVzIGZvciB0aGUgc2Vjb25kIGRpZ2l0LlxuICAgICAgICAgICAgLy8gVGhlcmVmb3JlLCBuZWVkIHRvIHNjYW4gMTAgbGluZXMgYW5kIHRoZW5cbiAgICAgICAgICAgIC8vIHNwbGl0IHRoZXNlIGludG8gdHdvIGFycmF5c1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJEaWdpdFBhaXIgPSBuZXcgSW50MzJBcnJheSgxMCk7IC8vIDEwXG4gICAgICAgICAgICBsZXQgY291bnRlckJsYWNrID0gbmV3IEludDMyQXJyYXkoNSk7IC8vIDVcbiAgICAgICAgICAgIGxldCBjb3VudGVyV2hpdGUgPSBuZXcgSW50MzJBcnJheSg1KTsgLy8gNVxuICAgICAgICAgICAgY291bnRlckRpZ2l0UGFpci5maWxsKDApO1xuICAgICAgICAgICAgY291bnRlckJsYWNrLmZpbGwoMCk7XG4gICAgICAgICAgICBjb3VudGVyV2hpdGUuZmlsbCgwKTtcbiAgICAgICAgICAgIHdoaWxlIChwYXlsb2FkU3RhcnQgPCBwYXlsb2FkRW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IDEwIHJ1bnMgb2YgYmxhY2svd2hpdGUuXG4gICAgICAgICAgICAgICAgT25lRFJlYWRlci5yZWNvcmRQYXR0ZXJuKHJvdywgcGF5bG9hZFN0YXJ0LCBjb3VudGVyRGlnaXRQYWlyKTtcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCB0aGVtIGludG8gZWFjaCBhcnJheVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgNTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0d29LID0gMiAqIGs7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJCbGFja1trXSA9IGNvdW50ZXJEaWdpdFBhaXJbdHdvS107XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJXaGl0ZVtrXSA9IGNvdW50ZXJEaWdpdFBhaXJbdHdvSyArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gSVRGUmVhZGVyLmRlY29kZURpZ2l0KGNvdW50ZXJCbGFjayk7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nLmFwcGVuZChiZXN0TWF0Y2gudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gdGhpcy5kZWNvZGVEaWdpdChjb3VudGVyV2hpdGUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZy5hcHBlbmQoYmVzdE1hdGNoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJEaWdpdFBhaXIuZm9yRWFjaChmdW5jdGlvbiAoY291bnRlckRpZ2l0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWRTdGFydCArPSBjb3VudGVyRGlnaXQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyovISoqXG4gICAgICAgICAqIElkZW50aWZ5IHdoZXJlIHRoZSBzdGFydCBvZiB0aGUgbWlkZGxlIC8gcGF5bG9hZCBzZWN0aW9uIHN0YXJ0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvdyByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcmV0dXJuIEFycmF5LCBjb250YWluaW5nIGluZGV4IG9mIHN0YXJ0IG9mICdzdGFydCBibG9jaycgYW5kIGVuZCBvZlxuICAgICAgICAgKiAgICAgICAgICdzdGFydCBibG9jaydcbiAgICAgICAgICohLyovXG4gICAgICAgIGRlY29kZVN0YXJ0KHJvdykge1xuICAgICAgICAgICAgbGV0IGVuZFN0YXJ0ID0gSVRGUmVhZGVyLnNraXBXaGl0ZVNwYWNlKHJvdyk7XG4gICAgICAgICAgICBsZXQgc3RhcnRQYXR0ZXJuID0gSVRGUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4ocm93LCBlbmRTdGFydCwgSVRGUmVhZGVyLlNUQVJUX1BBVFRFUk4pO1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB3aWR0aCBvZiBhIG5hcnJvdyBsaW5lIGluIHBpeGVscy4gV2UgY2FuIGRvIHRoaXMgYnlcbiAgICAgICAgICAgIC8vIGdldHRpbmcgdGhlIHdpZHRoIG9mIHRoZSBzdGFydCBwYXR0ZXJuIGFuZCBkaXZpZGluZyBieSA0IGJlY2F1c2UgaXRzXG4gICAgICAgICAgICAvLyBtYWRlIHVwIG9mIDQgbmFycm93IGxpbmVzLlxuICAgICAgICAgICAgdGhpcy5uYXJyb3dMaW5lV2lkdGggPSAoc3RhcnRQYXR0ZXJuWzFdIC0gc3RhcnRQYXR0ZXJuWzBdKSAvIDQ7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUXVpZXRab25lKHJvdywgc3RhcnRQYXR0ZXJuWzBdKTtcbiAgICAgICAgICAgIHJldHVybiBzdGFydFBhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgLyovISoqXG4gICAgICAgICAqIFRoZSBzdGFydCAmIGVuZCBwYXR0ZXJucyBtdXN0IGJlIHByZS9wb3N0IGZpeGVkIGJ5IGEgcXVpZXQgem9uZS4gVGhpc1xuICAgICAgICAgKiB6b25lIG11c3QgYmUgYXQgbGVhc3QgMTAgdGltZXMgdGhlIHdpZHRoIG9mIGEgbmFycm93IGxpbmUuICBTY2FuIGJhY2sgdW50aWxcbiAgICAgICAgICogd2UgZWl0aGVyIGdldCB0byB0aGUgc3RhcnQgb2YgdGhlIGJhcmNvZGUgb3IgbWF0Y2ggdGhlIG5lY2Vzc2FyeSBudW1iZXIgb2ZcbiAgICAgICAgICogcXVpZXQgem9uZSBwaXhlbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IEl0cyBhc3N1bWVkIHRoZSByb3cgaXMgcmV2ZXJzZWQgd2hlbiB1c2luZyB0aGlzIG1ldGhvZCB0byBmaW5kXG4gICAgICAgICAqIHF1aWV0IHpvbmUgYWZ0ZXIgdGhlIGVuZCBwYXR0ZXJuLlxuICAgICAgICAgKlxuICAgICAgICAgKiByZWY6IGh0dHA6Ly93d3cuYmFyY29kZS0xLm5ldC9pMjVjb2RlLmh0bWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvdyBiaXQgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBzY2FubmVkIGJhcmNvZGUuXG4gICAgICAgICAqIEBwYXJhbSBzdGFydFBhdHRlcm4gaW5kZXggaW50byByb3cgb2YgdGhlIHN0YXJ0IG9yIGVuZCBwYXR0ZXJuLlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIHRoZSBxdWlldCB6b25lIGNhbm5vdCBiZSBmb3VuZFxuICAgICAgICAgKiEvKi9cbiAgICAgICAgdmFsaWRhdGVRdWlldFpvbmUocm93LCBzdGFydFBhdHRlcm4pIHtcbiAgICAgICAgICAgIGxldCBxdWlldENvdW50ID0gdGhpcy5uYXJyb3dMaW5lV2lkdGggKiAxMDsgLy8gZXhwZWN0IHRvIGZpbmQgdGhpcyBtYW55IHBpeGVscyBvZiBxdWlldCB6b25lXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm90IHNvIG1hbnkgcGl4ZWwgYXQgYWxsIGxldCdzIHRyeSBhcyBtYW55IGFzIHBvc3NpYmxlXG4gICAgICAgICAgICBxdWlldENvdW50ID0gcXVpZXRDb3VudCA8IHN0YXJ0UGF0dGVybiA/IHF1aWV0Q291bnQgOiBzdGFydFBhdHRlcm47XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRQYXR0ZXJuIC0gMTsgcXVpZXRDb3VudCA+IDAgJiYgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmdldChpKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXVpZXRDb3VudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHF1aWV0Q291bnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBVbmFibGUgdG8gZmluZCB0aGUgbmVjZXNzYXJ5IG51bWJlciBvZiBxdWlldCB6b25lIHBpeGVscy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAvISoqXG4gICAgICAgICAqIFNraXAgYWxsIHdoaXRlc3BhY2UgdW50aWwgd2UgZ2V0IHRvIHRoZSBmaXJzdCBibGFjayBsaW5lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcm93IHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgdG8gc2VhcmNoXG4gICAgICAgICAqIEByZXR1cm4gaW5kZXggb2YgdGhlIGZpcnN0IGJsYWNrIGxpbmUuXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gVGhyb3dzIGV4Y2VwdGlvbiBpZiBubyBibGFjayBsaW5lcyBhcmUgZm91bmQgaW4gdGhlIHJvd1xuICAgICAgICAgKiEvKi9cbiAgICAgICAgc3RhdGljIHNraXBXaGl0ZVNwYWNlKHJvdykge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgY29uc3QgZW5kU3RhcnQgPSByb3cuZ2V0TmV4dFNldCgwKTtcbiAgICAgICAgICAgIGlmIChlbmRTdGFydCA9PT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbmRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICAvKi8hKipcbiAgICAgICAgICogSWRlbnRpZnkgd2hlcmUgdGhlIGVuZCBvZiB0aGUgbWlkZGxlIC8gcGF5bG9hZCBzZWN0aW9uIGVuZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByb3cgcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlcyB0byBzZWFyY2hcbiAgICAgICAgICogQHJldHVybiBBcnJheSwgY29udGFpbmluZyBpbmRleCBvZiBzdGFydCBvZiAnZW5kIGJsb2NrJyBhbmQgZW5kIG9mICdlbmRcbiAgICAgICAgICogICAgICAgICBibG9jaydcbiAgICAgICAgICohLyovXG4gICAgICAgIGRlY29kZUVuZChyb3cpIHtcbiAgICAgICAgICAgIC8vIEZvciBjb252ZW5pZW5jZSwgcmV2ZXJzZSB0aGUgcm93IGFuZCB0aGVuXG4gICAgICAgICAgICAvLyBzZWFyY2ggZnJvbSAndGhlIHN0YXJ0JyBmb3IgdGhlIGVuZCBibG9ja1xuICAgICAgICAgICAgcm93LnJldmVyc2UoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFN0YXJ0ID0gSVRGUmVhZGVyLnNraXBXaGl0ZVNwYWNlKHJvdyk7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFBhdHRlcm47XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZW5kUGF0dGVybiA9IElURlJlYWRlci5maW5kR3VhcmRQYXR0ZXJuKHJvdywgZW5kU3RhcnQsIElURlJlYWRlci5FTkRfUEFUVEVSTl9SRVZFUlNFRFswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBOb3RGb3VuZEV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUGF0dGVybiA9IElURlJlYWRlci5maW5kR3VhcmRQYXR0ZXJuKHJvdywgZW5kU3RhcnQsIElURlJlYWRlci5FTkRfUEFUVEVSTl9SRVZFUlNFRFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIHN0YXJ0ICYgZW5kIHBhdHRlcm5zIG11c3QgYmUgcHJlL3Bvc3QgZml4ZWQgYnkgYSBxdWlldCB6b25lLiBUaGlzXG4gICAgICAgICAgICAgICAgLy8gem9uZSBtdXN0IGJlIGF0IGxlYXN0IDEwIHRpbWVzIHRoZSB3aWR0aCBvZiBhIG5hcnJvdyBsaW5lLlxuICAgICAgICAgICAgICAgIC8vIHJlZjogaHR0cDovL3d3dy5iYXJjb2RlLTEubmV0L2kyNWNvZGUuaHRtbFxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVRdWlldFpvbmUocm93LCBlbmRQYXR0ZXJuWzBdKTtcbiAgICAgICAgICAgICAgICAvLyBOb3cgcmVjYWxjdWxhdGUgdGhlIGluZGljZXMgb2Ygd2hlcmUgdGhlICdlbmRibG9jaycgc3RhcnRzICYgc3RvcHMgdG9cbiAgICAgICAgICAgICAgICAvLyBhY2NvbW1vZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRoZSByZXZlcnNlZCBuYXR1cmUgb2YgdGhlIHNlYXJjaFxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gZW5kUGF0dGVyblswXTtcbiAgICAgICAgICAgICAgICBlbmRQYXR0ZXJuWzBdID0gcm93LmdldFNpemUoKSAtIGVuZFBhdHRlcm5bMV07XG4gICAgICAgICAgICAgICAgZW5kUGF0dGVyblsxXSA9IHJvdy5nZXRTaXplKCkgLSB0ZW1wO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRQYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLy8gUHV0IHRoZSByb3cgYmFjayB0aGUgcmlnaHQgd2F5LlxuICAgICAgICAgICAgICAgIHJvdy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgLyEqKlxuICAgICAgICAgKiBAcGFyYW0gcm93ICAgICAgIHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgdG8gc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSByb3dPZmZzZXQgcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSBwYXR0ZXJuICAgcGF0dGVybiBvZiBjb3VudHMgb2YgbnVtYmVyIG9mIGJsYWNrIGFuZCB3aGl0ZSBwaXhlbHMgdGhhdCBhcmVcbiAgICAgICAgICogICAgICAgICAgICAgICAgICBiZWluZyBzZWFyY2hlZCBmb3IgYXMgYSBwYXR0ZXJuXG4gICAgICAgICAqIEByZXR1cm4gc3RhcnQvZW5kIGhvcml6b250YWwgb2Zmc2V0IG9mIGd1YXJkIHBhdHRlcm4sIGFzIGFuIGFycmF5IG9mIHR3b1xuICAgICAgICAgKiAgICAgICAgIGludHNcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBwYXR0ZXJuIGlzIG5vdCBmb3VuZFxuICAgICAgICAgKiEvKi9cbiAgICAgICAgc3RhdGljIGZpbmRHdWFyZFBhdHRlcm4ocm93LCByb3dPZmZzZXQsIHBhdHRlcm4pIHtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuTGVuZ3RoID0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgY291bnRlcnMgPSBuZXcgSW50MzJBcnJheShwYXR0ZXJuTGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xuICAgICAgICAgICAgY291bnRlcnMuZmlsbCgwKTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSByb3dPZmZzZXQ7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXQoeCkgIT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3NpdGlvbiA9PT0gcGF0dGVybkxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPbmVEUmVhZGVyLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBJVEZSZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpIDwgSVRGUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3BhdHRlcm5TdGFydCwgeF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoY291bnRlcnMsIDIsIGNvdW50ZXJzLCAwLCBjb3VudGVyUG9zaXRpb24gLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbiAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8qLyEqKlxuICAgICAgICAgKiBBdHRlbXB0cyB0byBkZWNvZGUgYSBzZXF1ZW5jZSBvZiBJVEYgYmxhY2svd2hpdGUgbGluZXMgaW50byBzaW5nbGVcbiAgICAgICAgICogZGlnaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb3VudGVycyB0aGUgY291bnRzIG9mIHJ1bnMgb2Ygb2JzZXJ2ZWQgYmxhY2svd2hpdGUvYmxhY2svLi4uIHZhbHVlc1xuICAgICAgICAgKiBAcmV0dXJuIFRoZSBkZWNvZGVkIGRpZ2l0XG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgZGlnaXQgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgICAgICohLyovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVEaWdpdChjb3VudGVycykge1xuICAgICAgICAgICAgbGV0IGJlc3RWYXJpYW5jZSA9IElURlJlYWRlci5NQVhfQVZHX1ZBUklBTkNFOyAvLyB3b3JzdCB2YXJpYW5jZSB3ZSdsbCBhY2NlcHRcbiAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSAtMTtcbiAgICAgICAgICAgIGxldCBtYXggPSBJVEZSZWFkZXIuUEFUVEVSTlMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwYXR0ZXJuID0gSVRGUmVhZGVyLlBBVFRFUk5TW2ldO1xuICAgICAgICAgICAgICAgIGxldCB2YXJpYW5jZSA9IE9uZURSZWFkZXIucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIElURlJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhbmNlIDwgYmVzdFZhcmlhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RWYXJpYW5jZSA9IHZhcmlhbmNlO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YXJpYW5jZSA9PT0gYmVzdFZhcmlhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGZpbmQgYSBzZWNvbmQgJ2Jlc3QgbWF0Y2gnIHdpdGggdGhlIHNhbWUgdmFyaWFuY2UsIHdlIGNhbiBub3QgcmVsaWFibHkgcmVwb3J0IHRvIGhhdmUgYSBzdWl0YWJsZSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmVzdE1hdGNoID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoICUgMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBJVEZSZWFkZXIuUEFUVEVSTlMgPSBbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMiwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAxLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMiwgMSwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAyLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAxLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDMsIDMsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAxLCAxLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMSwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDMsIDEsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAzLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMywgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDMsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAzLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDEsIDMsIDFdKSAvLyA5XG4gICAgXTtcbiAgICBJVEZSZWFkZXIuTUFYX0FWR19WQVJJQU5DRSA9IDAuMzg7XG4gICAgSVRGUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFID0gMC41O1xuICAgIC8qIC8hKiogVmFsaWQgSVRGIGxlbmd0aHMuIEFueXRoaW5nIGxvbmdlciB0aGFuIHRoZSBsYXJnZXN0IHZhbHVlIGlzIGFsc28gYWxsb3dlZC4gKiEvKi9cbiAgICBJVEZSZWFkZXIuREVGQVVMVF9BTExPV0VEX0xFTkdUSFMgPSBbNiwgOCwgMTAsIDEyLCAxNF07XG4gICAgLyovISoqXG4gICAgICogU3RhcnQvZW5kIGd1YXJkIHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGUgZW5kIHBhdHRlcm4gaXMgcmV2ZXJzZWQgYmVjYXVzZSB0aGUgcm93IGlzIHJldmVyc2VkIGJlZm9yZVxuICAgICAqIHNlYXJjaGluZyBmb3IgdGhlIEVORF9QQVRURVJOXG4gICAgICohLyovXG4gICAgSVRGUmVhZGVyLlNUQVJUX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDFdKTtcbiAgICBJVEZSZWFkZXIuRU5EX1BBVFRFUk5fUkVWRVJTRUQgPSBbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDNdKSAvLyAzeFxuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgZnVuY3Rpb25hbGl0eSBhbmQgaW1wbGVtZW50YXRpb24gdGhhdCBpcyBjb21tb24gdG8gVVBDIGFuZCBFQU4gZmFtaWxpZXNcbiAgICAgKiBvZiBvbmUtZGltZW5zaW9uYWwgYmFyY29kZXMuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBhdXRob3IgYWxhc2RhaXJAZ29vZ2xlLmNvbSAoQWxhc2RhaXIgTWFja2ludG9zaClcbiAgICAgKi9cbiAgICBjbGFzcyBBYnN0cmFjdFVQQ0VBTlJlYWRlciBleHRlbmRzIE9uZURSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZVJvd1N0cmluZ0J1ZmZlciA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGZpbmRTdGFydEd1YXJkUGF0dGVybihyb3cpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZFN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc3RhcnRSYW5nZTtcbiAgICAgICAgICAgIGxldCBuZXh0U3RhcnQgPSAwO1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJzID0gSW50MzJBcnJheS5mcm9tKFswLCAwLCAwXSk7XG4gICAgICAgICAgICB3aGlsZSAoIWZvdW5kU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pO1xuICAgICAgICAgICAgICAgIHN0YXJ0UmFuZ2UgPSBBYnN0cmFjdFVQQ0VBTlJlYWRlci5maW5kR3VhcmRQYXR0ZXJuKHJvdywgbmV4dFN0YXJ0LCBmYWxzZSwgdGhpcy5TVEFSVF9FTkRfUEFUVEVSTiwgY291bnRlcnMpO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHN0YXJ0UmFuZ2VbMF07XG4gICAgICAgICAgICAgICAgbmV4dFN0YXJ0ID0gc3RhcnRSYW5nZVsxXTtcbiAgICAgICAgICAgICAgICBsZXQgcXVpZXRTdGFydCA9IHN0YXJ0IC0gKG5leHRTdGFydCAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAocXVpZXRTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kU3RhcnQgPSByb3cuaXNSYW5nZShxdWlldFN0YXJ0LCBzdGFydCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFydFJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjaGVja0NoZWNrc3VtKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBBYnN0cmFjdFVQQ0VBTlJlYWRlci5jaGVja1N0YW5kYXJkVVBDRUFOQ2hlY2tzdW0ocyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNoZWNrU3RhbmRhcmRVUENFQU5DaGVja3N1bShzKSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjaGVjayA9IHBhcnNlSW50KHMuY2hhckF0KGxlbmd0aCAtIDEpLCAxMCk7XG4gICAgICAgICAgICByZXR1cm4gQWJzdHJhY3RVUENFQU5SZWFkZXIuZ2V0U3RhbmRhcmRVUENFQU5DaGVja3N1bShzLnN1YnN0cmluZygwLCBsZW5ndGggLSAxKSkgPT09IGNoZWNrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRTdGFuZGFyZFVQQ0VBTkNoZWNrc3VtKHMpIHtcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSBzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpZ2l0ID0gcy5jaGFyQXQoaSkuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGlmIChkaWdpdCA8IDAgfHwgZGlnaXQgPiA5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtICs9IGRpZ2l0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VtICo9IDM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlnaXQgPSBzLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZ2l0IDwgMCB8fCBkaWdpdCA+IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdW0gKz0gZGlnaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDEwMDAgLSBzdW0pICUgMTA7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlY29kZUVuZChyb3csIGVuZFN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gQWJzdHJhY3RVUENFQU5SZWFkZXIuZmluZEd1YXJkUGF0dGVybihyb3csIGVuZFN0YXJ0LCBmYWxzZSwgQWJzdHJhY3RVUENFQU5SZWFkZXIuU1RBUlRfRU5EX1BBVFRFUk4sIG5ldyBJbnQzMkFycmF5KEFic3RyYWN0VVBDRUFOUmVhZGVyLlNUQVJUX0VORF9QQVRURVJOLmxlbmd0aCkuZmlsbCgwKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmaW5kR3VhcmRQYXR0ZXJuV2l0aG91dENvdW50ZXJzKHJvdywgcm93T2Zmc2V0LCB3aGl0ZUZpcnN0LCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kR3VhcmRQYXR0ZXJuKHJvdywgcm93T2Zmc2V0LCB3aGl0ZUZpcnN0LCBwYXR0ZXJuLCBuZXcgSW50MzJBcnJheShwYXR0ZXJuLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gcm93IHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgdG8gc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSByb3dPZmZzZXQgcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSB3aGl0ZUZpcnN0IGlmIHRydWUsIGluZGljYXRlcyB0aGF0IHRoZSBwYXR0ZXJuIHNwZWNpZmllcyB3aGl0ZS9ibGFjay93aGl0ZS8uLi5cbiAgICAgICAgICogcGl4ZWwgY291bnRzLCBvdGhlcndpc2UsIGl0IGlzIGludGVycHJldGVkIGFzIGJsYWNrL3doaXRlL2JsYWNrLy4uLlxuICAgICAgICAgKiBAcGFyYW0gcGF0dGVybiBwYXR0ZXJuIG9mIGNvdW50cyBvZiBudW1iZXIgb2YgYmxhY2sgYW5kIHdoaXRlIHBpeGVscyB0aGF0IGFyZSBiZWluZ1xuICAgICAgICAgKiBzZWFyY2hlZCBmb3IgYXMgYSBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBjb3VudGVycyBhcnJheSBvZiBjb3VudGVycywgYXMgbG9uZyBhcyBwYXR0ZXJuLCB0byByZS11c2VcbiAgICAgICAgICogQHJldHVybiBzdGFydC9lbmQgaG9yaXpvbnRhbCBvZmZzZXQgb2YgZ3VhcmQgcGF0dGVybiwgYXMgYW4gYXJyYXkgb2YgdHdvIGludHNcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBwYXR0ZXJuIGlzIG5vdCBmb3VuZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZpbmRHdWFyZFBhdHRlcm4ocm93LCByb3dPZmZzZXQsIHdoaXRlRmlyc3QsIHBhdHRlcm4sIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgcm93T2Zmc2V0ID0gd2hpdGVGaXJzdCA/IHJvdy5nZXROZXh0VW5zZXQocm93T2Zmc2V0KSA6IHJvdy5nZXROZXh0U2V0KHJvd09mZnNldCk7XG4gICAgICAgICAgICBsZXQgY291bnRlclBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSByb3dPZmZzZXQ7XG4gICAgICAgICAgICBsZXQgcGF0dGVybkxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGlzV2hpdGUgPSB3aGl0ZUZpcnN0O1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IHJvd09mZnNldDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmdldCh4KSAhPT0gaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSBwYXR0ZXJuTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9uZURSZWFkZXIucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIEFic3RyYWN0VVBDRUFOUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKSA8IEFic3RyYWN0VVBDRUFOUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSW50MzJBcnJheS5mcm9tKFtwYXR0ZXJuU3RhcnQsIHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNsaWNlID0gY291bnRlcnMuc2xpY2UoMiwgY291bnRlcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXJQb3NpdGlvbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2ldID0gc2xpY2VbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb24gLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGVjb2RlRGlnaXQocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBwYXR0ZXJucykge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRQYXR0ZXJuKHJvdywgcm93T2Zmc2V0LCBjb3VudGVycyk7XG4gICAgICAgICAgICBsZXQgYmVzdFZhcmlhbmNlID0gdGhpcy5NQVhfQVZHX1ZBUklBTkNFO1xuICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IC0xO1xuICAgICAgICAgICAgbGV0IG1heCA9IHBhdHRlcm5zLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IHBhdHRlcm5zW2ldO1xuICAgICAgICAgICAgICAgIGxldCB2YXJpYW5jZSA9IE9uZURSZWFkZXIucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIEFic3RyYWN0VVBDRUFOUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyaWFuY2UgPCBiZXN0VmFyaWFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFZhcmlhbmNlID0gdmFyaWFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoZXNlIHR3byB2YWx1ZXMgYXJlIGNyaXRpY2FsIGZvciBkZXRlcm1pbmluZyBob3cgcGVybWlzc2l2ZSB0aGUgZGVjb2Rpbmcgd2lsbCBiZS5cbiAgICAvLyBXZSd2ZSBhcnJpdmVkIGF0IHRoZXNlIHZhbHVlcyB0aHJvdWdoIGEgbG90IG9mIHRyaWFsIGFuZCBlcnJvci4gU2V0dGluZyB0aGVtIGFueSBoaWdoZXJcbiAgICAvLyBsZXRzIGZhbHNlIHBvc2l0aXZlcyBjcmVlcCBpbiBxdWlja2x5LlxuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UgPSAwLjQ4O1xuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFID0gMC43O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0L2VuZCBndWFyZCBwYXR0ZXJuLlxuICAgICAqL1xuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLlNUQVJUX0VORF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxXSk7XG4gICAgLyoqXG4gICAgICogUGF0dGVybiBtYXJraW5nIHRoZSBtaWRkbGUgb2YgYSBVUEMvRUFOIHBhdHRlcm4sIHNlcGFyYXRpbmcgdGhlIHR3byBoYWx2ZXMuXG4gICAgICovXG4gICAgQWJzdHJhY3RVUENFQU5SZWFkZXIuTUlERExFX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDEsIDFdKTtcbiAgICAvKipcbiAgICAgKiBlbmQgZ3VhcmQgcGF0dGVybi5cbiAgICAgKi9cbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5FTkRfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMSwgMSwgMV0pO1xuICAgIC8qKlxuICAgICAqIFwiT2RkXCIsIG9yIFwiTFwiIHBhdHRlcm5zIHVzZWQgdG8gZW5jb2RlIFVQQy9FQU4gZGlnaXRzLlxuICAgICAqL1xuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLkxfUEFUVEVSTlMgPSBbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgNCwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDMsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMSwgMl0pLFxuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIFVQQ0VBTkV4dGVuc2lvbjJTdXBwb3J0XG4gICAgICovXG4gICAgY2xhc3MgVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuQ0hFQ0tfRElHSVRfRU5DT0RJTkdTID0gWzB4MTgsIDB4MTQsIDB4MTIsIDB4MTEsIDB4MEMsIDB4MDYsIDB4MDMsIDB4MEEsIDB4MDksIDB4MDVdO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMCwgMF0pO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVSb3dTdHJpbmdCdWZmZXIgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGV4dGVuc2lvblN0YXJ0UmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmRlY29kZVJvd1N0cmluZ0J1ZmZlcjtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLmRlY29kZU1pZGRsZShyb3csIGV4dGVuc2lvblN0YXJ0UmFuZ2UsIHJlc3VsdCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0U3RyaW5nID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uRGF0YSA9IFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0LnBhcnNlRXh0ZW5zaW9uU3RyaW5nKHJlc3VsdFN0cmluZyk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0UG9pbnRzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCgoZXh0ZW5zaW9uU3RhcnRSYW5nZVswXSArIGV4dGVuc2lvblN0YXJ0UmFuZ2VbMV0pIC8gMi4wLCByb3dOdW1iZXIpLFxuICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludChlbmQsIHJvd051bWJlcilcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uUmVzdWx0ID0gbmV3IFJlc3VsdChyZXN1bHRTdHJpbmcsIG51bGwsIDAsIHJlc3VsdFBvaW50cywgQmFyY29kZUZvcm1hdCQxLlVQQ19FQU5fRVhURU5TSU9OLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uUmVzdWx0LnB1dEFsbE1ldGFkYXRhKGV4dGVuc2lvbkRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvblJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVNaWRkbGUocm93LCBzdGFydFJhbmdlLCByZXN1bHRTdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnM7XG4gICAgICAgICAgICBjb3VudGVyc1swXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1sxXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1syXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1szXSA9IDA7XG4gICAgICAgICAgICBsZXQgZW5kID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgICAgIGxldCByb3dPZmZzZXQgPSBzdGFydFJhbmdlWzFdO1xuICAgICAgICAgICAgbGV0IGxnUGF0dGVybkZvdW5kID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNSAmJiByb3dPZmZzZXQgPCBlbmQ7IHgrKykge1xuICAgICAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSBBYnN0cmFjdFVQQ0VBTlJlYWRlci5kZWNvZGVEaWdpdChcbiAgICAgICAgICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgICAgICAgICBjb3VudGVycyxcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5MX0FORF9HX1BBVFRFUk5TKTtcbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJzAnLmNoYXJDb2RlQXQoMCkgKyBiZXN0TWF0Y2ggJSAxMCkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgY291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPj0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgbGdQYXR0ZXJuRm91bmQgfD0gMSA8PCAoNCAtIHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeCAhPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIG9mZiBzZXBhcmF0b3IgaWYgbm90IGxhc3RcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ID0gcm93LmdldE5leHRTZXQocm93T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ID0gcm93LmdldE5leHRVbnNldChyb3dPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHRTdHJpbmcubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hlY2tEaWdpdCA9IHRoaXMuZGV0ZXJtaW5lQ2hlY2tEaWdpdChsZ1BhdHRlcm5Gb3VuZCk7XG4gICAgICAgICAgICBpZiAoVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQuZXh0ZW5zaW9uQ2hlY2tzdW0ocmVzdWx0U3RyaW5nLnRvU3RyaW5nKCkpICE9PSBjaGVja0RpZ2l0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBleHRlbnNpb25DaGVja3N1bShzKSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgICAgIHN1bSArPSBzLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdW0gKj0gMztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgICAgIHN1bSArPSBzLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdW0gKj0gMztcbiAgICAgICAgICAgIHJldHVybiBzdW0gJSAxMDtcbiAgICAgICAgfVxuICAgICAgICBkZXRlcm1pbmVDaGVja0RpZ2l0KGxnUGF0dGVybkZvdW5kKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IDEwOyBkKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGdQYXR0ZXJuRm91bmQgPT09IHRoaXMuQ0hFQ0tfRElHSVRfRU5DT0RJTkdTW2RdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBwYXJzZUV4dGVuc2lvblN0cmluZyhyYXcpIHtcbiAgICAgICAgICAgIGlmIChyYXcubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBVUENFQU5FeHRlbnNpb241U3VwcG9ydC5wYXJzZUV4dGVuc2lvbjVTdHJpbmcocmF3KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hcChbW1Jlc3VsdE1ldGFkYXRhVHlwZSQxLlNVR0dFU1RFRF9QUklDRSwgdmFsdWVdXSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHBhcnNlRXh0ZW5zaW9uNVN0cmluZyhyYXcpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeTtcbiAgICAgICAgICAgIHN3aXRjaCAocmF3LmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeSA9ICfCoyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzUnOlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeSA9ICckJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnOSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZTogaHR0cDovL3d3dy5qb2xseXRlY2guY29tXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocmF3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc5MDAwMCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gc3VnZ2VzdGVkIHJldGFpbCBwcmljZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOTk5OTEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBsZW1lbnRhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzAuMDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOTk5OTAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnVXNlZCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLi4uIHVua25vd24gY3VycmVuY3k/XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJhd0Ftb3VudCA9IHBhcnNlSW50KHJhdy5zdWJzdHJpbmcoMSkpO1xuICAgICAgICAgICAgbGV0IHVuaXRzU3RyaW5nID0gKHJhd0Ftb3VudCAvIDEwMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBodW5kcmVkdGhzID0gcmF3QW1vdW50ICUgMTAwO1xuICAgICAgICAgICAgbGV0IGh1bmRyZWR0aHNTdHJpbmcgPSBodW5kcmVkdGhzIDwgMTAgPyAnMCcgKyBodW5kcmVkdGhzIDogaHVuZHJlZHRocy50b1N0cmluZygpOyAvLyBmaXhtZVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbmN5ICsgdW5pdHNTdHJpbmcgKyAnLicgKyBodW5kcmVkdGhzU3RyaW5nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBVUENFQU5FeHRlbnNpb241U3VwcG9ydFxuICAgICAqL1xuICAgIGNsYXNzIFVQQ0VBTkV4dGVuc2lvbjJTdXBwb3J0IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzID0gSW50MzJBcnJheS5mcm9tKFswLCAwLCAwLCAwXSk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZVJvd1N0cmluZ0J1ZmZlciA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgZXh0ZW5zaW9uU3RhcnRSYW5nZSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuZGVjb2RlUm93U3RyaW5nQnVmZmVyO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMuZGVjb2RlTWlkZGxlKHJvdywgZXh0ZW5zaW9uU3RhcnRSYW5nZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIGxldCByZXN1bHRTdHJpbmcgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb25EYXRhID0gVVBDRUFORXh0ZW5zaW9uMlN1cHBvcnQucGFyc2VFeHRlbnNpb25TdHJpbmcocmVzdWx0U3RyaW5nKTtcbiAgICAgICAgICAgIGxldCByZXN1bHRQb2ludHMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IFJlc3VsdFBvaW50KChleHRlbnNpb25TdGFydFJhbmdlWzBdICsgZXh0ZW5zaW9uU3RhcnRSYW5nZVsxXSkgLyAyLjAsIHJvd051bWJlciksXG4gICAgICAgICAgICAgICAgbmV3IFJlc3VsdFBvaW50KGVuZCwgcm93TnVtYmVyKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb25SZXN1bHQgPSBuZXcgUmVzdWx0KHJlc3VsdFN0cmluZywgbnVsbCwgMCwgcmVzdWx0UG9pbnRzLCBCYXJjb2RlRm9ybWF0JDEuVVBDX0VBTl9FWFRFTlNJT04sIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb25EYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25SZXN1bHQucHV0QWxsTWV0YWRhdGEoZXh0ZW5zaW9uRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZU1pZGRsZShyb3csIHN0YXJ0UmFuZ2UsIHJlc3VsdFN0cmluZykge1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJzID0gdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycztcbiAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzFdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgIGxldCBlbmQgPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IHJvd09mZnNldCA9IHN0YXJ0UmFuZ2VbMV07XG4gICAgICAgICAgICBsZXQgY2hlY2tQYXJpdHkgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAyICYmIHJvd09mZnNldCA8IGVuZDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IEFic3RyYWN0VVBDRUFOUmVhZGVyLmRlY29kZURpZ2l0KHJvdywgY291bnRlcnMsIHJvd09mZnNldCwgQWJzdHJhY3RVUENFQU5SZWFkZXIuTF9BTkRfR19QQVRURVJOUyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgYmVzdE1hdGNoICUgMTApKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb3VudGVyIG9mIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoID49IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrUGFyaXR5IHw9IDEgPDwgKDEgLSB4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHggIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCBvZmYgc2VwYXJhdG9yIGlmIG5vdCBsYXN0XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCA9IHJvdy5nZXROZXh0U2V0KHJvd09mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCA9IHJvdy5nZXROZXh0VW5zZXQocm93T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0U3RyaW5nLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlSW50KHJlc3VsdFN0cmluZy50b1N0cmluZygpKSAlIDQgIT09IGNoZWNrUGFyaXR5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBwYXJzZUV4dGVuc2lvblN0cmluZyhyYXcpIHtcbiAgICAgICAgICAgIGlmIChyYXcubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hcChbW1Jlc3VsdE1ldGFkYXRhVHlwZSQxLklTU1VFX05VTUJFUiwgcGFyc2VJbnQocmF3KV1dKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIFVQQ0VBTkV4dGVuc2lvblN1cHBvcnQge1xuICAgICAgICBzdGF0aWMgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCByb3dPZmZzZXQpIHtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb25TdGFydFJhbmdlID0gQWJzdHJhY3RVUENFQU5SZWFkZXIuZmluZEd1YXJkUGF0dGVybihcbiAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHRoaXMuRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4sXG4gICAgICAgICAgICAgICAgbmV3IEludDMyQXJyYXkodGhpcy5FWFRFTlNJT05fU1RBUlRfUEFUVEVSTi5sZW5ndGgpLmZpbGwoMCkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgZml2ZVN1cHBvcnQgPSBuZXcgVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml2ZVN1cHBvcnQuZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBleHRlbnNpb25TdGFydFJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgdHdvU3VwcG9ydCA9IG5ldyBVUENFQU5FeHRlbnNpb24yU3VwcG9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0d29TdXBwb3J0LmRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgZXh0ZW5zaW9uU3RhcnRSYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgVVBDRUFORXh0ZW5zaW9uU3VwcG9ydC5FWFRFTlNJT05fU1RBUlRfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbMSwgMSwgMl0pO1xuXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGZ1bmN0aW9uYWxpdHkgYW5kIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgY29tbW9uIHRvIFVQQyBhbmQgRUFOIGZhbWlsaWVzXG4gICAgICogb2Ygb25lLWRpbWVuc2lvbmFsIGJhcmNvZGVzLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIGFsYXNkYWlyQGdvb2dsZS5jb20gKEFsYXNkYWlyIE1hY2tpbnRvc2gpXG4gICAgICovXG4gICAgY2xhc3MgVVBDRUFOUmVhZGVyIGV4dGVuZHMgQWJzdHJhY3RVUENFQU5SZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZVJvd1N0cmluZ0J1ZmZlciA9ICcnO1xuICAgICAgICAgICAgVVBDRUFOUmVhZGVyLkxfQU5EX0dfUEFUVEVSTlMgPSBVUENFQU5SZWFkZXIuTF9QQVRURVJOUy5tYXAoYXJyID0+IEludDMyQXJyYXkuZnJvbShhcnIpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxMDsgaSA8IDIwOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgd2lkdGhzID0gVVBDRUFOUmVhZGVyLkxfUEFUVEVSTlNbaSAtIDEwXTtcbiAgICAgICAgICAgICAgICBsZXQgcmV2ZXJzZWRXaWR0aHMgPSBuZXcgSW50MzJBcnJheSh3aWR0aHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlZFdpZHRoc1tqXSA9IHdpZHRoc1t3aWR0aHMubGVuZ3RoIC0gaiAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBVUENFQU5SZWFkZXIuTF9BTkRfR19QQVRURVJOU1tpXSA9IHJldmVyc2VkV2lkdGhzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydEd1YXJkUmFuZ2UgPSBVUENFQU5SZWFkZXIuZmluZFN0YXJ0R3VhcmRQYXR0ZXJuKHJvdyk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0UG9pbnRDYWxsYmFjayA9IGhpbnRzID09IG51bGwgPyBudWxsIDogaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0spO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFBvaW50Q2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdFBvaW50ID0gbmV3IFJlc3VsdFBvaW50KChzdGFydEd1YXJkUmFuZ2VbMF0gKyBzdGFydEd1YXJkUmFuZ2VbMV0pIC8gMi4wLCByb3dOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFBvaW50Q2FsbGJhY2suZm91bmRQb3NzaWJsZVJlc3VsdFBvaW50KHJlc3VsdFBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBidWRlbGxvID0gdGhpcy5kZWNvZGVNaWRkbGUocm93LCBzdGFydEd1YXJkUmFuZ2UsIHRoaXMuZGVjb2RlUm93U3RyaW5nQnVmZmVyKTtcbiAgICAgICAgICAgIGxldCBlbmRTdGFydCA9IGJ1ZGVsbG8ucm93T2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGJ1ZGVsbG8ucmVzdWx0U3RyaW5nO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFBvaW50Q2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdFBvaW50ID0gbmV3IFJlc3VsdFBvaW50KGVuZFN0YXJ0LCByb3dOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFBvaW50Q2FsbGJhY2suZm91bmRQb3NzaWJsZVJlc3VsdFBvaW50KHJlc3VsdFBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbmRSYW5nZSA9IHRoaXMuZGVjb2RlRW5kKHJvdywgZW5kU3RhcnQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFBvaW50Q2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdFBvaW50ID0gbmV3IFJlc3VsdFBvaW50KChlbmRSYW5nZVswXSArIGVuZFJhbmdlWzFdKSAvIDIuMCwgcm93TnVtYmVyKTtcbiAgICAgICAgICAgICAgICByZXN1bHRQb2ludENhbGxiYWNrLmZvdW5kUG9zc2libGVSZXN1bHRQb2ludChyZXN1bHRQb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgaXMgYSBxdWlldCB6b25lIGF0IGxlYXN0IGFzIGJpZyBhcyB0aGUgZW5kIHBhdHRlcm4gYWZ0ZXIgdGhlIGJhcmNvZGUuIFRoZVxuICAgICAgICAgICAgLy8gc3BlYyBtaWdodCB3YW50IG1vcmUgd2hpdGVzcGFjZSwgYnV0IGluIHByYWN0aWNlIHRoaXMgaXMgdGhlIG1heGltdW0gd2UgY2FuIGNvdW50IG9uLlxuICAgICAgICAgICAgbGV0IGVuZCA9IGVuZFJhbmdlWzFdO1xuICAgICAgICAgICAgbGV0IHF1aWV0RW5kID0gZW5kICsgKGVuZCAtIGVuZFJhbmdlWzBdKTtcbiAgICAgICAgICAgIGlmIChxdWlldEVuZCA+PSByb3cuZ2V0U2l6ZSgpIHx8ICFyb3cuaXNSYW5nZShlbmQsIHF1aWV0RW5kLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHRTdHJpbmcgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIFVQQy9FQU4gc2hvdWxkIG5ldmVyIGJlIGxlc3MgdGhhbiA4IGNoYXJzIGFueXdheVxuICAgICAgICAgICAgaWYgKHJlc3VsdFN0cmluZy5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFVUENFQU5SZWFkZXIuY2hlY2tDaGVja3N1bShyZXN1bHRTdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENoZWNrc3VtRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGVmdCA9IChzdGFydEd1YXJkUmFuZ2VbMV0gKyBzdGFydEd1YXJkUmFuZ2VbMF0pIC8gMi4wO1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gKGVuZFJhbmdlWzFdICsgZW5kUmFuZ2VbMF0pIC8gMi4wO1xuICAgICAgICAgICAgbGV0IGZvcm1hdCA9IHRoaXMuZ2V0QmFyY29kZUZvcm1hdCgpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdFBvaW50ID0gW25ldyBSZXN1bHRQb2ludChsZWZ0LCByb3dOdW1iZXIpLCBuZXcgUmVzdWx0UG9pbnQocmlnaHQsIHJvd051bWJlcildO1xuICAgICAgICAgICAgbGV0IGRlY29kZVJlc3VsdCA9IG5ldyBSZXN1bHQocmVzdWx0U3RyaW5nLCBudWxsLCAwLCByZXN1bHRQb2ludCwgZm9ybWF0LCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4dGVuc2lvblJlc3VsdCA9IFVQQ0VBTkV4dGVuc2lvblN1cHBvcnQuZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBlbmRSYW5nZVsxXSk7XG4gICAgICAgICAgICAgICAgZGVjb2RlUmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLlVQQ19FQU5fRVhURU5TSU9OLCBleHRlbnNpb25SZXN1bHQuZ2V0VGV4dCgpKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVSZXN1bHQucHV0QWxsTWV0YWRhdGEoZXh0ZW5zaW9uUmVzdWx0LmdldFJlc3VsdE1ldGFkYXRhKCkpO1xuICAgICAgICAgICAgICAgIGRlY29kZVJlc3VsdC5hZGRSZXN1bHRQb2ludHMoZXh0ZW5zaW9uUmVzdWx0LmdldFJlc3VsdFBvaW50cygpKTtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25MZW5ndGggPSBleHRlbnNpb25SZXN1bHQuZ2V0VGV4dCgpLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVFcnJvcikge31cbiAgICAgICAgICAgIGxldCBhbGxvd2VkRXh0ZW5zaW9ucyA9IGhpbnRzID09IG51bGwgPyBudWxsIDogaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuQUxMT1dFRF9FQU5fRVhURU5TSU9OUyk7XG4gICAgICAgICAgICBpZiAoYWxsb3dlZEV4dGVuc2lvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGxlbmd0aCBpbiBhbGxvd2VkRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uTGVuZ3RoLnRvU3RyaW5nKCkgPT09IGxlbmd0aCkgeyAvLyBjaGVjayBtZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZUVuZChyb3csIGVuZFN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gVVBDRUFOUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4oXG4gICAgICAgICAgICAgICAgcm93LCBlbmRTdGFydCwgZmFsc2UsIFVQQ0VBTlJlYWRlci5TVEFSVF9FTkRfUEFUVEVSTixcbiAgICAgICAgICAgICAgICBuZXcgSW50MzJBcnJheShVUENFQU5SZWFkZXIuU1RBUlRfRU5EX1BBVFRFUk4ubGVuZ3RoKS5maWxsKDApKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2hlY2tDaGVja3N1bShzKSB7XG4gICAgICAgICAgICByZXR1cm4gVVBDRUFOUmVhZGVyLmNoZWNrU3RhbmRhcmRVUENFQU5DaGVja3N1bShzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2hlY2tTdGFuZGFyZFVQQ0VBTkNoZWNrc3VtKHMpIHtcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSBzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IGNoZWNrID0gcGFyc2VJbnQocy5jaGFyQXQobGVuZ3RoIC0gMSksIDEwKTtcbiAgICAgICAgICAgIHJldHVybiBVUENFQU5SZWFkZXIuZ2V0U3RhbmRhcmRVUENFQU5DaGVja3N1bShzLnN1YnN0cmluZygwLCBsZW5ndGggLSAxKSkgPT09IGNoZWNrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRTdGFuZGFyZFVQQ0VBTkNoZWNrc3VtKHMpIHtcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSBzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpZ2l0ID0gcy5jaGFyQXQoaSkuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGlmIChkaWdpdCA8IDAgfHwgZGlnaXQgPiA5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtICs9IGRpZ2l0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VtICo9IDM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlnaXQgPSBzLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZ2l0IDwgMCB8fCBkaWdpdCA+IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdW0gKz0gZGlnaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDEwMDAgLSBzdW0pICUgMTA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8cD5JbXBsZW1lbnRzIGRlY29kaW5nIG9mIHRoZSBFQU4tMTMgZm9ybWF0LjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIGFsYXNkYWlyQGdvb2dsZS5jb20gKEFsYXNkYWlyIE1hY2tpbnRvc2gpXG4gICAgICovXG4gICAgY2xhc3MgRUFOMTNSZWFkZXIgZXh0ZW5kcyBVUENFQU5SZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzID0gSW50MzJBcnJheS5mcm9tKFswLCAwLCAwLCAwXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlTWlkZGxlKHJvdywgc3RhcnRSYW5nZSwgcmVzdWx0U3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgY291bnRlcnMgPSB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzO1xuICAgICAgICAgICAgY291bnRlcnNbMF0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMV0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMl0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgcm93T2Zmc2V0ID0gc3RhcnRSYW5nZVsxXTtcbiAgICAgICAgICAgIGxldCBsZ1BhdHRlcm5Gb3VuZCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDYgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gVVBDRUFOUmVhZGVyLmRlY29kZURpZ2l0KHJvdywgY291bnRlcnMsIHJvd09mZnNldCwgVVBDRUFOUmVhZGVyLkxfQU5EX0dfUEFUVEVSTlMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIGJlc3RNYXRjaCAlIDEwKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY291bnRlciBvZiBjb3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICByb3dPZmZzZXQgKz0gY291bnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICBsZ1BhdHRlcm5Gb3VuZCB8PSAxIDw8ICg1IC0geCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0U3RyaW5nID0gRUFOMTNSZWFkZXIuZGV0ZXJtaW5lRmlyc3REaWdpdChyZXN1bHRTdHJpbmcsIGxnUGF0dGVybkZvdW5kKTtcbiAgICAgICAgICAgIGxldCBtaWRkbGVSYW5nZSA9IFVQQ0VBTlJlYWRlci5maW5kR3VhcmRQYXR0ZXJuKFxuICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICByb3dPZmZzZXQsXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBVUENFQU5SZWFkZXIuTUlERExFX1BBVFRFUk4sXG4gICAgICAgICAgICAgICAgbmV3IEludDMyQXJyYXkoVVBDRUFOUmVhZGVyLk1JRERMRV9QQVRURVJOLmxlbmd0aCkuZmlsbCgwKSk7XG4gICAgICAgICAgICByb3dPZmZzZXQgPSBtaWRkbGVSYW5nZVsxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNiAmJiByb3dPZmZzZXQgPCBlbmQ7IHgrKykge1xuICAgICAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSBVUENFQU5SZWFkZXIuZGVjb2RlRGlnaXQocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBVUENFQU5SZWFkZXIuTF9QQVRURVJOUyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgYmVzdE1hdGNoKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY291bnRlciBvZiBjb3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICByb3dPZmZzZXQgKz0gY291bnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyByb3dPZmZzZXQsIHJlc3VsdFN0cmluZyB9O1xuICAgICAgICB9XG4gICAgICAgIGdldEJhcmNvZGVGb3JtYXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gQmFyY29kZUZvcm1hdCQxLkVBTl8xMztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGV0ZXJtaW5lRmlyc3REaWdpdChyZXN1bHRTdHJpbmcsIGxnUGF0dGVybkZvdW5kKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IDEwOyBkKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGdQYXR0ZXJuRm91bmQgPT09IHRoaXMuRklSU1RfRElHSVRfRU5DT0RJTkdTW2RdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgZCkpICsgcmVzdWx0U3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0U3RyaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEVBTjEzUmVhZGVyLkZJUlNUX0RJR0lUX0VOQ09ESU5HUyA9IFsweDAwLCAweDBCLCAweDBELCAweEUsIDB4MTMsIDB4MTksIDB4MUMsIDB4MTUsIDB4MTYsIDB4MUFdO1xuXG4gICAgLyoqXG4gICAgICogPHA+SW1wbGVtZW50cyBkZWNvZGluZyBvZiB0aGUgRUFOLTggZm9ybWF0LjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRUFOOFJlYWRlciBleHRlbmRzIFVQQ0VBTlJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnMgPSBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVNaWRkbGUocm93LCBzdGFydFJhbmdlLCByZXN1bHRTdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycztcbiAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzFdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgIGxldCBlbmQgPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IHJvd09mZnNldCA9IHN0YXJ0UmFuZ2VbMV07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDQgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gVVBDRUFOUmVhZGVyLmRlY29kZURpZ2l0KHJvdywgY291bnRlcnMsIHJvd09mZnNldCwgVVBDRUFOUmVhZGVyLkxfUEFUVEVSTlMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIGJlc3RNYXRjaCkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgY291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1pZGRsZVJhbmdlID0gVVBDRUFOUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4ocm93LCByb3dPZmZzZXQsIHRydWUsIFVQQ0VBTlJlYWRlci5NSURETEVfUEFUVEVSTiwgbmV3IEludDMyQXJyYXkoVVBDRUFOUmVhZGVyLk1JRERMRV9QQVRURVJOLmxlbmd0aCkuZmlsbCgwKSk7XG4gICAgICAgICAgICByb3dPZmZzZXQgPSBtaWRkbGVSYW5nZVsxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNCAmJiByb3dPZmZzZXQgPCBlbmQ7IHgrKykge1xuICAgICAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSBVUENFQU5SZWFkZXIuZGVjb2RlRGlnaXQocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBVUENFQU5SZWFkZXIuTF9QQVRURVJOUyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgYmVzdE1hdGNoKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY291bnRlciBvZiBjb3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICByb3dPZmZzZXQgKz0gY291bnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyByb3dPZmZzZXQsIHJlc3VsdFN0cmluZyB9O1xuICAgICAgICB9XG4gICAgICAgIGdldEJhcmNvZGVGb3JtYXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gQmFyY29kZUZvcm1hdCQxLkVBTl84O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jYXBzdWxhdGVzIGZ1bmN0aW9uYWxpdHkgYW5kIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgY29tbW9uIHRvIGFsbCBmYW1pbGllc1xuICAgICAqIG9mIG9uZS1kaW1lbnNpb25hbCBiYXJjb2Rlcy5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIHNhbTIzMzIgKFNhbSBSdWRsb2ZmKVxuICAgICAqXG4gICAgICogQHNvdXJjZSBodHRwczovL2dpdGh1Yi5jb20venhpbmcvenhpbmcvYmxvYi8zYzk2OTIzMjc2ZGQ1Nzg1ZDU4ZWI5NzBiNmJhM2Y4MGQzNmE5NTA1L2NvcmUvc3JjL21haW4vamF2YS9jb20vZ29vZ2xlL3p4aW5nL29uZWQvVVBDQVJlYWRlci5qYXZhXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgY2xhc3MgVVBDQVJlYWRlciBleHRlbmRzIFVQQ0VBTlJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuZWFuMTNSZWFkZXIgPSBuZXcgRUFOMTNSZWFkZXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgZ2V0QmFyY29kZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBCYXJjb2RlRm9ybWF0JDEuVVBDX0E7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGRvbid0IHRyeSByb3RhdGlvbiB3aXRob3V0IHRoZSB0cnkgaGFyZGVyIGZsYWcsIGV2ZW4gaWYgcm90YXRpb24gd2FzIHN1cHBvcnRlZC5cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGRlY29kZShpbWFnZSwgaGludHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heWJlUmV0dXJuUmVzdWx0KHRoaXMuZWFuMTNSZWFkZXIuZGVjb2RlKGltYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heWJlUmV0dXJuUmVzdWx0KHRoaXMuZWFuMTNSZWFkZXIuZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBkZWNvZGVNaWRkbGUocm93LCBzdGFydFJhbmdlLCByZXN1bHRTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhbjEzUmVhZGVyLmRlY29kZU1pZGRsZShyb3csIHN0YXJ0UmFuZ2UsIHJlc3VsdFN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgbWF5YmVSZXR1cm5SZXN1bHQocmVzdWx0KSB7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IHJlc3VsdC5nZXRUZXh0KCk7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGxldCB1cGNhUmVzdWx0ID0gbmV3IFJlc3VsdCh0ZXh0LnN1YnN0cmluZygxKSwgbnVsbCwgbnVsbCwgcmVzdWx0LmdldFJlc3VsdFBvaW50cygpLCBCYXJjb2RlRm9ybWF0JDEuVVBDX0EpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZ2V0UmVzdWx0TWV0YWRhdGEoKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwY2FSZXN1bHQucHV0QWxsTWV0YWRhdGEocmVzdWx0LmdldFJlc3VsdE1ldGFkYXRhKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdXBjYVJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgdGhpcy5lYW4xM1JlYWRlci5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPHA+SW1wbGVtZW50cyBkZWNvZGluZyBvZiB0aGUgVVBDLUUgZm9ybWF0LjwvcD5cbiAgICAgKiA8cD48YSBocmVmPVwiaHR0cDovL3d3dy5iYXJjb2RlaXNsYW5kLmNvbS91cGNlLnBodG1sXCI+VGhpczwvYT4gaXMgYSBncmVhdCByZWZlcmVuY2UgZm9yXG4gICAgICogVVBDLUUgaW5mb3JtYXRpb24uPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKlxuICAgICAqIEBzb3VyY2UgaHR0cHM6Ly9naXRodWIuY29tL3p4aW5nL3p4aW5nL2Jsb2IvM2M5NjkyMzI3NmRkNTc4NWQ1OGViOTcwYjZiYTNmODBkMzZhOTUwNS9jb3JlL3NyYy9tYWluL2phdmEvY29tL2dvb2dsZS96eGluZy9vbmVkL1VQQ0VSZWFkZXIuamF2YVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIC8qIGZpbmFsICovIGNsYXNzIFVQQ0VSZWFkZXIgZXh0ZW5kcyBVUENFQU5SZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzID0gbmV3IEludDMyQXJyYXkoNCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBkZWNvZGVNaWRkbGUocm93LCBzdGFydFJhbmdlLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycy5tYXAoeCA9PiB4KTtcbiAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzFdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgcm93T2Zmc2V0ID0gc3RhcnRSYW5nZVsxXTtcbiAgICAgICAgICAgIGxldCBsZ1BhdHRlcm5Gb3VuZCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDYgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSBVUENFUmVhZGVyLmRlY29kZURpZ2l0KFxuICAgICAgICAgICAgICAgICAgICByb3csIGNvdW50ZXJzLCByb3dPZmZzZXQsIFVQQ0VSZWFkZXIuTF9BTkRfR19QQVRURVJOUyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgKGJlc3RNYXRjaCAlIDEwKSkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgY291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPj0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgbGdQYXR0ZXJuRm91bmQgfD0gKDEgPDwgKDUgLSB4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdFN0cmluZyA9IFVQQ0VSZWFkZXIuZGV0ZXJtaW5lTnVtU3lzQW5kQ2hlY2tEaWdpdChcbiAgICAgICAgICAgICAgICByZXN1bHQsIGxnUGF0dGVybkZvdW5kKTtcbiAgICAgICAgICAgIHJldHVybiB7cm93T2Zmc2V0LCByZXN1bHRTdHJpbmd9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgZGVjb2RlRW5kKHJvdywgZW5kU3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBVUENFUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm5XaXRob3V0Q291bnRlcnMoXG4gICAgICAgICAgICAgICAgcm93LCBlbmRTdGFydCwgdHJ1ZSwgVVBDRVJlYWRlci5NSURETEVfRU5EX1BBVFRFUk4pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGNoZWNrQ2hlY2tzdW0ocykge1xuICAgICAgICAgICAgcmV0dXJuIFVQQ0VBTlJlYWRlci5jaGVja0NoZWNrc3VtKFVQQ0VSZWFkZXIuY29udmVydFVQQ0V0b1VQQ0EocykpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGV0ZXJtaW5lTnVtU3lzQW5kQ2hlY2tEaWdpdChyZXN1bHRTdHJpbmcsIGxnUGF0dGVybkZvdW5kKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBudW1TeXMgPSAwOyBudW1TeXMgPD0gMTsgbnVtU3lzKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IDEwOyBkKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxnUGF0dGVybkZvdW5kID09PSB0aGlzLk5VTVNZU19BTkRfQ0hFQ0tfRElHSVRfUEFUVEVSTlNbbnVtU3lzXVtkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByZWZpeCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJzAnLmNoYXJDb2RlQXQoMCkgKyBudW1TeXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJzAnLmNoYXJDb2RlQXQoMCkgKyBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyByZXN1bHRTdHJpbmcgKyBzdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBOb3RGb3VuZEV4Y2VwdGlvbi5nZXROb3RGb3VuZEluc3RhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGdldEJhcmNvZGVGb3JtYXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gQmFyY29kZUZvcm1hdCQxLlVQQ19FO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBhbmRzIGEgVVBDLUUgdmFsdWUgYmFjayBpbnRvIGl0cyBmdWxsLCBlcXVpdmFsZW50IFVQQy1BIGNvZGUgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB1cGNlIFVQQy1FIGNvZGUgYXMgc3RyaW5nIG9mIGRpZ2l0c1xuICAgICAgICAgKiBAcmV0dXJuIGVxdWl2YWxlbnQgVVBDLUEgY29kZSBhcyBzdHJpbmcgb2YgZGlnaXRzXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY29udmVydFVQQ0V0b1VQQ0EodXBjZSkge1xuICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBsaW5lIGlzIGVxdWl2YWxlbnQgdG8gdXBjZS5nZXRDaGFycygxLCA3LCB1cGNlQ2hhcnMsIDApO1xuICAgICAgICAgICAgY29uc3QgdXBjZUNoYXJzID0gdXBjZS5zbGljZSgxLCA3KS5zcGxpdCgnJykubWFwKHggPT4geC5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCAvKjEyKi8pO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh1cGNlLmNoYXJBdCgwKSk7XG4gICAgICAgICAgICBsZXQgbGFzdENoYXIgPSB1cGNlQ2hhcnNbNV07XG4gICAgICAgICAgICBzd2l0Y2ggKGxhc3RDaGFyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRDaGFycyh1cGNlQ2hhcnMsIDAsIDIpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGxhc3RDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnMDAwMCcpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kQ2hhcnModXBjZUNoYXJzLCAyLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kQ2hhcnModXBjZUNoYXJzLCAwLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnMDAwMDAnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZENoYXJzKHVwY2VDaGFycywgMywgMik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZENoYXJzKHVwY2VDaGFycywgMCwgNCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJzAwMDAwJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodXBjZUNoYXJzWzRdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZENoYXJzKHVwY2VDaGFycywgMCwgNSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJzAwMDAnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChsYXN0Q2hhcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSBhcHBlbmQgY2hlY2sgZGlnaXQgaW4gY29udmVyc2lvbiBpZiBzdXBwbGllZFxuICAgICAgICAgICAgaWYgKHVwY2UubGVuZ3RoID49IDgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKHVwY2UuY2hhckF0KDcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcGF0dGVybiB0aGF0IG1hcmtzIHRoZSBtaWRkbGUsIGFuZCBlbmQsIG9mIGEgVVBDLUUgcGF0dGVybi5cbiAgICAgKiBUaGVyZSBpcyBubyBcInNlY29uZCBoYWxmXCIgdG8gYSBVUEMtRSBiYXJjb2RlLlxuICAgICAqL1xuICAgIFVQQ0VSZWFkZXIuTUlERExFX0VORF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxLCAxXSk7XG4gICAgLy8gRm9yIGFuIFVQQy1FIGJhcmNvZGUsIHRoZSBmaW5hbCBkaWdpdCBpcyByZXByZXNlbnRlZCBieSB0aGUgcGFyaXRpZXMgdXNlZFxuICAgIC8vIHRvIGVuY29kZSB0aGUgbWlkZGxlIHNpeCBkaWdpdHMsIGFjY29yZGluZyB0byB0aGUgdGFibGUgYmVsb3cuXG4gICAgLy9cbiAgICAvLyAgICAgICAgICAgICAgICBQYXJpdHkgb2YgbmV4dCA2IGRpZ2l0c1xuICAgIC8vICAgIERpZ2l0ICAgMCAgICAgMSAgICAgMiAgICAgMyAgICAgNCAgICAgNVxuICAgIC8vICAgICAgIDAgICAgRXZlbiAgIEV2ZW4gIEV2ZW4gT2RkICBPZGQgICBPZGRcbiAgICAvLyAgICAgICAxICAgIEV2ZW4gICBFdmVuICBPZGQgIEV2ZW4gT2RkICAgT2RkXG4gICAgLy8gICAgICAgMiAgICBFdmVuICAgRXZlbiAgT2RkICBPZGQgIEV2ZW4gIE9kZFxuICAgIC8vICAgICAgIDMgICAgRXZlbiAgIEV2ZW4gIE9kZCAgT2RkICBPZGQgICBFdmVuXG4gICAgLy8gICAgICAgNCAgICBFdmVuICAgT2RkICAgRXZlbiBFdmVuIE9kZCAgIE9kZFxuICAgIC8vICAgICAgIDUgICAgRXZlbiAgIE9kZCAgIE9kZCAgRXZlbiBFdmVuICBPZGRcbiAgICAvLyAgICAgICA2ICAgIEV2ZW4gICBPZGQgICBPZGQgIE9kZCAgRXZlbiAgRXZlblxuICAgIC8vICAgICAgIDcgICAgRXZlbiAgIE9kZCAgIEV2ZW4gT2RkICBFdmVuICBPZGRcbiAgICAvLyAgICAgICA4ICAgIEV2ZW4gICBPZGQgICBFdmVuIE9kZCAgT2RkICAgRXZlblxuICAgIC8vICAgICAgIDkgICAgRXZlbiAgIE9kZCAgIE9kZCAgRXZlbiBPZGQgICBFdmVuXG4gICAgLy9cbiAgICAvLyBUaGUgZW5jb2RpbmcgaXMgcmVwcmVzZW50ZWQgYnkgdGhlIGZvbGxvd2luZyBhcnJheSwgd2hpY2ggaXMgYSBiaXQgcGF0dGVyblxuICAgIC8vIHVzaW5nIE9kZCA9IDAgYW5kIEV2ZW4gPSAxLiBGb3IgZXhhbXBsZSwgNSBpcyByZXByZXNlbnRlZCBieTpcbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgICBPZGQgRXZlbiBFdmVuIE9kZCBPZGQgRXZlblxuICAgIC8vIGluIGJpbmFyeTpcbiAgICAvLyAgICAgICAgICAgICAgICAwICAgIDEgICAgMSAgIDAgICAwICAgIDEgICA9PSAweDE5XG4gICAgLy9cbiAgICAvKipcbiAgICAgKiBTZWUge0BsaW5rICNMX0FORF9HX1BBVFRFUk5TfTsgdGhlc2UgdmFsdWVzIHNpbWlsYXJseSByZXByZXNlbnQgcGF0dGVybnMgb2ZcbiAgICAgKiBldmVuLW9kZCBwYXJpdHkgZW5jb2RpbmdzIG9mIGRpZ2l0cyB0aGF0IGltcGx5IGJvdGggdGhlIG51bWJlciBzeXN0ZW0gKDAgb3IgMSlcbiAgICAgKiB1c2VkLCBhbmQgdGhlIGNoZWNrIGRpZ2l0LlxuICAgICAqL1xuICAgIFVQQ0VSZWFkZXIuTlVNU1lTX0FORF9DSEVDS19ESUdJVF9QQVRURVJOUyA9IFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDM4LCAweDM0LCAweDMyLCAweDMxLCAweDJDLCAweDI2LCAweDIzLCAweDJBLCAweDI5LCAweDI1XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgwNywgMHgwQiwgMHgwRCwgMHgwRSwgMHgxMywgMHgxOSwgMHgxQywgMHgxNSwgMHgxNiwgMHgxQV0pLFxuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiA8cD5BIHJlYWRlciB0aGF0IGNhbiByZWFkIGFsbCBhdmFpbGFibGUgVVBDL0VBTiBmb3JtYXRzLiBJZiBhIGNhbGxlciB3YW50cyB0byB0cnkgdG9cbiAgICAgKiByZWFkIGFsbCBzdWNoIGZvcm1hdHMsIGl0IGlzIG1vc3QgZWZmaWNpZW50IHRvIHVzZSB0aGlzIGltcGxlbWVudGF0aW9uIHJhdGhlciB0aGFuIGludm9rZVxuICAgICAqIGluZGl2aWR1YWwgcmVhZGVycy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIE11bHRpRm9ybWF0VVBDRUFOUmVhZGVyIGV4dGVuZHMgT25lRFJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGhpbnRzKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgbGV0IHBvc3NpYmxlRm9ybWF0cyA9IGhpbnRzID09IG51bGwgPyBudWxsIDogaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuUE9TU0lCTEVfRk9STUFUUyk7XG4gICAgICAgICAgICBsZXQgcmVhZGVycyA9IFtdO1xuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwb3NzaWJsZUZvcm1hdHMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmRleE9mKEJhcmNvZGVGb3JtYXQkMS5FQU5fMTMpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBFQU4xM1JlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmRleE9mKEJhcmNvZGVGb3JtYXQkMS5VUENfQSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IFVQQ0FSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5kZXhPZihCYXJjb2RlRm9ybWF0JDEuRUFOXzgpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBFQU44UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluZGV4T2YoQmFyY29kZUZvcm1hdCQxLlVQQ19FKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgVVBDRVJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vIGhpbnRzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgRUFOMTNSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBVUENBUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgRUFOOFJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IFVQQ0VSZWFkZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWRlcnMgPSByZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJlYWRlciBvZiB0aGlzLnJlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCByZXN1bHQ6IFJlc3VsdCA9IHJlYWRlci5kZWNvZGVSb3cocm93TnVtYmVyLCByb3csIHN0YXJ0R3VhcmRQYXR0ZXJuLCBoaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlYWRlci5kZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBhIDEyLWRpZ2l0IGNvZGUgZW5jb2RlZCBpbiBVUEMtQSBpcyBpZGVudGljYWwgdG8gYSBcIjBcIlxuICAgICAgICAgICAgICAgICAgICAvLyBmb2xsb3dlZCBieSB0aG9zZSAxMiBkaWdpdHMgZW5jb2RlZCBhcyBFQU4tMTMuIEVhY2ggd2lsbCByZWNvZ25pemUgc3VjaCBhIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIFVQQy1BIGFzIGEgMTItZGlnaXQgc3RyaW5nIGFuZCBFQU4tMTMgYXMgYSAxMy1kaWdpdCBzdHJpbmcgc3RhcnRpbmcgd2l0aCBcIjBcIi5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5kaXZpZHVhbGx5IHRoZXNlIGFyZSBjb3JyZWN0IGFuZCB0aGVpciByZWFkZXJzIHdpbGwgYm90aCByZWFkIHN1Y2ggYSBjb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBjb3JyZWN0bHkgY2FsbCBpdCBFQU4tMTMsIG9yIFVQQy1BLCByZXNwZWN0aXZlbHkuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgaWYgd2UndmUgYmVlbiBsb29raW5nIGZvciBib3RoIHR5cGVzLCB3ZSdkIGxpa2UgdG8gY2FsbCBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBhIFVQQy1BIGNvZGUuIEJ1dCBmb3IgZWZmaWNpZW5jeSB3ZSBvbmx5IHJ1biB0aGUgRUFOLTEzIGRlY29kZXIgdG8gYWxzbyByZWFkXG4gICAgICAgICAgICAgICAgICAgIC8vIFVQQy1BLiBTbyB3ZSBzcGVjaWFsIGNhc2UgaXQgaGVyZSwgYW5kIGNvbnZlcnQgYW4gRUFOLTEzIHJlc3VsdCB0byBhIFVQQy1BXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdCBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0LCBkb24ndCByZXR1cm4gVVBDLUEgaWYgVVBDLUEgd2FzIG5vdCBhIHJlcXVlc3RlZCBmb3JtYXQhXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVhbjEzTWF5QmVVUENBID0gcmVzdWx0LmdldEJhcmNvZGVGb3JtYXQoKSA9PT0gQmFyY29kZUZvcm1hdCQxLkVBTl8xMyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmdldFRleHQoKS5jaGFyQXQoMCkgPT09ICcwJztcbiAgICAgICAgICAgICAgICAgICAgLy8gQFN1cHByZXNzV2FybmluZ3MoXCJ1bmNoZWNrZWRcIilcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zc2libGVGb3JtYXRzID0gaGludHMgPT0gbnVsbCA/IG51bGwgOiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5QT1NTSUJMRV9GT1JNQVRTKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FuUmV0dXJuVVBDQSA9IHBvc3NpYmxlRm9ybWF0cyA9PSBudWxsIHx8IHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0JDEuVVBDX0EpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWFuMTNNYXlCZVVQQ0EgJiYgY2FuUmV0dXJuVVBDQSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3Qnl0ZXMgPSByZXN1bHQuZ2V0UmF3Qnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZmVyIHRoZSBtZXRhZGF0YSBhY3Jvc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdFVQQ0EgPSBuZXcgUmVzdWx0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5nZXRUZXh0KCkuc3Vic3RyaW5nKDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd0J5dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyYXdCeXRlcyA/IHJhd0J5dGVzLmxlbmd0aCA6IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5nZXRSZXN1bHRQb2ludHMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCYXJjb2RlRm9ybWF0JDEuVVBDX0EpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0VVBDQS5wdXRBbGxNZXRhZGF0YShyZXN1bHQuZ2V0UmVzdWx0TWV0YWRhdGEoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0VVBDQTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgZm9yIChsZXQgcmVhZGVyIG9mIHRoaXMucmVhZGVycykge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaW1wb3J0IEludGVnZXIgZnJvbSAnLi4vLi4vdXRpbC9JbnRlZ2VyJztcbiAgICAvLyBpbXBvcnQgRmxvYXQgZnJvbSAnLi4vLi4vdXRpbC9GbG9hdCc7XG4gICAgY2xhc3MgQWJzdHJhY3RSU1NSZWFkZXIgZXh0ZW5kcyBPbmVEUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVGaW5kZXJDb3VudGVycyA9IG5ldyBJbnQzMkFycmF5KDQpO1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhcmFjdGVyQ291bnRlcnMgPSBuZXcgSW50MzJBcnJheSg4KTtcbiAgICAgICAgICAgIHRoaXMub2RkUm91bmRpbmdFcnJvcnMgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgICAgICB0aGlzLmV2ZW5Sb3VuZGluZ0Vycm9ycyA9IG5ldyBBcnJheSg0KTtcbiAgICAgICAgICAgIHRoaXMub2RkQ291bnRzID0gbmV3IEFycmF5KHRoaXMuZGF0YUNoYXJhY3RlckNvdW50ZXJzLmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgdGhpcy5ldmVuQ291bnRzID0gbmV3IEFycmF5KHRoaXMuZGF0YUNoYXJhY3RlckNvdW50ZXJzLmxlbmd0aCAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIGdldERlY29kZUZpbmRlckNvdW50ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRmluZGVyQ291bnRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGF0YUNoYXJhY3RlckNvdW50ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUNoYXJhY3RlckNvdW50ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGdldE9kZFJvdW5kaW5nRXJyb3JzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2RkUm91bmRpbmdFcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RXZlblJvdW5kaW5nRXJyb3JzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlblJvdW5kaW5nRXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIGdldE9kZENvdW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9kZENvdW50cztcbiAgICAgICAgfVxuICAgICAgICBnZXRFdmVuQ291bnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbkNvdW50cztcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUZpbmRlclZhbHVlKGNvdW50ZXJzLCBmaW5kZXJQYXR0ZXJucykge1xuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgPSAwOyB2YWx1ZSA8IGZpbmRlclBhdHRlcm5zLmxlbmd0aDsgdmFsdWUrKykge1xuICAgICAgICAgICAgICAgIGlmIChPbmVEUmVhZGVyLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBmaW5kZXJQYXR0ZXJuc1t2YWx1ZV0sIEFic3RyYWN0UlNTUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKSA8IEFic3RyYWN0UlNTUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYXJyYXkgdmFsdWVzIHRvIHN1bVxuICAgICAgICAgKiBAcmV0dXJuIHN1bSBvZiB2YWx1ZXNcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgY2FsbCB7QGxpbmsgTWF0aFV0aWxzI3N1bShpbnRbXSl9XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY291bnQoYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMuc3VtKG5ldyBJbnQzMkFycmF5KGFycmF5KSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGluY3JlbWVudChhcnJheSwgZXJyb3JzKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IGJpZ2dlc3RFcnJvciA9IGVycm9yc1swXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzW2ldID4gYmlnZ2VzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpZ2dlc3RFcnJvciA9IGVycm9yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFycmF5W2luZGV4XSsrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWNyZW1lbnQoYXJyYXksIGVycm9ycykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBiaWdnZXN0RXJyb3IgPSBlcnJvcnNbMF07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yc1tpXSA8IGJpZ2dlc3RFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBiaWdnZXN0RXJyb3IgPSBlcnJvcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcnJheVtpbmRleF0tLTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXNGaW5kZXJQYXR0ZXJuKGNvdW50ZXJzKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3RUd29TdW0gPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xuICAgICAgICAgICAgbGV0IHN1bSA9IGZpcnN0VHdvU3VtICsgY291bnRlcnNbMl0gKyBjb3VudGVyc1szXTtcbiAgICAgICAgICAgIGxldCByYXRpbyA9IGZpcnN0VHdvU3VtIC8gc3VtO1xuICAgICAgICAgICAgaWYgKHJhdGlvID49IEFic3RyYWN0UlNTUmVhZGVyLk1JTl9GSU5ERVJfUEFUVEVSTl9SQVRJTyAmJiByYXRpbyA8PSBBYnN0cmFjdFJTU1JlYWRlci5NQVhfRklOREVSX1BBVFRFUk5fUkFUSU8pIHtcbiAgICAgICAgICAgICAgICAvLyBwYXNzZXMgcmF0aW8gdGVzdCBpbiBzcGVjLCBidXQgc2VlIGlmIHRoZSBjb3VudHMgYXJlIHVucmVhc29uYWJsZVxuICAgICAgICAgICAgICAgIGxldCBtaW5Db3VudGVyID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICAgICAgbGV0IG1heENvdW50ZXIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb3VudGVyIG9mIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyID4gbWF4Q291bnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4Q291bnRlciA9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXIgPCBtaW5Db3VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5Db3VudGVyID0gY291bnRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF4Q291bnRlciA8IDEwICogbWluQ291bnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBYnN0cmFjdFJTU1JlYWRlci5NQVhfQVZHX1ZBUklBTkNFID0gMC4yO1xuICAgIEFic3RyYWN0UlNTUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFID0gMC40NTtcbiAgICBBYnN0cmFjdFJTU1JlYWRlci5NSU5fRklOREVSX1BBVFRFUk5fUkFUSU8gPSA5LjUgLyAxMi4wO1xuICAgIEFic3RyYWN0UlNTUmVhZGVyLk1BWF9GSU5ERVJfUEFUVEVSTl9SQVRJTyA9IDEyLjUgLyAxNC4wO1xuXG4gICAgY2xhc3MgRGF0YUNoYXJhY3RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBjaGVja3N1bVBvcnRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tzdW1Qb3J0aW9uID0gY2hlY2tzdW1Qb3J0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q2hlY2tzdW1Qb3J0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tzdW1Qb3J0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgKyAnKCcgKyB0aGlzLmNoZWNrc3VtUG9ydGlvbiArICcpJztcbiAgICAgICAgfVxuICAgICAgICBlcXVhbHMobykge1xuICAgICAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIERhdGFDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGhhdCA9IG87XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gdGhhdC52YWx1ZSAmJiB0aGlzLmNoZWNrc3VtUG9ydGlvbiA9PT0gdGhhdC5jaGVja3N1bVBvcnRpb247XG4gICAgICAgIH1cbiAgICAgICAgaGFzaENvZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSBeIHRoaXMuY2hlY2tzdW1Qb3J0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgRmluZGVyUGF0dGVybiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBzdGFydEVuZCwgc3RhcnQsIGVuZCwgcm93TnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RW5kID0gc3RhcnRFbmQ7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RW5kID0gc3RhcnRFbmQ7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludHMucHVzaChuZXcgUmVzdWx0UG9pbnQoc3RhcnQsIHJvd051bWJlcikpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludHMucHVzaChuZXcgUmVzdWx0UG9pbnQoZW5kLCByb3dOdW1iZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGdldFN0YXJ0RW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRFbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UmVzdWx0UG9pbnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0UG9pbnRzO1xuICAgICAgICB9XG4gICAgICAgIGVxdWFscyhvKSB7XG4gICAgICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgRmluZGVyUGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aGF0ID0gbztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSB0aGF0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGhhc2hDb2RlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSU1MgdXRpbCBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgUlNTVXRpbHMge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgICAgICBzdGF0aWMgZ2V0UlNTdmFsdWUod2lkdGhzLCBtYXhXaWR0aCwgbm9OYXJyb3cpIHtcbiAgICAgICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpZHRoIG9mIHdpZHRocykge1xuICAgICAgICAgICAgICAgIG4gKz0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsID0gMDtcbiAgICAgICAgICAgIGxldCBuYXJyb3dNYXNrID0gMDtcbiAgICAgICAgICAgIGxldCBlbGVtZW50cyA9IHdpZHRocy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBiYXIgPSAwOyBiYXIgPCBlbGVtZW50cyAtIDE7IGJhcisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVsbVdpZHRoO1xuICAgICAgICAgICAgICAgIGZvciAoZWxtV2lkdGggPSAxLCBuYXJyb3dNYXNrIHw9IDEgPDwgYmFyOyBlbG1XaWR0aCA8IHdpZHRoc1tiYXJdOyBlbG1XaWR0aCsrLCBuYXJyb3dNYXNrICY9IH4oMSA8PCBiYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWJWYWwgPSBSU1NVdGlscy5jb21iaW5zKG4gLSBlbG1XaWR0aCAtIDEsIGVsZW1lbnRzIC0gYmFyIC0gMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub05hcnJvdyAmJiAobmFycm93TWFzayA9PT0gMCkgJiYgKG4gLSBlbG1XaWR0aCAtIChlbGVtZW50cyAtIGJhciAtIDEpID49IGVsZW1lbnRzIC0gYmFyIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlZhbCAtPSBSU1NVdGlscy5jb21iaW5zKG4gLSBlbG1XaWR0aCAtIChlbGVtZW50cyAtIGJhciksIGVsZW1lbnRzIC0gYmFyIC0gMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzIC0gYmFyIC0gMSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsZXNzVmFsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG14d0VsZW1lbnQgPSBuIC0gZWxtV2lkdGggLSAoZWxlbWVudHMgLSBiYXIgLSAyKTsgbXh3RWxlbWVudCA+IG1heFdpZHRoOyBteHdFbGVtZW50LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXNzVmFsICs9IFJTU1V0aWxzLmNvbWJpbnMobiAtIGVsbVdpZHRoIC0gbXh3RWxlbWVudCAtIDEsIGVsZW1lbnRzIC0gYmFyIC0gMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJWYWwgLT0gbGVzc1ZhbCAqIChlbGVtZW50cyAtIDEgLSBiYXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG4gLSBlbG1XaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJWYWwtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWwgKz0gc3ViVmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuIC09IGVsbVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY29tYmlucyhuLCByKSB7XG4gICAgICAgICAgICBsZXQgbWF4RGVub207XG4gICAgICAgICAgICBsZXQgbWluRGVub207XG4gICAgICAgICAgICBpZiAobiAtIHIgPiByKSB7XG4gICAgICAgICAgICAgICAgbWluRGVub20gPSByO1xuICAgICAgICAgICAgICAgIG1heERlbm9tID0gbiAtIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW5EZW5vbSA9IG4gLSByO1xuICAgICAgICAgICAgICAgIG1heERlbm9tID0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2YWwgPSAxO1xuICAgICAgICAgICAgbGV0IGogPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG47IGkgPiBtYXhEZW5vbTsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFsICo9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGogPD0gbWluRGVub20pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsIC89IGo7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoKGogPD0gbWluRGVub20pKSB7XG4gICAgICAgICAgICAgICAgdmFsIC89IGo7XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIEJpdEFycmF5QnVpbGRlciB7XG4gICAgICAgIHN0YXRpYyBidWlsZEJpdEFycmF5KHBhaXJzKSB7XG4gICAgICAgICAgICBsZXQgY2hhck51bWJlciA9IChwYWlycy5sZW5ndGggKiAyKSAtIDE7XG4gICAgICAgICAgICBpZiAocGFpcnNbcGFpcnMubGVuZ3RoIC0gMV0uZ2V0UmlnaHRDaGFyKCkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoYXJOdW1iZXIgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaXplID0gMTIgKiBjaGFyTnVtYmVyO1xuICAgICAgICAgICAgbGV0IGJpbmFyeSA9IG5ldyBCaXRBcnJheShzaXplKTtcbiAgICAgICAgICAgIGxldCBhY2NQb3MgPSAwO1xuICAgICAgICAgICAgbGV0IGZpcnN0UGFpciA9IHBhaXJzWzBdO1xuICAgICAgICAgICAgbGV0IGZpcnN0VmFsdWUgPSBmaXJzdFBhaXIuZ2V0UmlnaHRDaGFyKCkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGZpcnN0VmFsdWUgJiAoMSA8PCBpKSkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBiaW5hcnkuc2V0KGFjY1Bvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY1BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYWlycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50UGFpciA9IHBhaXJzW2ldO1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0VmFsdWUgPSBjdXJyZW50UGFpci5nZXRMZWZ0Q2hhcigpLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDExOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGxlZnRWYWx1ZSAmICgxIDw8IGopKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnkuc2V0KGFjY1Bvcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWNjUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFpci5nZXRSaWdodENoYXIoKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByaWdodFZhbHVlID0gY3VycmVudFBhaXIuZ2V0UmlnaHRDaGFyKCkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDExOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyaWdodFZhbHVlICYgKDEgPDwgaikpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnkuc2V0KGFjY1Bvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaW5hcnk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBCbG9ja1BhcnNlZFJlc3VsdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGZpbmlzaGVkLCBkZWNvZGVkSW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChkZWNvZGVkSW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZWRJbmZvcm1hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVkSW5mb3JtYXRpb24gPSBkZWNvZGVkSW5mb3JtYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGVjb2RlZEluZm9ybWF0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlZEluZm9ybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlzRmluaXNoZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIERlY29kZWRPYmplY3Qge1xuICAgICAgICBjb25zdHJ1Y3RvcihuZXdQb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5uZXdQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldE5ld1Bvc2l0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV3UG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBEZWNvZGVkQ2hhciBleHRlbmRzIERlY29kZWRPYmplY3Qge1xuICAgICAgICBjb25zdHJ1Y3RvcihuZXdQb3NpdGlvbiwgdmFsdWUpIHtcbiAgICAgICAgICAgIHN1cGVyKG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlzRk5DMSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBEZWNvZGVkQ2hhci5GTkMxO1xuICAgICAgICB9XG4gICAgfVxuICAgIERlY29kZWRDaGFyLkZOQzEgPSAnJCc7XG5cbiAgICBjbGFzcyBEZWNvZGVkSW5mb3JtYXRpb24gZXh0ZW5kcyBEZWNvZGVkT2JqZWN0IHtcbiAgICAgICAgY29uc3RydWN0b3IobmV3UG9zaXRpb24sIG5ld1N0cmluZywgcmVtYWluaW5nVmFsdWUpIHtcbiAgICAgICAgICAgIHN1cGVyKG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbWFpbmluZ1ZhbHVlID0gdGhpcy5yZW1haW5pbmdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1haW5pbmdWYWx1ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5ld1N0cmluZyA9IG5ld1N0cmluZztcbiAgICAgICAgfVxuICAgICAgICBnZXROZXdTdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXdTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaXNSZW1haW5pbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1haW5pbmc7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UmVtYWluaW5nVmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1haW5pbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIERlY29kZWROdW1lcmljIGV4dGVuZHMgRGVjb2RlZE9iamVjdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG5ld1Bvc2l0aW9uLCBmaXJzdERpZ2l0LCBzZWNvbmREaWdpdCkge1xuICAgICAgICAgICAgc3VwZXIobmV3UG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKGZpcnN0RGlnaXQgPCAwIHx8IGZpcnN0RGlnaXQgPiAxMCB8fCBzZWNvbmREaWdpdCA8IDAgfHwgc2Vjb25kRGlnaXQgPiAxMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmlyc3REaWdpdCA9IGZpcnN0RGlnaXQ7XG4gICAgICAgICAgICB0aGlzLnNlY29uZERpZ2l0ID0gc2Vjb25kRGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Rmlyc3REaWdpdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0RGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U2Vjb25kRGlnaXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmREaWdpdDtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0RGlnaXQgKiAxMCArIHRoaXMuc2Vjb25kRGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaXNGaXJzdERpZ2l0Rk5DMSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0RGlnaXQgPT09IERlY29kZWROdW1lcmljLkZOQzE7XG4gICAgICAgIH1cbiAgICAgICAgaXNTZWNvbmREaWdpdEZOQzEoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmREaWdpdCA9PT0gRGVjb2RlZE51bWVyaWMuRk5DMTtcbiAgICAgICAgfVxuICAgICAgICBpc0FueUZOQzEoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdERpZ2l0ID09PSBEZWNvZGVkTnVtZXJpYy5GTkMxIHx8IHRoaXMuc2Vjb25kRGlnaXQgPT09IERlY29kZWROdW1lcmljLkZOQzE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGVjb2RlZE51bWVyaWMuRk5DMSA9IDEwO1xuXG4gICAgY2xhc3MgRmllbGRQYXJzZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcGFyc2VGaWVsZHNJbkdlbmVyYWxQdXJwb3NlKHJhd0luZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXJhd0luZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcm9jZXNzaW5nIDItZGlnaXQgQUlzXG4gICAgICAgICAgICBpZiAocmF3SW5mb3JtYXRpb24ubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZpcnN0VHdvRGlnaXRzID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKDAsIDIpO1xuICAgICAgICAgICAgZm9yIChsZXQgZGF0YUxlbmd0aCBvZiBGaWVsZFBhcnNlci5UV09fRElHSVRfREFUQV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFswXSA9PT0gZmlyc3RUd29EaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMV0gPT09IEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpZWxkUGFyc2VyLnByb2Nlc3NWYXJpYWJsZUFJKDIsIGRhdGFMZW5ndGhbMl0sIHJhd0luZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc0ZpeGVkQUkoMiwgZGF0YUxlbmd0aFsxXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyYXdJbmZvcm1hdGlvbi5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmlyc3RUaHJlZURpZ2l0cyA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZygwLCAzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGRhdGFMZW5ndGggb2YgRmllbGRQYXJzZXIuVEhSRUVfRElHSVRfREFUQV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFswXSA9PT0gZmlyc3RUaHJlZURpZ2l0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFsxXSA9PT0gRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc1ZhcmlhYmxlQUkoMywgZGF0YUxlbmd0aFsyXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZFBhcnNlci5wcm9jZXNzRml4ZWRBSSgzLCBkYXRhTGVuZ3RoWzFdLCByYXdJbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZGF0YUxlbmd0aCBvZiBGaWVsZFBhcnNlci5USFJFRV9ESUdJVF9QTFVTX0RJR0lUX0RBVEFfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMF0gPT09IGZpcnN0VGhyZWVEaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMV0gPT09IEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpZWxkUGFyc2VyLnByb2Nlc3NWYXJpYWJsZUFJKDQsIGRhdGFMZW5ndGhbMl0sIHJhd0luZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc0ZpeGVkQUkoNCwgZGF0YUxlbmd0aFsxXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyYXdJbmZvcm1hdGlvbi5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmlyc3RGb3VyRGlnaXRzID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKDAsIDQpO1xuICAgICAgICAgICAgZm9yIChsZXQgZGF0YUxlbmd0aCBvZiBGaWVsZFBhcnNlci5GT1VSX0RJR0lUX0RBVEFfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMF0gPT09IGZpcnN0Rm91ckRpZ2l0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFsxXSA9PT0gRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc1ZhcmlhYmxlQUkoNCwgZGF0YUxlbmd0aFsyXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZFBhcnNlci5wcm9jZXNzRml4ZWRBSSg0LCBkYXRhTGVuZ3RoWzFdLCByYXdJbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHByb2Nlc3NGaXhlZEFJKGFpU2l6ZSwgZmllbGRTaXplLCByYXdJbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgaWYgKHJhd0luZm9ybWF0aW9uLmxlbmd0aCA8IGFpU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFpID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKDAsIGFpU2l6ZSk7XG4gICAgICAgICAgICBpZiAocmF3SW5mb3JtYXRpb24ubGVuZ3RoIDwgYWlTaXplICsgZmllbGRTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmllbGQgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoYWlTaXplLCBhaVNpemUgKyBmaWVsZFNpemUpO1xuICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZyhhaVNpemUgKyBmaWVsZFNpemUpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICcoJyArIGFpICsgJyknICsgZmllbGQ7XG4gICAgICAgICAgICBsZXQgcGFyc2VkQUkgPSBGaWVsZFBhcnNlci5wYXJzZUZpZWxkc0luR2VuZXJhbFB1cnBvc2UocmVtYWluaW5nKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRBSSA9PSBudWxsID8gcmVzdWx0IDogcmVzdWx0ICsgcGFyc2VkQUk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHByb2Nlc3NWYXJpYWJsZUFJKGFpU2l6ZSwgdmFyaWFibGVGaWVsZFNpemUsIHJhd0luZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBsZXQgYWkgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoMCwgYWlTaXplKTtcbiAgICAgICAgICAgIGxldCBtYXhTaXplO1xuICAgICAgICAgICAgaWYgKHJhd0luZm9ybWF0aW9uLmxlbmd0aCA8IGFpU2l6ZSArIHZhcmlhYmxlRmllbGRTaXplKSB7XG4gICAgICAgICAgICAgICAgbWF4U2l6ZSA9IHJhd0luZm9ybWF0aW9uLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1heFNpemUgPSBhaVNpemUgKyB2YXJpYWJsZUZpZWxkU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmaWVsZCA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZyhhaVNpemUsIG1heFNpemUpO1xuICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZyhtYXhTaXplKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAnKCcgKyBhaSArICcpJyArIGZpZWxkO1xuICAgICAgICAgICAgbGV0IHBhcnNlZEFJID0gRmllbGRQYXJzZXIucGFyc2VGaWVsZHNJbkdlbmVyYWxQdXJwb3NlKHJlbWFpbmluZyk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkQUkgPT0gbnVsbCA/IHJlc3VsdCA6IHJlc3VsdCArIHBhcnNlZEFJO1xuICAgICAgICB9XG4gICAgfVxuICAgIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCA9IFtdO1xuICAgIEZpZWxkUGFyc2VyLlRXT19ESUdJVF9EQVRBX0xFTkdUSCA9IFtcbiAgICAgICAgWycwMCcsIDE4XSxcbiAgICAgICAgWycwMScsIDE0XSxcbiAgICAgICAgWycwMicsIDE0XSxcbiAgICAgICAgWycxMCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMjBdLFxuICAgICAgICBbJzExJywgNl0sXG4gICAgICAgIFsnMTInLCA2XSxcbiAgICAgICAgWycxMycsIDZdLFxuICAgICAgICBbJzE1JywgNl0sXG4gICAgICAgIFsnMTcnLCA2XSxcbiAgICAgICAgWycyMCcsIDJdLFxuICAgICAgICBbJzIxJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAyMF0sXG4gICAgICAgIFsnMjInLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDI5XSxcbiAgICAgICAgWyczMCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgOF0sXG4gICAgICAgIFsnMzcnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDhdLFxuICAgICAgICAvLyBpbnRlcm5hbCBjb21wYW55IGNvZGVzXG4gICAgICAgIFsnOTAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5MScsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzkyJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnOTMnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5NCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzk1JywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnOTYnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5NycsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgM10sXG4gICAgICAgIFsnOTgnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5OScsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgIF07XG4gICAgRmllbGRQYXJzZXIuVEhSRUVfRElHSVRfREFUQV9MRU5HVEggPSBbXG4gICAgICAgIC8vIFNhbWUgZm9ybWF0IGFzIGFib3ZlXG4gICAgICAgIFsnMjQwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnMjQxJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnMjQyJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCA2XSxcbiAgICAgICAgWycyNTAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWycyNTEnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWycyNTMnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE3XSxcbiAgICAgICAgWycyNTQnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDIwXSxcbiAgICAgICAgWyc0MDAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc0MDEnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc0MDInLCAxN10sXG4gICAgICAgIFsnNDAzJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnNDEwJywgMTNdLFxuICAgICAgICBbJzQxMScsIDEzXSxcbiAgICAgICAgWyc0MTInLCAxM10sXG4gICAgICAgIFsnNDEzJywgMTNdLFxuICAgICAgICBbJzQxNCcsIDEzXSxcbiAgICAgICAgWyc0MjAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDIwXSxcbiAgICAgICAgWyc0MjEnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE1XSxcbiAgICAgICAgWyc0MjInLCAzXSxcbiAgICAgICAgWyc0MjMnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE1XSxcbiAgICAgICAgWyc0MjQnLCAzXSxcbiAgICAgICAgWyc0MjUnLCAzXSxcbiAgICAgICAgWyc0MjYnLCAzXSxcbiAgICBdO1xuICAgIEZpZWxkUGFyc2VyLlRIUkVFX0RJR0lUX1BMVVNfRElHSVRfREFUQV9MRU5HVEggPSBbXG4gICAgICAgIC8vIFNhbWUgZm9ybWF0IGFzIGFib3ZlXG4gICAgICAgIFsnMzEwJywgNl0sXG4gICAgICAgIFsnMzExJywgNl0sXG4gICAgICAgIFsnMzEyJywgNl0sXG4gICAgICAgIFsnMzEzJywgNl0sXG4gICAgICAgIFsnMzE0JywgNl0sXG4gICAgICAgIFsnMzE1JywgNl0sXG4gICAgICAgIFsnMzE2JywgNl0sXG4gICAgICAgIFsnMzIwJywgNl0sXG4gICAgICAgIFsnMzIxJywgNl0sXG4gICAgICAgIFsnMzIyJywgNl0sXG4gICAgICAgIFsnMzIzJywgNl0sXG4gICAgICAgIFsnMzI0JywgNl0sXG4gICAgICAgIFsnMzI1JywgNl0sXG4gICAgICAgIFsnMzI2JywgNl0sXG4gICAgICAgIFsnMzI3JywgNl0sXG4gICAgICAgIFsnMzI4JywgNl0sXG4gICAgICAgIFsnMzI5JywgNl0sXG4gICAgICAgIFsnMzMwJywgNl0sXG4gICAgICAgIFsnMzMxJywgNl0sXG4gICAgICAgIFsnMzMyJywgNl0sXG4gICAgICAgIFsnMzMzJywgNl0sXG4gICAgICAgIFsnMzM0JywgNl0sXG4gICAgICAgIFsnMzM1JywgNl0sXG4gICAgICAgIFsnMzM2JywgNl0sXG4gICAgICAgIFsnMzQwJywgNl0sXG4gICAgICAgIFsnMzQxJywgNl0sXG4gICAgICAgIFsnMzQyJywgNl0sXG4gICAgICAgIFsnMzQzJywgNl0sXG4gICAgICAgIFsnMzQ0JywgNl0sXG4gICAgICAgIFsnMzQ1JywgNl0sXG4gICAgICAgIFsnMzQ2JywgNl0sXG4gICAgICAgIFsnMzQ3JywgNl0sXG4gICAgICAgIFsnMzQ4JywgNl0sXG4gICAgICAgIFsnMzQ5JywgNl0sXG4gICAgICAgIFsnMzUwJywgNl0sXG4gICAgICAgIFsnMzUxJywgNl0sXG4gICAgICAgIFsnMzUyJywgNl0sXG4gICAgICAgIFsnMzUzJywgNl0sXG4gICAgICAgIFsnMzU0JywgNl0sXG4gICAgICAgIFsnMzU1JywgNl0sXG4gICAgICAgIFsnMzU2JywgNl0sXG4gICAgICAgIFsnMzU3JywgNl0sXG4gICAgICAgIFsnMzYwJywgNl0sXG4gICAgICAgIFsnMzYxJywgNl0sXG4gICAgICAgIFsnMzYyJywgNl0sXG4gICAgICAgIFsnMzYzJywgNl0sXG4gICAgICAgIFsnMzY0JywgNl0sXG4gICAgICAgIFsnMzY1JywgNl0sXG4gICAgICAgIFsnMzY2JywgNl0sXG4gICAgICAgIFsnMzY3JywgNl0sXG4gICAgICAgIFsnMzY4JywgNl0sXG4gICAgICAgIFsnMzY5JywgNl0sXG4gICAgICAgIFsnMzkwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxNV0sXG4gICAgICAgIFsnMzkxJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxOF0sXG4gICAgICAgIFsnMzkyJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxNV0sXG4gICAgICAgIFsnMzkzJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxOF0sXG4gICAgICAgIFsnNzAzJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgXTtcbiAgICBGaWVsZFBhcnNlci5GT1VSX0RJR0lUX0RBVEFfTEVOR1RIID0gW1xuICAgICAgICAvLyBTYW1lIGZvcm1hdCBhcyBhYm92ZVxuICAgICAgICBbJzcwMDEnLCAxM10sXG4gICAgICAgIFsnNzAwMicsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzcwMDMnLCAxMF0sXG4gICAgICAgIFsnODAwMScsIDE0XSxcbiAgICAgICAgWyc4MDAyJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAyMF0sXG4gICAgICAgIFsnODAwMycsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzgwMDQnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc4MDA1JywgNl0sXG4gICAgICAgIFsnODAwNicsIDE4XSxcbiAgICAgICAgWyc4MDA3JywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnODAwOCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMTJdLFxuICAgICAgICBbJzgwMTgnLCAxOF0sXG4gICAgICAgIFsnODAyMCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMjVdLFxuICAgICAgICBbJzgxMDAnLCA2XSxcbiAgICAgICAgWyc4MTAxJywgMTBdLFxuICAgICAgICBbJzgxMDInLCAyXSxcbiAgICAgICAgWyc4MTEwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCA3MF0sXG4gICAgICAgIFsnODIwMCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgNzBdLFxuICAgIF07XG5cbiAgICBjbGFzcyBHZW5lcmFsQXBwSWREZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuaW5mb3JtYXRpb24gPSBpbmZvcm1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVBbGxDb2RlcyhidWZmLCBpbml0aWFsUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSBpbml0aWFsUG9zaXRpb247XG4gICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5mbyA9IHRoaXMuZGVjb2RlR2VuZXJhbFB1cnBvc2VGaWVsZChjdXJyZW50UG9zaXRpb24sIHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZEZpZWxkcyA9IEZpZWxkUGFyc2VyLnBhcnNlRmllbGRzSW5HZW5lcmFsUHVycG9zZShpbmZvLmdldE5ld1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkRmllbGRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZi5hcHBlbmQocGFyc2VkRmllbGRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uaXNSZW1haW5pbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmcgPSAnJyArIGluZm8uZ2V0UmVtYWluaW5nVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UG9zaXRpb24gPT09IGluZm8uZ2V0TmV3UG9zaXRpb24oKSkgeyAvLyBObyBzdGVwIGZvcndhcmQhXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gPSBpbmZvLmdldE5ld1Bvc2l0aW9uKCk7XG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBidWZmLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNTdGlsbE51bWVyaWMocG9zKSB7XG4gICAgICAgICAgICAvLyBJdCdzIG51bWVyaWMgaWYgaXQgc3RpbGwgaGFzIDcgcG9zaXRpb25zXG4gICAgICAgICAgICAvLyBhbmQgb25lIG9mIHRoZSBmaXJzdCA0IGJpdHMgaXMgXCIxXCIuXG4gICAgICAgICAgICBpZiAocG9zICsgNyA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcyArIDQgPD0gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgcG9zICsgMzsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5mb3JtYXRpb24uZ2V0KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZm9ybWF0aW9uLmdldChwb3MgKyAzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVOdW1lcmljKHBvcykge1xuICAgICAgICAgICAgaWYgKHBvcyArIDcgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgIGxldCBudW1lcmljID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNCk7XG4gICAgICAgICAgICAgICAgaWYgKG51bWVyaWMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkTnVtZXJpYyh0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSwgRGVjb2RlZE51bWVyaWMuRk5DMSwgRGVjb2RlZE51bWVyaWMuRk5DMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZE51bWVyaWModGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCksIG51bWVyaWMgLSAxLCBEZWNvZGVkTnVtZXJpYy5GTkMxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBudW1lcmljID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNyk7XG4gICAgICAgICAgICBsZXQgZGlnaXQxID0gKG51bWVyaWMgLSA4KSAvIDExO1xuICAgICAgICAgICAgbGV0IGRpZ2l0MiA9IChudW1lcmljIC0gOCkgJSAxMTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZE51bWVyaWMocG9zICsgNywgZGlnaXQxLCBkaWdpdDIpO1xuICAgICAgICB9XG4gICAgICAgIGV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCBiaXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gR2VuZXJhbEFwcElkRGVjb2Rlci5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHRoaXMuaW5mb3JtYXRpb24sIHBvcywgYml0cyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoaW5mb3JtYXRpb24sIHBvcywgYml0cykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYml0czsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm9ybWF0aW9uLmdldChwb3MgKyBpKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSB8PSAxIDw8IChiaXRzIC0gaSAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVHZW5lcmFsUHVycG9zZUZpZWxkKHBvcywgcmVtYWluaW5nKSB7XG4gICAgICAgICAgICAvLyB0aGlzLmJ1ZmZlci5zZXRMZW5ndGgoMCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5zZXRMZW5ndGhUb1plcm8oKTtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLmFwcGVuZChyZW1haW5pbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldFBvc2l0aW9uKHBvcyk7XG4gICAgICAgICAgICBsZXQgbGFzdERlY29kZWQgPSB0aGlzLnBhcnNlQmxvY2tzKCk7XG4gICAgICAgICAgICBpZiAobGFzdERlY29kZWQgIT0gbnVsbCAmJiBsYXN0RGVjb2RlZC5pc1JlbWFpbmluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkSW5mb3JtYXRpb24odGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCksIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCksIGxhc3REZWNvZGVkLmdldFJlbWFpbmluZ1ZhbHVlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkSW5mb3JtYXRpb24odGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCksIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlQmxvY2tzKCkge1xuICAgICAgICAgICAgbGV0IGlzRmluaXNoZWQ7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGxldCBpbml0aWFsUG9zaXRpb24gPSB0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50LmlzQWxwaGEoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlQWxwaGFCbG9jaygpO1xuICAgICAgICAgICAgICAgICAgICBpc0ZpbmlzaGVkID0gcmVzdWx0LmlzRmluaXNoZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJyZW50LmlzSXNvSWVjNjQ2KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUlzb0llYzY0NkJsb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIGlzRmluaXNoZWQgPSByZXN1bHQuaXNGaW5pc2hlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gaXQgbXVzdCBiZSBudW1lcmljXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VOdW1lcmljQmxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgaXNGaW5pc2hlZCA9IHJlc3VsdC5pc0ZpbmlzaGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbkNoYW5nZWQgPSBpbml0aWFsUG9zaXRpb24gIT09IHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmICghcG9zaXRpb25DaGFuZ2VkICYmICFpc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKCFpc0ZpbmlzaGVkKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZ2V0RGVjb2RlZEluZm9ybWF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VOdW1lcmljQmxvY2soKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc1N0aWxsTnVtZXJpYyh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbnVtZXJpYyA9IHRoaXMuZGVjb2RlTnVtZXJpYyh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldFBvc2l0aW9uKG51bWVyaWMuZ2V0TmV3UG9zaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgaWYgKG51bWVyaWMuaXNGaXJzdERpZ2l0Rk5DMSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmZvcm1hdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bWVyaWMuaXNTZWNvbmREaWdpdEZOQzEoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5mb3JtYXRpb24gPSBuZXcgRGVjb2RlZEluZm9ybWF0aW9uKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpLCB0aGlzLmJ1ZmZlci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uID0gbmV3IERlY29kZWRJbmZvcm1hdGlvbih0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSwgbnVtZXJpYy5nZXRTZWNvbmREaWdpdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrUGFyc2VkUmVzdWx0KHRydWUsIGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKG51bWVyaWMuZ2V0Rmlyc3REaWdpdCgpKTtcbiAgICAgICAgICAgICAgICBpZiAobnVtZXJpYy5pc1NlY29uZERpZ2l0Rk5DMSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmZvcm1hdGlvbiA9IG5ldyBEZWNvZGVkSW5mb3JtYXRpb24odGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCksIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrUGFyc2VkUmVzdWx0KHRydWUsIGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKG51bWVyaWMuZ2V0U2Vjb25kRGlnaXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc051bWVyaWNUb0FscGhhTnVtZXJpY0xhdGNoKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRBbHBoYSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5pbmNyZW1lbnRQb3NpdGlvbig0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tQYXJzZWRSZXN1bHQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlSXNvSWVjNjQ2QmxvY2soKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc1N0aWxsSXNvSWVjNjQ2KHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xuICAgICAgICAgICAgICAgIGxldCBpc28gPSB0aGlzLmRlY29kZUlzb0llYzY0Nih0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldFBvc2l0aW9uKGlzby5nZXROZXdQb3NpdGlvbigpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNvLmlzRk5DMSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmZvcm1hdGlvbiA9IG5ldyBEZWNvZGVkSW5mb3JtYXRpb24odGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCksIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrUGFyc2VkUmVzdWx0KHRydWUsIGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKGlzby5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWxwaGFPcjY0NlRvTnVtZXJpY0xhdGNoKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5pbmNyZW1lbnRQb3NpdGlvbigzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0TnVtZXJpYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0FscGhhVG82NDZUb0FscGhhTGF0Y2godGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpICsgNSA8IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5pbmNyZW1lbnRQb3NpdGlvbig1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRQb3NpdGlvbih0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRBbHBoYSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VBbHBoYUJsb2NrKCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNTdGlsbEFscGhhKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xuICAgICAgICAgICAgICAgIGxldCBhbHBoYSA9IHRoaXMuZGVjb2RlQWxwaGFudW1lcmljKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0UG9zaXRpb24oYWxwaGEuZ2V0TmV3UG9zaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgaWYgKGFscGhhLmlzRk5DMSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmZvcm1hdGlvbiA9IG5ldyBEZWNvZGVkSW5mb3JtYXRpb24odGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCksIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrUGFyc2VkUmVzdWx0KHRydWUsIGluZm9ybWF0aW9uKTsgLy8gZW5kIG9mIHRoZSBjaGFyIGJsb2NrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLmFwcGVuZChhbHBoYS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWxwaGFPcjY0NlRvTnVtZXJpY0xhdGNoKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5pbmNyZW1lbnRQb3NpdGlvbigzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0TnVtZXJpYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0FscGhhVG82NDZUb0FscGhhTGF0Y2godGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpICsgNSA8IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5pbmNyZW1lbnRQb3NpdGlvbig1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRQb3NpdGlvbih0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRJc29JZWM2NDYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tQYXJzZWRSZXN1bHQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlzU3RpbGxJc29JZWM2NDYocG9zKSB7XG4gICAgICAgICAgICBpZiAocG9zICsgNSA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZpdmVCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDUpO1xuICAgICAgICAgICAgaWYgKGZpdmVCaXRWYWx1ZSA+PSA1ICYmIGZpdmVCaXRWYWx1ZSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zICsgNyA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNldmVuQml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA3KTtcbiAgICAgICAgICAgIGlmIChzZXZlbkJpdFZhbHVlID49IDY0ICYmIHNldmVuQml0VmFsdWUgPCAxMTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgKyA4ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZWlnaHRCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDgpO1xuICAgICAgICAgICAgcmV0dXJuIGVpZ2h0Qml0VmFsdWUgPj0gMjMyICYmIGVpZ2h0Qml0VmFsdWUgPCAyNTM7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlSXNvSWVjNjQ2KHBvcykge1xuICAgICAgICAgICAgbGV0IGZpdmVCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDUpO1xuICAgICAgICAgICAgaWYgKGZpdmVCaXRWYWx1ZSA9PT0gMTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyKHBvcyArIDUsIERlY29kZWRDaGFyLkZOQzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpdmVCaXRWYWx1ZSA+PSA1ICYmIGZpdmVCaXRWYWx1ZSA8IDE1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcihwb3MgKyA1LCAoJzAnICsgKGZpdmVCaXRWYWx1ZSAtIDUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2V2ZW5CaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDcpO1xuICAgICAgICAgICAgaWYgKHNldmVuQml0VmFsdWUgPj0gNjQgJiYgc2V2ZW5CaXRWYWx1ZSA8IDkwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcihwb3MgKyA3LCAoJycgKyAoc2V2ZW5CaXRWYWx1ZSArIDEpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V2ZW5CaXRWYWx1ZSA+PSA5MCAmJiBzZXZlbkJpdFZhbHVlIDwgMTE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcihwb3MgKyA3LCAoJycgKyAoc2V2ZW5CaXRWYWx1ZSArIDcpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZWlnaHRCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDgpO1xuICAgICAgICAgICAgbGV0IGM7XG4gICAgICAgICAgICBzd2l0Y2ggKGVpZ2h0Qml0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDIzMjpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICchJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMzM6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnXCInO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIzNDpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICclJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMzU6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnJic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM2OlxuICAgICAgICAgICAgICAgICAgICBjID0gJ1xcJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM3OlxuICAgICAgICAgICAgICAgICAgICBjID0gJygnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIzODpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcpJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMzk6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnKic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQwOlxuICAgICAgICAgICAgICAgICAgICBjID0gJysnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0MTpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDI6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnLSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQzOlxuICAgICAgICAgICAgICAgICAgICBjID0gJy4nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0NDpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcvJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDU6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnOic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQ2OlxuICAgICAgICAgICAgICAgICAgICBjID0gJzsnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0NzpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICc8JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDg6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnPSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQ5OlxuICAgICAgICAgICAgICAgICAgICBjID0gJz4nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI1MDpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICc/JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNTE6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnXyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjUyOlxuICAgICAgICAgICAgICAgICAgICBjID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyKHBvcyArIDgsIGMpO1xuICAgICAgICB9XG4gICAgICAgIGlzU3RpbGxBbHBoYShwb3MpIHtcbiAgICAgICAgICAgIGlmIChwb3MgKyA1ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBub3cgY2hlY2sgaWYgaXQncyBhIHZhbGlkIDUtYml0IHZhbHVlICgwLi45IGFuZCBGTkMxKVxuICAgICAgICAgICAgbGV0IGZpdmVCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDUpO1xuICAgICAgICAgICAgaWYgKGZpdmVCaXRWYWx1ZSA+PSA1ICYmIGZpdmVCaXRWYWx1ZSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zICsgNiA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNpeEJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNik7XG4gICAgICAgICAgICByZXR1cm4gc2l4Qml0VmFsdWUgPj0gMTYgJiYgc2l4Qml0VmFsdWUgPCA2MzsgLy8gNjMgbm90IGluY2x1ZGVkXG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlQWxwaGFudW1lcmljKHBvcykge1xuICAgICAgICAgICAgbGV0IGZpdmVCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDUpO1xuICAgICAgICAgICAgaWYgKGZpdmVCaXRWYWx1ZSA9PT0gMTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyKHBvcyArIDUsIERlY29kZWRDaGFyLkZOQzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpdmVCaXRWYWx1ZSA+PSA1ICYmIGZpdmVCaXRWYWx1ZSA8IDE1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcihwb3MgKyA1LCAoJzAnICsgKGZpdmVCaXRWYWx1ZSAtIDUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2l4Qml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA2KTtcbiAgICAgICAgICAgIGlmIChzaXhCaXRWYWx1ZSA+PSAzMiAmJiBzaXhCaXRWYWx1ZSA8IDU4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcihwb3MgKyA2LCAoJycgKyAoc2l4Qml0VmFsdWUgKyAzMykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjO1xuICAgICAgICAgICAgc3dpdGNoIChzaXhCaXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgNTg6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnKic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTk6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnLCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjA6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnLSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjE6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnLic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjI6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnLyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oJ0RlY29kaW5nIGludmFsaWQgYWxwaGFudW1lcmljIHZhbHVlOiAnICsgc2l4Qml0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcihwb3MgKyA2LCBjKTtcbiAgICAgICAgfVxuICAgICAgICBpc0FscGhhVG82NDZUb0FscGhhTGF0Y2gocG9zKSB7XG4gICAgICAgICAgICBpZiAocG9zICsgMSA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1ICYmIGkgKyBwb3MgPCB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluZm9ybWF0aW9uLmdldChwb3MgKyAyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW5mb3JtYXRpb24uZ2V0KHBvcyArIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpc0FscGhhT3I2NDZUb051bWVyaWNMYXRjaChwb3MpIHtcbiAgICAgICAgICAgIC8vIE5leHQgaXMgYWxwaGFudW1lcmljIGlmIHRoZXJlIGFyZSAzIHBvc2l0aW9ucyBhbmQgdGhleSBhcmUgYWxsIHplcm9zXG4gICAgICAgICAgICBpZiAocG9zICsgMyA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IHBvcyArIDM7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZm9ybWF0aW9uLmdldChpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaXNOdW1lcmljVG9BbHBoYU51bWVyaWNMYXRjaChwb3MpIHtcbiAgICAgICAgICAgIC8vIE5leHQgaXMgYWxwaGFudW1lcmljIGlmIHRoZXJlIGFyZSA0IHBvc2l0aW9ucyBhbmQgdGhleSBhcmUgYWxsIHplcm9zLCBvclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzdWJzZXQgb2YgdGhpcyBqdXN0IGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBzeW1ib2xcbiAgICAgICAgICAgIGlmIChwb3MgKyAxID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQgJiYgaSArIHBvcyA8IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmZvcm1hdGlvbi5nZXQocG9zICsgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgQWJzdHJhY3RFeHBhbmRlZERlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5pbmZvcm1hdGlvbiA9IGluZm9ybWF0aW9uO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmFsRGVjb2RlciA9IG5ldyBHZW5lcmFsQXBwSWREZWNvZGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRJbmZvcm1hdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZm9ybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldEdlbmVyYWxEZWNvZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhbERlY29kZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBBSTAxZGVjb2RlciBleHRlbmRzIEFic3RyYWN0RXhwYW5kZWREZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHN1cGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVDb21wcmVzc2VkR3RpbihidWYsIGN1cnJlbnRQb3MpIHtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJygwMSknKTtcbiAgICAgICAgICAgIGxldCBpbml0aWFsUG9zaXRpb24gPSBidWYubGVuZ3RoKCk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCc5Jyk7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRHdGluV2l0aG91dEFJKGJ1ZiwgY3VycmVudFBvcywgaW5pdGlhbFBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVDb21wcmVzc2VkR3RpbldpdGhvdXRBSShidWYsIGN1cnJlbnRQb3MsIGluaXRpYWxCdWZmZXJQb3NpdGlvbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEJsb2NrID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoY3VycmVudFBvcyArIDEwICogaSwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2sgLyAxMDAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEJsb2NrIC8gMTAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWYuYXBwZW5kKGN1cnJlbnRCbG9jayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBBSTAxZGVjb2Rlci5hcHBlbmRDaGVja0RpZ2l0KGJ1ZiwgaW5pdGlhbEJ1ZmZlclBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYXBwZW5kQ2hlY2tEaWdpdChidWYsIGN1cnJlbnRQb3MpIHtcbiAgICAgICAgICAgIGxldCBjaGVja0RpZ2l0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTM7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGxldCBkaWdpdCA9IGJ1Zi5jaGFyQXQoaSArIGN1cnJlbnRQb3MpIC0gJzAnO1xuICAgICAgICAgICAgICAgIC8vIFRvIGJlIGNoZWNrZWRcbiAgICAgICAgICAgICAgICBsZXQgZGlnaXQgPSBidWYuY2hhckF0KGkgKyBjdXJyZW50UG9zKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgY2hlY2tEaWdpdCArPSAoaSAmIDB4MDEpID09PSAwID8gMyAqIGRpZ2l0IDogZGlnaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja0RpZ2l0ID0gMTAgLSAoY2hlY2tEaWdpdCAlIDEwKTtcbiAgICAgICAgICAgIGlmIChjaGVja0RpZ2l0ID09PSAxMCkge1xuICAgICAgICAgICAgICAgIGNoZWNrRGlnaXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmLmFwcGVuZChjaGVja0RpZ2l0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBSTAxZGVjb2Rlci5HVElOX1NJWkUgPSA0MDtcblxuICAgIGNsYXNzIEFJMDFBbmRPdGhlckFJcyBleHRlbmRzIEFJMDFkZWNvZGVyIHtcbiAgICAgICAgLy8gdGhlIHNlY29uZCBvbmUgaXMgdGhlIGVuY29kYXRpb24gbWV0aG9kLCBhbmQgdGhlIG90aGVyIHR3byBhcmUgZm9yIHRoZSB2YXJpYWJsZSBsZW5ndGhcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHN1cGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUluZm9ybWF0aW9uKCkge1xuICAgICAgICAgICAgbGV0IGJ1ZmYgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgYnVmZi5hcHBlbmQoJygwMSknKTtcbiAgICAgICAgICAgIGxldCBpbml0aWFsR3RpblBvc2l0aW9uID0gYnVmZi5sZW5ndGgoKTtcbiAgICAgICAgICAgIGxldCBmaXJzdEd0aW5EaWdpdCA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KEFJMDFBbmRPdGhlckFJcy5IRUFERVJfU0laRSwgNCk7XG4gICAgICAgICAgICBidWZmLmFwcGVuZChmaXJzdEd0aW5EaWdpdCk7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRHdGluV2l0aG91dEFJKGJ1ZmYsIEFJMDFBbmRPdGhlckFJcy5IRUFERVJfU0laRSArIDQsIGluaXRpYWxHdGluUG9zaXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5kZWNvZGVBbGxDb2RlcyhidWZmLCBBSTAxQW5kT3RoZXJBSXMuSEVBREVSX1NJWkUgKyA0NCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQUkwMUFuZE90aGVyQUlzLkhFQURFUl9TSVpFID0gMSArIDEgKyAyOyAvLyBmaXJzdCBiaXQgZW5jb2RlcyB0aGUgbGlua2FnZSBmbGFnLFxuXG4gICAgY2xhc3MgQW55QUlEZWNvZGVyIGV4dGVuZHMgQWJzdHJhY3RFeHBhbmRlZERlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgc3VwZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlSW5mb3JtYXRpb24oKSB7XG4gICAgICAgICAgICBsZXQgYnVmID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZGVjb2RlQWxsQ29kZXMoYnVmLCBBbnlBSURlY29kZXIuSEVBREVSX1NJWkUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFueUFJRGVjb2Rlci5IRUFERVJfU0laRSA9IDIgKyAxICsgMjtcblxuICAgIGNsYXNzIEFJMDF3ZWlnaHREZWNvZGVyIGV4dGVuZHMgQUkwMWRlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgc3VwZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZUNvbXByZXNzZWRXZWlnaHQoYnVmLCBjdXJyZW50UG9zLCB3ZWlnaHRTaXplKSB7XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxXZWlnaHROdW1lcmljID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoY3VycmVudFBvcywgd2VpZ2h0U2l6ZSk7XG4gICAgICAgICAgICB0aGlzLmFkZFdlaWdodENvZGUoYnVmLCBvcmlnaW5hbFdlaWdodE51bWVyaWMpO1xuICAgICAgICAgICAgbGV0IHdlaWdodE51bWVyaWMgPSB0aGlzLmNoZWNrV2VpZ2h0KG9yaWdpbmFsV2VpZ2h0TnVtZXJpYyk7XG4gICAgICAgICAgICBsZXQgY3VycmVudERpdmlzb3IgPSAxMDAwMDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh3ZWlnaHROdW1lcmljIC8gY3VycmVudERpdmlzb3IgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50RGl2aXNvciAvPSAxMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQod2VpZ2h0TnVtZXJpYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBBSTAxM3gweERlY29kZXIgZXh0ZW5kcyBBSTAxd2VpZ2h0RGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBzdXBlcihpbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VJbmZvcm1hdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEluZm9ybWF0aW9uKCkuZ2V0U2l6ZSgpICE9IEFJMDEzeDB4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDF3ZWlnaHREZWNvZGVyLkdUSU5fU0laRSArIEFJMDEzeDB4RGVjb2Rlci5XRUlHSFRfU0laRSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJ1ZiA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRHdGluKGJ1ZiwgQUkwMTN4MHhEZWNvZGVyLkhFQURFUl9TSVpFKTtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZFdlaWdodChidWYsIEFJMDEzeDB4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDF3ZWlnaHREZWNvZGVyLkdUSU5fU0laRSwgQUkwMTN4MHhEZWNvZGVyLldFSUdIVF9TSVpFKTtcbiAgICAgICAgICAgIHJldHVybiBidWYudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBSTAxM3gweERlY29kZXIuSEVBREVSX1NJWkUgPSA0ICsgMTtcbiAgICBBSTAxM3gweERlY29kZXIuV0VJR0hUX1NJWkUgPSAxNTtcblxuICAgIGNsYXNzIEFJMDEzMTAzZGVjb2RlciBleHRlbmRzIEFJMDEzeDB4RGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBzdXBlcihpbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgYWRkV2VpZ2h0Q29kZShidWYsIHdlaWdodCkge1xuICAgICAgICAgICAgYnVmLmFwcGVuZCgnKDMxMDMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tXZWlnaHQod2VpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gd2VpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgQUkwMTMyMHhEZWNvZGVyIGV4dGVuZHMgQUkwMTN4MHhEZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHN1cGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRXZWlnaHRDb2RlKGJ1Ziwgd2VpZ2h0KSB7XG4gICAgICAgICAgICBpZiAod2VpZ2h0IDwgMTAwMDApIHtcbiAgICAgICAgICAgICAgICBidWYuYXBwZW5kKCcoMzIwMiknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJygzMjAzKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoZWNrV2VpZ2h0KHdlaWdodCkge1xuICAgICAgICAgICAgaWYgKHdlaWdodCA8IDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3ZWlnaHQgLSAxMDAwMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIEFJMDEzOTJ4RGVjb2RlciBleHRlbmRzIEFJMDFkZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHN1cGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUluZm9ybWF0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0SW5mb3JtYXRpb24oKS5nZXRTaXplKCkgPCBBSTAxMzkyeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxZGVjb2Rlci5HVElOX1NJWkUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBidWYgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkR3RpbihidWYsIEFJMDEzOTJ4RGVjb2Rlci5IRUFERVJfU0laRSk7XG4gICAgICAgICAgICBsZXQgbGFzdEFJZGlnaXQgPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShBSTAxMzkyeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxZGVjb2Rlci5HVElOX1NJWkUsIEFJMDEzOTJ4RGVjb2Rlci5MQVNUX0RJR0lUX1NJWkUpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZCgnKDM5MicpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZChsYXN0QUlkaWdpdCk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcpJyk7XG4gICAgICAgICAgICBsZXQgZGVjb2RlZEluZm9ybWF0aW9uID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmRlY29kZUdlbmVyYWxQdXJwb3NlRmllbGQoQUkwMTM5MnhEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMWRlY29kZXIuR1RJTl9TSVpFICsgQUkwMTM5MnhEZWNvZGVyLkxBU1RfRElHSVRfU0laRSwgbnVsbCk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKGRlY29kZWRJbmZvcm1hdGlvbi5nZXROZXdTdHJpbmcoKSk7XG4gICAgICAgICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQUkwMTM5MnhEZWNvZGVyLkhFQURFUl9TSVpFID0gNSArIDEgKyAyO1xuICAgIEFJMDEzOTJ4RGVjb2Rlci5MQVNUX0RJR0lUX1NJWkUgPSAyO1xuXG4gICAgY2xhc3MgQUkwMTM5M3hEZWNvZGVyIGV4dGVuZHMgQUkwMWRlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgc3VwZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlSW5mb3JtYXRpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRJbmZvcm1hdGlvbigpLmdldFNpemUoKSA8IEFJMDEzOTN4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDFkZWNvZGVyLkdUSU5fU0laRSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJ1ZiA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRHdGluKGJ1ZiwgQUkwMTM5M3hEZWNvZGVyLkhFQURFUl9TSVpFKTtcbiAgICAgICAgICAgIGxldCBsYXN0QUlkaWdpdCA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KEFJMDEzOTN4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDFkZWNvZGVyLkdUSU5fU0laRSwgQUkwMTM5M3hEZWNvZGVyLkxBU1RfRElHSVRfU0laRSk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcoMzkzJyk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKGxhc3RBSWRpZ2l0KTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJyknKTtcbiAgICAgICAgICAgIGxldCBmaXJzdFRocmVlRGlnaXRzID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoQUkwMTM5M3hEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMWRlY29kZXIuR1RJTl9TSVpFICsgQUkwMTM5M3hEZWNvZGVyLkxBU1RfRElHSVRfU0laRSwgQUkwMTM5M3hEZWNvZGVyLkZJUlNUX1RIUkVFX0RJR0lUU19TSVpFKTtcbiAgICAgICAgICAgIGlmIChmaXJzdFRocmVlRGlnaXRzIC8gMTAwID09IDApIHtcbiAgICAgICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaHJlZURpZ2l0cyAvIDEwID09IDApIHtcbiAgICAgICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWYuYXBwZW5kKGZpcnN0VGhyZWVEaWdpdHMpO1xuICAgICAgICAgICAgbGV0IGdlbmVyYWxJbmZvcm1hdGlvbiA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5kZWNvZGVHZW5lcmFsUHVycG9zZUZpZWxkKEFJMDEzOTN4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDFkZWNvZGVyLkdUSU5fU0laRSArIEFJMDEzOTN4RGVjb2Rlci5MQVNUX0RJR0lUX1NJWkUgKyBBSTAxMzkzeERlY29kZXIuRklSU1RfVEhSRUVfRElHSVRTX1NJWkUsIG51bGwpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZChnZW5lcmFsSW5mb3JtYXRpb24uZ2V0TmV3U3RyaW5nKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFJMDEzOTN4RGVjb2Rlci5IRUFERVJfU0laRSA9IDUgKyAxICsgMjtcbiAgICBBSTAxMzkzeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFID0gMjtcbiAgICBBSTAxMzkzeERlY29kZXIuRklSU1RfVEhSRUVfRElHSVRTX1NJWkUgPSAxMDtcblxuICAgIGNsYXNzIEFJMDEzeDB4MXhEZWNvZGVyIGV4dGVuZHMgQUkwMXdlaWdodERlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbiwgZmlyc3RBSWRpZ2l0cywgZGF0ZUNvZGUpIHtcbiAgICAgICAgICAgIHN1cGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuZGF0ZUNvZGUgPSBkYXRlQ29kZTtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RBSWRpZ2l0cyA9IGZpcnN0QUlkaWdpdHM7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VJbmZvcm1hdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEluZm9ybWF0aW9uKCkuZ2V0U2l6ZSgpICE9IEFJMDEzeDB4MXhEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMTN4MHgxeERlY29kZXIuR1RJTl9TSVpFICsgQUkwMTN4MHgxeERlY29kZXIuV0VJR0hUX1NJWkUgKyBBSTAxM3gweDF4RGVjb2Rlci5EQVRFX1NJWkUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBidWYgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkR3RpbihidWYsIEFJMDEzeDB4MXhEZWNvZGVyLkhFQURFUl9TSVpFKTtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZFdlaWdodChidWYsIEFJMDEzeDB4MXhEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMTN4MHgxeERlY29kZXIuR1RJTl9TSVpFLCBBSTAxM3gweDF4RGVjb2Rlci5XRUlHSFRfU0laRSk7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWREYXRlKGJ1ZiwgQUkwMTN4MHgxeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxM3gweDF4RGVjb2Rlci5HVElOX1NJWkUgKyBBSTAxM3gweDF4RGVjb2Rlci5XRUlHSFRfU0laRSk7XG4gICAgICAgICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlQ29tcHJlc3NlZERhdGUoYnVmLCBjdXJyZW50UG9zKSB7XG4gICAgICAgICAgICBsZXQgbnVtZXJpY0RhdGUgPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShjdXJyZW50UG9zLCBBSTAxM3gweDF4RGVjb2Rlci5EQVRFX1NJWkUpO1xuICAgICAgICAgICAgaWYgKG51bWVyaWNEYXRlID09IDM4NDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmLmFwcGVuZCgnKCcpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZCh0aGlzLmRhdGVDb2RlKTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJyknKTtcbiAgICAgICAgICAgIGxldCBkYXkgPSBudW1lcmljRGF0ZSAlIDMyO1xuICAgICAgICAgICAgbnVtZXJpY0RhdGUgLz0gMzI7XG4gICAgICAgICAgICBsZXQgbW9udGggPSBudW1lcmljRGF0ZSAlIDEyICsgMTtcbiAgICAgICAgICAgIG51bWVyaWNEYXRlIC89IDEyO1xuICAgICAgICAgICAgbGV0IHllYXIgPSBudW1lcmljRGF0ZTtcbiAgICAgICAgICAgIGlmICh5ZWFyIC8gMTAgPT0gMCkge1xuICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoeWVhcik7XG4gICAgICAgICAgICBpZiAobW9udGggLyAxMCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmLmFwcGVuZChtb250aCk7XG4gICAgICAgICAgICBpZiAoZGF5IC8gMTAgPT0gMCkge1xuICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoZGF5KTtcbiAgICAgICAgfVxuICAgICAgICBhZGRXZWlnaHRDb2RlKGJ1Ziwgd2VpZ2h0KSB7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcoJyk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKHRoaXMuZmlyc3RBSWRpZ2l0cyk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKHdlaWdodCAvIDEwMDAwMCk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tXZWlnaHQod2VpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gd2VpZ2h0ICUgMTAwMDAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFJMDEzeDB4MXhEZWNvZGVyLkhFQURFUl9TSVpFID0gNyArIDE7XG4gICAgQUkwMTN4MHgxeERlY29kZXIuV0VJR0hUX1NJWkUgPSAyMDtcbiAgICBBSTAxM3gweDF4RGVjb2Rlci5EQVRFX1NJWkUgPSAxNjtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURlY29kZXIoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpbmZvcm1hdGlvbi5nZXQoMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFJMDFBbmRPdGhlckFJcyhpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWluZm9ybWF0aW9uLmdldCgyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQW55QUlEZWNvZGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3VyQml0RW5jb2RhdGlvbk1ldGhvZCA9IEdlbmVyYWxBcHBJZERlY29kZXIuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShpbmZvcm1hdGlvbiwgMSwgNCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZvdXJCaXRFbmNvZGF0aW9uTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEFJMDEzMTAzZGVjb2RlcihpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEFJMDEzMjB4RGVjb2RlcihpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZml2ZUJpdEVuY29kYXRpb25NZXRob2QgPSBHZW5lcmFsQXBwSWREZWNvZGVyLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoaW5mb3JtYXRpb24sIDEsIDUpO1xuICAgICAgICAgICAgc3dpdGNoIChmaXZlQml0RW5jb2RhdGlvbk1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBuZXcgQUkwMTM5MnhEZWNvZGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gbmV3IEFJMDEzOTN4RGVjb2RlcihpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2V2ZW5CaXRFbmNvZGF0aW9uTWV0aG9kID0gR2VuZXJhbEFwcElkRGVjb2Rlci5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KGluZm9ybWF0aW9uLCAxLCA3KTtcbiAgICAgICAgICAgIHN3aXRjaCAoc2V2ZW5CaXRFbmNvZGF0aW9uTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA1NjogcmV0dXJuIG5ldyBBSTAxM3gweDF4RGVjb2RlcihpbmZvcm1hdGlvbiwgJzMxMCcsICcxMScpO1xuICAgICAgICAgICAgICAgIGNhc2UgNTc6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXIoaW5mb3JtYXRpb24sICczMjAnLCAnMTEnKTtcbiAgICAgICAgICAgICAgICBjYXNlIDU4OiByZXR1cm4gbmV3IEFJMDEzeDB4MXhEZWNvZGVyKGluZm9ybWF0aW9uLCAnMzEwJywgJzEzJyk7XG4gICAgICAgICAgICAgICAgY2FzZSA1OTogcmV0dXJuIG5ldyBBSTAxM3gweDF4RGVjb2RlcihpbmZvcm1hdGlvbiwgJzMyMCcsICcxMycpO1xuICAgICAgICAgICAgICAgIGNhc2UgNjA6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXIoaW5mb3JtYXRpb24sICczMTAnLCAnMTUnKTtcbiAgICAgICAgICAgICAgICBjYXNlIDYxOiByZXR1cm4gbmV3IEFJMDEzeDB4MXhEZWNvZGVyKGluZm9ybWF0aW9uLCAnMzIwJywgJzE1Jyk7XG4gICAgICAgICAgICAgICAgY2FzZSA2MjogcmV0dXJuIG5ldyBBSTAxM3gweDF4RGVjb2RlcihpbmZvcm1hdGlvbiwgJzMxMCcsICcxNycpO1xuICAgICAgICAgICAgICAgIGNhc2UgNjM6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXIoaW5mb3JtYXRpb24sICczMjAnLCAnMTcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCd1bmtub3duIGRlY29kZXI6ICcgKyBpbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBFeHBhbmRlZFBhaXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihsZWZ0Q2hhciwgcmlnaHRDaGFyLCBmaW5kZXJQYXR0ZXIsIG1heUJlTGFzdCkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0Y2hhciA9IGxlZnRDaGFyO1xuICAgICAgICAgICAgdGhpcy5yaWdodGNoYXIgPSByaWdodENoYXI7XG4gICAgICAgICAgICB0aGlzLmZpbmRlcnBhdHRlcm4gPSBmaW5kZXJQYXR0ZXI7XG4gICAgICAgICAgICB0aGlzLm1heWJlTGFzdCA9IG1heUJlTGFzdDtcbiAgICAgICAgfVxuICAgICAgICBtYXlCZUxhc3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXliZUxhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TGVmdENoYXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0Y2hhcjtcbiAgICAgICAgfVxuICAgICAgICBnZXRSaWdodENoYXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodGNoYXI7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RmluZGVyUGF0dGVybigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRlcnBhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgbXVzdEJlTGFzdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Y2hhciA9PSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICdbICcgKyB0aGlzLmxlZnRjaGFyICsgJywgJyArIHRoaXMucmlnaHRjaGFyICsgJyA6ICcgKyAodGhpcy5maW5kZXJwYXR0ZXJuID09IG51bGwgPyAnbnVsbCcgOiB0aGlzLmZpbmRlcnBhdHRlcm4uZ2V0VmFsdWUoKSkgKyAnIF0nO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBlcXVhbHMobzEsIG8yKSB7XG4gICAgICAgICAgICBpZiAoIShvMSBpbnN0YW5jZW9mIEV4cGFuZGVkUGFpcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRXhwYW5kZWRQYWlyLmVxdWFsc09yTnVsbChvMS5sZWZ0Y2hhciwgbzIubGVmdGNoYXIpICYmXG4gICAgICAgICAgICAgICAgRXhwYW5kZWRQYWlyLmVxdWFsc09yTnVsbChvMS5yaWdodGNoYXIsIG8yLnJpZ2h0Y2hhcikgJiZcbiAgICAgICAgICAgICAgICBFeHBhbmRlZFBhaXIuZXF1YWxzT3JOdWxsKG8xLmZpbmRlcnBhdHRlcm4sIG8yLmZpbmRlcnBhdHRlcm4pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBlcXVhbHNPck51bGwobzEsIG8yKSB7XG4gICAgICAgICAgICByZXR1cm4gbzEgPT09IG51bGwgPyBvMiA9PT0gbnVsbCA6IEV4cGFuZGVkUGFpci5lcXVhbHMobzEsIG8yKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNoQ29kZSgpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBFeHBhbmRlZFBhaXIuaGFzaE5vdE51bGwobGVmdENoYXIpIF4gaGFzaE5vdE51bGwocmlnaHRDaGFyKSBeIGhhc2hOb3ROdWxsKGZpbmRlclBhdHRlcm4pO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5sZWZ0Y2hhci5nZXRWYWx1ZSgpIF4gdGhpcy5yaWdodGNoYXIuZ2V0VmFsdWUoKSBeIHRoaXMuZmluZGVycGF0dGVybi5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgRXhwYW5kZWRSb3cge1xuICAgICAgICBjb25zdHJ1Y3RvcihwYWlycywgcm93TnVtYmVyLCB3YXNSZXZlcnNlZCkge1xuICAgICAgICAgICAgdGhpcy5wYWlycyA9IHBhaXJzO1xuICAgICAgICAgICAgdGhpcy5yb3dOdW1iZXIgPSByb3dOdW1iZXI7XG4gICAgICAgICAgICB0aGlzLndhc1JldmVyc2VkID0gd2FzUmV2ZXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UGFpcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWlycztcbiAgICAgICAgfVxuICAgICAgICBnZXRSb3dOdW1iZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgaXNSZXZlcnNlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhc1JldmVyc2VkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlzRXF1aXZhbGVudChvdGhlclBhaXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja0VxdWFsaXRpdHkodGhpcywgb3RoZXJQYWlycyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICd7ICcgKyB0aGlzLnBhaXJzICsgJyB9JztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVHdvIHJvd3MgYXJlIGVxdWFsIGlmIHRoZXkgY29udGFpbiB0aGUgc2FtZSBwYWlycyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICovXG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICAvLyBjaGVjayBpbXBsZW1lbnRhdGlvblxuICAgICAgICBlcXVhbHMobzEsIG8yKSB7XG4gICAgICAgICAgICBpZiAoIShvMSBpbnN0YW5jZW9mIEV4cGFuZGVkUm93KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrRXF1YWxpdGl0eShvMSwgbzIpICYmIG8xLndhc1JldmVyc2VkID09PSBvMi53YXNSZXZlcnNlZDtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0VxdWFsaXRpdHkocGFpcjEsIHBhaXIyKSB7XG4gICAgICAgICAgICBpZiAoIXBhaXIxIHx8ICFwYWlyMilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgcGFpcjEuZm9yRWFjaCgoZTEsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBwYWlyMi5mb3JFYWNoKGUyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUxLmdldExlZnRDaGFyKCkuZ2V0VmFsdWUoKSA9PT0gZTIuZ2V0TGVmdENoYXIoKS5nZXRWYWx1ZSgpICYmIGUxLmdldFJpZ2h0Q2hhcigpLmdldFZhbHVlKCkgPT09IGUyLmdldFJpZ2h0Q2hhcigpLmdldFZhbHVlKCkgJiYgZTEuZ2V0RmluZGVyUGF0dGVyKCkuZ2V0VmFsdWUoKSA9PT0gZTIuZ2V0RmluZGVyUGF0dGVyKCkuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5JdGVyYXRvcjtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkxpc3Q7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5NYXA7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5Db2xsZWN0aW9ucztcbiAgICBjbGFzcyBSU1NFeHBhbmRlZFJlYWRlciBleHRlbmRzIEFic3RyYWN0UlNTUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IodmVyYm9zZSkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMucGFpcnMgPSBuZXcgQXJyYXkoUlNTRXhwYW5kZWRSZWFkZXIuTUFYX1BBSVJTKTtcbiAgICAgICAgICAgIHRoaXMucm93cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFydEVuZCA9IFsyXTtcbiAgICAgICAgICAgIHRoaXMudmVyYm9zZSA9ICh2ZXJib3NlID09PSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgICAgICAvLyBSb3dzIGNhbiBzdGFydCB3aXRoIGV2ZW4gcGF0dGVybiBpbiBjYXNlIGluIHByZXYgcm93cyB0aGVyZSB3aGVyZSBvZGQgbnVtYmVyIG9mIHBhdHRlcnMuXG4gICAgICAgICAgICAvLyBTbyBsZXRzIHRyeSB0d2ljZVxuICAgICAgICAgICAgLy8gdGhpcy5wYWlycy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5wYWlycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5zdGFydEZyb21FdmVuID0gZmFsc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSU1NFeHBhbmRlZFJlYWRlci5jb25zdHJ1Y3RSZXN1bHQodGhpcy5kZWNvZGVSb3cycGFpcnMocm93TnVtYmVyLCByb3cpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gT0tcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFpcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRGcm9tRXZlbiA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gUlNTRXhwYW5kZWRSZWFkZXIuY29uc3RydWN0UmVzdWx0KHRoaXMuZGVjb2RlUm93MnBhaXJzKHJvd051bWJlciwgcm93KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICB0aGlzLnBhaXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnJvd3MubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgcHJpdmF0ZSBmb3IgdGVzdGluZ1xuICAgICAgICBkZWNvZGVSb3cycGFpcnMocm93TnVtYmVyLCByb3cpIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhaXJzLnB1c2godGhpcy5yZXRyaWV2ZU5leHRQYWlyKHJvdywgdGhpcy5wYWlycywgcm93TnVtYmVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBOb3RGb3VuZEV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhaXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhpdCB0aGlzIGxvb3Agd2hlbiByZXRyaWV2ZU5leHRQYWlyKCkgZmFpbHMgYW5kIHRocm93c1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiB2ZXJpZnkgc2VxdWVuY2Ugb2YgZmluZGVyIHBhdHRlcm5zIGFzIGluIGNoZWNrUGFpclNlcXVlbmNlKClcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrQ2hlY2tzdW0oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhaXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyeVN0YWNrZWREZWNvZGU7XG4gICAgICAgICAgICBpZiAodGhpcy5yb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRyeVN0YWNrZWREZWNvZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5U3RhY2tlZERlY29kZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGV0IHRyeVN0YWNrZWREZWNvZGUgPSAhdGhpcy5yb3dzLmlzRW1wdHkoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVSb3cocm93TnVtYmVyLCBmYWxzZSk7IC8vIFRPRE86IGRlYWwgd2l0aCByZXZlcnNlZCByb3dzXG4gICAgICAgICAgICBpZiAodHJ5U3RhY2tlZERlY29kZSkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGltYWdlIGlzIDE4MC1yb3RhdGVkLCB0aGVuIHJvd3MgYXJlIHNvcnRlZCBpbiB3cm9uZyBkaXJlY3Rpb24uXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHR3aWNlIHdpdGggYm90aCB0aGUgZGlyZWN0aW9ucy5cbiAgICAgICAgICAgICAgICBsZXQgcHMgPSB0aGlzLmNoZWNrUm93c0Jvb2xlYW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChwcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHMgPSB0aGlzLmNoZWNrUm93c0Jvb2xlYW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5lZWQgdG8gVmVyaWZ5XG4gICAgICAgIGNoZWNrUm93c0Jvb2xlYW4ocmV2ZXJzZSkge1xuICAgICAgICAgICAgLy8gTGltaXQgbnVtYmVyIG9mIHJvd3Mgd2UgYXJlIGNoZWNraW5nXG4gICAgICAgICAgICAvLyBXZSB1c2UgcmVjdXJzaXZlIGFsZ29yaXRobSB3aXRoIHB1cmUgY29tcGxleGl0eSBhbmQgZG9uJ3Qgd2FudCBpdCB0byB0YWtlIGZvcmV2ZXJcbiAgICAgICAgICAgIC8vIFN0YWNrZWQgYmFyY29kZSBjYW4gaGF2ZSB1cCB0byAxMSByb3dzLCBzbyAyNSBzZWVtcyByZWFzb25hYmxlIGVub3VnaFxuICAgICAgICAgICAgaWYgKHRoaXMucm93cy5sZW5ndGggPiAyNSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm93cy5sZW5ndGggPSAwOyAvLyBXZSB3aWxsIG5ldmVyIGhhdmUgYSBjaGFuY2UgdG8gZ2V0IHJlc3VsdCwgc28gY2xlYXIgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFpcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzID0gdGhpcy5yb3dzLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAvLyBDb2xsZWN0aW9ucy5yZXZlcnNlKHRoaXMucm93cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHMgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcyA9IHRoaXMuY2hlY2tSb3dzKG5ldyBBcnJheSgpLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gT0tcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzID0gdGhpcy5yb3dzLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAvLyBDb2xsZWN0aW9ucy5yZXZlcnNlKHRoaXMucm93cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IHRvIGNvbnN0cnVjdCBhIHZhbGlkIHJvd3Mgc2VxdWVuY2VcbiAgICAgICAgLy8gUmVjdXJzaW9uIGlzIHVzZWQgdG8gaW1wbGVtZW50IGJhY2t0cmFja2luZ1xuICAgICAgICBjaGVja1Jvd3MoY29sbGVjdGVkUm93cywgY3VycmVudFJvdykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGN1cnJlbnRSb3c7IGkgPCB0aGlzLnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcm93ID0gdGhpcy5yb3dzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMucGFpcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2xsZWN0ZWRSb3cgb2YgY29sbGVjdGVkUm93cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhaXJzLnB1c2goY29sbGVjdGVkUm93LmdldFBhaXJzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhaXJzLnB1c2gocm93LmdldFBhaXJzKCkpO1xuICAgICAgICAgICAgICAgIGlmICghUlNTRXhwYW5kZWRSZWFkZXIuaXNWYWxpZFNlcXVlbmNlKHRoaXMucGFpcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja0NoZWNrc3VtKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBycyA9IG5ldyBBcnJheShjb2xsZWN0ZWRSb3dzKTtcbiAgICAgICAgICAgICAgICBycy5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzaW9uOiB0cnkgdG8gYWRkIG1vcmUgcm93c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja1Jvd3MocnMsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZmFpbGVkLCB0cnkgdGhlIG5leHQgY2FuZGlkYXRlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hldGhlciB0aGUgcGFpcnMgZm9ybSBhIHZhbGlkIGZpbmQgcGF0dGVybiBzZXF1ZW5jZSxcbiAgICAgICAgLy8gZWl0aGVyIGNvbXBsZXRlIG9yIGEgcHJlZml4XG4gICAgICAgIHN0YXRpYyBpc1ZhbGlkU2VxdWVuY2UocGFpcnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNlcXVlbmNlIG9mIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRURVJOX1NFUVVFTkNFUykge1xuICAgICAgICAgICAgICAgIGlmIChwYWlycy5sZW5ndGggPiBzZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBhaXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWlyc1tqXS5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0VmFsdWUoKSAhPSBzZXF1ZW5jZVtqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlUm93KHJvd051bWJlciwgd2FzUmV2ZXJzZWQpIHtcbiAgICAgICAgICAgIC8vIERpc2NhcmQgaWYgZHVwbGljYXRlIGFib3ZlIG9yIGJlbG93OyBvdGhlcndpc2UgaW5zZXJ0IGluIG9yZGVyIGJ5IHJvdyBudW1iZXIuXG4gICAgICAgICAgICBsZXQgaW5zZXJ0UG9zID0gMDtcbiAgICAgICAgICAgIGxldCBwcmV2SXNTYW1lID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbmV4dElzU2FtZSA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKGluc2VydFBvcyA8IHRoaXMucm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXJvdyA9IHRoaXMucm93c1tpbnNlcnRQb3NdO1xuICAgICAgICAgICAgICAgIGlmIChlcm93LmdldFJvd051bWJlcigpID4gcm93TnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRJc1NhbWUgPSBlcm93LmlzRXF1aXZhbGVudCh0aGlzLnBhaXJzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZJc1NhbWUgPSBlcm93LmlzRXF1aXZhbGVudCh0aGlzLnBhaXJzKTtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0SXNTYW1lIHx8IHByZXZJc1NhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSByb3cgd2FzIHBhcnRpYWxseSBkZWNvZGVkIChlLmcuIDIgcGFpcnMgZm91bmQgaW5zdGVhZCBvZiAzKSxcbiAgICAgICAgICAgIC8vIGl0IHdpbGwgcHJldmVudCB1cyBmcm9tIGRldGVjdGluZyB0aGUgYmFyY29kZS5cbiAgICAgICAgICAgIC8vIFRyeSB0byBtZXJnZSBwYXJ0aWFsIHJvd3NcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIHJvdyBpcyBwYXJ0IG9mIGFuIGFsbHJlYWR5IGRldGVjdGVkIHJvd1xuICAgICAgICAgICAgaWYgKFJTU0V4cGFuZGVkUmVhZGVyLmlzUGFydGlhbFJvdyh0aGlzLnBhaXJzLCB0aGlzLnJvd3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yb3dzLnB1c2goaW5zZXJ0UG9zLCBuZXcgRXhwYW5kZWRSb3codGhpcy5wYWlycywgcm93TnVtYmVyLCB3YXNSZXZlcnNlZCkpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVQYXJ0aWFsUm93cyh0aGlzLnBhaXJzLCB0aGlzLnJvd3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgdGhlIHJvd3MgdGhhdCBjb250YWlucyBvbmx5IHNwZWNpZmllZCBwYWlyc1xuICAgICAgICByZW1vdmVQYXJ0aWFsUm93cyhwYWlycywgcm93cykge1xuICAgICAgICAgICAgLy8gZm9yIChJdGVyYXRvcjxFeHBhbmRlZFJvdz4gaXRlcmF0b3IgPSByb3dzLml0ZXJhdG9yKCk7IGl0ZXJhdG9yLmhhc05leHQoKTspIHtcbiAgICAgICAgICAgIC8vICAgRXhwYW5kZWRSb3cgciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIC8vICAgaWYgKHIuZ2V0UGFpcnMoKS5zaXplKCkgPT0gcGFpcnMuc2l6ZSgpKSB7XG4gICAgICAgICAgICAvLyAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgIC8vICAgYm9vbGVhbiBhbGxGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAvLyAgIGZvciAoRXhwYW5kZWRQYWlyIHAgOiByLmdldFBhaXJzKCkpIHtcbiAgICAgICAgICAgIC8vICAgICBib29sZWFuIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAvLyAgICAgZm9yIChFeHBhbmRlZFBhaXIgcHAgOiBwYWlycykge1xuICAgICAgICAgICAgLy8gICAgICAgaWYgKHAuZXF1YWxzKHBwKSkge1xuICAgICAgICAgICAgLy8gICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAvLyAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gICAgICAgfVxuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAvLyAgICAgICBhbGxGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAvLyAgIGlmIChhbGxGb3VuZCkge1xuICAgICAgICAgICAgLy8gICAgIC8vICdwYWlycycgY29udGFpbnMgYWxsIHRoZSBwYWlycyBmcm9tIHRoZSByb3cgJ3InXG4gICAgICAgICAgICAvLyAgICAgaXRlcmF0b3IucmVtb3ZlKCk7XG4gICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIGZvciAobGV0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXRQYWlycygpLmxlbmd0aCA9PT0gcGFpcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIG9mIHJvdy5nZXRQYWlycygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHBwIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRXhwYW5kZWRQYWlyLmVxdWFscyhwLCBwcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm5zIHRydWUgd2hlbiBvbmUgb2YgdGhlIHJvd3MgYWxyZWFkeSBjb250YWlucyBhbGwgdGhlIHBhaXJzXG4gICAgICAgIHN0YXRpYyBpc1BhcnRpYWxSb3cocGFpcnMsIHJvd3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHIgb2Ygcm93cykge1xuICAgICAgICAgICAgICAgIGxldCBhbGxGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcHAgb2Ygci5nZXRQYWlycygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5lcXVhbHMocHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJvdyAncicgY29udGFpbiBhbGwgdGhlIHBhaXJzIGZyb20gJ3BhaXJzJ1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSB1c2VkIGZvciB1bml0IHRlc3RpbmdcbiAgICAgICAgZ2V0Um93cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHByaXZhdGUgZm9yIHVuaXQgdGVzdGluZ1xuICAgICAgICBzdGF0aWMgY29uc3RydWN0UmVzdWx0KHBhaXJzKSB7XG4gICAgICAgICAgICBsZXQgYmluYXJ5ID0gQml0QXJyYXlCdWlsZGVyLmJ1aWxkQml0QXJyYXkocGFpcnMpO1xuICAgICAgICAgICAgbGV0IGRlY29kZXIgPSBjcmVhdGVEZWNvZGVyKGJpbmFyeSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0aW5nU3RyaW5nID0gZGVjb2Rlci5wYXJzZUluZm9ybWF0aW9uKCk7XG4gICAgICAgICAgICBsZXQgZmlyc3RQb2ludHMgPSBwYWlyc1swXS5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0UmVzdWx0UG9pbnRzKCk7XG4gICAgICAgICAgICBsZXQgbGFzdFBvaW50cyA9IHBhaXJzW3BhaXJzLmxlbmd0aCAtIDFdLmdldEZpbmRlclBhdHRlcm4oKS5nZXRSZXN1bHRQb2ludHMoKTtcbiAgICAgICAgICAgIGxldCBwb2ludHMgPSBbZmlyc3RQb2ludHNbMF0sIGZpcnN0UG9pbnRzWzFdLCBsYXN0UG9pbnRzWzBdLCBsYXN0UG9pbnRzWzFdXTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzdWx0KHJlc3VsdGluZ1N0cmluZywgbnVsbCwgbnVsbCwgcG9pbnRzLCBCYXJjb2RlRm9ybWF0JDEuUlNTX0VYUEFOREVELCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0NoZWNrc3VtKCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0UGFpciA9IHRoaXMucGFpcnMuZ2V0KDApO1xuICAgICAgICAgICAgbGV0IGNoZWNrQ2hhcmFjdGVyID0gZmlyc3RQYWlyLmdldExlZnRDaGFyKCk7XG4gICAgICAgICAgICBsZXQgZmlyc3RDaGFyYWN0ZXIgPSBmaXJzdFBhaXIuZ2V0UmlnaHRDaGFyKCk7XG4gICAgICAgICAgICBpZiAoZmlyc3RDaGFyYWN0ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGVja3N1bSA9IGZpcnN0Q2hhcmFjdGVyLmdldENoZWNrc3VtUG9ydGlvbigpO1xuICAgICAgICAgICAgbGV0IHMgPSAyO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnBhaXJzLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRQYWlyID0gdGhpcy5wYWlycy5nZXQoaSk7XG4gICAgICAgICAgICAgICAgY2hlY2tzdW0gKz0gY3VycmVudFBhaXIuZ2V0TGVmdENoYXIoKS5nZXRDaGVja3N1bVBvcnRpb24oKTtcbiAgICAgICAgICAgICAgICBzKys7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRSaWdodENoYXIgPSBjdXJyZW50UGFpci5nZXRSaWdodENoYXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFJpZ2h0Q2hhciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrc3VtICs9IGN1cnJlbnRSaWdodENoYXIuZ2V0Q2hlY2tzdW1Qb3J0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja3N1bSAlPSAyMTE7XG4gICAgICAgICAgICBsZXQgY2hlY2tDaGFyYWN0ZXJWYWx1ZSA9IDIxMSAqIChzIC0gNCkgKyBjaGVja3N1bTtcbiAgICAgICAgICAgIHJldHVybiBjaGVja0NoYXJhY3RlclZhbHVlID09IGNoZWNrQ2hhcmFjdGVyLmdldFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldE5leHRTZWNvbmRCYXIocm93LCBpbml0aWFsUG9zKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFBvcztcbiAgICAgICAgICAgIGlmIChyb3cuZ2V0KGluaXRpYWxQb3MpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvcyA9IHJvdy5nZXROZXh0VW5zZXQoaW5pdGlhbFBvcyk7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvcyA9IHJvdy5nZXROZXh0U2V0KGN1cnJlbnRQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvcyA9IHJvdy5nZXROZXh0U2V0KGluaXRpYWxQb3MpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSByb3cuZ2V0TmV4dFVuc2V0KGN1cnJlbnRQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQb3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90IHByaXZhdGUgZm9yIHRlc3RpbmdcbiAgICAgICAgcmV0cmlldmVOZXh0UGFpcihyb3csIHByZXZpb3VzUGFpcnMsIHJvd051bWJlcikge1xuICAgICAgICAgICAgbGV0IGlzT2RkUGF0dGVybiA9IHByZXZpb3VzUGFpcnMubGVuZ3RoICUgMiA9PSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRGcm9tRXZlbikge1xuICAgICAgICAgICAgICAgIGlzT2RkUGF0dGVybiA9ICFpc09kZFBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGF0dGVybjtcbiAgICAgICAgICAgIGxldCBrZWVwRmluZGluZyA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZm9yY2VkT2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kTmV4dFBhaXIocm93LCBwcmV2aW91c1BhaXJzLCBmb3JjZWRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLnBhcnNlRm91bmRGaW5kZXJQYXR0ZXJuKHJvdywgcm93TnVtYmVyLCBpc09kZFBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VkT2Zmc2V0ID0gUlNTRXhwYW5kZWRSZWFkZXIuZ2V0TmV4dFNlY29uZEJhcihyb3csIHRoaXMuc3RhcnRFbmRbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2VlcEZpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChrZWVwRmluZGluZyk7XG4gICAgICAgICAgICAvLyBXaGVuIHN0YWNrZWQgc3ltYm9sIGlzIHNwbGl0IG92ZXIgbXVsdGlwbGUgcm93cywgdGhlcmUncyBubyB3YXkgdG8gZ3Vlc3MgaWYgdGhpcyBwYWlyIGNhbiBiZSBsYXN0IG9yIG5vdC5cbiAgICAgICAgICAgIC8vIGJvb2xlYW4gbWF5QmVMYXN0ID0gY2hlY2tQYWlyU2VxdWVuY2UocHJldmlvdXNQYWlycywgcGF0dGVybik7XG4gICAgICAgICAgICBsZXQgbGVmdENoYXIgPSB0aGlzLmRlY29kZURhdGFDaGFyYWN0ZXIocm93LCBwYXR0ZXJuLCBpc09kZFBhdHRlcm4sIHRydWUpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRW1wdHlQYWlyKHByZXZpb3VzUGFpcnMpICYmIHByZXZpb3VzUGFpcnNbcHJldmlvdXNQYWlycy5sZW5ndGggLSAxXS5tdXN0QmVMYXN0KCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByaWdodENoYXI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJpZ2h0Q2hhciA9IHRoaXMuZGVjb2RlRGF0YUNoYXJhY3Rlcihyb3csIHBhdHRlcm4sIGlzT2RkUGF0dGVybiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByaWdodENoYXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHBhbmRlZFBhaXIobGVmdENoYXIsIHJpZ2h0Q2hhciwgcGF0dGVybiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaXNFbXB0eVBhaXIocGFpcnMpIHtcbiAgICAgICAgICAgIGlmIChwYWlycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5kTmV4dFBhaXIocm93LCBwcmV2aW91c1BhaXJzLCBmb3JjZWRPZmZzZXQpIHtcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IHRoaXMuZ2V0RGVjb2RlRmluZGVyQ291bnRlcnMoKTtcbiAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzFdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgcm93T2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGZvcmNlZE9mZnNldCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0ID0gZm9yY2VkT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0VtcHR5UGFpcihwcmV2aW91c1BhaXJzKSkge1xuICAgICAgICAgICAgICAgIHJvd09mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdFBhaXIgPSBwcmV2aW91c1BhaXJzW3ByZXZpb3VzUGFpcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0ID0gbGFzdFBhaXIuZ2V0RmluZGVyUGF0dGVybigpLmdldFN0YXJ0RW5kKClbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2VhcmNoaW5nRXZlblBhaXIgPSBwcmV2aW91c1BhaXJzLmxlbmd0aCAlIDIgIT0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0RnJvbUV2ZW4pIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hpbmdFdmVuUGFpciA9ICFzZWFyY2hpbmdFdmVuUGFpcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAocm93T2Zmc2V0IDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIXJvdy5nZXQocm93T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvd09mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvdW50ZXJQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IHJvd09mZnNldDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmdldCh4KSAhPSBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaGluZ0V2ZW5QYWlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIucmV2ZXJzZUNvdW50ZXJzKGNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSU1NFeHBhbmRlZFJlYWRlci5pc0ZpbmRlclBhdHRlcm4oY291bnRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydEVuZFswXSA9IHBhdHRlcm5TdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RW5kWzFdID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoaW5nRXZlblBhaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5yZXZlcnNlQ291bnRlcnMoY291bnRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJzWzBdICsgY291bnRlcnNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1swXSA9IGNvdW50ZXJzWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbMV0gPSBjb3VudGVyc1szXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcmV2ZXJzZUNvdW50ZXJzKGNvdW50ZXJzKSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGggLyAyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG1wID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgY291bnRlcnNbaV0gPSBjb3VudGVyc1tsZW5ndGggLSBpIC0gMV07XG4gICAgICAgICAgICAgICAgY291bnRlcnNbbGVuZ3RoIC0gaSAtIDFdID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcnNlRm91bmRGaW5kZXJQYXR0ZXJuKHJvdywgcm93TnVtYmVyLCBvZGRQYXR0ZXJuKSB7XG4gICAgICAgICAgICAvLyBBY3R1YWxseSB3ZSBmb3VuZCBlbGVtZW50cyAyLTUuXG4gICAgICAgICAgICBsZXQgZmlyc3RDb3VudGVyO1xuICAgICAgICAgICAgbGV0IHN0YXJ0O1xuICAgICAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgICAgIGlmIChvZGRQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGF0dGVybiBudW1iZXIgaXMgb2RkLCB3ZSBuZWVkIHRvIGxvY2F0ZSBlbGVtZW50IDEgKmJlZm9yZSogdGhlIGN1cnJlbnQgYmxvY2suXG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0RWxlbWVudFN0YXJ0ID0gdGhpcy5zdGFydEVuZFswXSAtIDE7XG4gICAgICAgICAgICAgICAgLy8gTG9jYXRlIGVsZW1lbnQgMVxuICAgICAgICAgICAgICAgIHdoaWxlIChmaXJzdEVsZW1lbnRTdGFydCA+PSAwICYmICFyb3cuZ2V0KGZpcnN0RWxlbWVudFN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEVsZW1lbnRTdGFydC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaXJzdEVsZW1lbnRTdGFydCsrO1xuICAgICAgICAgICAgICAgIGZpcnN0Q291bnRlciA9IHRoaXMuc3RhcnRFbmRbMF0gLSBmaXJzdEVsZW1lbnRTdGFydDtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGZpcnN0RWxlbWVudFN0YXJ0O1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuc3RhcnRFbmRbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXR0ZXJuIG51bWJlciBpcyBldmVuLCB0aGUgcGF0dGVybiBpcyByZXZlcnNlZCwgc28gd2UgbmVlZCB0byBsb2NhdGUgZWxlbWVudCAxICphZnRlciogdGhlIGN1cnJlbnQgYmxvY2suXG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnN0YXJ0RW5kWzBdO1xuICAgICAgICAgICAgICAgIGVuZCA9IHJvdy5nZXROZXh0VW5zZXQodGhpcy5zdGFydEVuZFsxXSArIDEpO1xuICAgICAgICAgICAgICAgIGZpcnN0Q291bnRlciA9IGVuZCAtIHRoaXMuc3RhcnRFbmRbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlICdjb3VudGVycycgaG9sZCAxLTRcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IHRoaXMuZ2V0RGVjb2RlRmluZGVyQ291bnRlcnMoKTtcbiAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoY291bnRlcnMsIDAsIGNvdW50ZXJzLCAxLCBjb3VudGVycy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gZmlyc3RDb3VudGVyO1xuICAgICAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VGaW5kZXJWYWx1ZShjb3VudGVycywgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVFRFUk5TKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gbmV3IEZpbmRlclBhdHRlcm4odmFsdWUsIG5ldyBpbnRbXSB7IHN0YXJ0LCBlbmQgfSwgc3RhcnQsIGVuZCwgcm93TnVtYmVyfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbmRlclBhdHRlcm4odmFsdWUsIFtzdGFydCwgZW5kXSwgc3RhcnQsIGVuZCwgcm93TnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVEYXRhQ2hhcmFjdGVyKHJvdywgcGF0dGVybiwgaXNPZGRQYXR0ZXJuLCBsZWZ0Q2hhcikge1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJzID0gdGhpcy5nZXREYXRhQ2hhcmFjdGVyQ291bnRlcnMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgY291bnRlcnMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1t4XSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdENoYXIpIHtcbiAgICAgICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5yZWNvcmRQYXR0ZXJuSW5SZXZlcnNlKHJvdywgcGF0dGVybi5nZXRTdGFydEVuZCgpWzBdLCBjb3VudGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5yZWNvcmRQYXR0ZXJuKHJvdywgcGF0dGVybi5nZXRTdGFydEVuZCgpWzFdLCBjb3VudGVycyk7XG4gICAgICAgICAgICAgICAgLy8gcmV2ZXJzZSBpdFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gY291bnRlcnMubGVuZ3RoIC0gMTsgaSA8IGo7IGkrKywgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2ldID0gY291bnRlcnNbal07XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2pdID0gdGVtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIGNvdW50ZXJzW10gaGFzIHRoZSBwaXhlbHMgb2YgdGhlIG1vZHVsZVxuICAgICAgICAgICAgbGV0IG51bU1vZHVsZXMgPSAxNzsgLy8gbGVmdCBhbmQgcmlnaHQgZGF0YSBjaGFyYWN0ZXJzIGhhdmUgYWxsIHRoZSBzYW1lIGxlbmd0aFxuICAgICAgICAgICAgbGV0IGVsZW1lbnRXaWR0aCA9IE1hdGhVdGlscy5zdW0obmV3IEludDMyQXJyYXkoY291bnRlcnMpKSAvIG51bU1vZHVsZXM7XG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2s6IGVsZW1lbnQgd2lkdGggZm9yIHBhdHRlcm4gYW5kIHRoZSBjaGFyYWN0ZXIgc2hvdWxkIG1hdGNoXG4gICAgICAgICAgICBsZXQgZXhwZWN0ZWRFbGVtZW50V2lkdGggPSAocGF0dGVybi5nZXRTdGFydEVuZCgpWzFdIC0gcGF0dGVybi5nZXRTdGFydEVuZCgpWzBdKSAvIDE1LjA7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZWxlbWVudFdpZHRoIC0gZXhwZWN0ZWRFbGVtZW50V2lkdGgpIC8gZXhwZWN0ZWRFbGVtZW50V2lkdGggPiAwLjMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvZGRDb3VudHMgPSB0aGlzLmdldE9kZENvdW50cygpO1xuICAgICAgICAgICAgbGV0IGV2ZW5Db3VudHMgPSB0aGlzLmdldEV2ZW5Db3VudHMoKTtcbiAgICAgICAgICAgIGxldCBvZGRSb3VuZGluZ0Vycm9ycyA9IHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKTtcbiAgICAgICAgICAgIGxldCBldmVuUm91bmRpbmdFcnJvcnMgPSB0aGlzLmdldEV2ZW5Sb3VuZGluZ0Vycm9ycygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IDEuMCAqIGNvdW50ZXJzW2ldIC8gZWxlbWVudFdpZHRoO1xuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IHZhbHVlICsgMC41OyAvLyBSb3VuZFxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMC4zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvdW50ID4gOCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiA4LjcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGkgLyAyO1xuICAgICAgICAgICAgICAgIGlmICgoaSAmIDB4MDEpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2RkQ291bnRzW29mZnNldF0gPSBjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgb2RkUm91bmRpbmdFcnJvcnNbb2Zmc2V0XSA9IHZhbHVlIC0gY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBldmVuQ291bnRzW29mZnNldF0gPSBjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgZXZlblJvdW5kaW5nRXJyb3JzW29mZnNldF0gPSB2YWx1ZSAtIGNvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRqdXN0T2RkRXZlbkNvdW50cyhudW1Nb2R1bGVzKTtcbiAgICAgICAgICAgIGxldCB3ZWlnaHRSb3dOdW1iZXIgPSA0ICogcGF0dGVybi5nZXRWYWx1ZSgpICsgKGlzT2RkUGF0dGVybiA/IDAgOiAyKSArIChsZWZ0Q2hhciA/IDAgOiAxKSAtIDE7XG4gICAgICAgICAgICBsZXQgb2RkU3VtID0gMDtcbiAgICAgICAgICAgIGxldCBvZGRDaGVja3N1bVBvcnRpb24gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG9kZENvdW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChSU1NFeHBhbmRlZFJlYWRlci5pc05vdEExbGVmdChwYXR0ZXJuLCBpc09kZFBhdHRlcm4sIGxlZnRDaGFyKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2VpZ2h0ID0gUlNTRXhwYW5kZWRSZWFkZXIuV0VJR0hUU1t3ZWlnaHRSb3dOdW1iZXJdWzIgKiBpXTtcbiAgICAgICAgICAgICAgICAgICAgb2RkQ2hlY2tzdW1Qb3J0aW9uICs9IG9kZENvdW50c1tpXSAqIHdlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2RkU3VtICs9IG9kZENvdW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBldmVuQ2hlY2tzdW1Qb3J0aW9uID0gMDtcbiAgICAgICAgICAgIC8vIGludCBldmVuU3VtID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBldmVuQ291bnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKFJTU0V4cGFuZGVkUmVhZGVyLmlzTm90QTFsZWZ0KHBhdHRlcm4sIGlzT2RkUGF0dGVybiwgbGVmdENoYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3ZWlnaHQgPSBSU1NFeHBhbmRlZFJlYWRlci5XRUlHSFRTW3dlaWdodFJvd051bWJlcl1bMiAqIGkgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbkNoZWNrc3VtUG9ydGlvbiArPSBldmVuQ291bnRzW2ldICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBldmVuU3VtICs9IGV2ZW5Db3VudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hlY2tzdW1Qb3J0aW9uID0gb2RkQ2hlY2tzdW1Qb3J0aW9uICsgZXZlbkNoZWNrc3VtUG9ydGlvbjtcbiAgICAgICAgICAgIGlmICgob2RkU3VtICYgMHgwMSkgIT0gMCB8fCBvZGRTdW0gPiAxMyB8fCBvZGRTdW0gPCA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSAoMTMgLSBvZGRTdW0pIC8gMjtcbiAgICAgICAgICAgIGxldCBvZGRXaWRlc3QgPSBSU1NFeHBhbmRlZFJlYWRlci5TWU1CT0xfV0lERVNUW2dyb3VwXTtcbiAgICAgICAgICAgIGxldCBldmVuV2lkZXN0ID0gOSAtIG9kZFdpZGVzdDtcbiAgICAgICAgICAgIGxldCB2T2RkID0gUlNTVXRpbHMuZ2V0UlNTdmFsdWUob2RkQ291bnRzLCBvZGRXaWRlc3QsIHRydWUpO1xuICAgICAgICAgICAgbGV0IHZFdmVuID0gUlNTVXRpbHMuZ2V0UlNTdmFsdWUoZXZlbkNvdW50cywgZXZlbldpZGVzdCwgZmFsc2UpO1xuICAgICAgICAgICAgbGV0IHRFdmVuID0gUlNTRXhwYW5kZWRSZWFkZXIuRVZFTl9UT1RBTF9TVUJTRVRbZ3JvdXBdO1xuICAgICAgICAgICAgbGV0IGdTdW0gPSBSU1NFeHBhbmRlZFJlYWRlci5HU1VNW2dyb3VwXTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHZPZGQgKiB0RXZlbiArIHZFdmVuICsgZ1N1bTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YUNoYXJhY3Rlcih2YWx1ZSwgY2hlY2tzdW1Qb3J0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXNOb3RBMWxlZnQocGF0dGVybiwgaXNPZGRQYXR0ZXJuLCBsZWZ0Q2hhcikge1xuICAgICAgICAgICAgLy8gQTE6IHBhdHRlcm4uZ2V0VmFsdWUgaXMgMCAoQSksIGFuZCBpdCdzIGFuIG9kZFBhdHRlcm4sIGFuZCBpdCBpcyBhIGxlZnQgY2hhclxuICAgICAgICAgICAgcmV0dXJuICEocGF0dGVybi5nZXRWYWx1ZSgpID09IDAgJiYgaXNPZGRQYXR0ZXJuICYmIGxlZnRDaGFyKTtcbiAgICAgICAgfVxuICAgICAgICBhZGp1c3RPZGRFdmVuQ291bnRzKG51bU1vZHVsZXMpIHtcbiAgICAgICAgICAgIGxldCBvZGRTdW0gPSBNYXRoVXRpbHMuc3VtKG5ldyBJbnQzMkFycmF5KHRoaXMuZ2V0T2RkQ291bnRzKCkpKTtcbiAgICAgICAgICAgIGxldCBldmVuU3VtID0gTWF0aFV0aWxzLnN1bShuZXcgSW50MzJBcnJheSh0aGlzLmdldEV2ZW5Db3VudHMoKSkpO1xuICAgICAgICAgICAgbGV0IGluY3JlbWVudE9kZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGRlY3JlbWVudE9kZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG9kZFN1bSA+IDEzKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9kZFN1bSA8IDQpIHtcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGluY3JlbWVudEV2ZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBkZWNyZW1lbnRFdmVuID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXZlblN1bSA+IDEzKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVuU3VtIDwgNCkge1xuICAgICAgICAgICAgICAgIGluY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1pc21hdGNoID0gb2RkU3VtICsgZXZlblN1bSAtIG51bU1vZHVsZXM7XG4gICAgICAgICAgICBsZXQgb2RkUGFyaXR5QmFkID0gKG9kZFN1bSAmIDB4MDEpID09IDE7XG4gICAgICAgICAgICBsZXQgZXZlblBhcml0eUJhZCA9IChldmVuU3VtICYgMHgwMSkgPT0gMDtcbiAgICAgICAgICAgIGlmIChtaXNtYXRjaCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9kZFBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWlzbWF0Y2ggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAob2RkUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtaXNtYXRjaCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9kZFBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEJvdGggYmFkXG4gICAgICAgICAgICAgICAgICAgIGlmIChvZGRTdW0gPCBldmVuU3VtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluY3JlbWVudE9kZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWNyZW1lbnRPZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLmluY3JlbWVudCh0aGlzLmdldE9kZENvdW50cygpLCB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY3JlbWVudE9kZCkge1xuICAgICAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLmRlY3JlbWVudCh0aGlzLmdldE9kZENvdW50cygpLCB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluY3JlbWVudEV2ZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVjcmVtZW50RXZlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuaW5jcmVtZW50KHRoaXMuZ2V0RXZlbkNvdW50cygpLCB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY3JlbWVudEV2ZW4pIHtcbiAgICAgICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5kZWNyZW1lbnQodGhpcy5nZXRFdmVuQ291bnRzKCksIHRoaXMuZ2V0RXZlblJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFJTU0V4cGFuZGVkUmVhZGVyLlNZTUJPTF9XSURFU1QgPSBbNywgNSwgNCwgMywgMV07XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRVZFTl9UT1RBTF9TVUJTRVQgPSBbNCwgMjAsIDUyLCAxMDQsIDIwNF07XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuR1NVTSA9IFswLCAzNDgsIDEzODgsIDI5NDgsIDM5ODhdO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRURVJOUyA9IFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCA4LCA0LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgNiwgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDQsIDYsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAyLCA4LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgNiwgNSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDksIDFdKSAvLyBGXG4gICAgXTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5XRUlHSFRTID0gW1xuICAgICAgICBbMSwgMywgOSwgMjcsIDgxLCAzMiwgOTYsIDc3XSxcbiAgICAgICAgWzIwLCA2MCwgMTgwLCAxMTgsIDE0MywgNywgMjEsIDYzXSxcbiAgICAgICAgWzE4OSwgMTQ1LCAxMywgMzksIDExNywgMTQwLCAyMDksIDIwNV0sXG4gICAgICAgIFsxOTMsIDE1NywgNDksIDE0NywgMTksIDU3LCAxNzEsIDkxXSxcbiAgICAgICAgWzYyLCAxODYsIDEzNiwgMTk3LCAxNjksIDg1LCA0NCwgMTMyXSxcbiAgICAgICAgWzE4NSwgMTMzLCAxODgsIDE0MiwgNCwgMTIsIDM2LCAxMDhdLFxuICAgICAgICBbMTEzLCAxMjgsIDE3MywgOTcsIDgwLCAyOSwgODcsIDUwXSxcbiAgICAgICAgWzE1MCwgMjgsIDg0LCA0MSwgMTIzLCAxNTgsIDUyLCAxNTZdLFxuICAgICAgICBbNDYsIDEzOCwgMjAzLCAxODcsIDEzOSwgMjA2LCAxOTYsIDE2Nl0sXG4gICAgICAgIFs3NiwgMTcsIDUxLCAxNTMsIDM3LCAxMTEsIDEyMiwgMTU1XSxcbiAgICAgICAgWzQzLCAxMjksIDE3NiwgMTA2LCAxMDcsIDExMCwgMTE5LCAxNDZdLFxuICAgICAgICBbMTYsIDQ4LCAxNDQsIDEwLCAzMCwgOTAsIDU5LCAxNzddLFxuICAgICAgICBbMTA5LCAxMTYsIDEzNywgMjAwLCAxNzgsIDExMiwgMTI1LCAxNjRdLFxuICAgICAgICBbNzAsIDIxMCwgMjA4LCAyMDIsIDE4NCwgMTMwLCAxNzksIDExNV0sXG4gICAgICAgIFsxMzQsIDE5MSwgMTUxLCAzMSwgOTMsIDY4LCAyMDQsIDE5MF0sXG4gICAgICAgIFsxNDgsIDIyLCA2NiwgMTk4LCAxNzIsIDk0LCA3MSwgMl0sXG4gICAgICAgIFs2LCAxOCwgNTQsIDE2MiwgNjQsIDE5MiwgMTU0LCA0MF0sXG4gICAgICAgIFsxMjAsIDE0OSwgMjUsIDc1LCAxNCwgNDIsIDEyNiwgMTY3XSxcbiAgICAgICAgWzc5LCAyNiwgNzgsIDIzLCA2OSwgMjA3LCAxOTksIDE3NV0sXG4gICAgICAgIFsxMDMsIDk4LCA4MywgMzgsIDExNCwgMTMxLCAxODIsIDEyNF0sXG4gICAgICAgIFsxNjEsIDYxLCAxODMsIDEyNywgMTcwLCA4OCwgNTMsIDE1OV0sXG4gICAgICAgIFs1NSwgMTY1LCA3MywgOCwgMjQsIDcyLCA1LCAxNV0sXG4gICAgICAgIFs0NSwgMTM1LCAxOTQsIDE2MCwgNTgsIDE3NCwgMTAwLCA4OV1cbiAgICBdO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSA9IDA7XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CID0gMTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MgPSAyO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCA9IDM7XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FID0gNDtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0YgPSA1O1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRURVJOX1NFUVVFTkNFUyA9IFtcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BXSxcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0JdLFxuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9EXSxcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DXSxcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0ZdLFxuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GXSxcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9EXSxcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0VdLFxuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQywgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GXSxcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GXSxcbiAgICBdO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLk1BWF9QQUlSUyA9IDExO1xuXG4gICAgY2xhc3MgUGFpciBleHRlbmRzIERhdGFDaGFyYWN0ZXIge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgY2hlY2tzdW1Qb3J0aW9uLCBmaW5kZXJQYXR0ZXJuKSB7XG4gICAgICAgICAgICBzdXBlcih2YWx1ZSwgY2hlY2tzdW1Qb3J0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5maW5kZXJQYXR0ZXJuID0gZmluZGVyUGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICBnZXRGaW5kZXJQYXR0ZXJuKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZGVyUGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICBnZXRDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGluY3JlbWVudENvdW50KCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgUlNTMTRSZWFkZXIgZXh0ZW5kcyBBYnN0cmFjdFJTU1JlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMucG9zc2libGVMZWZ0UGFpcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMucG9zc2libGVSaWdodFBhaXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICAgICAgY29uc3QgbGVmdFBhaXIgPSB0aGlzLmRlY29kZVBhaXIocm93LCBmYWxzZSwgcm93TnVtYmVyLCBoaW50cyk7XG4gICAgICAgICAgICBSU1MxNFJlYWRlci5hZGRPclRhbGx5KHRoaXMucG9zc2libGVMZWZ0UGFpcnMsIGxlZnRQYWlyKTtcbiAgICAgICAgICAgIHJvdy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsZXQgcmlnaHRQYWlyID0gdGhpcy5kZWNvZGVQYWlyKHJvdywgdHJ1ZSwgcm93TnVtYmVyLCBoaW50cyk7XG4gICAgICAgICAgICBSU1MxNFJlYWRlci5hZGRPclRhbGx5KHRoaXMucG9zc2libGVSaWdodFBhaXJzLCByaWdodFBhaXIpO1xuICAgICAgICAgICAgcm93LnJldmVyc2UoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGxlZnQgb2YgdGhpcy5wb3NzaWJsZUxlZnRQYWlycykge1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0LmdldENvdW50KCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHJpZ2h0IG9mIHRoaXMucG9zc2libGVSaWdodFBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHQuZ2V0Q291bnQoKSA+IDEgJiYgUlNTMTRSZWFkZXIuY2hlY2tDaGVja3N1bShsZWZ0LCByaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUlNTMTRSZWFkZXIuY29uc3RydWN0UmVzdWx0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhZGRPclRhbGx5KHBvc3NpYmxlUGFpcnMsIHBhaXIpIHtcbiAgICAgICAgICAgIGlmIChwYWlyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IG90aGVyIG9mIHBvc3NpYmxlUGFpcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3RoZXIuZ2V0VmFsdWUoKSA9PT0gcGFpci5nZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyLmluY3JlbWVudENvdW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlUGFpcnMucHVzaChwYWlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIHRoaXMucG9zc2libGVMZWZ0UGFpcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMucG9zc2libGVSaWdodFBhaXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNvbnN0cnVjdFJlc3VsdChsZWZ0UGFpciwgcmlnaHRQYWlyKSB7XG4gICAgICAgICAgICBsZXQgc3ltYm9sVmFsdWUgPSA0NTM3MDc3ICogbGVmdFBhaXIuZ2V0VmFsdWUoKSArIHJpZ2h0UGFpci5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgbGV0IHRleHQgPSBuZXcgU3RyaW5nKHN5bWJvbFZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTMgLSB0ZXh0Lmxlbmd0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQodGV4dCk7XG4gICAgICAgICAgICBsZXQgY2hlY2tEaWdpdCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlnaXQgPSBidWZmZXIuY2hhckF0KGkpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBjaGVja0RpZ2l0ICs9ICgoaSAmIDB4MDEpID09PSAwKSA/IDMgKiBkaWdpdCA6IGRpZ2l0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2tEaWdpdCA9IDEwIC0gKGNoZWNrRGlnaXQgJSAxMCk7XG4gICAgICAgICAgICBpZiAoY2hlY2tEaWdpdCA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICBjaGVja0RpZ2l0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoY2hlY2tEaWdpdC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGxldCBsZWZ0UG9pbnRzID0gbGVmdFBhaXIuZ2V0RmluZGVyUGF0dGVybigpLmdldFJlc3VsdFBvaW50cygpO1xuICAgICAgICAgICAgbGV0IHJpZ2h0UG9pbnRzID0gcmlnaHRQYWlyLmdldEZpbmRlclBhdHRlcm4oKS5nZXRSZXN1bHRQb2ludHMoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzdWx0KGJ1ZmZlci50b1N0cmluZygpLCBudWxsLCAwLCBbbGVmdFBvaW50c1swXSwgbGVmdFBvaW50c1sxXSwgcmlnaHRQb2ludHNbMF0sIHJpZ2h0UG9pbnRzWzFdXSwgQmFyY29kZUZvcm1hdCQxLlJTU18xNCwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjaGVja0NoZWNrc3VtKGxlZnRQYWlyLCByaWdodFBhaXIpIHtcbiAgICAgICAgICAgIGxldCBjaGVja1ZhbHVlID0gKGxlZnRQYWlyLmdldENoZWNrc3VtUG9ydGlvbigpICsgMTYgKiByaWdodFBhaXIuZ2V0Q2hlY2tzdW1Qb3J0aW9uKCkpICUgNzk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0Q2hlY2tWYWx1ZSA9IDkgKiBsZWZ0UGFpci5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0VmFsdWUoKSArIHJpZ2h0UGFpci5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRDaGVja1ZhbHVlID4gNzIpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRDaGVja1ZhbHVlLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0Q2hlY2tWYWx1ZSA+IDgpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRDaGVja1ZhbHVlLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tWYWx1ZSA9PT0gdGFyZ2V0Q2hlY2tWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVQYWlyKHJvdywgcmlnaHQsIHJvd051bWJlciwgaGludHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0RW5kID0gdGhpcy5maW5kRmluZGVyUGF0dGVybihyb3csIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IHRoaXMucGFyc2VGb3VuZEZpbmRlclBhdHRlcm4ocm93LCByb3dOdW1iZXIsIHJpZ2h0LCBzdGFydEVuZCk7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdFBvaW50Q2FsbGJhY2sgPSBoaW50cyA9PSBudWxsID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLk5FRURfUkVTVUxUX1BPSU5UX0NBTExCQUNLKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0UG9pbnRDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjZW50ZXIgPSAoc3RhcnRFbmRbMF0gKyBzdGFydEVuZFsxXSkgLyAyLjA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm93IGlzIGFjdHVhbGx5IHJldmVyc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXIgPSByb3cuZ2V0U2l6ZSgpIC0gMSAtIGNlbnRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRQb2ludENhbGxiYWNrLmZvdW5kUG9zc2libGVSZXN1bHRQb2ludChuZXcgUmVzdWx0UG9pbnQoY2VudGVyLCByb3dOdW1iZXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG91dHNpZGUgPSB0aGlzLmRlY29kZURhdGFDaGFyYWN0ZXIocm93LCBwYXR0ZXJuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBsZXQgaW5zaWRlID0gdGhpcy5kZWNvZGVEYXRhQ2hhcmFjdGVyKHJvdywgcGF0dGVybiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGFpcigxNTk3ICogb3V0c2lkZS5nZXRWYWx1ZSgpICsgaW5zaWRlLmdldFZhbHVlKCksIG91dHNpZGUuZ2V0Q2hlY2tzdW1Qb3J0aW9uKCkgKyA0ICogaW5zaWRlLmdldENoZWNrc3VtUG9ydGlvbigpLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVEYXRhQ2hhcmFjdGVyKHJvdywgcGF0dGVybiwgb3V0c2lkZUNoYXIpIHtcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IHRoaXMuZ2V0RGF0YUNoYXJhY3RlckNvdW50ZXJzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGNvdW50ZXJzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcnNbeF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG91dHNpZGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgT25lRFJlYWRlci5yZWNvcmRQYXR0ZXJuSW5SZXZlcnNlKHJvdywgcGF0dGVybi5nZXRTdGFydEVuZCgpWzBdLCBjb3VudGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBPbmVEUmVhZGVyLnJlY29yZFBhdHRlcm4ocm93LCBwYXR0ZXJuLmdldFN0YXJ0RW5kKClbMV0gKyAxLCBjb3VudGVycyk7XG4gICAgICAgICAgICAgICAgLy8gcmV2ZXJzZSBpdFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gY291bnRlcnMubGVuZ3RoIC0gMTsgaSA8IGo7IGkrKywgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2ldID0gY291bnRlcnNbal07XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2pdID0gdGVtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbnVtTW9kdWxlcyA9IG91dHNpZGVDaGFyID8gMTYgOiAxNTtcbiAgICAgICAgICAgIGxldCBlbGVtZW50V2lkdGggPSBNYXRoVXRpbHMuc3VtKG5ldyBJbnQzMkFycmF5KGNvdW50ZXJzKSkgLyBudW1Nb2R1bGVzO1xuICAgICAgICAgICAgbGV0IG9kZENvdW50cyA9IHRoaXMuZ2V0T2RkQ291bnRzKCk7XG4gICAgICAgICAgICBsZXQgZXZlbkNvdW50cyA9IHRoaXMuZ2V0RXZlbkNvdW50cygpO1xuICAgICAgICAgICAgbGV0IG9kZFJvdW5kaW5nRXJyb3JzID0gdGhpcy5nZXRPZGRSb3VuZGluZ0Vycm9ycygpO1xuICAgICAgICAgICAgbGV0IGV2ZW5Sb3VuZGluZ0Vycm9ycyA9IHRoaXMuZ2V0RXZlblJvdW5kaW5nRXJyb3JzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gY291bnRlcnNbaV0gLyBlbGVtZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gTWF0aC5mbG9vcih2YWx1ZSArIDAuNSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvdW50ID4gOCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBNYXRoLmZsb29yKGkgLyAyKTtcbiAgICAgICAgICAgICAgICBpZiAoKGkgJiAweDAxKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZGRDb3VudHNbb2Zmc2V0XSA9IGNvdW50O1xuICAgICAgICAgICAgICAgICAgICBvZGRSb3VuZGluZ0Vycm9yc1tvZmZzZXRdID0gdmFsdWUgLSBjb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW5Db3VudHNbb2Zmc2V0XSA9IGNvdW50O1xuICAgICAgICAgICAgICAgICAgICBldmVuUm91bmRpbmdFcnJvcnNbb2Zmc2V0XSA9IHZhbHVlIC0gY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGp1c3RPZGRFdmVuQ291bnRzKG91dHNpZGVDaGFyLCBudW1Nb2R1bGVzKTtcbiAgICAgICAgICAgIGxldCBvZGRTdW0gPSAwO1xuICAgICAgICAgICAgbGV0IG9kZENoZWNrc3VtUG9ydGlvbiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gb2RkQ291bnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgb2RkQ2hlY2tzdW1Qb3J0aW9uICo9IDk7XG4gICAgICAgICAgICAgICAgb2RkQ2hlY2tzdW1Qb3J0aW9uICs9IG9kZENvdW50c1tpXTtcbiAgICAgICAgICAgICAgICBvZGRTdW0gKz0gb2RkQ291bnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV2ZW5DaGVja3N1bVBvcnRpb24gPSAwO1xuICAgICAgICAgICAgbGV0IGV2ZW5TdW0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGV2ZW5Db3VudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBldmVuQ2hlY2tzdW1Qb3J0aW9uICo9IDk7XG4gICAgICAgICAgICAgICAgZXZlbkNoZWNrc3VtUG9ydGlvbiArPSBldmVuQ291bnRzW2ldO1xuICAgICAgICAgICAgICAgIGV2ZW5TdW0gKz0gZXZlbkNvdW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGVja3N1bVBvcnRpb24gPSBvZGRDaGVja3N1bVBvcnRpb24gKyAzICogZXZlbkNoZWNrc3VtUG9ydGlvbjtcbiAgICAgICAgICAgIGlmIChvdXRzaWRlQ2hhcikge1xuICAgICAgICAgICAgICAgIGlmICgob2RkU3VtICYgMHgwMSkgIT09IDAgfHwgb2RkU3VtID4gMTIgfHwgb2RkU3VtIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gKDEyIC0gb2RkU3VtKSAvIDI7XG4gICAgICAgICAgICAgICAgbGV0IG9kZFdpZGVzdCA9IFJTUzE0UmVhZGVyLk9VVFNJREVfT0REX1dJREVTVFtncm91cF07XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW5XaWRlc3QgPSA5IC0gb2RkV2lkZXN0O1xuICAgICAgICAgICAgICAgIGxldCB2T2RkID0gUlNTVXRpbHMuZ2V0UlNTdmFsdWUob2RkQ291bnRzLCBvZGRXaWRlc3QsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBsZXQgdkV2ZW4gPSBSU1NVdGlscy5nZXRSU1N2YWx1ZShldmVuQ291bnRzLCBldmVuV2lkZXN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBsZXQgdEV2ZW4gPSBSU1MxNFJlYWRlci5PVVRTSURFX0VWRU5fVE9UQUxfU1VCU0VUW2dyb3VwXTtcbiAgICAgICAgICAgICAgICBsZXQgZ1N1bSA9IFJTUzE0UmVhZGVyLk9VVFNJREVfR1NVTVtncm91cF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhQ2hhcmFjdGVyKHZPZGQgKiB0RXZlbiArIHZFdmVuICsgZ1N1bSwgY2hlY2tzdW1Qb3J0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgoZXZlblN1bSAmIDB4MDEpICE9PSAwIHx8IGV2ZW5TdW0gPiAxMCB8fCBldmVuU3VtIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gKDEwIC0gZXZlblN1bSkgLyAyO1xuICAgICAgICAgICAgICAgIGxldCBvZGRXaWRlc3QgPSBSU1MxNFJlYWRlci5JTlNJREVfT0REX1dJREVTVFtncm91cF07XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW5XaWRlc3QgPSA5IC0gb2RkV2lkZXN0O1xuICAgICAgICAgICAgICAgIGxldCB2T2RkID0gUlNTVXRpbHMuZ2V0UlNTdmFsdWUob2RkQ291bnRzLCBvZGRXaWRlc3QsIHRydWUpO1xuICAgICAgICAgICAgICAgIGxldCB2RXZlbiA9IFJTU1V0aWxzLmdldFJTU3ZhbHVlKGV2ZW5Db3VudHMsIGV2ZW5XaWRlc3QsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBsZXQgdE9kZCA9IFJTUzE0UmVhZGVyLklOU0lERV9PRERfVE9UQUxfU1VCU0VUW2dyb3VwXTtcbiAgICAgICAgICAgICAgICBsZXQgZ1N1bSA9IFJTUzE0UmVhZGVyLklOU0lERV9HU1VNW2dyb3VwXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGFDaGFyYWN0ZXIodkV2ZW4gKiB0T2RkICsgdk9kZCArIGdTdW0sIGNoZWNrc3VtUG9ydGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluZEZpbmRlclBhdHRlcm4ocm93LCByaWdodEZpbmRlclBhdHRlcm4pIHtcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IHRoaXMuZ2V0RGVjb2RlRmluZGVyQ291bnRlcnMoKTtcbiAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzFdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHJvd09mZnNldCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAocm93T2Zmc2V0IDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIXJvdy5nZXQocm93T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRGaW5kZXJQYXR0ZXJuID09PSBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdpbGwgZW5jb3VudGVyIHdoaXRlIGZpcnN0IHdoZW4gc2VhcmNoaW5nIGZvciByaWdodCBmaW5kZXIgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY291bnRlclBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSByb3dPZmZzZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gcm93T2Zmc2V0OyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGlmIChyb3cuZ2V0KHgpICE9PSBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBYnN0cmFjdFJTU1JlYWRlci5pc0ZpbmRlclBhdHRlcm4oY291bnRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtwYXR0ZXJuU3RhcnQsIHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJzWzBdICsgY291bnRlcnNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1swXSA9IGNvdW50ZXJzWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbMV0gPSBjb3VudGVyc1szXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUZvdW5kRmluZGVyUGF0dGVybihyb3csIHJvd051bWJlciwgcmlnaHQsIHN0YXJ0RW5kKSB7XG4gICAgICAgICAgICAvLyBBY3R1YWxseSB3ZSBmb3VuZCBlbGVtZW50cyAyLTVcbiAgICAgICAgICAgIGxldCBmaXJzdElzQmxhY2sgPSByb3cuZ2V0KHN0YXJ0RW5kWzBdKTtcbiAgICAgICAgICAgIGxldCBmaXJzdEVsZW1lbnRTdGFydCA9IHN0YXJ0RW5kWzBdIC0gMTtcbiAgICAgICAgICAgIC8vIExvY2F0ZSBlbGVtZW50IDFcbiAgICAgICAgICAgIHdoaWxlIChmaXJzdEVsZW1lbnRTdGFydCA+PSAwICYmIGZpcnN0SXNCbGFjayAhPT0gcm93LmdldChmaXJzdEVsZW1lbnRTdGFydCkpIHtcbiAgICAgICAgICAgICAgICBmaXJzdEVsZW1lbnRTdGFydC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3RFbGVtZW50U3RhcnQrKztcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q291bnRlciA9IHN0YXJ0RW5kWzBdIC0gZmlyc3RFbGVtZW50U3RhcnQ7XG4gICAgICAgICAgICAvLyBNYWtlICdjb3VudGVycycgaG9sZCAxLTRcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5nZXREZWNvZGVGaW5kZXJDb3VudGVycygpO1xuICAgICAgICAgICAgY29uc3QgY29weSA9IG5ldyBJbnQzMkFycmF5KGNvdW50ZXJzLmxlbmd0aCk7XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGNvdW50ZXJzLCAwLCBjb3B5LCAxLCBjb3VudGVycy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGNvcHlbMF0gPSBmaXJzdENvdW50ZXI7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucGFyc2VGaW5kZXJWYWx1ZShjb3B5LCBSU1MxNFJlYWRlci5GSU5ERVJfUEFUVEVSTlMpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gZmlyc3RFbGVtZW50U3RhcnQ7XG4gICAgICAgICAgICBsZXQgZW5kID0gc3RhcnRFbmRbMV07XG4gICAgICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyByb3cgaXMgYWN0dWFsbHkgcmV2ZXJzZWRcbiAgICAgICAgICAgICAgICBzdGFydCA9IHJvdy5nZXRTaXplKCkgLSAxIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgZW5kID0gcm93LmdldFNpemUoKSAtIDEgLSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbmRlclBhdHRlcm4odmFsdWUsIFtmaXJzdEVsZW1lbnRTdGFydCwgc3RhcnRFbmRbMV1dLCBzdGFydCwgZW5kLCByb3dOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGFkanVzdE9kZEV2ZW5Db3VudHMob3V0c2lkZUNoYXIsIG51bU1vZHVsZXMpIHtcbiAgICAgICAgICAgIGxldCBvZGRTdW0gPSBNYXRoVXRpbHMuc3VtKG5ldyBJbnQzMkFycmF5KHRoaXMuZ2V0T2RkQ291bnRzKCkpKTtcbiAgICAgICAgICAgIGxldCBldmVuU3VtID0gTWF0aFV0aWxzLnN1bShuZXcgSW50MzJBcnJheSh0aGlzLmdldEV2ZW5Db3VudHMoKSkpO1xuICAgICAgICAgICAgbGV0IGluY3JlbWVudE9kZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGRlY3JlbWVudE9kZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGluY3JlbWVudEV2ZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBkZWNyZW1lbnRFdmVuID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAob3V0c2lkZUNoYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAob2RkU3VtID4gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2RkU3VtIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlblN1bSA+IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVuU3VtIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob2RkU3VtID4gMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2RkU3VtIDwgNSkge1xuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlblN1bSA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVuU3VtIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWlzbWF0Y2ggPSBvZGRTdW0gKyBldmVuU3VtIC0gbnVtTW9kdWxlcztcbiAgICAgICAgICAgIGxldCBvZGRQYXJpdHlCYWQgPSAob2RkU3VtICYgMHgwMSkgPT09IChvdXRzaWRlQ2hhciA/IDEgOiAwKTtcbiAgICAgICAgICAgIGxldCBldmVuUGFyaXR5QmFkID0gKGV2ZW5TdW0gJiAweDAxKSA9PT0gMTtcbiAgICAgICAgICAgIGlmIChtaXNtYXRjaCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChvZGRQYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1pc21hdGNoID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChvZGRQYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1pc21hdGNoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9kZFBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEJvdGggYmFkXG4gICAgICAgICAgICAgICAgICAgIGlmIChvZGRTdW0gPCBldmVuU3VtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluY3JlbWVudE9kZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWNyZW1lbnRPZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEFic3RyYWN0UlNTUmVhZGVyLmluY3JlbWVudCh0aGlzLmdldE9kZENvdW50cygpLCB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY3JlbWVudE9kZCkge1xuICAgICAgICAgICAgICAgIEFic3RyYWN0UlNTUmVhZGVyLmRlY3JlbWVudCh0aGlzLmdldE9kZENvdW50cygpLCB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluY3JlbWVudEV2ZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVjcmVtZW50RXZlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQWJzdHJhY3RSU1NSZWFkZXIuaW5jcmVtZW50KHRoaXMuZ2V0RXZlbkNvdW50cygpLCB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY3JlbWVudEV2ZW4pIHtcbiAgICAgICAgICAgICAgICBBYnN0cmFjdFJTU1JlYWRlci5kZWNyZW1lbnQodGhpcy5nZXRFdmVuQ291bnRzKCksIHRoaXMuZ2V0RXZlblJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFJTUzE0UmVhZGVyLk9VVFNJREVfRVZFTl9UT1RBTF9TVUJTRVQgPSBbMSwgMTAsIDM0LCA3MCwgMTI2XTtcbiAgICBSU1MxNFJlYWRlci5JTlNJREVfT0REX1RPVEFMX1NVQlNFVCA9IFs0LCAyMCwgNDgsIDgxXTtcbiAgICBSU1MxNFJlYWRlci5PVVRTSURFX0dTVU0gPSBbMCwgMTYxLCA5NjEsIDIwMTUsIDI3MTVdO1xuICAgIFJTUzE0UmVhZGVyLklOU0lERV9HU1VNID0gWzAsIDMzNiwgMTAzNiwgMTUxNl07XG4gICAgUlNTMTRSZWFkZXIuT1VUU0lERV9PRERfV0lERVNUID0gWzgsIDYsIDQsIDMsIDFdO1xuICAgIFJTUzE0UmVhZGVyLklOU0lERV9PRERfV0lERVNUID0gWzIsIDQsIDYsIDhdO1xuICAgIFJTUzE0UmVhZGVyLkZJTkRFUl9QQVRURVJOUyA9IFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCA4LCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgNSwgNSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDMsIDcsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAxLCA5LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgNywgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDUsIDYsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCA4LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgNSwgNywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDksIDFdKSxcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBEYW5pZWwgU3dpdGtpbiA8ZHN3aXRraW5AZ29vZ2xlLmNvbT5cbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIE11bHRpRm9ybWF0T25lRFJlYWRlciBleHRlbmRzIE9uZURSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihoaW50cywgdmVyYm9zZSkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMucmVhZGVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy52ZXJib3NlID0gKHZlcmJvc2UgPT09IHRydWUpO1xuICAgICAgICAgICAgY29uc3QgcG9zc2libGVGb3JtYXRzID0gIWhpbnRzID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlBPU1NJQkxFX0ZPUk1BVFMpO1xuICAgICAgICAgICAgY29uc3QgdXNlQ29kZTM5Q2hlY2tEaWdpdCA9IGhpbnRzICYmIGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLkFTU1VNRV9DT0RFXzM5X0NIRUNLX0RJR0lUKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cykge1xuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLkVBTl8xMykgfHxcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5VUENfQSkgfHxcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5FQU5fOCkgfHxcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5VUENfRSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IE11bHRpRm9ybWF0VVBDRUFOUmVhZGVyKGhpbnRzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLkNPREVfMzkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBDb2RlMzlSZWFkZXIodXNlQ29kZTM5Q2hlY2tEaWdpdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiAocG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQuQ09ERV85MykpIHtcbiAgICAgICAgICAgICAgICAvLyAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kZTkzUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5DT0RFXzEyOCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGUxMjhSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLklURikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IElURlJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0LkNPREFCQVIpKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGFCYXJSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLlJTU18xNCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IFJTUzE0UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5SU1NfRVhQQU5ERUQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBSU1NFeHBhbmRlZFJlYWRlcih0aGlzLnZlcmJvc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENhc2Ugd2hlbiBubyBoaW50cyB3ZXJlIHByb3ZpZGVkIC0+IGFkZCBhbGwuXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IE11bHRpRm9ybWF0VVBDRUFOUmVhZGVyKGhpbnRzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGUzOVJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kYUJhclJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kZTkzUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdFVQQ0VBTlJlYWRlcihoaW50cykpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBDb2RlMTI4UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBJVEZSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IFJTUzE0UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBSU1NFeHBhbmRlZFJlYWRlcih0aGlzLnZlcmJvc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkZXJzW2ldLmRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAocmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlcnMuZm9yRWFjaChyZWFkZXIgPT4gcmVhZGVyLnJlc2V0KCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICpcbiAgICAgKiBCYXJjb2RlIHJlYWRlciByZWFkZXIgdG8gdXNlIGZyb20gYnJvd3Nlci5cbiAgICAgKi9cbiAgICBjbGFzcyBCcm93c2VyQmFyY29kZVJlYWRlciBleHRlbmRzIEJyb3dzZXJDb2RlUmVhZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQnJvd3NlckJhcmNvZGVSZWFkZXIuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZUJldHdlZW5TY2Fuc01pbGxpcz01MDBdIHRoZSB0aW1lIGRlbGF5IGJldHdlZW4gc3Vic2VxdWVudCBkZWNvZGUgdHJpZXNcbiAgICAgICAgICogQHBhcmFtIHtNYXA8RGVjb2RlSGludFR5cGUsIGFueT59IGhpbnRzXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcih0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwLCBoaW50cykge1xuICAgICAgICAgICAgc3VwZXIobmV3IE11bHRpRm9ybWF0T25lRFJlYWRlcihoaW50cyksIHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMsIGhpbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGEgc2V0IG9mIGVycm9yLWNvcnJlY3Rpb24gYmxvY2tzIGluIG9uZSBzeW1ib2wgdmVyc2lvbi4gTW9zdCB2ZXJzaW9ucyB3aWxsXG4gICAgICogdXNlIGJsb2NrcyBvZiBkaWZmZXJpbmcgc2l6ZXMgd2l0aGluIG9uZSB2ZXJzaW9uLCBzbywgdGhpcyBlbmNhcHN1bGF0ZXMgdGhlIHBhcmFtZXRlcnMgZm9yXG4gICAgICogZWFjaCBzZXQgb2YgYmxvY2tzLiBJdCBhbHNvIGhvbGRzIHRoZSBudW1iZXIgb2YgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHMgcGVyIGJsb2NrIHNpbmNlIGl0XG4gICAgICogd2lsbCBiZSB0aGUgc2FtZSBhY3Jvc3MgYWxsIGJsb2NrcyB3aXRoaW4gb25lIHZlcnNpb24uPC9wPlxuICAgICAqL1xuICAgIGNsYXNzIEVDQmxvY2tzIHtcbiAgICAgICAgY29uc3RydWN0b3IoZWNDb2Rld29yZHMsIGVjQmxvY2tzMSwgZWNCbG9ja3MyKSB7XG4gICAgICAgICAgICB0aGlzLmVjQ29kZXdvcmRzID0gZWNDb2Rld29yZHM7XG4gICAgICAgICAgICB0aGlzLmVjQmxvY2tzID0gW2VjQmxvY2tzMV07XG4gICAgICAgICAgICBlY0Jsb2NrczIgJiYgdGhpcy5lY0Jsb2Nrcy5wdXNoKGVjQmxvY2tzMik7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RUNDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lY0NvZGV3b3JkcztcbiAgICAgICAgfVxuICAgICAgICBnZXRFQ0Jsb2NrcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjQmxvY2tzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyB0aGUgcGFyYW1ldGVycyBmb3Igb25lIGVycm9yLWNvcnJlY3Rpb24gYmxvY2sgaW4gb25lIHN5bWJvbCB2ZXJzaW9uLlxuICAgICAqIFRoaXMgaW5jbHVkZXMgdGhlIG51bWJlciBvZiBkYXRhIGNvZGV3b3JkcywgYW5kIHRoZSBudW1iZXIgb2YgdGltZXMgYSBibG9jayB3aXRoIHRoZXNlXG4gICAgICogcGFyYW1ldGVycyBpcyB1c2VkIGNvbnNlY3V0aXZlbHkgaW4gdGhlIERhdGEgTWF0cml4IGNvZGUgdmVyc2lvbidzIGZvcm1hdC48L3A+XG4gICAgICovXG4gICAgY2xhc3MgRUNCIHtcbiAgICAgICAgY29uc3RydWN0b3IoY291bnQsIGRhdGFDb2Rld29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNvZGV3b3JkcyA9IGRhdGFDb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcbiAgICAgICAgfVxuICAgICAgICBnZXREYXRhQ29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUNvZGV3b3JkcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgVmVyc2lvbiBvYmplY3QgZW5jYXBzdWxhdGVzIGF0dHJpYnV0ZXMgYWJvdXQgYSBwYXJ0aWN1bGFyXG4gICAgICogc2l6ZSBEYXRhIE1hdHJpeCBDb2RlLlxuICAgICAqXG4gICAgICogQGF1dGhvciBiYnJvd25AZ29vZ2xlLmNvbSAoQnJpYW4gQnJvd24pXG4gICAgICovXG4gICAgY2xhc3MgVmVyc2lvbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZlcnNpb25OdW1iZXIsIHN5bWJvbFNpemVSb3dzLCBzeW1ib2xTaXplQ29sdW1ucywgZGF0YVJlZ2lvblNpemVSb3dzLCBkYXRhUmVnaW9uU2l6ZUNvbHVtbnMsIGVjQmxvY2tzKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb25OdW1iZXIgPSB2ZXJzaW9uTnVtYmVyO1xuICAgICAgICAgICAgdGhpcy5zeW1ib2xTaXplUm93cyA9IHN5bWJvbFNpemVSb3dzO1xuICAgICAgICAgICAgdGhpcy5zeW1ib2xTaXplQ29sdW1ucyA9IHN5bWJvbFNpemVDb2x1bW5zO1xuICAgICAgICAgICAgdGhpcy5kYXRhUmVnaW9uU2l6ZVJvd3MgPSBkYXRhUmVnaW9uU2l6ZVJvd3M7XG4gICAgICAgICAgICB0aGlzLmRhdGFSZWdpb25TaXplQ29sdW1ucyA9IGRhdGFSZWdpb25TaXplQ29sdW1ucztcbiAgICAgICAgICAgIHRoaXMuZWNCbG9ja3MgPSBlY0Jsb2NrcztcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgbnVtYmVyIG9mIGNvZGV3b3Jkc1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGVjQ29kZXdvcmRzID0gZWNCbG9ja3MuZ2V0RUNDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGVjYkFycmF5ID0gZWNCbG9ja3MuZ2V0RUNCbG9ja3MoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGVjQmxvY2sgb2YgZWNiQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBlY0Jsb2NrLmdldENvdW50KCkgKiAoZWNCbG9jay5nZXREYXRhQ29kZXdvcmRzKCkgKyBlY0NvZGV3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRvdGFsQ29kZXdvcmRzID0gdG90YWw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmVyc2lvbk51bWJlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcnNpb25OdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U3ltYm9sU2l6ZVJvd3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2xTaXplUm93cztcbiAgICAgICAgfVxuICAgICAgICBnZXRTeW1ib2xTaXplQ29sdW1ucygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFNpemVDb2x1bW5zO1xuICAgICAgICB9XG4gICAgICAgIGdldERhdGFSZWdpb25TaXplUm93cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFSZWdpb25TaXplUm93cztcbiAgICAgICAgfVxuICAgICAgICBnZXREYXRhUmVnaW9uU2l6ZUNvbHVtbnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhUmVnaW9uU2l6ZUNvbHVtbnM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VG90YWxDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbENvZGV3b3JkcztcbiAgICAgICAgfVxuICAgICAgICBnZXRFQ0Jsb2NrcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjQmxvY2tzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5EZWR1Y2VzIHZlcnNpb24gaW5mb3JtYXRpb24gZnJvbSBEYXRhIE1hdHJpeCBkaW1lbnNpb25zLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gbW9kdWxlc1xuICAgICAgICAgKiBAcGFyYW0gbnVtQ29sdW1ucyBOdW1iZXIgb2YgY29sdW1ucyBpbiBtb2R1bGVzXG4gICAgICAgICAqIEByZXR1cm4gVmVyc2lvbiBmb3IgYSBEYXRhIE1hdHJpeCBDb2RlIG9mIHRob3NlIGRpbWVuc2lvbnNcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgZGltZW5zaW9ucyBkbyBjb3JyZXNwb25kIHRvIGEgdmFsaWQgRGF0YSBNYXRyaXggc2l6ZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldFZlcnNpb25Gb3JEaW1lbnNpb25zKG51bVJvd3MsIG51bUNvbHVtbnMpIHtcbiAgICAgICAgICAgIGlmICgobnVtUm93cyAmIDB4MDEpICE9PSAwIHx8IChudW1Db2x1bW5zICYgMHgwMSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCB2ZXJzaW9uIG9mIFZlcnNpb24uVkVSU0lPTlMpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbi5zeW1ib2xTaXplUm93cyA9PT0gbnVtUm93cyAmJiB2ZXJzaW9uLnN5bWJvbFNpemVDb2x1bW5zID09PSBudW1Db2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAgQE92ZXJyaWRlXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgdGhpcy52ZXJzaW9uTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYgNS41LjEgVGFibGUgN1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGJ1aWxkVmVyc2lvbnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDEsIDEwLCAxMCwgOCwgOCwgbmV3IEVDQmxvY2tzKDUsIG5ldyBFQ0IoMSwgMykpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyLCAxMiwgMTIsIDEwLCAxMCwgbmV3IEVDQmxvY2tzKDcsIG5ldyBFQ0IoMSwgNSkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigzLCAxNCwgMTQsIDEyLCAxMiwgbmV3IEVDQmxvY2tzKDEwLCBuZXcgRUNCKDEsIDgpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oNCwgMTYsIDE2LCAxNCwgMTQsIG5ldyBFQ0Jsb2NrcygxMiwgbmV3IEVDQigxLCAxMikpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbig1LCAxOCwgMTgsIDE2LCAxNiwgbmV3IEVDQmxvY2tzKDE0LCBuZXcgRUNCKDEsIDE4KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDYsIDIwLCAyMCwgMTgsIDE4LCBuZXcgRUNCbG9ja3MoMTgsIG5ldyBFQ0IoMSwgMjIpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oNywgMjIsIDIyLCAyMCwgMjAsIG5ldyBFQ0Jsb2NrcygyMCwgbmV3IEVDQigxLCAzMCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbig4LCAyNCwgMjQsIDIyLCAyMiwgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDEsIDM2KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDksIDI2LCAyNiwgMjQsIDI0LCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMSwgNDQpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMTAsIDMyLCAzMiwgMTQsIDE0LCBuZXcgRUNCbG9ja3MoMzYsIG5ldyBFQ0IoMSwgNjIpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMTEsIDM2LCAzNiwgMTYsIDE2LCBuZXcgRUNCbG9ja3MoNDIsIG5ldyBFQ0IoMSwgODYpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMTIsIDQwLCA0MCwgMTgsIDE4LCBuZXcgRUNCbG9ja3MoNDgsIG5ldyBFQ0IoMSwgMTE0KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDEzLCA0NCwgNDQsIDIwLCAyMCwgbmV3IEVDQmxvY2tzKDU2LCBuZXcgRUNCKDEsIDE0NCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigxNCwgNDgsIDQ4LCAyMiwgMjIsIG5ldyBFQ0Jsb2Nrcyg2OCwgbmV3IEVDQigxLCAxNzQpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMTUsIDUyLCA1MiwgMjQsIDI0LCBuZXcgRUNCbG9ja3MoNDIsIG5ldyBFQ0IoMiwgMTAyKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDE2LCA2NCwgNjQsIDE0LCAxNCwgbmV3IEVDQmxvY2tzKDU2LCBuZXcgRUNCKDIsIDE0MCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigxNywgNzIsIDcyLCAxNiwgMTYsIG5ldyBFQ0Jsb2NrcygzNiwgbmV3IEVDQig0LCA5MikpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigxOCwgODAsIDgwLCAxOCwgMTgsIG5ldyBFQ0Jsb2Nrcyg0OCwgbmV3IEVDQig0LCAxMTQpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMTksIDg4LCA4OCwgMjAsIDIwLCBuZXcgRUNCbG9ja3MoNTYsIG5ldyBFQ0IoNCwgMTQ0KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDIwLCA5NiwgOTYsIDIyLCAyMiwgbmV3IEVDQmxvY2tzKDY4LCBuZXcgRUNCKDQsIDE3NCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyMSwgMTA0LCAxMDQsIDI0LCAyNCwgbmV3IEVDQmxvY2tzKDU2LCBuZXcgRUNCKDYsIDEzNikpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyMiwgMTIwLCAxMjAsIDE4LCAxOCwgbmV3IEVDQmxvY2tzKDY4LCBuZXcgRUNCKDYsIDE3NSkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyMywgMTMyLCAxMzIsIDIwLCAyMCwgbmV3IEVDQmxvY2tzKDYyLCBuZXcgRUNCKDgsIDE2MykpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyNCwgMTQ0LCAxNDQsIDIyLCAyMiwgbmV3IEVDQmxvY2tzKDYyLCBuZXcgRUNCKDgsIDE1NiksIG5ldyBFQ0IoMiwgMTU1KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDI1LCA4LCAxOCwgNiwgMTYsIG5ldyBFQ0Jsb2Nrcyg3LCBuZXcgRUNCKDEsIDUpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMjYsIDgsIDMyLCA2LCAxNCwgbmV3IEVDQmxvY2tzKDExLCBuZXcgRUNCKDEsIDEwKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDI3LCAxMiwgMjYsIDEwLCAyNCwgbmV3IEVDQmxvY2tzKDE0LCBuZXcgRUNCKDEsIDE2KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDI4LCAxMiwgMzYsIDEwLCAxNiwgbmV3IEVDQmxvY2tzKDE4LCBuZXcgRUNCKDEsIDIyKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDI5LCAxNiwgMzYsIDE0LCAxNiwgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDEsIDMyKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDMwLCAxNiwgNDgsIDE0LCAyMiwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDEsIDQ5KSkpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIFZlcnNpb24uVkVSU0lPTlMgPSBWZXJzaW9uLmJ1aWxkVmVyc2lvbnMoKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBiYnJvd25AZ29vZ2xlLmNvbSAoQnJpYW4gQnJvd24pXG4gICAgICovXG4gICAgY2xhc3MgQml0TWF0cml4UGFyc2VyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBiaXRNYXRyaXgge0BsaW5rIEJpdE1hdHJpeH0gdG8gcGFyc2VcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgZGltZW5zaW9uIGlzIDwgOCBvciA+IDE0NCBvciBub3QgMCBtb2QgMlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoYml0TWF0cml4KSB7XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb24gPSBiaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uIDwgOCB8fCBkaW1lbnNpb24gPiAxNDQgfHwgKGRpbWVuc2lvbiAmIDB4MDEpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52ZXJzaW9uID0gQml0TWF0cml4UGFyc2VyLnJlYWRWZXJzaW9uKGJpdE1hdHJpeCk7XG4gICAgICAgICAgICB0aGlzLm1hcHBpbmdCaXRNYXRyaXggPSB0aGlzLmV4dHJhY3REYXRhUmVnaW9uKGJpdE1hdHJpeCk7XG4gICAgICAgICAgICB0aGlzLnJlYWRNYXBwaW5nTWF0cml4ID0gbmV3IEJpdE1hdHJpeCh0aGlzLm1hcHBpbmdCaXRNYXRyaXguZ2V0V2lkdGgoKSwgdGhpcy5tYXBwaW5nQml0TWF0cml4LmdldEhlaWdodCgpKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWZXJzaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+Q3JlYXRlcyB0aGUgdmVyc2lvbiBvYmplY3QgYmFzZWQgb24gdGhlIGRpbWVuc2lvbiBvZiB0aGUgb3JpZ2luYWwgYml0IG1hdHJpeCBmcm9tXG4gICAgICAgICAqIHRoZSBkYXRhbWF0cml4IGNvZGUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5TZWUgSVNPIDE2MDIyOjIwMDYgVGFibGUgNyAtIEVDQyAyMDAgc3ltYm9sIGF0dHJpYnV0ZXM8L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBiaXRNYXRyaXggT3JpZ2luYWwge0BsaW5rIEJpdE1hdHJpeH0gaW5jbHVkaW5nIGFsaWdubWVudCBwYXR0ZXJuc1xuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBWZXJzaW9ufSBlbmNhcHN1bGF0aW5nIHRoZSBEYXRhIE1hdHJpeCBDb2RlJ3MgXCJ2ZXJzaW9uXCJcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG1hcHBpbmcgbWF0cml4IGFyZSBub3QgdmFsaWRcbiAgICAgICAgICogRGF0YSBNYXRyaXggZGltZW5zaW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyByZWFkVmVyc2lvbihiaXRNYXRyaXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bVJvd3MgPSBiaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBudW1Db2x1bW5zID0gYml0TWF0cml4LmdldFdpZHRoKCk7XG4gICAgICAgICAgICByZXR1cm4gVmVyc2lvbi5nZXRWZXJzaW9uRm9yRGltZW5zaW9ucyhudW1Sb3dzLCBudW1Db2x1bW5zKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UmVhZHMgdGhlIGJpdHMgaW4gdGhlIHtAbGluayBCaXRNYXRyaXh9IHJlcHJlc2VudGluZyB0aGUgbWFwcGluZyBtYXRyaXggKE5vIGFsaWdubWVudCBwYXR0ZXJucylcbiAgICAgICAgICogaW4gdGhlIGNvcnJlY3Qgb3JkZXIgaW4gb3JkZXIgdG8gcmVjb25zdGl0dXRlIHRoZSBjb2Rld29yZHMgYnl0ZXMgY29udGFpbmVkIHdpdGhpbiB0aGVcbiAgICAgICAgICogRGF0YSBNYXRyaXggQ29kZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gYnl0ZXMgZW5jb2RlZCB3aXRoaW4gdGhlIERhdGEgTWF0cml4IENvZGVcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyBleHBlY3RlZCBpcyBub3QgcmVhZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZENvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBJbnQ4QXJyYXkodGhpcy52ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdE9mZnNldCA9IDA7XG4gICAgICAgICAgICBsZXQgcm93ID0gNDtcbiAgICAgICAgICAgIGxldCBjb2x1bW4gPSAwO1xuICAgICAgICAgICAgY29uc3QgbnVtUm93cyA9IHRoaXMubWFwcGluZ0JpdE1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IG51bUNvbHVtbnMgPSB0aGlzLm1hcHBpbmdCaXRNYXRyaXguZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGxldCBjb3JuZXIxUmVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGNvcm5lcjJSZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgY29ybmVyM1JlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjb3JuZXI0UmVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gUmVhZCBhbGwgb2YgdGhlIGNvZGV3b3Jkc1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBmb3VyIGNvcm5lciBjYXNlc1xuICAgICAgICAgICAgICAgIGlmICgocm93ID09PSBudW1Sb3dzKSAmJiAoY29sdW1uID09PSAwKSAmJiAhY29ybmVyMVJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdE9mZnNldCsrXSA9IHRoaXMucmVhZENvcm5lcjEobnVtUm93cywgbnVtQ29sdW1ucykgJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICByb3cgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvcm5lcjFSZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHJvdyA9PT0gbnVtUm93cyAtIDIpICYmIChjb2x1bW4gPT09IDApICYmICgobnVtQ29sdW1ucyAmIDB4MDMpICE9PSAwKSAmJiAhY29ybmVyMlJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdE9mZnNldCsrXSA9IHRoaXMucmVhZENvcm5lcjIobnVtUm93cywgbnVtQ29sdW1ucykgJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICByb3cgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvcm5lcjJSZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHJvdyA9PT0gbnVtUm93cyArIDQpICYmIChjb2x1bW4gPT09IDIpICYmICgobnVtQ29sdW1ucyAmIDB4MDcpID09PSAwKSAmJiAhY29ybmVyM1JlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdE9mZnNldCsrXSA9IHRoaXMucmVhZENvcm5lcjMobnVtUm93cywgbnVtQ29sdW1ucykgJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICByb3cgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvcm5lcjNSZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHJvdyA9PT0gbnVtUm93cyAtIDIpICYmIChjb2x1bW4gPT09IDApICYmICgobnVtQ29sdW1ucyAmIDB4MDcpID09PSA0KSAmJiAhY29ybmVyNFJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdE9mZnNldCsrXSA9IHRoaXMucmVhZENvcm5lcjQobnVtUm93cywgbnVtQ29sdW1ucykgJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICByb3cgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvcm5lcjRSZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN3ZWVwIHVwd2FyZCBkaWFnb25hbGx5IHRvIHRoZSByaWdodFxuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJvdyA8IG51bVJvd3MpICYmIChjb2x1bW4gPj0gMCkgJiYgIXRoaXMucmVhZE1hcHBpbmdNYXRyaXguZ2V0KGNvbHVtbiwgcm93KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRVdGFoKHJvdywgY29sdW1uLCBudW1Sb3dzLCBudW1Db2x1bW5zKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiArPSAyO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgocm93ID49IDApICYmIChjb2x1bW4gPCBudW1Db2x1bW5zKSk7XG4gICAgICAgICAgICAgICAgICAgIHJvdyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMztcbiAgICAgICAgICAgICAgICAgICAgLy8gU3dlZXAgZG93bndhcmQgZGlhZ29uYWxseSB0byB0aGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJvdyA+PSAwKSAmJiAoY29sdW1uIDwgbnVtQ29sdW1ucykgJiYgIXRoaXMucmVhZE1hcHBpbmdNYXRyaXguZ2V0KGNvbHVtbiwgcm93KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRVdGFoKHJvdywgY29sdW1uLCBudW1Sb3dzLCBudW1Db2x1bW5zKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiAtPSAyO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgocm93IDwgbnVtUm93cykgJiYgKGNvbHVtbiA+PSAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHJvdyArPSAzO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICgocm93IDwgbnVtUm93cykgfHwgKGNvbHVtbiA8IG51bUNvbHVtbnMpKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRPZmZzZXQgIT09IHRoaXMudmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UmVhZHMgYSBiaXQgb2YgdGhlIG1hcHBpbmcgbWF0cml4IGFjY291bnRpbmcgZm9yIGJvdW5kYXJ5IHdyYXBwaW5nLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvdyBSb3cgdG8gcmVhZCBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIGNvbHVtbiBDb2x1bW4gdG8gcmVhZCBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEBwYXJhbSBudW1Db2x1bW5zIE51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcmV0dXJuIHZhbHVlIG9mIHRoZSBnaXZlbiBiaXQgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqL1xuICAgICAgICByZWFkTW9kdWxlKHJvdywgY29sdW1uLCBudW1Sb3dzLCBudW1Db2x1bW5zKSB7XG4gICAgICAgICAgICAvLyBBZGp1c3QgdGhlIHJvdyBhbmQgY29sdW1uIGluZGljZXMgYmFzZWQgb24gYm91bmRhcnkgd3JhcHBpbmdcbiAgICAgICAgICAgIGlmIChyb3cgPCAwKSB7XG4gICAgICAgICAgICAgICAgcm93ICs9IG51bVJvd3M7XG4gICAgICAgICAgICAgICAgY29sdW1uICs9IDQgLSAoKG51bVJvd3MgKyA0KSAmIDB4MDcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbHVtbiA8IDApIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gKz0gbnVtQ29sdW1ucztcbiAgICAgICAgICAgICAgICByb3cgKz0gNCAtICgobnVtQ29sdW1ucyArIDQpICYgMHgwNyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWRNYXBwaW5nTWF0cml4LnNldChjb2x1bW4sIHJvdyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBwaW5nQml0TWF0cml4LmdldChjb2x1bW4sIHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlJlYWRzIHRoZSA4IGJpdHMgb2YgdGhlIHN0YW5kYXJkIFV0YWgtc2hhcGVkIHBhdHRlcm4uPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5TZWUgSVNPIDE2MDIyOjIwMDYsIDUuOC4xIEZpZ3VyZSA2PC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcm93IEN1cnJlbnQgcm93IGluIHRoZSBtYXBwaW5nIG1hdHJpeCwgYW5jaG9yZWQgYXQgdGhlIDh0aCBiaXQgKExTQikgb2YgdGhlIHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIGNvbHVtbiBDdXJyZW50IGNvbHVtbiBpbiB0aGUgbWFwcGluZyBtYXRyaXgsIGFuY2hvcmVkIGF0IHRoZSA4dGggYml0IChMU0IpIG9mIHRoZSBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBudW1Sb3dzIE51bWJlciBvZiByb3dzIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcGFyYW0gbnVtQ29sdW1ucyBOdW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHJldHVybiBieXRlIGZyb20gdGhlIHV0YWggc2hhcGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRVdGFoKHJvdywgY29sdW1uLCBudW1Sb3dzLCBudW1Db2x1bW5zKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudEJ5dGUgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3cgLSAyLCBjb2x1bW4gLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93IC0gMiwgY29sdW1uIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKHJvdyAtIDEsIGNvbHVtbiAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3cgLSAxLCBjb2x1bW4gLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93IC0gMSwgY29sdW1uLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93LCBjb2x1bW4gLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93LCBjb2x1bW4gLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93LCBjb2x1bW4sIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Qnl0ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UmVhZHMgdGhlIDggYml0cyBvZiB0aGUgc3BlY2lhbCBjb3JuZXIgY29uZGl0aW9uIDEuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5TZWUgSVNPIDE2MDIyOjIwMDYsIEZpZ3VyZSBGLjM8L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBudW1Sb3dzIE51bWJlciBvZiByb3dzIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcGFyYW0gbnVtQ29sdW1ucyBOdW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHJldHVybiBieXRlIGZyb20gdGhlIENvcm5lciBjb25kaXRpb24gMVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZENvcm5lcjEobnVtUm93cywgbnVtQ29sdW1ucykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRCeXRlID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDEsIDAsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMSwgMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAxLCAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDEsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMiwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgzLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRCeXRlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5SZWFkcyB0aGUgOCBiaXRzIG9mIHRoZSBzcGVjaWFsIGNvcm5lciBjb25kaXRpb24gMi48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlNlZSBJU08gMTYwMjI6MjAwNiwgRmlndXJlIEYuNDwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEBwYXJhbSBudW1Db2x1bW5zIE51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcmV0dXJuIGJ5dGUgZnJvbSB0aGUgQ29ybmVyIGNvbmRpdGlvbiAyXG4gICAgICAgICAqL1xuICAgICAgICByZWFkQ29ybmVyMihudW1Sb3dzLCBudW1Db2x1bW5zKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudEJ5dGUgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMywgMCwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAyLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDEsIDAsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gNCwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAzLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDEsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlJlYWRzIHRoZSA4IGJpdHMgb2YgdGhlIHNwZWNpYWwgY29ybmVyIGNvbmRpdGlvbiAzLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+U2VlIElTTyAxNjAyMjoyMDA2LCBGaWd1cmUgRi41PC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbnVtUm93cyBOdW1iZXIgb2Ygcm93cyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIG51bUNvbHVtbnMgTnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4gYnl0ZSBmcm9tIHRoZSBDb3JuZXIgY29uZGl0aW9uIDNcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRDb3JuZXIzKG51bVJvd3MsIG51bUNvbHVtbnMpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Qnl0ZSA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAxLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDEsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDMsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMSwgbnVtQ29sdW1ucyAtIDMsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgxLCBudW1Db2x1bW5zIC0gMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDEsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlJlYWRzIHRoZSA4IGJpdHMgb2YgdGhlIHNwZWNpYWwgY29ybmVyIGNvbmRpdGlvbiA0LjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+U2VlIElTTyAxNjAyMjoyMDA2LCBGaWd1cmUgRi42PC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbnVtUm93cyBOdW1iZXIgb2Ygcm93cyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIG51bUNvbHVtbnMgTnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4gYnl0ZSBmcm9tIHRoZSBDb3JuZXIgY29uZGl0aW9uIDRcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRDb3JuZXI0KG51bVJvd3MsIG51bUNvbHVtbnMpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Qnl0ZSA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAzLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDIsIDAsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMSwgMCwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgxLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDIsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMywgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Qnl0ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RXh0cmFjdHMgdGhlIGRhdGEgcmVnaW9uIGZyb20gYSB7QGxpbmsgQml0TWF0cml4fSB0aGF0IGNvbnRhaW5zXG4gICAgICAgICAqIGFsaWdubWVudCBwYXR0ZXJucy48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBiaXRNYXRyaXggT3JpZ2luYWwge0BsaW5rIEJpdE1hdHJpeH0gd2l0aCBhbGlnbm1lbnQgcGF0dGVybnNcbiAgICAgICAgICogQHJldHVybiBCaXRNYXRyaXggdGhhdCBoYXMgdGhlIGFsaWdubWVudCBwYXR0ZXJucyByZW1vdmVkXG4gICAgICAgICAqL1xuICAgICAgICBleHRyYWN0RGF0YVJlZ2lvbihiaXRNYXRyaXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN5bWJvbFNpemVSb3dzID0gdGhpcy52ZXJzaW9uLmdldFN5bWJvbFNpemVSb3dzKCk7XG4gICAgICAgICAgICBjb25zdCBzeW1ib2xTaXplQ29sdW1ucyA9IHRoaXMudmVyc2lvbi5nZXRTeW1ib2xTaXplQ29sdW1ucygpO1xuICAgICAgICAgICAgaWYgKGJpdE1hdHJpeC5nZXRIZWlnaHQoKSAhPT0gc3ltYm9sU2l6ZVJvd3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdEaW1lbnNpb24gb2YgYml0TWF0cml4IG11c3QgbWF0Y2ggdGhlIHZlcnNpb24gc2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YVJlZ2lvblNpemVSb3dzID0gdGhpcy52ZXJzaW9uLmdldERhdGFSZWdpb25TaXplUm93cygpO1xuICAgICAgICAgICAgY29uc3QgZGF0YVJlZ2lvblNpemVDb2x1bW5zID0gdGhpcy52ZXJzaW9uLmdldERhdGFSZWdpb25TaXplQ29sdW1ucygpO1xuICAgICAgICAgICAgY29uc3QgbnVtRGF0YVJlZ2lvbnNSb3cgPSBzeW1ib2xTaXplUm93cyAvIGRhdGFSZWdpb25TaXplUm93cyB8IDA7XG4gICAgICAgICAgICBjb25zdCBudW1EYXRhUmVnaW9uc0NvbHVtbiA9IHN5bWJvbFNpemVDb2x1bW5zIC8gZGF0YVJlZ2lvblNpemVDb2x1bW5zIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpemVEYXRhUmVnaW9uUm93ID0gbnVtRGF0YVJlZ2lvbnNSb3cgKiBkYXRhUmVnaW9uU2l6ZVJvd3M7XG4gICAgICAgICAgICBjb25zdCBzaXplRGF0YVJlZ2lvbkNvbHVtbiA9IG51bURhdGFSZWdpb25zQ29sdW1uICogZGF0YVJlZ2lvblNpemVDb2x1bW5zO1xuICAgICAgICAgICAgY29uc3QgYml0TWF0cml4V2l0aG91dEFsaWdubWVudCA9IG5ldyBCaXRNYXRyaXgoc2l6ZURhdGFSZWdpb25Db2x1bW4sIHNpemVEYXRhUmVnaW9uUm93KTtcbiAgICAgICAgICAgIGZvciAobGV0IGRhdGFSZWdpb25Sb3cgPSAwOyBkYXRhUmVnaW9uUm93IDwgbnVtRGF0YVJlZ2lvbnNSb3c7ICsrZGF0YVJlZ2lvblJvdykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFSZWdpb25Sb3dPZmZzZXQgPSBkYXRhUmVnaW9uUm93ICogZGF0YVJlZ2lvblNpemVSb3dzO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGRhdGFSZWdpb25Db2x1bW4gPSAwOyBkYXRhUmVnaW9uQ29sdW1uIDwgbnVtRGF0YVJlZ2lvbnNDb2x1bW47ICsrZGF0YVJlZ2lvbkNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhUmVnaW9uQ29sdW1uT2Zmc2V0ID0gZGF0YVJlZ2lvbkNvbHVtbiAqIGRhdGFSZWdpb25TaXplQ29sdW1ucztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhUmVnaW9uU2l6ZVJvd3M7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZFJvd09mZnNldCA9IGRhdGFSZWdpb25Sb3cgKiAoZGF0YVJlZ2lvblNpemVSb3dzICsgMikgKyAxICsgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlUm93T2Zmc2V0ID0gZGF0YVJlZ2lvblJvd09mZnNldCArIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRhdGFSZWdpb25TaXplQ29sdW1uczsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZENvbHVtbk9mZnNldCA9IGRhdGFSZWdpb25Db2x1bW4gKiAoZGF0YVJlZ2lvblNpemVDb2x1bW5zICsgMikgKyAxICsgajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0TWF0cml4LmdldChyZWFkQ29sdW1uT2Zmc2V0LCByZWFkUm93T2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3cml0ZUNvbHVtbk9mZnNldCA9IGRhdGFSZWdpb25Db2x1bW5PZmZzZXQgKyBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRNYXRyaXhXaXRob3V0QWxpZ25tZW50LnNldCh3cml0ZUNvbHVtbk9mZnNldCwgd3JpdGVSb3dPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaXRNYXRyaXhXaXRob3V0QWxpZ25tZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGEgYmxvY2sgb2YgZGF0YSB3aXRoaW4gYSBEYXRhIE1hdHJpeCBDb2RlLiBEYXRhIE1hdHJpeCBDb2RlcyBtYXkgc3BsaXQgdGhlaXIgZGF0YSBpbnRvXG4gICAgICogbXVsdGlwbGUgYmxvY2tzLCBlYWNoIG9mIHdoaWNoIGlzIGEgdW5pdCBvZiBkYXRhIGFuZCBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3Jkcy4gRWFjaFxuICAgICAqIGlzIHJlcHJlc2VudGVkIGJ5IGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBiYnJvd25AZ29vZ2xlLmNvbSAoQnJpYW4gQnJvd24pXG4gICAgICovXG4gICAgY2xhc3MgRGF0YUJsb2NrIHtcbiAgICAgICAgY29uc3RydWN0b3IobnVtRGF0YUNvZGV3b3JkcywgY29kZXdvcmRzKSB7XG4gICAgICAgICAgICB0aGlzLm51bURhdGFDb2Rld29yZHMgPSBudW1EYXRhQ29kZXdvcmRzO1xuICAgICAgICAgICAgdGhpcy5jb2Rld29yZHMgPSBjb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPldoZW4gRGF0YSBNYXRyaXggQ29kZXMgdXNlIG11bHRpcGxlIGRhdGEgYmxvY2tzLCB0aGV5IGFjdHVhbGx5IGludGVybGVhdmUgdGhlIGJ5dGVzIG9mIGVhY2ggb2YgdGhlbS5cbiAgICAgICAgICogVGhhdCBpcywgdGhlIGZpcnN0IGJ5dGUgb2YgZGF0YSBibG9jayAxIHRvIG4gaXMgd3JpdHRlbiwgdGhlbiB0aGUgc2Vjb25kIGJ5dGVzLCBhbmQgc28gb24uIFRoaXNcbiAgICAgICAgICogbWV0aG9kIHdpbGwgc2VwYXJhdGUgdGhlIGRhdGEgaW50byBvcmlnaW5hbCBibG9ja3MuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcmF3Q29kZXdvcmRzIGJ5dGVzIGFzIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgRGF0YSBNYXRyaXggQ29kZVxuICAgICAgICAgKiBAcGFyYW0gdmVyc2lvbiB2ZXJzaW9uIG9mIHRoZSBEYXRhIE1hdHJpeCBDb2RlXG4gICAgICAgICAqIEByZXR1cm4gRGF0YUJsb2NrcyBjb250YWluaW5nIG9yaWdpbmFsIGJ5dGVzLCBcImRlLWludGVybGVhdmVkXCIgZnJvbSByZXByZXNlbnRhdGlvbiBpbiB0aGVcbiAgICAgICAgICogICAgICAgICBEYXRhIE1hdHJpeCBDb2RlXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0RGF0YUJsb2NrcyhyYXdDb2Rld29yZHMsIHZlcnNpb24pIHtcbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIG51bWJlciBhbmQgc2l6ZSBvZiBkYXRhIGJsb2NrcyB1c2VkIGJ5IHRoaXMgdmVyc2lvblxuICAgICAgICAgICAgY29uc3QgZWNCbG9ja3MgPSB2ZXJzaW9uLmdldEVDQmxvY2tzKCk7XG4gICAgICAgICAgICAvLyBGaXJzdCBjb3VudCB0aGUgdG90YWwgbnVtYmVyIG9mIGRhdGEgYmxvY2tzXG4gICAgICAgICAgICBsZXQgdG90YWxCbG9ja3MgPSAwO1xuICAgICAgICAgICAgY29uc3QgZWNCbG9ja0FycmF5ID0gZWNCbG9ja3MuZ2V0RUNCbG9ja3MoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGVjQmxvY2sgb2YgZWNCbG9ja0FycmF5KSB7XG4gICAgICAgICAgICAgICAgdG90YWxCbG9ja3MgKz0gZWNCbG9jay5nZXRDb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IGVzdGFibGlzaCBEYXRhQmxvY2tzIG9mIHRoZSBhcHByb3ByaWF0ZSBzaXplIGFuZCBudW1iZXIgb2YgZGF0YSBjb2Rld29yZHNcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheSh0b3RhbEJsb2Nrcyk7XG4gICAgICAgICAgICBsZXQgbnVtUmVzdWx0QmxvY2tzID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGVjQmxvY2sgb2YgZWNCbG9ja0FycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlY0Jsb2NrLmdldENvdW50KCk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1EYXRhQ29kZXdvcmRzID0gZWNCbG9jay5nZXREYXRhQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bUJsb2NrQ29kZXdvcmRzID0gZWNCbG9ja3MuZ2V0RUNDb2Rld29yZHMoKSArIG51bURhdGFDb2Rld29yZHM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtudW1SZXN1bHRCbG9ja3MrK10gPSBuZXcgRGF0YUJsb2NrKG51bURhdGFDb2Rld29yZHMsIG5ldyBVaW50OEFycmF5KG51bUJsb2NrQ29kZXdvcmRzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWxsIGJsb2NrcyBoYXZlIHRoZSBzYW1lIGFtb3VudCBvZiBkYXRhLCBleGNlcHQgdGhhdCB0aGUgbGFzdCBuXG4gICAgICAgICAgICAvLyAod2hlcmUgbiBtYXkgYmUgMCkgaGF2ZSAxIGxlc3MgYnl0ZS4gRmlndXJlIG91dCB3aGVyZSB0aGVzZSBzdGFydC5cbiAgICAgICAgICAgIC8vIFRPRE8oYmJyb3duKTogVGhlcmUgaXMgb25seSBvbmUgY2FzZSB3aGVyZSB0aGVyZSBpcyBhIGRpZmZlcmVuY2UgZm9yIERhdGEgTWF0cml4IGZvciBzaXplIDE0NFxuICAgICAgICAgICAgY29uc3QgbG9uZ2VyQmxvY2tzVG90YWxDb2Rld29yZHMgPSByZXN1bHRbMF0uY29kZXdvcmRzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGludCBzaG9ydGVyQmxvY2tzVG90YWxDb2Rld29yZHMgPSBsb25nZXJCbG9ja3NUb3RhbENvZGV3b3JkcyAtIDE7XG4gICAgICAgICAgICBjb25zdCBsb25nZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzID0gbG9uZ2VyQmxvY2tzVG90YWxDb2Rld29yZHMgLSBlY0Jsb2Nrcy5nZXRFQ0NvZGV3b3JkcygpO1xuICAgICAgICAgICAgY29uc3Qgc2hvcnRlckJsb2Nrc051bURhdGFDb2Rld29yZHMgPSBsb25nZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzIC0gMTtcbiAgICAgICAgICAgIC8vIFRoZSBsYXN0IGVsZW1lbnRzIG9mIHJlc3VsdCBtYXkgYmUgMSBlbGVtZW50IHNob3J0ZXIgZm9yIDE0NCBtYXRyaXhcbiAgICAgICAgICAgIC8vIGZpcnN0IGZpbGwgb3V0IGFzIG1hbnkgZWxlbWVudHMgYXMgYWxsIG9mIHRoZW0gaGF2ZSBtaW51cyAxXG4gICAgICAgICAgICBsZXQgcmF3Q29kZXdvcmRzT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hvcnRlckJsb2Nrc051bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtUmVzdWx0QmxvY2tzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2pdLmNvZGV3b3Jkc1tpXSA9IHJhd0NvZGV3b3Jkc1tyYXdDb2Rld29yZHNPZmZzZXQrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlsbCBvdXQgdGhlIGxhc3QgZGF0YSBibG9jayBpbiB0aGUgbG9uZ2VyIG9uZXNcbiAgICAgICAgICAgIGNvbnN0IHNwZWNpYWxWZXJzaW9uID0gdmVyc2lvbi5nZXRWZXJzaW9uTnVtYmVyKCkgPT09IDI0O1xuICAgICAgICAgICAgY29uc3QgbnVtTG9uZ2VyQmxvY2tzID0gc3BlY2lhbFZlcnNpb24gPyA4IDogbnVtUmVzdWx0QmxvY2tzO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1Mb25nZXJCbG9ja3M7IGorKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtqXS5jb2Rld29yZHNbbG9uZ2VyQmxvY2tzTnVtRGF0YUNvZGV3b3JkcyAtIDFdID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyBhZGQgaW4gZXJyb3IgY29ycmVjdGlvbiBibG9ja3NcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHJlc3VsdFswXS5jb2Rld29yZHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxvbmdlckJsb2Nrc051bURhdGFDb2Rld29yZHM7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtUmVzdWx0QmxvY2tzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgak9mZnNldCA9IHNwZWNpYWxWZXJzaW9uID8gKGogKyA4KSAlIG51bVJlc3VsdEJsb2NrcyA6IGo7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlPZmZzZXQgPSBzcGVjaWFsVmVyc2lvbiAmJiBqT2Zmc2V0ID4gNyA/IGkgLSAxIDogaTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2pPZmZzZXRdLmNvZGV3b3Jkc1tpT2Zmc2V0XSA9IHJhd0NvZGV3b3Jkc1tyYXdDb2Rld29yZHNPZmZzZXQrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJhd0NvZGV3b3Jkc09mZnNldCAhPT0gcmF3Q29kZXdvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TnVtRGF0YUNvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bURhdGFDb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5UaGlzIHByb3ZpZGVzIGFuIGVhc3kgYWJzdHJhY3Rpb24gdG8gcmVhZCBiaXRzIGF0IGEgdGltZSBmcm9tIGEgc2VxdWVuY2Ugb2YgYnl0ZXMsIHdoZXJlIHRoZVxuICAgICAqIG51bWJlciBvZiBiaXRzIHJlYWQgaXMgbm90IG9mdGVuIGEgbXVsdGlwbGUgb2YgOC48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaGlzIGNsYXNzIGlzIHRocmVhZC1zYWZlIGJ1dCBub3QgcmVlbnRyYW50IC0tIHVubGVzcyB0aGUgY2FsbGVyIG1vZGlmaWVzIHRoZSBieXRlcyBhcnJheVxuICAgICAqIGl0IHBhc3NlZCBpbiwgaW4gd2hpY2ggY2FzZSBhbGwgYmV0cyBhcmUgb2ZmLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgQml0U291cmNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBieXRlcyBieXRlcyBmcm9tIHdoaWNoIHRoaXMgd2lsbCByZWFkIGJpdHMuIEJpdHMgd2lsbCBiZSByZWFkIGZyb20gdGhlIGZpcnN0IGJ5dGUgZmlyc3QuXG4gICAgICAgICAqIEJpdHMgYXJlIHJlYWQgd2l0aGluIGEgYnl0ZSBmcm9tIG1vc3Qtc2lnbmlmaWNhbnQgdG8gbGVhc3Qtc2lnbmlmaWNhbnQgYml0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgICAgICAgICAgIHRoaXMuYnl0ZU9mZnNldCA9IDA7XG4gICAgICAgICAgICB0aGlzLmJpdE9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gaW5kZXggb2YgbmV4dCBiaXQgaW4gY3VycmVudCBieXRlIHdoaWNoIHdvdWxkIGJlIHJlYWQgYnkgdGhlIG5leHQgY2FsbCB0byB7QGxpbmsgI3JlYWRCaXRzKGludCl9LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Qml0T2Zmc2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYml0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGluZGV4IG9mIG5leHQgYnl0ZSBpbiBpbnB1dCBieXRlIGFycmF5IHdoaWNoIHdvdWxkIGJlIHJlYWQgYnkgdGhlIG5leHQgY2FsbCB0byB7QGxpbmsgI3JlYWRCaXRzKGludCl9LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Qnl0ZU9mZnNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBudW1CaXRzIG51bWJlciBvZiBiaXRzIHRvIHJlYWRcbiAgICAgICAgICogQHJldHVybiBpbnQgcmVwcmVzZW50aW5nIHRoZSBiaXRzIHJlYWQuIFRoZSBiaXRzIHdpbGwgYXBwZWFyIGFzIHRoZSBsZWFzdC1zaWduaWZpY2FudFxuICAgICAgICAgKiAgICAgICAgIGJpdHMgb2YgdGhlIGludFxuICAgICAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiBudW1CaXRzIGlzbid0IGluIFsxLDMyXSBvciBtb3JlIHRoYW4gaXMgYXZhaWxhYmxlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkQml0cyhudW1CaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChudW1CaXRzIDwgMSB8fCBudW1CaXRzID4gMzIgfHwgbnVtQml0cyA+IHRoaXMuYXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCcnICsgbnVtQml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgICAgIGxldCBiaXRPZmZzZXQgPSB0aGlzLmJpdE9mZnNldDtcbiAgICAgICAgICAgIGxldCBieXRlT2Zmc2V0ID0gdGhpcy5ieXRlT2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLmJ5dGVzO1xuICAgICAgICAgICAgLy8gRmlyc3QsIHJlYWQgcmVtYWluZGVyIGZyb20gY3VycmVudCBieXRlXG4gICAgICAgICAgICBpZiAoYml0T2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpdHNMZWZ0ID0gOCAtIGJpdE9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCB0b1JlYWQgPSBudW1CaXRzIDwgYml0c0xlZnQgPyBudW1CaXRzIDogYml0c0xlZnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYml0c1RvTm90UmVhZCA9IGJpdHNMZWZ0IC0gdG9SZWFkO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hc2sgPSAoMHhGRiA+PiAoOCAtIHRvUmVhZCkpIDw8IGJpdHNUb05vdFJlYWQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKGJ5dGVzW2J5dGVPZmZzZXRdICYgbWFzaykgPj4gYml0c1RvTm90UmVhZDtcbiAgICAgICAgICAgICAgICBudW1CaXRzIC09IHRvUmVhZDtcbiAgICAgICAgICAgICAgICBiaXRPZmZzZXQgKz0gdG9SZWFkO1xuICAgICAgICAgICAgICAgIGlmIChiaXRPZmZzZXQgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgYml0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5leHQgcmVhZCB3aG9sZSBieXRlc1xuICAgICAgICAgICAgaWYgKG51bUJpdHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG51bUJpdHMgPj0gOCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDgpIHwgKGJ5dGVzW2J5dGVPZmZzZXRdICYgMHhGRik7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgbnVtQml0cyAtPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5IHJlYWQgYSBwYXJ0aWFsIGJ5dGVcbiAgICAgICAgICAgICAgICBpZiAobnVtQml0cyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYml0c1RvTm90UmVhZCA9IDggLSBudW1CaXRzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gKDB4RkYgPj4gYml0c1RvTm90UmVhZCkgPDwgYml0c1RvTm90UmVhZDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCBudW1CaXRzKSB8ICgoYnl0ZXNbYnl0ZU9mZnNldF0gJiBtYXNrKSA+PiBiaXRzVG9Ob3RSZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgYml0T2Zmc2V0ICs9IG51bUJpdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iaXRPZmZzZXQgPSBiaXRPZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgPSBieXRlT2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBudW1iZXIgb2YgYml0cyB0aGF0IGNhbiBiZSByZWFkIHN1Y2Nlc3NmdWxseVxuICAgICAgICAgKi9cbiAgICAgICAgYXZhaWxhYmxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIDggKiAodGhpcy5ieXRlcy5sZW5ndGggLSB0aGlzLmJ5dGVPZmZzZXQpIC0gdGhpcy5iaXRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgTW9kZTtcbiAgICAoZnVuY3Rpb24gKE1vZGUpIHtcbiAgICAgICAgTW9kZVtNb2RlW1wiUEFEX0VOQ09ERVwiXSA9IDBdID0gXCJQQURfRU5DT0RFXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIkFTQ0lJX0VOQ09ERVwiXSA9IDFdID0gXCJBU0NJSV9FTkNPREVcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiQzQwX0VOQ09ERVwiXSA9IDJdID0gXCJDNDBfRU5DT0RFXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIlRFWFRfRU5DT0RFXCJdID0gM10gPSBcIlRFWFRfRU5DT0RFXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIkFOU0lYMTJfRU5DT0RFXCJdID0gNF0gPSBcIkFOU0lYMTJfRU5DT0RFXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIkVESUZBQ1RfRU5DT0RFXCJdID0gNV0gPSBcIkVESUZBQ1RfRU5DT0RFXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIkJBU0UyNTZfRU5DT0RFXCJdID0gNl0gPSBcIkJBU0UyNTZfRU5DT0RFXCI7XG4gICAgfSkoTW9kZSB8fCAoTW9kZSA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogPHA+RGF0YSBNYXRyaXggQ29kZXMgY2FuIGVuY29kZSB0ZXh0IGFzIGJpdHMgaW4gb25lIG9mIHNldmVyYWwgbW9kZXMsIGFuZCBjYW4gdXNlIG11bHRpcGxlIG1vZGVzXG4gICAgICogaW4gb25lIERhdGEgTWF0cml4IENvZGUuIFRoaXMgY2xhc3MgZGVjb2RlcyB0aGUgYml0cyBiYWNrIGludG8gdGV4dC48L3A+XG4gICAgICpcbiAgICAgKiA8cD5TZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi4xIC0gNS4yLjkuMjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciB7XG4gICAgICAgIHN0YXRpYyBkZWNvZGUoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBuZXcgQml0U291cmNlKGJ5dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRUcmFpbGVyID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVTZWdtZW50cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgbGV0IG1vZGUgPSBNb2RlLkFTQ0lJX0VOQ09ERTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gTW9kZS5BU0NJSV9FTkNPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IHRoaXMuZGVjb2RlQXNjaWlTZWdtZW50KGJpdHMsIHJlc3VsdCwgcmVzdWx0VHJhaWxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5DNDBfRU5DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlQzQwU2VnbWVudChiaXRzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlLlRFWFRfRU5DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlVGV4dFNlZ21lbnQoYml0cywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5BTlNJWDEyX0VOQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY29kZUFuc2lYMTJTZWdtZW50KGJpdHMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuRURJRkFDVF9FTkNPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVFZGlmYWN0U2VnbWVudChiaXRzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlLkJBU0UyNTZfRU5DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlQmFzZTI1NlNlZ21lbnQoYml0cywgcmVzdWx0LCBieXRlU2VnbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IE1vZGUuQVNDSUlfRU5DT0RFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKG1vZGUgIT09IE1vZGUuUEFEX0VOQ09ERSAmJiBiaXRzLmF2YWlsYWJsZSgpID4gMCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0VHJhaWxlci5sZW5ndGgoKSA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKHJlc3VsdFRyYWlsZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZXJSZXN1bHQoYnl0ZXMsIHJlc3VsdC50b1N0cmluZygpLCBieXRlU2VnbWVudHMubGVuZ3RoID09PSAwID8gbnVsbCA6IGJ5dGVTZWdtZW50cywgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgNS4yLjMgYW5kIEFubmV4IEMsIFRhYmxlIEMuMlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZUFzY2lpU2VnbWVudChiaXRzLCByZXN1bHQsIHJlc3VsdFRyYWlsZXIpIHtcbiAgICAgICAgICAgIGxldCB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IG9uZUJ5dGUgPSBiaXRzLnJlYWRCaXRzKDgpO1xuICAgICAgICAgICAgICAgIGlmIChvbmVCeXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob25lQnl0ZSA8PSAxMjgpIHsgLy8gQVNDSUkgZGF0YSAoQVNDSUkgdmFsdWUgKyAxKVxuICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lQnl0ZSArPSAxMjg7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKG9uZUJ5dGUgLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLkFTQ0lJX0VOQ09ERTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob25lQnl0ZSA9PT0gMTI5KSB7IC8vIFBhZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTW9kZS5QQURfRU5DT0RFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbmVCeXRlIDw9IDIyOSkgeyAvLyAyLWRpZ2l0IGRhdGEgMDAtOTkgKE51bWVyaWMgVmFsdWUgKyAxMzApXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb25lQnl0ZSAtIDEzMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMTApIHsgLy8gcGFkIHdpdGggJzAnIGZvciBzaW5nbGUgZGlnaXQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcwJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnJyArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob25lQnl0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzA6IC8vIExhdGNoIHRvIEM0MCBlbmNvZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuQzQwX0VOQ09ERTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjMxOiAvLyBMYXRjaCB0byBCYXNlIDI1NiBlbmNvZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuQkFTRTI1Nl9FTkNPREU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzMjogLy8gRk5DMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZSgyOSkpOyAvLyB0cmFuc2xhdGUgYXMgQVNDSUkgMjlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjMzOiAvLyBTdHJ1Y3R1cmVkIEFwcGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzQ6IC8vIFJlYWRlciBQcm9ncmFtbWluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aGVzZSBzeW1ib2xzIGZvciBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyBSZWFkZXJFeGNlcHRpb24uZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjM1OiAvLyBVcHBlciBTaGlmdCAoc2hpZnQgdG8gRXh0ZW5kZWQgQVNDSUkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzNjogLy8gMDUgTWFjcm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdbKT5cXHUwMDFFMDVcXHUwMDFEJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0VHJhaWxlci5pbnNlcnQoMCwgJ1xcdTAwMUVcXHUwMDA0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzNzogLy8gMDYgTWFjcm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdbKT5cXHUwMDFFMDZcXHUwMDFEJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0VHJhaWxlci5pbnNlcnQoMCwgJ1xcdTAwMUVcXHUwMDA0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzODogLy8gTGF0Y2ggdG8gQU5TSSBYMTIgZW5jb2RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLkFOU0lYMTJfRU5DT0RFO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzk6IC8vIExhdGNoIHRvIFRleHQgZW5jb2RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLlRFWFRfRU5DT0RFO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDA6IC8vIExhdGNoIHRvIEVESUZBQ1QgZW5jb2RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLkVESUZBQ1RfRU5DT0RFO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDE6IC8vIEVDSSBDaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGJicm93bik6IEkgdGhpbmsgd2UgbmVlZCB0byBzdXBwb3J0IEVDSVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm93IFJlYWRlckV4Y2VwdGlvbi5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aGlzIHN5bWJvbCBmb3Igbm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCB0byBiZSB1c2VkIGluIEFTQ0lJIGVuY29kYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgd29yayBhcm91bmQgZW5jb2RlcnMgdGhhdCBlbmQgd2l0aCAyNTQsIGxhdGNoIGJhY2sgdG8gQVNDSUlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25lQnl0ZSAhPT0gMjU0IHx8IGJpdHMuYXZhaWxhYmxlKCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGJpdHMuYXZhaWxhYmxlKCkgPiAwKTtcbiAgICAgICAgICAgIHJldHVybiBNb2RlLkFTQ0lJX0VOQ09ERTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIElTTyAxNjAyMjoyMDA2LCA1LjIuNSBhbmQgQW5uZXggQywgVGFibGUgQy4xXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlQzQwU2VnbWVudChiaXRzLCByZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIFRocmVlIEM0MCB2YWx1ZXMgYXJlIGVuY29kZWQgaW4gYSAxNi1iaXQgdmFsdWUgYXNcbiAgICAgICAgICAgIC8vICgxNjAwICogQzEpICsgKDQwICogQzIpICsgQzMgKyAxXG4gICAgICAgICAgICAvLyBUT0RPKGJicm93bik6IFRoZSBVcHBlciBTaGlmdCB3aXRoIEM0MCBkb2Vzbid0IHdvcmsgaW4gdGhlIDQgdmFsdWUgc2NlbmFyaW8gYWxsIHRoZSB0aW1lXG4gICAgICAgICAgICBsZXQgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY1ZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgbGV0IHNoaWZ0ID0gMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSBieXRlIGxlZnQgdGhlbiBpdCB3aWxsIGJlIGVuY29kZWQgYXMgQVNDSUlcbiAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA9PT0gMjU0KSB7IC8vIFVubGF0Y2ggY29kZXdvcmRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVHdvQnl0ZXMoZmlyc3RCeXRlLCBiaXRzLnJlYWRCaXRzKDgpLCBjVmFsdWVzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjVmFsdWUgPSBjVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNWYWx1ZSA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBjVmFsdWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjVmFsdWUgPCB0aGlzLkM0MF9CQVNJQ19TRVRfQ0hBUlMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGM0MGNoYXIgPSB0aGlzLkM0MF9CQVNJQ19TRVRfQ0hBUlNbY1ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjNDBjaGFyLmNoYXJDb2RlQXQoMCkgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoYzQwY2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNWYWx1ZSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY1ZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY1ZhbHVlIDwgdGhpcy5DNDBfU0hJRlQyX1NFVF9DSEFSUy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYzQwY2hhciA9IHRoaXMuQzQwX1NISUZUMl9TRVRfQ0hBUlNbY1ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjNDBjaGFyLmNoYXJDb2RlQXQoMCkgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoYzQwY2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI3OiAvLyBGTkMxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KSk7IC8vIHRyYW5zbGF0ZSBhcyBBU0NJSSAyOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzMDogLy8gVXBwZXIgU2hpZnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY1ZhbHVlICsgMjI0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUgKyA5NikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGJpdHMuYXZhaWxhYmxlKCkgPiAwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIElTTyAxNjAyMjoyMDA2LCA1LjIuNiBhbmQgQW5uZXggQywgVGFibGUgQy4yXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlVGV4dFNlZ21lbnQoYml0cywgcmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBUaHJlZSBUZXh0IHZhbHVlcyBhcmUgZW5jb2RlZCBpbiBhIDE2LWJpdCB2YWx1ZSBhc1xuICAgICAgICAgICAgLy8gKDE2MDAgKiBDMSkgKyAoNDAgKiBDMikgKyBDMyArIDFcbiAgICAgICAgICAgIC8vIFRPRE8oYmJyb3duKTogVGhlIFVwcGVyIFNoaWZ0IHdpdGggVGV4dCBkb2Vzbid0IHdvcmsgaW4gdGhlIDQgdmFsdWUgc2NlbmFyaW8gYWxsIHRoZSB0aW1lXG4gICAgICAgICAgICBsZXQgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGNWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGxldCBzaGlmdCA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgYnl0ZSBsZWZ0IHRoZW4gaXQgd2lsbCBiZSBlbmNvZGVkIGFzIEFTQ0lJXG4gICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEJ5dGUgPSBiaXRzLnJlYWRCaXRzKDgpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPT09IDI1NCkgeyAvLyBVbmxhdGNoIGNvZGV3b3JkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVR3b0J5dGVzKGZpcnN0Qnl0ZSwgYml0cy5yZWFkQml0cyg4KSwgY1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY1ZhbHVlID0gY1ZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjVmFsdWUgPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gY1ZhbHVlICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY1ZhbHVlIDwgdGhpcy5URVhUX0JBU0lDX1NFVF9DSEFSUy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dENoYXIgPSB0aGlzLlRFWFRfQkFTSUNfU0VUX0NIQVJTW2NWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUodGV4dENoYXIuY2hhckNvZGVBdCgwKSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0ZXh0Q2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNWYWx1ZSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY1ZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGlmdCAyIGZvciBUZXh0IGlzIHRoZSBzYW1lIGVuY29kaW5nIGFzIEM0MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjVmFsdWUgPCB0aGlzLlRFWFRfU0hJRlQyX1NFVF9DSEFSUy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dENoYXIgPSB0aGlzLlRFWFRfU0hJRlQyX1NFVF9DSEFSU1tjVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKHRleHRDaGFyLmNoYXJDb2RlQXQoMCkgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodGV4dENoYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNzogLy8gRk5DMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZSgyOSkpOyAvLyB0cmFuc2xhdGUgYXMgQVNDSUkgMjlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzA6IC8vIFVwcGVyIFNoaWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNWYWx1ZSA8IHRoaXMuVEVYVF9TSElGVDNfU0VUX0NIQVJTLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0Q2hhciA9IHRoaXMuVEVYVF9TSElGVDNfU0VUX0NIQVJTW2NWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUodGV4dENoYXIuY2hhckNvZGVBdCgwKSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0ZXh0Q2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoYml0cy5hdmFpbGFibGUoKSA+IDApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi43XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlQW5zaVgxMlNlZ21lbnQoYml0cywgcmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBUaHJlZSBBTlNJIFgxMiB2YWx1ZXMgYXJlIGVuY29kZWQgaW4gYSAxNi1iaXQgdmFsdWUgYXNcbiAgICAgICAgICAgIC8vICgxNjAwICogQzEpICsgKDQwICogQzIpICsgQzMgKyAxXG4gICAgICAgICAgICBjb25zdCBjVmFsdWVzID0gW107XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgYnl0ZSBsZWZ0IHRoZW4gaXQgd2lsbCBiZSBlbmNvZGVkIGFzIEFTQ0lJXG4gICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEJ5dGUgPSBiaXRzLnJlYWRCaXRzKDgpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPT09IDI1NCkgeyAvLyBVbmxhdGNoIGNvZGV3b3JkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVR3b0J5dGVzKGZpcnN0Qnl0ZSwgYml0cy5yZWFkQml0cyg4KSwgY1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY1ZhbHVlID0gY1ZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogLy8gWDEyIHNlZ21lbnQgdGVybWluYXRvciA8Q1I+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIFgxMiBzZWdtZW50IHNlcGFyYXRvciAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnKicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiAvLyBYMTIgc3ViLWVsZW1lbnQgc2VwYXJhdG9yID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCc+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IC8vIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY1ZhbHVlIDwgMTQpIHsgLy8gMCAtIDlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNWYWx1ZSArIDQ0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNWYWx1ZSA8IDQwKSB7IC8vIEEgLSBaXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUgKyA1MSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGJpdHMuYXZhaWxhYmxlKCkgPiAwKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcGFyc2VUd29CeXRlcyhmaXJzdEJ5dGUsIHNlY29uZEJ5dGUsIHJlc3VsdCkge1xuICAgICAgICAgICAgbGV0IGZ1bGxCaXRWYWx1ZSA9IChmaXJzdEJ5dGUgPDwgOCkgKyBzZWNvbmRCeXRlIC0gMTtcbiAgICAgICAgICAgIGxldCB0ZW1wID0gTWF0aC5mbG9vcihmdWxsQml0VmFsdWUgLyAxNjAwKTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXA7XG4gICAgICAgICAgICBmdWxsQml0VmFsdWUgLT0gdGVtcCAqIDE2MDA7XG4gICAgICAgICAgICB0ZW1wID0gTWF0aC5mbG9vcihmdWxsQml0VmFsdWUgLyA0MCk7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0ZW1wO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gZnVsbEJpdFZhbHVlIC0gdGVtcCAqIDQwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi44IGFuZCBBbm5leCBDIFRhYmxlIEMuM1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZUVkaWZhY3RTZWdtZW50KGJpdHMsIHJlc3VsdCkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgdHdvIG9yIGxlc3MgYnl0ZXMgbGVmdCB0aGVuIGl0IHdpbGwgYmUgZW5jb2RlZCBhcyBBU0NJSVxuICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDw9IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVkaWZhY3RWYWx1ZSA9IGJpdHMucmVhZEJpdHMoNik7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgdW5sYXRjaCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVkaWZhY3RWYWx1ZSA9PT0gMHgxRikgeyAvLyAwMTExMTFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgcmVzdCBvZiBieXRlLCB3aGljaCBzaG91bGQgYmUgMCwgYW5kIHN0b3BcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdHNMZWZ0ID0gOCAtIGJpdHMuZ2V0Qml0T2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0c0xlZnQgIT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzLnJlYWRCaXRzKGJpdHNMZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKGVkaWZhY3RWYWx1ZSAmIDB4MjApID09PSAwKSB7IC8vIG5vIDEgaW4gdGhlIGxlYWRpbmcgKDZ0aCkgYml0XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGlmYWN0VmFsdWUgfD0gMHg0MDsgLy8gQWRkIGEgbGVhZGluZyAwMSB0byB0aGUgNiBiaXQgYmluYXJ5IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGVkaWZhY3RWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGJpdHMuYXZhaWxhYmxlKCkgPiAwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIElTTyAxNjAyMjoyMDA2LCA1LjIuOSBhbmQgQW5uZXggQiwgQi4yXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlQmFzZTI1NlNlZ21lbnQoYml0cywgcmVzdWx0LCBieXRlU2VnbWVudHMpIHtcbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgaG93IGxvbmcgdGhlIEJhc2UgMjU2IFNlZ21lbnQgaXMuXG4gICAgICAgICAgICBsZXQgY29kZXdvcmRQb3NpdGlvbiA9IDEgKyBiaXRzLmdldEJ5dGVPZmZzZXQoKTsgLy8gcG9zaXRpb24gaXMgMS1pbmRleGVkXG4gICAgICAgICAgICBjb25zdCBkMSA9IHRoaXMudW5yYW5kb21pemUyNTVTdGF0ZShiaXRzLnJlYWRCaXRzKDgpLCBjb2Rld29yZFBvc2l0aW9uKyspO1xuICAgICAgICAgICAgbGV0IGNvdW50O1xuICAgICAgICAgICAgaWYgKGQxID09PSAwKSB7IC8vIFJlYWQgdGhlIHJlbWFpbmRlciBvZiB0aGUgc3ltYm9sXG4gICAgICAgICAgICAgICAgY291bnQgPSBiaXRzLmF2YWlsYWJsZSgpIC8gOCB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkMSA8IDI1MCkge1xuICAgICAgICAgICAgICAgIGNvdW50ID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudCA9IDI1MCAqIChkMSAtIDI0OSkgKyB0aGlzLnVucmFuZG9taXplMjU1U3RhdGUoYml0cy5yZWFkQml0cyg4KSwgY29kZXdvcmRQb3NpdGlvbisrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlJ3JlIHNlZWluZyBOZWdhdGl2ZUFycmF5U2l6ZUV4Y2VwdGlvbiBlcnJvcnMgZnJvbSB1c2Vycy5cbiAgICAgICAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGNvdW50KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIEhhdmUgc2VlbiB0aGlzIHBhcnRpY3VsYXIgZXJyb3IgaW4gdGhlIHdpbGQsIHN1Y2ggYXMgYXRcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LmJjZ2VuLmNvbS9kZW1vL0lEQXV0b21hdGlvblN0cmVhbWluZ0RhdGFNYXRyaXguYXNweD9NT0RFPTMmRD1GcmVkJlBGTVQ9MyZQVD1GJlg9MC4zJk89MCZMTT0wLjJcbiAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBieXRlc1tpXSA9IHRoaXMudW5yYW5kb21pemUyNTVTdGF0ZShiaXRzLnJlYWRCaXRzKDgpLCBjb2Rld29yZFBvc2l0aW9uKyspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnl0ZVNlZ21lbnRzLnB1c2goYnl0ZXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZ0VuY29kaW5nLmRlY29kZShieXRlcywgU3RyaW5nVXRpbHMuSVNPODg1OTEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoICh1ZWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCdQbGF0Zm9ybSBkb2VzIG5vdCBzdXBwb3J0IHJlcXVpcmVkIGVuY29kaW5nOiAnICsgdWVlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIEFubmV4IEIsIEIuMlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHVucmFuZG9taXplMjU1U3RhdGUocmFuZG9taXplZEJhc2UyNTZDb2Rld29yZCwgYmFzZTI1NkNvZGV3b3JkUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHBzZXVkb1JhbmRvbU51bWJlciA9ICgoMTQ5ICogYmFzZTI1NkNvZGV3b3JkUG9zaXRpb24pICUgMjU1KSArIDE7XG4gICAgICAgICAgICBjb25zdCB0ZW1wVmFyaWFibGUgPSByYW5kb21pemVkQmFzZTI1NkNvZGV3b3JkIC0gcHNldWRvUmFuZG9tTnVtYmVyO1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBWYXJpYWJsZSA+PSAwID8gdGVtcFZhcmlhYmxlIDogdGVtcFZhcmlhYmxlICsgMjU2O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgQW5uZXggQyBUYWJsZSBDLjFcbiAgICAgKiBUaGUgQzQwIEJhc2ljIENoYXJhY3RlciBTZXQgKConcyB1c2VkIGZvciBwbGFjZWhvbGRlcnMgZm9yIHRoZSBzaGlmdCB2YWx1ZXMpXG4gICAgICovXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5DNDBfQkFTSUNfU0VUX0NIQVJTID0gW1xuICAgICAgICAnKicsICcqJywgJyonLCAnICcsICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JyxcbiAgICAgICAgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsXG4gICAgICAgICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWidcbiAgICBdO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQzQwX1NISUZUMl9TRVRfQ0hBUlMgPSBbXG4gICAgICAgICchJywgJ1wiJywgJyMnLCAnJCcsICclJywgJyYnLCAnXFwnJywgJygnLCAnKScsICcqJywgJysnLCAnLCcsICctJywgJy4nLFxuICAgICAgICAnLycsICc6JywgJzsnLCAnPCcsICc9JywgJz4nLCAnPycsICdAJywgJ1snLCAnXFxcXCcsICddJywgJ14nLCAnXydcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgQW5uZXggQyBUYWJsZSBDLjJcbiAgICAgKiBUaGUgVGV4dCBCYXNpYyBDaGFyYWN0ZXIgU2V0ICgqJ3MgdXNlZCBmb3IgcGxhY2Vob2xkZXJzIGZvciB0aGUgc2hpZnQgdmFsdWVzKVxuICAgICAqL1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9CQVNJQ19TRVRfQ0hBUlMgPSBbXG4gICAgICAgICcqJywgJyonLCAnKicsICcgJywgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLFxuICAgICAgICAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJyxcbiAgICAgICAgJ28nLCAncCcsICdxJywgJ3InLCAncycsICd0JywgJ3UnLCAndicsICd3JywgJ3gnLCAneScsICd6J1xuICAgIF07XG4gICAgLy8gU2hpZnQgMiBmb3IgVGV4dCBpcyB0aGUgc2FtZSBlbmNvZGluZyBhcyBDNDBcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlRFWFRfU0hJRlQyX1NFVF9DSEFSUyA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQzQwX1NISUZUMl9TRVRfQ0hBUlM7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX1NISUZUM19TRVRfQ0hBUlMgPSBbXG4gICAgICAgICdgJywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsXG4gICAgICAgICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICd7JywgJ3wnLCAnfScsICd+JywgU3RyaW5nLmZyb21DaGFyQ29kZSgxMjcpXG4gICAgXTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+VGhlIG1haW4gY2xhc3Mgd2hpY2ggaW1wbGVtZW50cyBEYXRhIE1hdHJpeCBDb2RlIGRlY29kaW5nIC0tIGFzIG9wcG9zZWQgdG8gbG9jYXRpbmcgYW5kIGV4dHJhY3RpbmdcbiAgICAgKiB0aGUgRGF0YSBNYXRyaXggQ29kZSBmcm9tIGFuIGltYWdlLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxuICAgICAqL1xuICAgIGNsYXNzIERlY29kZXIkMSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5yc0RlY29kZXIgPSBuZXcgUmVlZFNvbG9tb25EZWNvZGVyKEdlbmVyaWNHRi5EQVRBX01BVFJJWF9GSUVMRF8yNTYpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5EZWNvZGVzIGEgRGF0YSBNYXRyaXggQ29kZSByZXByZXNlbnRlZCBhcyBhIHtAbGluayBCaXRNYXRyaXh9LiBBIDEgb3IgXCJ0cnVlXCIgaXMgdGFrZW5cbiAgICAgICAgICogdG8gbWVhbiBhIGJsYWNrIG1vZHVsZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBiaXRzIGJvb2xlYW5zIHJlcHJlc2VudGluZyB3aGl0ZS9ibGFjayBEYXRhIE1hdHJpeCBDb2RlIG1vZHVsZXNcbiAgICAgICAgICogQHJldHVybiB0ZXh0IGFuZCBieXRlcyBlbmNvZGVkIHdpdGhpbiB0aGUgRGF0YSBNYXRyaXggQ29kZVxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiB0aGUgRGF0YSBNYXRyaXggQ29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHNcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZShiaXRzKSB7XG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgYSBwYXJzZXIgYW5kIHJlYWQgdmVyc2lvbiwgZXJyb3ItY29ycmVjdGlvbiBsZXZlbFxuICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IEJpdE1hdHJpeFBhcnNlcihiaXRzKTtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBwYXJzZXIuZ2V0VmVyc2lvbigpO1xuICAgICAgICAgICAgLy8gUmVhZCBjb2Rld29yZHNcbiAgICAgICAgICAgIGNvbnN0IGNvZGV3b3JkcyA9IHBhcnNlci5yZWFkQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAvLyBTZXBhcmF0ZSBpbnRvIGRhdGEgYmxvY2tzXG4gICAgICAgICAgICBjb25zdCBkYXRhQmxvY2tzID0gRGF0YUJsb2NrLmdldERhdGFCbG9ja3MoY29kZXdvcmRzLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgIC8vIENvdW50IHRvdGFsIG51bWJlciBvZiBkYXRhIGJ5dGVzXG4gICAgICAgICAgICBsZXQgdG90YWxCeXRlcyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBkYiBvZiBkYXRhQmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgdG90YWxCeXRlcyArPSBkYi5nZXROdW1EYXRhQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsQnl0ZXMpO1xuICAgICAgICAgICAgY29uc3QgZGF0YUJsb2Nrc0NvdW50ID0gZGF0YUJsb2Nrcy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBFcnJvci1jb3JyZWN0IGFuZCBjb3B5IGRhdGEgYmxvY2tzIHRvZ2V0aGVyIGludG8gYSBzdHJlYW0gb2YgYnl0ZXNcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGF0YUJsb2Nrc0NvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhQmxvY2sgPSBkYXRhQmxvY2tzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGV3b3JkQnl0ZXMgPSBkYXRhQmxvY2suZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtRGF0YUNvZGV3b3JkcyA9IGRhdGFCbG9jay5nZXROdW1EYXRhQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3JyZWN0RXJyb3JzKGNvZGV3b3JkQnl0ZXMsIG51bURhdGFDb2Rld29yZHMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlLWludGVybGFjZSBkYXRhIGJsb2Nrcy5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Qnl0ZXNbaSAqIGRhdGFCbG9ja3NDb3VudCArIGpdID0gY29kZXdvcmRCeXRlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWNvZGUgdGhlIGNvbnRlbnRzIG9mIHRoYXQgc3RyZWFtIG9mIGJ5dGVzXG4gICAgICAgICAgICByZXR1cm4gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGUocmVzdWx0Qnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5HaXZlbiBkYXRhIGFuZCBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcyByZWNlaXZlZCwgcG9zc2libHkgY29ycnVwdGVkIGJ5IGVycm9ycywgYXR0ZW1wdHMgdG9cbiAgICAgICAgICogY29ycmVjdCB0aGUgZXJyb3JzIGluLXBsYWNlIHVzaW5nIFJlZWQtU29sb21vbiBlcnJvciBjb3JyZWN0aW9uLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvZGV3b3JkQnl0ZXMgZGF0YSBhbmQgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHNcbiAgICAgICAgICogQHBhcmFtIG51bURhdGFDb2Rld29yZHMgbnVtYmVyIG9mIGNvZGV3b3JkcyB0aGF0IGFyZSBkYXRhIGJ5dGVzXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgY29ycmVjdEVycm9ycyhjb2Rld29yZEJ5dGVzLCBudW1EYXRhQ29kZXdvcmRzKSB7XG4gICAgICAgICAgICAvLyBjb25zdCBudW1Db2Rld29yZHMgPSBjb2Rld29yZEJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIEZpcnN0IHJlYWQgaW50byBhbiBhcnJheSBvZiBpbnRzXG4gICAgICAgICAgICBjb25zdCBjb2Rld29yZHNJbnRzID0gbmV3IEludDMyQXJyYXkoY29kZXdvcmRCeXRlcyk7XG4gICAgICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAvLyAgIGNvZGV3b3Jkc0ludHNbaV0gPSBjb2Rld29yZEJ5dGVzW2ldICYgMHhGRjtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yc0RlY29kZXIuZGVjb2RlKGNvZGV3b3Jkc0ludHMsIGNvZGV3b3JkQnl0ZXMubGVuZ3RoIC0gbnVtRGF0YUNvZGV3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCAvKiBSZWVkU29sb21vbkV4Y2VwdGlvbiAqLykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDaGVja3N1bUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29weSBiYWNrIGludG8gYXJyYXkgb2YgYnl0ZXMgLS0gb25seSBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZSBieXRlcyB0aGF0IHdlcmUgZGF0YVxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgY2FyZSBhYm91dCBlcnJvcnMgaW4gdGhlIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvZGV3b3JkQnl0ZXNbaV0gPSBjb2Rld29yZHNJbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGxvZ2ljIHRoYXQgY2FuIGRldGVjdCBhIERhdGEgTWF0cml4IENvZGUgaW4gYW4gaW1hZ2UsIGV2ZW4gaWYgdGhlIERhdGEgTWF0cml4IENvZGVcbiAgICAgKiBpcyByb3RhdGVkIG9yIHNrZXdlZCwgb3IgcGFydGlhbGx5IG9ic2N1cmVkLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGV0ZWN0b3IkMSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGltYWdlKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLnJlY3RhbmdsZURldGVjdG9yID0gbmV3IFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IodGhpcy5pbWFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRldGVjdHMgYSBEYXRhIE1hdHJpeCBDb2RlIGluIGFuIGltYWdlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgRGV0ZWN0b3JSZXN1bHR9IGVuY2Fwc3VsYXRpbmcgcmVzdWx0cyBvZiBkZXRlY3RpbmcgYSBEYXRhIE1hdHJpeCBDb2RlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgbm8gRGF0YSBNYXRyaXggQ29kZSBjYW4gYmUgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIGRldGVjdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvcm5lclBvaW50cyA9IHRoaXMucmVjdGFuZ2xlRGV0ZWN0b3IuZGV0ZWN0KCk7XG4gICAgICAgICAgICBsZXQgcG9pbnRzID0gdGhpcy5kZXRlY3RTb2xpZDEoY29ybmVyUG9pbnRzKTtcbiAgICAgICAgICAgIHBvaW50cyA9IHRoaXMuZGV0ZWN0U29saWQyKHBvaW50cyk7XG4gICAgICAgICAgICBwb2ludHNbM10gPSB0aGlzLmNvcnJlY3RUb3BSaWdodChwb2ludHMpO1xuICAgICAgICAgICAgaWYgKCFwb2ludHNbM10pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50cyA9IHRoaXMuc2hpZnRUb01vZHVsZUNlbnRlcihwb2ludHMpO1xuICAgICAgICAgICAgY29uc3QgdG9wTGVmdCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbUxlZnQgPSBwb2ludHNbMV07XG4gICAgICAgICAgICBjb25zdCBib3R0b21SaWdodCA9IHBvaW50c1syXTtcbiAgICAgICAgICAgIGNvbnN0IHRvcFJpZ2h0ID0gcG9pbnRzWzNdO1xuICAgICAgICAgICAgbGV0IGRpbWVuc2lvblRvcCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHRvcExlZnQsIHRvcFJpZ2h0KSArIDE7XG4gICAgICAgICAgICBsZXQgZGltZW5zaW9uUmlnaHQgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihib3R0b21SaWdodCwgdG9wUmlnaHQpICsgMTtcbiAgICAgICAgICAgIGlmICgoZGltZW5zaW9uVG9wICYgMHgwMSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25Ub3AgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZGltZW5zaW9uUmlnaHQgJiAweDAxKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvblJpZ2h0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoNCAqIGRpbWVuc2lvblRvcCA8IDcgKiBkaW1lbnNpb25SaWdodCAmJiA0ICogZGltZW5zaW9uUmlnaHQgPCA3ICogZGltZW5zaW9uVG9wKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG1hdHJpeCBpcyBzcXVhcmVcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25Ub3AgPSBkaW1lbnNpb25SaWdodCA9IE1hdGgubWF4KGRpbWVuc2lvblRvcCwgZGltZW5zaW9uUmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJpdHMgPSBEZXRlY3RvciQxLnNhbXBsZUdyaWQodGhpcy5pbWFnZSwgdG9wTGVmdCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQsIHRvcFJpZ2h0LCBkaW1lbnNpb25Ub3AsIGRpbWVuc2lvblJpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGV0ZWN0b3JSZXN1bHQoYml0cywgW3RvcExlZnQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCB0b3BSaWdodF0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBzaGlmdFBvaW50KHBvaW50LCB0bywgZGl2KSB7XG4gICAgICAgICAgICBsZXQgeCA9ICh0by5nZXRYKCkgLSBwb2ludC5nZXRYKCkpIC8gKGRpdiArIDEpO1xuICAgICAgICAgICAgbGV0IHkgPSAodG8uZ2V0WSgpIC0gcG9pbnQuZ2V0WSgpKSAvIChkaXYgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzdWx0UG9pbnQocG9pbnQuZ2V0WCgpICsgeCwgcG9pbnQuZ2V0WSgpICsgeSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG1vdmVBd2F5KHBvaW50LCBmcm9tWCwgZnJvbVkpIHtcbiAgICAgICAgICAgIGxldCB4ID0gcG9pbnQuZ2V0WCgpO1xuICAgICAgICAgICAgbGV0IHkgPSBwb2ludC5nZXRZKCk7XG4gICAgICAgICAgICBpZiAoeCA8IGZyb21YKSB7XG4gICAgICAgICAgICAgICAgeCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgPCBmcm9tWSkge1xuICAgICAgICAgICAgICAgIHkgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHkgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzdWx0UG9pbnQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVjdCBhIHNvbGlkIHNpZGUgd2hpY2ggaGFzIG1pbmltdW0gdHJhbnNpdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGRldGVjdFNvbGlkMShjb3JuZXJQb2ludHMpIHtcbiAgICAgICAgICAgIC8vIDAgIDJcbiAgICAgICAgICAgIC8vIDEgIDNcbiAgICAgICAgICAgIGxldCBwb2ludEEgPSBjb3JuZXJQb2ludHNbMF07XG4gICAgICAgICAgICBsZXQgcG9pbnRCID0gY29ybmVyUG9pbnRzWzFdO1xuICAgICAgICAgICAgbGV0IHBvaW50QyA9IGNvcm5lclBvaW50c1szXTtcbiAgICAgICAgICAgIGxldCBwb2ludEQgPSBjb3JuZXJQb2ludHNbMl07XG4gICAgICAgICAgICBsZXQgdHJBQiA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QSwgcG9pbnRCKTtcbiAgICAgICAgICAgIGxldCB0ckJDID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRCLCBwb2ludEMpO1xuICAgICAgICAgICAgbGV0IHRyQ0QgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEMsIHBvaW50RCk7XG4gICAgICAgICAgICBsZXQgdHJEQSA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50RCwgcG9pbnRBKTtcbiAgICAgICAgICAgIC8vIDAuLjNcbiAgICAgICAgICAgIC8vIDogIDpcbiAgICAgICAgICAgIC8vIDEtLTJcbiAgICAgICAgICAgIGxldCBtaW4gPSB0ckFCO1xuICAgICAgICAgICAgbGV0IHBvaW50cyA9IFtwb2ludEQsIHBvaW50QSwgcG9pbnRCLCBwb2ludENdO1xuICAgICAgICAgICAgaWYgKG1pbiA+IHRyQkMpIHtcbiAgICAgICAgICAgICAgICBtaW4gPSB0ckJDO1xuICAgICAgICAgICAgICAgIHBvaW50c1swXSA9IHBvaW50QTtcbiAgICAgICAgICAgICAgICBwb2ludHNbMV0gPSBwb2ludEI7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzJdID0gcG9pbnRDO1xuICAgICAgICAgICAgICAgIHBvaW50c1szXSA9IHBvaW50RDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaW4gPiB0ckNEKSB7XG4gICAgICAgICAgICAgICAgbWluID0gdHJDRDtcbiAgICAgICAgICAgICAgICBwb2ludHNbMF0gPSBwb2ludEI7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzFdID0gcG9pbnRDO1xuICAgICAgICAgICAgICAgIHBvaW50c1syXSA9IHBvaW50RDtcbiAgICAgICAgICAgICAgICBwb2ludHNbM10gPSBwb2ludEE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWluID4gdHJEQSkge1xuICAgICAgICAgICAgICAgIHBvaW50c1swXSA9IHBvaW50QztcbiAgICAgICAgICAgICAgICBwb2ludHNbMV0gPSBwb2ludEQ7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzJdID0gcG9pbnRBO1xuICAgICAgICAgICAgICAgIHBvaW50c1szXSA9IHBvaW50QjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVjdCBhIHNlY29uZCBzb2xpZCBzaWRlIG5leHQgdG8gZmlyc3Qgc29saWQgc2lkZS5cbiAgICAgICAgICovXG4gICAgICAgIGRldGVjdFNvbGlkMihwb2ludHMpIHtcbiAgICAgICAgICAgIC8vIEEuLkRcbiAgICAgICAgICAgIC8vIDogIDpcbiAgICAgICAgICAgIC8vIEItLUNcbiAgICAgICAgICAgIGxldCBwb2ludEEgPSBwb2ludHNbMF07XG4gICAgICAgICAgICBsZXQgcG9pbnRCID0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgbGV0IHBvaW50QyA9IHBvaW50c1syXTtcbiAgICAgICAgICAgIGxldCBwb2ludEQgPSBwb2ludHNbM107XG4gICAgICAgICAgICAvLyBUcmFuc2l0aW9uIGRldGVjdGlvbiBvbiB0aGUgZWRnZSBpcyBub3Qgc3RhYmxlLlxuICAgICAgICAgICAgLy8gVG8gc2FmZWx5IGRldGVjdCwgc2hpZnQgdGhlIHBvaW50cyB0byB0aGUgbW9kdWxlIGNlbnRlci5cbiAgICAgICAgICAgIGxldCB0ciA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QSwgcG9pbnREKTtcbiAgICAgICAgICAgIGxldCBwb2ludEJzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50QiwgcG9pbnRDLCAodHIgKyAxKSAqIDQpO1xuICAgICAgICAgICAgbGV0IHBvaW50Q3MgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRDLCBwb2ludEIsICh0ciArIDEpICogNCk7XG4gICAgICAgICAgICBsZXQgdHJCQSA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QnMsIHBvaW50QSk7XG4gICAgICAgICAgICBsZXQgdHJDRCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50Q3MsIHBvaW50RCk7XG4gICAgICAgICAgICAvLyAwLi4zXG4gICAgICAgICAgICAvLyB8ICA6XG4gICAgICAgICAgICAvLyAxLS0yXG4gICAgICAgICAgICBpZiAodHJCQSA8IHRyQ0QpIHtcbiAgICAgICAgICAgICAgICAvLyBzb2xpZCBzaWRlczogQS1CLUNcbiAgICAgICAgICAgICAgICBwb2ludHNbMF0gPSBwb2ludEE7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzFdID0gcG9pbnRCO1xuICAgICAgICAgICAgICAgIHBvaW50c1syXSA9IHBvaW50QztcbiAgICAgICAgICAgICAgICBwb2ludHNbM10gPSBwb2ludEQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzb2xpZCBzaWRlczogQi1DLURcbiAgICAgICAgICAgICAgICBwb2ludHNbMF0gPSBwb2ludEI7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzFdID0gcG9pbnRDO1xuICAgICAgICAgICAgICAgIHBvaW50c1syXSA9IHBvaW50RDtcbiAgICAgICAgICAgICAgICBwb2ludHNbM10gPSBwb2ludEE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBjb3JuZXIgcG9zaXRpb24gb2YgdGhlIHdoaXRlIHRvcCByaWdodCBtb2R1bGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb3JyZWN0VG9wUmlnaHQocG9pbnRzKSB7XG4gICAgICAgICAgICAvLyBBLi5EXG4gICAgICAgICAgICAvLyB8ICA6XG4gICAgICAgICAgICAvLyBCLS1DXG4gICAgICAgICAgICBsZXQgcG9pbnRBID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgbGV0IHBvaW50QiA9IHBvaW50c1sxXTtcbiAgICAgICAgICAgIGxldCBwb2ludEMgPSBwb2ludHNbMl07XG4gICAgICAgICAgICBsZXQgcG9pbnREID0gcG9pbnRzWzNdO1xuICAgICAgICAgICAgLy8gc2hpZnQgcG9pbnRzIGZvciBzYWZlIHRyYW5zaXRpb24gZGV0ZWN0aW9uLlxuICAgICAgICAgICAgbGV0IHRyVG9wID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBLCBwb2ludEQpO1xuICAgICAgICAgICAgbGV0IHRyUmlnaHQgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEIsIHBvaW50RCk7XG4gICAgICAgICAgICBsZXQgcG9pbnRBcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEEsIHBvaW50QiwgKHRyUmlnaHQgKyAxKSAqIDQpO1xuICAgICAgICAgICAgbGV0IHBvaW50Q3MgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRDLCBwb2ludEIsICh0clRvcCArIDEpICogNCk7XG4gICAgICAgICAgICB0clRvcCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QXMsIHBvaW50RCk7XG4gICAgICAgICAgICB0clJpZ2h0ID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRDcywgcG9pbnREKTtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUxID0gbmV3IFJlc3VsdFBvaW50KHBvaW50RC5nZXRYKCkgKyAocG9pbnRDLmdldFgoKSAtIHBvaW50Qi5nZXRYKCkpIC8gKHRyVG9wICsgMSksIHBvaW50RC5nZXRZKCkgKyAocG9pbnRDLmdldFkoKSAtIHBvaW50Qi5nZXRZKCkpIC8gKHRyVG9wICsgMSkpO1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZTIgPSBuZXcgUmVzdWx0UG9pbnQocG9pbnRELmdldFgoKSArIChwb2ludEEuZ2V0WCgpIC0gcG9pbnRCLmdldFgoKSkgLyAodHJSaWdodCArIDEpLCBwb2ludEQuZ2V0WSgpICsgKHBvaW50QS5nZXRZKCkgLSBwb2ludEIuZ2V0WSgpKSAvICh0clJpZ2h0ICsgMSkpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoY2FuZGlkYXRlMSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKGNhbmRpZGF0ZTIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKGNhbmRpZGF0ZTIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3VtYzEgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEFzLCBjYW5kaWRhdGUxKSArIHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50Q3MsIGNhbmRpZGF0ZTEpO1xuICAgICAgICAgICAgbGV0IHN1bWMyID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBcywgY2FuZGlkYXRlMikgKyB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludENzLCBjYW5kaWRhdGUyKTtcbiAgICAgICAgICAgIGlmIChzdW1jMSA+IHN1bWMyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2hpZnQgdGhlIGVkZ2UgcG9pbnRzIHRvIHRoZSBtb2R1bGUgY2VudGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc2hpZnRUb01vZHVsZUNlbnRlcihwb2ludHMpIHtcbiAgICAgICAgICAgIC8vIEEuLkRcbiAgICAgICAgICAgIC8vIHwgIDpcbiAgICAgICAgICAgIC8vIEItLUNcbiAgICAgICAgICAgIGxldCBwb2ludEEgPSBwb2ludHNbMF07XG4gICAgICAgICAgICBsZXQgcG9pbnRCID0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgbGV0IHBvaW50QyA9IHBvaW50c1syXTtcbiAgICAgICAgICAgIGxldCBwb2ludEQgPSBwb2ludHNbM107XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgcHNldWRvIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIGxldCBkaW1IID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBLCBwb2ludEQpICsgMTtcbiAgICAgICAgICAgIGxldCBkaW1WID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRDLCBwb2ludEQpICsgMTtcbiAgICAgICAgICAgIC8vIHNoaWZ0IHBvaW50cyBmb3Igc2FmZSBkaW1lbnNpb24gZGV0ZWN0aW9uXG4gICAgICAgICAgICBsZXQgcG9pbnRBcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEEsIHBvaW50QiwgZGltViAqIDQpO1xuICAgICAgICAgICAgbGV0IHBvaW50Q3MgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRDLCBwb2ludEIsIGRpbUggKiA0KTtcbiAgICAgICAgICAgIC8vICBjYWxjdWxhdGUgbW9yZSBwcmVjaXNlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIGRpbUggPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEFzLCBwb2ludEQpICsgMTtcbiAgICAgICAgICAgIGRpbVYgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludENzLCBwb2ludEQpICsgMTtcbiAgICAgICAgICAgIGlmICgoZGltSCAmIDB4MDEpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGltSCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChkaW1WICYgMHgwMSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkaW1WICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXaGl0ZVJlY3RhbmdsZURldGVjdG9yIHJldHVybnMgcG9pbnRzIGluc2lkZSBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgICAgICAgICAgLy8gSSB3YW50IHBvaW50cyBvbiB0aGUgZWRnZXMuXG4gICAgICAgICAgICBsZXQgY2VudGVyWCA9IChwb2ludEEuZ2V0WCgpICsgcG9pbnRCLmdldFgoKSArIHBvaW50Qy5nZXRYKCkgKyBwb2ludEQuZ2V0WCgpKSAvIDQ7XG4gICAgICAgICAgICBsZXQgY2VudGVyWSA9IChwb2ludEEuZ2V0WSgpICsgcG9pbnRCLmdldFkoKSArIHBvaW50Qy5nZXRZKCkgKyBwb2ludEQuZ2V0WSgpKSAvIDQ7XG4gICAgICAgICAgICBwb2ludEEgPSBEZXRlY3RvciQxLm1vdmVBd2F5KHBvaW50QSwgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgICAgICBwb2ludEIgPSBEZXRlY3RvciQxLm1vdmVBd2F5KHBvaW50QiwgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgICAgICBwb2ludEMgPSBEZXRlY3RvciQxLm1vdmVBd2F5KHBvaW50QywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgICAgICBwb2ludEQgPSBEZXRlY3RvciQxLm1vdmVBd2F5KHBvaW50RCwgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgICAgICBsZXQgcG9pbnRCcztcbiAgICAgICAgICAgIGxldCBwb2ludERzO1xuICAgICAgICAgICAgLy8gc2hpZnQgcG9pbnRzIHRvIHRoZSBjZW50ZXIgb2YgZWFjaCBtb2R1bGVzXG4gICAgICAgICAgICBwb2ludEFzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50QSwgcG9pbnRCLCBkaW1WICogNCk7XG4gICAgICAgICAgICBwb2ludEFzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50QXMsIHBvaW50RCwgZGltSCAqIDQpO1xuICAgICAgICAgICAgcG9pbnRCcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEIsIHBvaW50QSwgZGltViAqIDQpO1xuICAgICAgICAgICAgcG9pbnRCcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEJzLCBwb2ludEMsIGRpbUggKiA0KTtcbiAgICAgICAgICAgIHBvaW50Q3MgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRDLCBwb2ludEQsIGRpbVYgKiA0KTtcbiAgICAgICAgICAgIHBvaW50Q3MgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRDcywgcG9pbnRCLCBkaW1IICogNCk7XG4gICAgICAgICAgICBwb2ludERzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50RCwgcG9pbnRDLCBkaW1WICogNCk7XG4gICAgICAgICAgICBwb2ludERzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50RHMsIHBvaW50QSwgZGltSCAqIDQpO1xuICAgICAgICAgICAgcmV0dXJuIFtwb2ludEFzLCBwb2ludEJzLCBwb2ludENzLCBwb2ludERzXTtcbiAgICAgICAgfVxuICAgICAgICBpc1ZhbGlkKHApIHtcbiAgICAgICAgICAgIHJldHVybiBwLmdldFgoKSA+PSAwICYmIHAuZ2V0WCgpIDwgdGhpcy5pbWFnZS5nZXRXaWR0aCgpICYmIHAuZ2V0WSgpID4gMCAmJiBwLmdldFkoKSA8IHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHNhbXBsZUdyaWQoaW1hZ2UsIHRvcExlZnQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCB0b3BSaWdodCwgZGltZW5zaW9uWCwgZGltZW5zaW9uWSkge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlciA9IEdyaWRTYW1wbGVySW5zdGFuY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVyLnNhbXBsZUdyaWQoaW1hZ2UsIGRpbWVuc2lvblgsIGRpbWVuc2lvblksIDAuNSwgMC41LCBkaW1lbnNpb25YIC0gMC41LCAwLjUsIGRpbWVuc2lvblggLSAwLjUsIGRpbWVuc2lvblkgLSAwLjUsIDAuNSwgZGltZW5zaW9uWSAtIDAuNSwgdG9wTGVmdC5nZXRYKCksIHRvcExlZnQuZ2V0WSgpLCB0b3BSaWdodC5nZXRYKCksIHRvcFJpZ2h0LmdldFkoKSwgYm90dG9tUmlnaHQuZ2V0WCgpLCBib3R0b21SaWdodC5nZXRZKCksIGJvdHRvbUxlZnQuZ2V0WCgpLCBib3R0b21MZWZ0LmdldFkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGJsYWNrL3doaXRlIHRyYW5zaXRpb25zIGJldHdlZW4gdHdvIHBvaW50cywgdXNpbmcgc29tZXRoaW5nIGxpa2UgQnJlc2VuaGFtJ3MgYWxnb3JpdGhtLlxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNpdGlvbnNCZXR3ZWVuKGZyb20sIHRvKSB7XG4gICAgICAgICAgICAvLyBTZWUgUVIgQ29kZSBEZXRlY3Rvciwgc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKClcbiAgICAgICAgICAgIGxldCBmcm9tWCA9IE1hdGgudHJ1bmMoZnJvbS5nZXRYKCkpO1xuICAgICAgICAgICAgbGV0IGZyb21ZID0gTWF0aC50cnVuYyhmcm9tLmdldFkoKSk7XG4gICAgICAgICAgICBsZXQgdG9YID0gTWF0aC50cnVuYyh0by5nZXRYKCkpO1xuICAgICAgICAgICAgbGV0IHRvWSA9IE1hdGgudHJ1bmModG8uZ2V0WSgpKTtcbiAgICAgICAgICAgIGxldCBzdGVlcCA9IE1hdGguYWJzKHRvWSAtIGZyb21ZKSA+IE1hdGguYWJzKHRvWCAtIGZyb21YKTtcbiAgICAgICAgICAgIGlmIChzdGVlcCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gZnJvbVg7XG4gICAgICAgICAgICAgICAgZnJvbVggPSBmcm9tWTtcbiAgICAgICAgICAgICAgICBmcm9tWSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgdGVtcCA9IHRvWDtcbiAgICAgICAgICAgICAgICB0b1ggPSB0b1k7XG4gICAgICAgICAgICAgICAgdG9ZID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkeCA9IE1hdGguYWJzKHRvWCAtIGZyb21YKTtcbiAgICAgICAgICAgIGxldCBkeSA9IE1hdGguYWJzKHRvWSAtIGZyb21ZKTtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IC1keCAvIDI7XG4gICAgICAgICAgICBsZXQgeXN0ZXAgPSBmcm9tWSA8IHRvWSA/IDEgOiAtMTtcbiAgICAgICAgICAgIGxldCB4c3RlcCA9IGZyb21YIDwgdG9YID8gMSA6IC0xO1xuICAgICAgICAgICAgbGV0IHRyYW5zaXRpb25zID0gMDtcbiAgICAgICAgICAgIGxldCBpbkJsYWNrID0gdGhpcy5pbWFnZS5nZXQoc3RlZXAgPyBmcm9tWSA6IGZyb21YLCBzdGVlcCA/IGZyb21YIDogZnJvbVkpO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IGZyb21YLCB5ID0gZnJvbVk7IHggIT09IHRvWDsgeCArPSB4c3RlcCkge1xuICAgICAgICAgICAgICAgIGxldCBpc0JsYWNrID0gdGhpcy5pbWFnZS5nZXQoc3RlZXAgPyB5IDogeCwgc3RlZXAgPyB4IDogeSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQmxhY2sgIT09IGluQmxhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbnMrKztcbiAgICAgICAgICAgICAgICAgICAgaW5CbGFjayA9IGlzQmxhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9yICs9IGR5O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPT09IHRvWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeSArPSB5c3RlcDtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgLT0gZHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zaXRpb25zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGNhbiBkZXRlY3QgYW5kIGRlY29kZSBEYXRhIE1hdHJpeCBjb2RlcyBpbiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxuICAgICAqL1xuICAgIGNsYXNzIERhdGFNYXRyaXhSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBEZWNvZGVyJDEoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTG9jYXRlcyBhbmQgZGVjb2RlcyBhIERhdGEgTWF0cml4IGNvZGUgaW4gYW4gaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gYSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb250ZW50IGVuY29kZWQgYnkgdGhlIERhdGEgTWF0cml4IGNvZGVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBhIERhdGEgTWF0cml4IGNvZGUgY2Fubm90IGJlIGZvdW5kXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgRGF0YSBNYXRyaXggY29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHNcbiAgICAgICAgICovXG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICAvLyBwdWJsaWMgUmVzdWx0IGRlY29kZShCaW5hcnlCaXRtYXAgaW1hZ2UpIHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiwgQ2hlY2tzdW1FeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiB7XG4gICAgICAgIC8vICAgcmV0dXJuIGRlY29kZShpbWFnZSwgbnVsbCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGRlY29kZShpbWFnZSwgaGludHMgPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgZGVjb2RlclJlc3VsdDtcbiAgICAgICAgICAgIGxldCBwb2ludHM7XG4gICAgICAgICAgICBpZiAoaGludHMgIT0gbnVsbCAmJiBoaW50cy5oYXMoRGVjb2RlSGludFR5cGUkMS5QVVJFX0JBUkNPREUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYml0cyA9IERhdGFNYXRyaXhSZWFkZXIuZXh0cmFjdFB1cmVCaXRzKGltYWdlLmdldEJsYWNrTWF0cml4KCkpO1xuICAgICAgICAgICAgICAgIGRlY29kZXJSZXN1bHQgPSB0aGlzLmRlY29kZXIuZGVjb2RlKGJpdHMpO1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IERhdGFNYXRyaXhSZWFkZXIuTk9fUE9JTlRTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGV0ZWN0b3JSZXN1bHQgPSBuZXcgRGV0ZWN0b3IkMShpbWFnZS5nZXRCbGFja01hdHJpeCgpKS5kZXRlY3QoKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVyUmVzdWx0ID0gdGhpcy5kZWNvZGVyLmRlY29kZShkZXRlY3RvclJlc3VsdC5nZXRCaXRzKCkpO1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IGRldGVjdG9yUmVzdWx0LmdldFBvaW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmF3Qnl0ZXMgPSBkZWNvZGVyUmVzdWx0LmdldFJhd0J5dGVzKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUmVzdWx0KGRlY29kZXJSZXN1bHQuZ2V0VGV4dCgpLCByYXdCeXRlcywgOCAqIHJhd0J5dGVzLmxlbmd0aCwgcG9pbnRzLCBCYXJjb2RlRm9ybWF0JDEuREFUQV9NQVRSSVgsIFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVTZWdtZW50cyA9IGRlY29kZXJSZXN1bHQuZ2V0Qnl0ZVNlZ21lbnRzKCk7XG4gICAgICAgICAgICBpZiAoYnl0ZVNlZ21lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlJDEuQllURV9TRUdNRU5UUywgYnl0ZVNlZ21lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVjTGV2ZWwgPSBkZWNvZGVyUmVzdWx0LmdldEVDTGV2ZWwoKTtcbiAgICAgICAgICAgIGlmIChlY0xldmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlJDEuRVJST1JfQ09SUkVDVElPTl9MRVZFTCwgZWNMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgZGV0ZWN0cyBhIGNvZGUgaW4gYSBcInB1cmVcIiBpbWFnZSAtLSB0aGF0IGlzLCBwdXJlIG1vbm9jaHJvbWUgaW1hZ2VcbiAgICAgICAgICogd2hpY2ggY29udGFpbnMgb25seSBhbiB1bnJvdGF0ZWQsIHVuc2tld2VkLCBpbWFnZSBvZiBhIGNvZGUsIHdpdGggc29tZSB3aGl0ZSBib3JkZXJcbiAgICAgICAgICogYXJvdW5kIGl0LiBUaGlzIGlzIGEgc3BlY2lhbGl6ZWQgbWV0aG9kIHRoYXQgd29ya3MgZXhjZXB0aW9uYWxseSBmYXN0IGluIHRoaXMgc3BlY2lhbFxuICAgICAgICAgKiBjYXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc2VlIGNvbS5nb29nbGUuenhpbmcucXJjb2RlLlFSQ29kZVJlYWRlciNleHRyYWN0UHVyZUJpdHMoQml0TWF0cml4KVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGV4dHJhY3RQdXJlQml0cyhpbWFnZSkge1xuICAgICAgICAgICAgY29uc3QgbGVmdFRvcEJsYWNrID0gaW1hZ2UuZ2V0VG9wTGVmdE9uQml0KCk7XG4gICAgICAgICAgICBjb25zdCByaWdodEJvdHRvbUJsYWNrID0gaW1hZ2UuZ2V0Qm90dG9tUmlnaHRPbkJpdCgpO1xuICAgICAgICAgICAgaWYgKGxlZnRUb3BCbGFjayA9PSBudWxsIHx8IHJpZ2h0Qm90dG9tQmxhY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kdWxlU2l6ZSA9IHRoaXMubW9kdWxlU2l6ZShsZWZ0VG9wQmxhY2ssIGltYWdlKTtcbiAgICAgICAgICAgIGxldCB0b3AgPSBsZWZ0VG9wQmxhY2tbMV07XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSByaWdodEJvdHRvbUJsYWNrWzFdO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSBsZWZ0VG9wQmxhY2tbMF07XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHJpZ2h0Qm90dG9tQmxhY2tbMF07XG4gICAgICAgICAgICBjb25zdCBtYXRyaXhXaWR0aCA9IChyaWdodCAtIGxlZnQgKyAxKSAvIG1vZHVsZVNpemU7XG4gICAgICAgICAgICBjb25zdCBtYXRyaXhIZWlnaHQgPSAoYm90dG9tIC0gdG9wICsgMSkgLyBtb2R1bGVTaXplO1xuICAgICAgICAgICAgaWYgKG1hdHJpeFdpZHRoIDw9IDAgfHwgbWF0cml4SGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFB1c2ggaW4gdGhlIFwiYm9yZGVyXCIgYnkgaGFsZiB0aGUgbW9kdWxlIHdpZHRoIHNvIHRoYXQgd2Ugc3RhcnRcbiAgICAgICAgICAgIC8vIHNhbXBsaW5nIGluIHRoZSBtaWRkbGUgb2YgdGhlIG1vZHVsZS4gSnVzdCBpbiBjYXNlIHRoZSBpbWFnZSBpcyBhXG4gICAgICAgICAgICAvLyBsaXR0bGUgb2ZmLCB0aGlzIHdpbGwgaGVscCByZWNvdmVyLlxuICAgICAgICAgICAgY29uc3QgbnVkZ2UgPSBtb2R1bGVTaXplIC8gMjtcbiAgICAgICAgICAgIHRvcCArPSBudWRnZTtcbiAgICAgICAgICAgIGxlZnQgKz0gbnVkZ2U7XG4gICAgICAgICAgICAvLyBOb3cganVzdCByZWFkIG9mZiB0aGUgYml0c1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IG5ldyBCaXRNYXRyaXgobWF0cml4V2lkdGgsIG1hdHJpeEhlaWdodCk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG1hdHJpeEhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaU9mZnNldCA9IHRvcCArIHkgKiBtb2R1bGVTaXplO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbWF0cml4V2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGxlZnQgKyB4ICogbW9kdWxlU2l6ZSwgaU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMuc2V0KHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG1vZHVsZVNpemUobGVmdFRvcEJsYWNrLCBpbWFnZSkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgbGV0IHggPSBsZWZ0VG9wQmxhY2tbMF07XG4gICAgICAgICAgICBjb25zdCB5ID0gbGVmdFRvcEJsYWNrWzFdO1xuICAgICAgICAgICAgd2hpbGUgKHggPCB3aWR0aCAmJiBpbWFnZS5nZXQoeCwgeSkpIHtcbiAgICAgICAgICAgICAgICB4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA9PT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNpemUgPSB4IC0gbGVmdFRvcEJsYWNrWzBdO1xuICAgICAgICAgICAgaWYgKG1vZHVsZVNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIERhdGFNYXRyaXhSZWFkZXIuTk9fUE9JTlRTID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBNb3ZpbmcgdG8gQHp4aW5nL2Jyb3dzZXJcbiAgICAgKlxuICAgICAqIFFSIENvZGUgcmVhZGVyIHRvIHVzZSBmcm9tIGJyb3dzZXIuXG4gICAgICovXG4gICAgY2xhc3MgQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyIGV4dGVuZHMgQnJvd3NlckNvZGVSZWFkZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCcm93c2VyUVJDb2RlUmVhZGVyLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVCZXR3ZWVuU2NhbnNNaWxsaXM9NTAwXSB0aGUgdGltZSBkZWxheSBiZXR3ZWVuIHN1YnNlcXVlbnQgZGVjb2RlIHRyaWVzXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcih0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwKSB7XG4gICAgICAgICAgICBzdXBlcihuZXcgRGF0YU1hdHJpeFJlYWRlcigpLCB0aW1lQmV0d2VlblNjYW5zTWlsbGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgdmFyIEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzO1xuICAgIChmdW5jdGlvbiAoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMpIHtcbiAgICAgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbXCJMXCJdID0gMF0gPSBcIkxcIjtcbiAgICAgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbXCJNXCJdID0gMV0gPSBcIk1cIjtcbiAgICAgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbXCJRXCJdID0gMl0gPSBcIlFcIjtcbiAgICAgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbXCJIXCJdID0gM10gPSBcIkhcIjtcbiAgICB9KShFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcyB8fCAoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIDxwPlNlZSBJU08gMTgwMDQ6MjAwNiwgNi41LjEuIFRoaXMgZW51bSBlbmNhcHN1bGF0ZXMgdGhlIGZvdXIgZXJyb3IgY29ycmVjdGlvbiBsZXZlbHNcbiAgICAgKiBkZWZpbmVkIGJ5IHRoZSBRUiBjb2RlIHN0YW5kYXJkLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRXJyb3JDb3JyZWN0aW9uTGV2ZWwge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc3RyaW5nVmFsdWUsIGJpdHMgLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdWYWx1ZSA9IHN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICAgICAgICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9CSVRTLnNldChiaXRzLCB0aGlzKTtcbiAgICAgICAgICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9WQUxVRS5zZXQodmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Qml0cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21TdHJpbmcocykge1xuICAgICAgICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTCc6IHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbC5MO1xuICAgICAgICAgICAgICAgIGNhc2UgJ00nOiByZXR1cm4gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuTTtcbiAgICAgICAgICAgICAgICBjYXNlICdRJzogcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsLlE7XG4gICAgICAgICAgICAgICAgY2FzZSAnSCc6IHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbC5IO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihzICsgJ25vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVxdWFscyhvKSB7XG4gICAgICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgRXJyb3JDb3JyZWN0aW9uTGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IG90aGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYml0cyBpbnQgY29udGFpbmluZyB0aGUgdHdvIGJpdHMgZW5jb2RpbmcgYSBRUiBDb2RlJ3MgZXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuICAgICAgICAgKiBAcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsIHJlcHJlc2VudGluZyB0aGUgZW5jb2RlZCBlcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZm9yQml0cyhiaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChiaXRzIDwgMCB8fCBiaXRzID49IEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9CSVRTLnNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuRk9SX0JJVFMuZ2V0KGJpdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9CSVRTID0gbmV3IE1hcCgpO1xuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9WQUxVRSA9IG5ldyBNYXAoKTtcbiAgICAvKiogTCA9IH43JSBjb3JyZWN0aW9uICovXG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuTCA9IG5ldyBFcnJvckNvcnJlY3Rpb25MZXZlbChFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcy5MLCAnTCcsIDB4MDEpO1xuICAgIC8qKiBNID0gfjE1JSBjb3JyZWN0aW9uICovXG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuTSA9IG5ldyBFcnJvckNvcnJlY3Rpb25MZXZlbChFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcy5NLCAnTScsIDB4MDApO1xuICAgIC8qKiBRID0gfjI1JSBjb3JyZWN0aW9uICovXG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuUSA9IG5ldyBFcnJvckNvcnJlY3Rpb25MZXZlbChFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcy5RLCAnUScsIDB4MDMpO1xuICAgIC8qKiBIID0gfjMwJSBjb3JyZWN0aW9uICovXG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuSCA9IG5ldyBFcnJvckNvcnJlY3Rpb25MZXZlbChFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcy5ILCAnSCcsIDB4MDIpO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgYSBRUiBDb2RlJ3MgZm9ybWF0IGluZm9ybWF0aW9uLCBpbmNsdWRpbmcgdGhlIGRhdGEgbWFzayB1c2VkIGFuZFxuICAgICAqIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAc2VlIERhdGFNYXNrXG4gICAgICogQHNlZSBFcnJvckNvcnJlY3Rpb25MZXZlbFxuICAgICAqL1xuICAgIGNsYXNzIEZvcm1hdEluZm9ybWF0aW9uIHtcbiAgICAgICAgY29uc3RydWN0b3IoZm9ybWF0SW5mbyAvKmludCovKSB7XG4gICAgICAgICAgICAvLyBCaXRzIDMsNFxuICAgICAgICAgICAgdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVycm9yQ29ycmVjdGlvbkxldmVsLmZvckJpdHMoKGZvcm1hdEluZm8gPj4gMykgJiAweDAzKTtcbiAgICAgICAgICAgIC8vIEJvdHRvbSAzIGJpdHNcbiAgICAgICAgICAgIHRoaXMuZGF0YU1hc2sgPSAvKihieXRlKSAqLyAoZm9ybWF0SW5mbyAmIDB4MDcpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBudW1CaXRzRGlmZmVyaW5nKGEgLyppbnQqLywgYiAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlci5iaXRDb3VudChhIF4gYik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBtYXNrZWRGb3JtYXRJbmZvMSBmb3JtYXQgaW5mbyBpbmRpY2F0b3IsIHdpdGggbWFzayBzdGlsbCBhcHBsaWVkXG4gICAgICAgICAqIEBwYXJhbSBtYXNrZWRGb3JtYXRJbmZvMiBzZWNvbmQgY29weSBvZiBzYW1lIGluZm87IGJvdGggYXJlIGNoZWNrZWQgYXQgdGhlIHNhbWUgdGltZVxuICAgICAgICAgKiAgdG8gZXN0YWJsaXNoIGJlc3QgbWF0Y2hcbiAgICAgICAgICogQHJldHVybiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZm9ybWF0IGl0IHNwZWNpZmllcywgb3Ige0Bjb2RlIG51bGx9XG4gICAgICAgICAqICBpZiBkb2Vzbid0IHNlZW0gdG8gbWF0Y2ggYW55IGtub3duIHBhdHRlcm5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVGb3JtYXRJbmZvcm1hdGlvbihtYXNrZWRGb3JtYXRJbmZvMSAvKmludCovLCBtYXNrZWRGb3JtYXRJbmZvMiAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXRJbmZvID0gRm9ybWF0SW5mb3JtYXRpb24uZG9EZWNvZGVGb3JtYXRJbmZvcm1hdGlvbihtYXNrZWRGb3JtYXRJbmZvMSwgbWFza2VkRm9ybWF0SW5mbzIpO1xuICAgICAgICAgICAgaWYgKGZvcm1hdEluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0SW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNob3VsZCByZXR1cm4gbnVsbCwgYnV0LCBzb21lIFFSIGNvZGVzIGFwcGFyZW50bHlcbiAgICAgICAgICAgIC8vIGRvIG5vdCBtYXNrIHRoaXMgaW5mby4gVHJ5IGFnYWluIGJ5IGFjdHVhbGx5IG1hc2tpbmcgdGhlIHBhdHRlcm5cbiAgICAgICAgICAgIC8vIGZpcnN0XG4gICAgICAgICAgICByZXR1cm4gRm9ybWF0SW5mb3JtYXRpb24uZG9EZWNvZGVGb3JtYXRJbmZvcm1hdGlvbihtYXNrZWRGb3JtYXRJbmZvMSBeIEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX01BU0tfUVIsIG1hc2tlZEZvcm1hdEluZm8yIF4gRm9ybWF0SW5mb3JtYXRpb24uRk9STUFUX0lORk9fTUFTS19RUik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRvRGVjb2RlRm9ybWF0SW5mb3JtYXRpb24obWFza2VkRm9ybWF0SW5mbzEgLyppbnQqLywgbWFza2VkRm9ybWF0SW5mbzIgLyppbnQqLykge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgaW50IGluIEZPUk1BVF9JTkZPX0RFQ09ERV9MT09LVVAgd2l0aCBmZXdlc3QgYml0cyBkaWZmZXJpbmdcbiAgICAgICAgICAgIGxldCBiZXN0RGlmZmVyZW5jZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgbGV0IGJlc3RGb3JtYXRJbmZvID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVjb2RlSW5mbyBvZiBGb3JtYXRJbmZvcm1hdGlvbi5GT1JNQVRfSU5GT19ERUNPREVfTE9PS1VQKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0SW5mbyA9IGRlY29kZUluZm9bMF07XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEluZm8gPT09IG1hc2tlZEZvcm1hdEluZm8xIHx8IHRhcmdldEluZm8gPT09IG1hc2tlZEZvcm1hdEluZm8yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIGFuIGV4YWN0IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0SW5mb3JtYXRpb24oZGVjb2RlSW5mb1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBiaXRzRGlmZmVyZW5jZSA9IEZvcm1hdEluZm9ybWF0aW9uLm51bUJpdHNEaWZmZXJpbmcobWFza2VkRm9ybWF0SW5mbzEsIHRhcmdldEluZm8pO1xuICAgICAgICAgICAgICAgIGlmIChiaXRzRGlmZmVyZW5jZSA8IGJlc3REaWZmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RGb3JtYXRJbmZvID0gZGVjb2RlSW5mb1sxXTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdERpZmZlcmVuY2UgPSBiaXRzRGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hc2tlZEZvcm1hdEluZm8xICE9PSBtYXNrZWRGb3JtYXRJbmZvMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIHRyeSB0aGUgb3RoZXIgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGJpdHNEaWZmZXJlbmNlID0gRm9ybWF0SW5mb3JtYXRpb24ubnVtQml0c0RpZmZlcmluZyhtYXNrZWRGb3JtYXRJbmZvMiwgdGFyZ2V0SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaXRzRGlmZmVyZW5jZSA8IGJlc3REaWZmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0Rm9ybWF0SW5mbyA9IGRlY29kZUluZm9bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0RGlmZmVyZW5jZSA9IGJpdHNEaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFtbWluZyBkaXN0YW5jZSBvZiB0aGUgMzIgbWFza2VkIGNvZGVzIGlzIDcsIGJ5IGNvbnN0cnVjdGlvbiwgc28gPD0gMyBiaXRzXG4gICAgICAgICAgICAvLyBkaWZmZXJpbmcgbWVhbnMgd2UgZm91bmQgYSBtYXRjaFxuICAgICAgICAgICAgaWYgKGJlc3REaWZmZXJlbmNlIDw9IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1hdEluZm9ybWF0aW9uKGJlc3RGb3JtYXRJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGdldEVycm9yQ29ycmVjdGlvbkxldmVsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGF0YU1hc2soKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhTWFzaztcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGhhc2hDb2RlKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsLmdldEJpdHMoKSA8PCAzKSB8IHRoaXMuZGF0YU1hc2s7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBlcXVhbHMobykge1xuICAgICAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIEZvcm1hdEluZm9ybWF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0gbztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsID09PSBvdGhlci5lcnJvckNvcnJlY3Rpb25MZXZlbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YU1hc2sgPT09IG90aGVyLmRhdGFNYXNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX01BU0tfUVIgPSAweDU0MTI7XG4gICAgLyoqXG4gICAgICogU2VlIElTTyAxODAwNDoyMDA2LCBBbm5leCBDLCBUYWJsZSBDLjFcbiAgICAgKi9cbiAgICBGb3JtYXRJbmZvcm1hdGlvbi5GT1JNQVRfSU5GT19ERUNPREVfTE9PS1VQID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NTQxMiwgMHgwMF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NTEyNSwgMHgwMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NUU3QywgMHgwMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NUI0QiwgMHgwM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NDVGOSwgMHgwNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NDBDRSwgMHgwNV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NEY5NywgMHgwNl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NEFBMCwgMHgwN10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NzdDNCwgMHgwOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NzJGMywgMHgwOV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4N0RBQSwgMHgwQV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4Nzg5RCwgMHgwQl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NjYyRiwgMHgwQ10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NjMxOCwgMHgwRF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NkM0MSwgMHgwRV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4Njk3NiwgMHgwRl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MTY4OSwgMHgxMF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MTNCRSwgMHgxMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MUNFNywgMHgxMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MTlEMCwgMHgxM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MDc2MiwgMHgxNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MDI1NSwgMHgxNV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MEQwQywgMHgxNl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MDgzQiwgMHgxN10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MzU1RiwgMHgxOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MzA2OCwgMHgxOV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4M0YzMSwgMHgxQV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4M0EwNiwgMHgxQl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MjRCNCwgMHgxQ10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MjE4MywgMHgxRF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MkVEQSwgMHgxRV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MkJFRCwgMHgxRl0pLFxuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgYSBzZXQgb2YgZXJyb3ItY29ycmVjdGlvbiBibG9ja3MgaW4gb25lIHN5bWJvbCB2ZXJzaW9uLiBNb3N0IHZlcnNpb25zIHdpbGxcbiAgICAgKiB1c2UgYmxvY2tzIG9mIGRpZmZlcmluZyBzaXplcyB3aXRoaW4gb25lIHZlcnNpb24sIHNvLCB0aGlzIGVuY2Fwc3VsYXRlcyB0aGUgcGFyYW1ldGVycyBmb3JcbiAgICAgKiBlYWNoIHNldCBvZiBibG9ja3MuIEl0IGFsc28gaG9sZHMgdGhlIG51bWJlciBvZiBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcyBwZXIgYmxvY2sgc2luY2UgaXRcbiAgICAgKiB3aWxsIGJlIHRoZSBzYW1lIGFjcm9zcyBhbGwgYmxvY2tzIHdpdGhpbiBvbmUgdmVyc2lvbi48L3A+XG4gICAgICovXG4gICAgY2xhc3MgRUNCbG9ja3MkMSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGVjQ29kZXdvcmRzUGVyQmxvY2sgLyppbnQqLywgLi4uZWNCbG9ja3MpIHtcbiAgICAgICAgICAgIHRoaXMuZWNDb2Rld29yZHNQZXJCbG9jayA9IGVjQ29kZXdvcmRzUGVyQmxvY2s7XG4gICAgICAgICAgICB0aGlzLmVjQmxvY2tzID0gZWNCbG9ja3M7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RUNDb2Rld29yZHNQZXJCbG9jaygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjQ29kZXdvcmRzUGVyQmxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TnVtQmxvY2tzKCkge1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGVjQmxvY2tzID0gdGhpcy5lY0Jsb2NrcztcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWNCbG9jayBvZiBlY0Jsb2Nrcykge1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGVjQmxvY2suZ2V0Q291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgICAgfVxuICAgICAgICBnZXRUb3RhbEVDQ29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWNDb2Rld29yZHNQZXJCbG9jayAqIHRoaXMuZ2V0TnVtQmxvY2tzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RUNCbG9ja3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lY0Jsb2NrcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyB0aGUgcGFyYW1ldGVycyBmb3Igb25lIGVycm9yLWNvcnJlY3Rpb24gYmxvY2sgaW4gb25lIHN5bWJvbCB2ZXJzaW9uLlxuICAgICAqIFRoaXMgaW5jbHVkZXMgdGhlIG51bWJlciBvZiBkYXRhIGNvZGV3b3JkcywgYW5kIHRoZSBudW1iZXIgb2YgdGltZXMgYSBibG9jayB3aXRoIHRoZXNlXG4gICAgICogcGFyYW1ldGVycyBpcyB1c2VkIGNvbnNlY3V0aXZlbHkgaW4gdGhlIFFSIGNvZGUgdmVyc2lvbidzIGZvcm1hdC48L3A+XG4gICAgICovXG4gICAgY2xhc3MgRUNCJDEge1xuICAgICAgICBjb25zdHJ1Y3Rvcihjb3VudCAvKmludCovLCBkYXRhQ29kZXdvcmRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNvZGV3b3JkcyA9IGRhdGFDb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcbiAgICAgICAgfVxuICAgICAgICBnZXREYXRhQ29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUNvZGV3b3JkcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogU2VlIElTTyAxODAwNDoyMDA2IEFubmV4IERcbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgVmVyc2lvbiQxIHtcbiAgICAgICAgY29uc3RydWN0b3IodmVyc2lvbk51bWJlciAvKmludCovLCBhbGlnbm1lbnRQYXR0ZXJuQ2VudGVycywgLi4uZWNCbG9ja3MpIHtcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbk51bWJlciA9IHZlcnNpb25OdW1iZXI7XG4gICAgICAgICAgICB0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzID0gYWxpZ25tZW50UGF0dGVybkNlbnRlcnM7XG4gICAgICAgICAgICB0aGlzLmVjQmxvY2tzID0gZWNCbG9ja3M7XG4gICAgICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICAgICAgY29uc3QgZWNDb2Rld29yZHMgPSBlY0Jsb2Nrc1swXS5nZXRFQ0NvZGV3b3Jkc1BlckJsb2NrKCk7XG4gICAgICAgICAgICBjb25zdCBlY2JBcnJheSA9IGVjQmxvY2tzWzBdLmdldEVDQmxvY2tzKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVjQmxvY2sgb2YgZWNiQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBlY0Jsb2NrLmdldENvdW50KCkgKiAoZWNCbG9jay5nZXREYXRhQ29kZXdvcmRzKCkgKyBlY0NvZGV3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRvdGFsQ29kZXdvcmRzID0gdG90YWw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmVyc2lvbk51bWJlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcnNpb25OdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QWxpZ25tZW50UGF0dGVybkNlbnRlcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVycztcbiAgICAgICAgfVxuICAgICAgICBnZXRUb3RhbENvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsQ29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIGdldERpbWVuc2lvbkZvclZlcnNpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gMTcgKyA0ICogdGhpcy52ZXJzaW9uTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGdldEVDQmxvY2tzRm9yTGV2ZWwoZWNMZXZlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWNCbG9ja3NbZWNMZXZlbC5nZXRWYWx1ZSgpXTtcbiAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBvcmlnaW5hbCB3YXMgdXNpbmcgb3JkaW5hbCwgYW5kIHVzaW5nIHRoZSBvcmRlciBvZiBsZXZlbHMgYXMgZGVmaW5lZCBpbiBFcnJvckNvcnJlY3Rpb25MZXZlbCBlbnVtIChMTVFIKVxuICAgICAgICAgICAgLy8gSSB3aWxsIHVzZSB0aGUgZGlyZWN0IHZhbHVlIGZyb20gRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMgZW51bSB3aGljaCBpbiB0eXBlc2NyaXB0IGdvZXMgdG8gYSBudW1iZXJcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RGVkdWNlcyB2ZXJzaW9uIGluZm9ybWF0aW9uIHB1cmVseSBmcm9tIFFSIENvZGUgZGltZW5zaW9ucy48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkaW1lbnNpb24gZGltZW5zaW9uIGluIG1vZHVsZXNcbiAgICAgICAgICogQHJldHVybiBWZXJzaW9uIGZvciBhIFFSIENvZGUgb2YgdGhhdCBkaW1lbnNpb25cbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgZGltZW5zaW9uIGlzIG5vdCAxIG1vZCA0XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0UHJvdmlzaW9uYWxWZXJzaW9uRm9yRGltZW5zaW9uKGRpbWVuc2lvbiAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uICUgNCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmVyc2lvbkZvck51bWJlcigoZGltZW5zaW9uIC0gMTcpIC8gNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCAvKjogSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldFZlcnNpb25Gb3JOdW1iZXIodmVyc2lvbk51bWJlciAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAodmVyc2lvbk51bWJlciA8IDEgfHwgdmVyc2lvbk51bWJlciA+IDQwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFZlcnNpb24kMS5WRVJTSU9OU1t2ZXJzaW9uTnVtYmVyIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlY29kZVZlcnNpb25JbmZvcm1hdGlvbih2ZXJzaW9uQml0cyAvKmludCovKSB7XG4gICAgICAgICAgICBsZXQgYmVzdERpZmZlcmVuY2UgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgIGxldCBiZXN0VmVyc2lvbiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFZlcnNpb24kMS5WRVJTSU9OX0RFQ09ERV9JTkZPLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VmVyc2lvbiA9IFZlcnNpb24kMS5WRVJTSU9OX0RFQ09ERV9JTkZPW2ldO1xuICAgICAgICAgICAgICAgIC8vIERvIHRoZSB2ZXJzaW9uIGluZm8gYml0cyBtYXRjaCBleGFjdGx5PyBkb25lLlxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRWZXJzaW9uID09PSB2ZXJzaW9uQml0cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmVyc2lvbiQxLmdldFZlcnNpb25Gb3JOdW1iZXIoaSArIDcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugc2VlIGlmIHRoaXMgaXMgdGhlIGNsb3Nlc3QgdG8gYSByZWFsIHZlcnNpb24gaW5mbyBiaXQgc3RyaW5nXG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBzZWVuIHNvIGZhclxuICAgICAgICAgICAgICAgIGNvbnN0IGJpdHNEaWZmZXJlbmNlID0gRm9ybWF0SW5mb3JtYXRpb24ubnVtQml0c0RpZmZlcmluZyh2ZXJzaW9uQml0cywgdGFyZ2V0VmVyc2lvbik7XG4gICAgICAgICAgICAgICAgaWYgKGJpdHNEaWZmZXJlbmNlIDwgYmVzdERpZmZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFZlcnNpb24gPSBpICsgNztcbiAgICAgICAgICAgICAgICAgICAgYmVzdERpZmZlcmVuY2UgPSBiaXRzRGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBjYW4gdG9sZXJhdGUgdXAgdG8gMyBiaXRzIG9mIGVycm9yIHNpbmNlIG5vIHR3byB2ZXJzaW9uIGluZm8gY29kZXdvcmRzIHdpbGxcbiAgICAgICAgICAgIC8vIGRpZmZlciBpbiBsZXNzIHRoYW4gOCBiaXRzLlxuICAgICAgICAgICAgaWYgKGJlc3REaWZmZXJlbmNlIDw9IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVyc2lvbiQxLmdldFZlcnNpb25Gb3JOdW1iZXIoYmVzdFZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYSBjbG9zZSBlbm91Z2ggbWF0Y2gsIGZhaWxcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYgQW5uZXggRVxuICAgICAgICAgKi9cbiAgICAgICAgYnVpbGRGdW5jdGlvblBhdHRlcm4oKSB7XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmdldERpbWVuc2lvbkZvclZlcnNpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGJpdE1hdHJpeCA9IG5ldyBCaXRNYXRyaXgoZGltZW5zaW9uKTtcbiAgICAgICAgICAgIC8vIFRvcCBsZWZ0IGZpbmRlciBwYXR0ZXJuICsgc2VwYXJhdG9yICsgZm9ybWF0XG4gICAgICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKDAsIDAsIDksIDkpO1xuICAgICAgICAgICAgLy8gVG9wIHJpZ2h0IGZpbmRlciBwYXR0ZXJuICsgc2VwYXJhdG9yICsgZm9ybWF0XG4gICAgICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKGRpbWVuc2lvbiAtIDgsIDAsIDgsIDkpO1xuICAgICAgICAgICAgLy8gQm90dG9tIGxlZnQgZmluZGVyIHBhdHRlcm4gKyBzZXBhcmF0b3IgKyBmb3JtYXRcbiAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oMCwgZGltZW5zaW9uIC0gOCwgOSwgOCk7XG4gICAgICAgICAgICAvLyBBbGlnbm1lbnQgcGF0dGVybnNcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHRoaXMuYWxpZ25tZW50UGF0dGVybkNlbnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBtYXg7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzW3hdIC0gMjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG1heDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoeCA9PT0gMCAmJiAoeSA9PT0gMCB8fCB5ID09PSBtYXggLSAxKSkgfHwgKHggPT09IG1heCAtIDEgJiYgeSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGFsaWdubWVudCBwYXR0ZXJucyBuZWFyIHRoZSB0aHJlZSBmaW5kZXIgcGF0dGVybnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24odGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVyc1t5XSAtIDIsIGksIDUsIDUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZlcnRpY2FsIHRpbWluZyBwYXR0ZXJuXG4gICAgICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKDYsIDksIDEsIGRpbWVuc2lvbiAtIDE3KTtcbiAgICAgICAgICAgIC8vIEhvcml6b250YWwgdGltaW5nIHBhdHRlcm5cbiAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oOSwgNiwgZGltZW5zaW9uIC0gMTcsIDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMudmVyc2lvbk51bWJlciA+IDYpIHtcbiAgICAgICAgICAgICAgICAvLyBWZXJzaW9uIGluZm8sIHRvcCByaWdodFxuICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oZGltZW5zaW9uIC0gMTEsIDAsIDMsIDYpO1xuICAgICAgICAgICAgICAgIC8vIFZlcnNpb24gaW5mbywgYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKDAsIGRpbWVuc2lvbiAtIDExLCA2LCAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaXRNYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIHRoaXMudmVyc2lvbk51bWJlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgICAqIFNlZSBJU08gMTgwMDQ6MjAwNiBBbm5leCBELlxuICAgICAgICogRWxlbWVudCBpIHJlcHJlc2VudHMgdGhlIHJhdyB2ZXJzaW9uIGJpdHMgdGhhdCBzcGVjaWZ5IHZlcnNpb24gaSArIDdcbiAgICAgICAqL1xuICAgIFZlcnNpb24kMS5WRVJTSU9OX0RFQ09ERV9JTkZPID0gSW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgMHgwN0M5NCwgMHgwODVCQywgMHgwOUE5OSwgMHgwQTREMywgMHgwQkJGNixcbiAgICAgICAgMHgwQzc2MiwgMHgwRDg0NywgMHgwRTYwRCwgMHgwRjkyOCwgMHgxMEI3OCxcbiAgICAgICAgMHgxMTQ1RCwgMHgxMkExNywgMHgxMzUzMiwgMHgxNDlBNiwgMHgxNTY4MyxcbiAgICAgICAgMHgxNjhDOSwgMHgxNzdFQywgMHgxOEVDNCwgMHgxOTFFMSwgMHgxQUZBQixcbiAgICAgICAgMHgxQjA4RSwgMHgxQ0MxQSwgMHgxRDMzRiwgMHgxRUQ3NSwgMHgxRjI1MCxcbiAgICAgICAgMHgyMDlENSwgMHgyMTZGMCwgMHgyMjhCQSwgMHgyMzc5RiwgMHgyNEIwQixcbiAgICAgICAgMHgyNTQyRSwgMHgyNkE2NCwgMHgyNzU0MSwgMHgyOEM2OVxuICAgIF0pO1xuICAgIC8qKlxuICAgICAgICogU2VlIElTTyAxODAwNDoyMDA2IDYuNS4xIFRhYmxlIDlcbiAgICAgICAqL1xuICAgIFZlcnNpb24kMS5WRVJTSU9OUyA9IFtcbiAgICAgICAgbmV3IFZlcnNpb24kMSgxLCBuZXcgSW50MzJBcnJheSgwKSwgbmV3IEVDQmxvY2tzJDEoNywgbmV3IEVDQiQxKDEsIDE5KSksIG5ldyBFQ0Jsb2NrcyQxKDEwLCBuZXcgRUNCJDEoMSwgMTYpKSwgbmV3IEVDQmxvY2tzJDEoMTMsIG5ldyBFQ0IkMSgxLCAxMykpLCBuZXcgRUNCbG9ja3MkMSgxNywgbmV3IEVDQiQxKDEsIDkpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMiwgSW50MzJBcnJheS5mcm9tKFs2LCAxOF0pLCBuZXcgRUNCbG9ja3MkMSgxMCwgbmV3IEVDQiQxKDEsIDM0KSksIG5ldyBFQ0Jsb2NrcyQxKDE2LCBuZXcgRUNCJDEoMSwgMjgpKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSgxLCAyMikpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDEsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDMsIEludDMyQXJyYXkuZnJvbShbNiwgMjJdKSwgbmV3IEVDQmxvY2tzJDEoMTUsIG5ldyBFQ0IkMSgxLCA1NSkpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDEsIDQ0KSksIG5ldyBFQ0Jsb2NrcyQxKDE4LCBuZXcgRUNCJDEoMiwgMTcpKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSgyLCAxMykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSg0LCBJbnQzMkFycmF5LmZyb20oWzYsIDI2XSksIG5ldyBFQ0Jsb2NrcyQxKDIwLCBuZXcgRUNCJDEoMSwgODApKSwgbmV3IEVDQmxvY2tzJDEoMTgsIG5ldyBFQ0IkMSgyLCAzMikpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDIsIDI0KSksIG5ldyBFQ0Jsb2NrcyQxKDE2LCBuZXcgRUNCJDEoNCwgOSkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSg1LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwXSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoMSwgMTA4KSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoMiwgNDMpKSwgbmV3IEVDQmxvY2tzJDEoMTgsIG5ldyBFQ0IkMSgyLCAxNSksIG5ldyBFQ0IkMSgyLCAxNikpLCBuZXcgRUNCbG9ja3MkMSgyMiwgbmV3IEVDQiQxKDIsIDExKSwgbmV3IEVDQiQxKDIsIDEyKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDYsIEludDMyQXJyYXkuZnJvbShbNiwgMzRdKSwgbmV3IEVDQmxvY2tzJDEoMTgsIG5ldyBFQ0IkMSgyLCA2OCkpLCBuZXcgRUNCbG9ja3MkMSgxNiwgbmV3IEVDQiQxKDQsIDI3KSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoNCwgMTkpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSg0LCAxNSkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSg3LCBJbnQzMkFycmF5LmZyb20oWzYsIDIyLCAzOF0pLCBuZXcgRUNCbG9ja3MkMSgyMCwgbmV3IEVDQiQxKDIsIDc4KSksIG5ldyBFQ0Jsb2NrcyQxKDE4LCBuZXcgRUNCJDEoNCwgMzEpKSwgbmV3IEVDQmxvY2tzJDEoMTgsIG5ldyBFQ0IkMSgyLCAxNCksIG5ldyBFQ0IkMSg0LCAxNSkpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDQsIDEzKSwgbmV3IEVDQiQxKDEsIDE0KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDgsIEludDMyQXJyYXkuZnJvbShbNiwgMjQsIDQyXSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoMiwgOTcpKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSgyLCAzOCksIG5ldyBFQ0IkMSgyLCAzOSkpLCBuZXcgRUNCbG9ja3MkMSgyMiwgbmV3IEVDQiQxKDQsIDE4KSwgbmV3IEVDQiQxKDIsIDE5KSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoNCwgMTQpLCBuZXcgRUNCJDEoMiwgMTUpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoOSwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNDZdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgyLCAxMTYpKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSgzLCAzNiksIG5ldyBFQ0IkMSgyLCAzNykpLCBuZXcgRUNCbG9ja3MkMSgyMCwgbmV3IEVDQiQxKDQsIDE2KSwgbmV3IEVDQiQxKDQsIDE3KSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoNCwgMTIpLCBuZXcgRUNCJDEoNCwgMTMpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTAsIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDUwXSksIG5ldyBFQ0Jsb2NrcyQxKDE4LCBuZXcgRUNCJDEoMiwgNjgpLCBuZXcgRUNCJDEoMiwgNjkpKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSg0LCA0MyksIG5ldyBFQ0IkMSgxLCA0NCkpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDYsIDE5KSwgbmV3IEVDQiQxKDIsIDIwKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoNiwgMTUpLCBuZXcgRUNCJDEoMiwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTEsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0XSksIG5ldyBFQ0Jsb2NrcyQxKDIwLCBuZXcgRUNCJDEoNCwgODEpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxLCA1MCksIG5ldyBFQ0IkMSg0LCA1MSkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDQsIDIyKSwgbmV3IEVDQiQxKDQsIDIzKSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoMywgMTIpLCBuZXcgRUNCJDEoOCwgMTMpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTIsIEludDMyQXJyYXkuZnJvbShbNiwgMzIsIDU4XSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoMiwgOTIpLCBuZXcgRUNCJDEoMiwgOTMpKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSg2LCAzNiksIG5ldyBFQ0IkMSgyLCAzNykpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDQsIDIwKSwgbmV3IEVDQiQxKDYsIDIxKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoNywgMTQpLCBuZXcgRUNCJDEoNCwgMTUpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTMsIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyXSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoNCwgMTA3KSksIG5ldyBFQ0Jsb2NrcyQxKDIyLCBuZXcgRUNCJDEoOCwgMzcpLCBuZXcgRUNCJDEoMSwgMzgpKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSg4LCAyMCksIG5ldyBFQ0IkMSg0LCAyMSkpLCBuZXcgRUNCbG9ja3MkMSgyMiwgbmV3IEVDQiQxKDEyLCAxMSksIG5ldyBFQ0IkMSg0LCAxMikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgxNCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNDYsIDY2XSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMywgMTE1KSwgbmV3IEVDQiQxKDEsIDExNikpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDQsIDQwKSwgbmV3IEVDQiQxKDUsIDQxKSksIG5ldyBFQ0Jsb2NrcyQxKDIwLCBuZXcgRUNCJDEoMTEsIDE2KSwgbmV3IEVDQiQxKDUsIDE3KSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoMTEsIDEyKSwgbmV3IEVDQiQxKDUsIDEzKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDE1LCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA0OCwgNzBdKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSg1LCA4NyksIG5ldyBFQ0IkMSgxLCA4OCkpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDUsIDQxKSwgbmV3IEVDQiQxKDUsIDQyKSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNSwgMjQpLCBuZXcgRUNCJDEoNywgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSgxMSwgMTIpLCBuZXcgRUNCJDEoNywgMTMpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTYsIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDUwLCA3NF0pLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDUsIDk4KSwgbmV3IEVDQiQxKDEsIDk5KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoNywgNDUpLCBuZXcgRUNCJDEoMywgNDYpKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSgxNSwgMTkpLCBuZXcgRUNCJDEoMiwgMjApKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgzLCAxNSksIG5ldyBFQ0IkMSgxMywgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTcsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OF0pLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDEsIDEwNyksIG5ldyBFQ0IkMSg1LCAxMDgpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxMCwgNDYpLCBuZXcgRUNCJDEoMSwgNDcpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxLCAyMiksIG5ldyBFQ0IkMSgxNSwgMjMpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgyLCAxNCksIG5ldyBFQ0IkMSgxNywgMTUpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTgsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU2LCA4Ml0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDUsIDEyMCksIG5ldyBFQ0IkMSgxLCAxMjEpKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSg5LCA0MyksIG5ldyBFQ0IkMSg0LCA0NCkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDE3LCAyMiksIG5ldyBFQ0IkMSgxLCAyMykpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDIsIDE0KSwgbmV3IEVDQiQxKDE5LCAxNSkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgxOSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2XSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMywgMTEzKSwgbmV3IEVDQiQxKDQsIDExNCkpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDMsIDQ0KSwgbmV3IEVDQiQxKDExLCA0NSkpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDE3LCAyMSksIG5ldyBFQ0IkMSg0LCAyMikpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDksIDEzKSwgbmV3IEVDQiQxKDE2LCAxNCkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgyMCwgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjIsIDkwXSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMywgMTA3KSwgbmV3IEVDQiQxKDUsIDEwOCkpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDMsIDQxKSwgbmV3IEVDQiQxKDEzLCA0MikpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDE1LCAyNCksIG5ldyBFQ0IkMSg1LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDE1LCAxNSksIG5ldyBFQ0IkMSgxMCwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjEsIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDUwLCA3MiwgOTRdKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSg0LCAxMTYpLCBuZXcgRUNCJDEoNCwgMTE3KSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoMTcsIDQyKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTcsIDIyKSwgbmV3IEVDQiQxKDYsIDIzKSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTksIDE2KSwgbmV3IEVDQiQxKDYsIDE3KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDIyLCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1MCwgNzQsIDk4XSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMiwgMTExKSwgbmV3IEVDQiQxKDcsIDExMikpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDE3LCA0NikpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDcsIDI0KSwgbmV3IEVDQiQxKDE2LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDM0LCAxMykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgyMywgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTQsIDc4LCAxMDJdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg0LCAxMjEpLCBuZXcgRUNCJDEoNSwgMTIyKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoNCwgNDcpLCBuZXcgRUNCJDEoMTQsIDQ4KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTEsIDI0KSwgbmV3IEVDQiQxKDE0LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDE2LCAxNSksIG5ldyBFQ0IkMSgxNCwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjQsIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDU0LCA4MCwgMTA2XSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNiwgMTE3KSwgbmV3IEVDQiQxKDQsIDExOCkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDYsIDQ1KSwgbmV3IEVDQiQxKDE0LCA0NikpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDExLCAyNCksIG5ldyBFQ0IkMSgxNiwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgzMCwgMTYpLCBuZXcgRUNCJDEoMiwgMTcpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjUsIEludDMyQXJyYXkuZnJvbShbNiwgMzIsIDU4LCA4NCwgMTEwXSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoOCwgMTA2KSwgbmV3IEVDQiQxKDQsIDEwNykpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDgsIDQ3KSwgbmV3IEVDQiQxKDEzLCA0OCkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDcsIDI0KSwgbmV3IEVDQiQxKDIyLCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDIyLCAxNSksIG5ldyBFQ0IkMSgxMywgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjYsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0XSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTAsIDExNCksIG5ldyBFQ0IkMSgyLCAxMTUpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxOSwgNDYpLCBuZXcgRUNCJDEoNCwgNDcpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgyOCwgMjIpLCBuZXcgRUNCJDEoNiwgMjMpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgzMywgMTYpLCBuZXcgRUNCJDEoNCwgMTcpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjcsIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgMTE4XSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoOCwgMTIyKSwgbmV3IEVDQiQxKDQsIDEyMykpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDIyLCA0NSksIG5ldyBFQ0IkMSgzLCA0NikpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDgsIDIzKSwgbmV3IEVDQiQxKDI2LCAyNCkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDEyLCAxNSksIG5ldyBFQ0IkMSgyOCwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjgsIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDUwLCA3NCwgOTgsIDEyMl0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDMsIDExNyksIG5ldyBFQ0IkMSgxMCwgMTE4KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMywgNDUpLCBuZXcgRUNCJDEoMjMsIDQ2KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNCwgMjQpLCBuZXcgRUNCJDEoMzEsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTEsIDE1KSwgbmV3IEVDQiQxKDMxLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgyOSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNl0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDcsIDExNiksIG5ldyBFQ0IkMSg3LCAxMTcpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgyMSwgNDUpLCBuZXcgRUNCJDEoNywgNDYpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxLCAyMyksIG5ldyBFQ0IkMSgzNywgMjQpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxOSwgMTUpLCBuZXcgRUNCJDEoMjYsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDMwLCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1MiwgNzgsIDEwNCwgMTMwXSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNSwgMTE1KSwgbmV3IEVDQiQxKDEwLCAxMTYpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxOSwgNDcpLCBuZXcgRUNCJDEoMTAsIDQ4KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTUsIDI0KSwgbmV3IEVDQiQxKDI1LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDIzLCAxNSksIG5ldyBFQ0IkMSgyNSwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMzEsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU2LCA4MiwgMTA4LCAxMzRdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxMywgMTE1KSwgbmV3IEVDQiQxKDMsIDExNikpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDIsIDQ2KSwgbmV3IEVDQiQxKDI5LCA0NykpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDQyLCAyNCksIG5ldyBFQ0IkMSgxLCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDIzLCAxNSksIG5ldyBFQ0IkMSgyOCwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMzIsIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzhdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxNywgMTE1KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTAsIDQ2KSwgbmV3IEVDQiQxKDIzLCA0NykpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDEwLCAyNCksIG5ldyBFQ0IkMSgzNSwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxOSwgMTUpLCBuZXcgRUNCJDEoMzUsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDMzLCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1OCwgODYsIDExNCwgMTQyXSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTcsIDExNSksIG5ldyBFQ0IkMSgxLCAxMTYpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxNCwgNDYpLCBuZXcgRUNCJDEoMjEsIDQ3KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMjksIDI0KSwgbmV3IEVDQiQxKDE5LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDExLCAxNSksIG5ldyBFQ0IkMSg0NiwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMzQsIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgMTE4LCAxNDZdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxMywgMTE1KSwgbmV3IEVDQiQxKDYsIDExNikpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDE0LCA0NiksIG5ldyBFQ0IkMSgyMywgNDcpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg0NCwgMjQpLCBuZXcgRUNCJDEoNywgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg1OSwgMTYpLCBuZXcgRUNCJDEoMSwgMTcpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMzUsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MF0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDEyLCAxMjEpLCBuZXcgRUNCJDEoNywgMTIyKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTIsIDQ3KSwgbmV3IEVDQiQxKDI2LCA0OCkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDM5LCAyNCksIG5ldyBFQ0IkMSgxNCwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgyMiwgMTUpLCBuZXcgRUNCJDEoNDEsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDM2LCBJbnQzMkFycmF5LmZyb20oWzYsIDI0LCA1MCwgNzYsIDEwMiwgMTI4LCAxNTRdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg2LCAxMjEpLCBuZXcgRUNCJDEoMTQsIDEyMikpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDYsIDQ3KSwgbmV3IEVDQiQxKDM0LCA0OCkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDQ2LCAyNCksIG5ldyBFQ0IkMSgxMCwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgyLCAxNSksIG5ldyBFQ0IkMSg2NCwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMzcsIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDU0LCA4MCwgMTA2LCAxMzIsIDE1OF0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDE3LCAxMjIpLCBuZXcgRUNCJDEoNCwgMTIzKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMjksIDQ2KSwgbmV3IEVDQiQxKDE0LCA0NykpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDQ5LCAyNCksIG5ldyBFQ0IkMSgxMCwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgyNCwgMTUpLCBuZXcgRUNCJDEoNDYsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDM4LCBJbnQzMkFycmF5LmZyb20oWzYsIDMyLCA1OCwgODQsIDExMCwgMTM2LCAxNjJdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg0LCAxMjIpLCBuZXcgRUNCJDEoMTgsIDEyMykpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDEzLCA0NiksIG5ldyBFQ0IkMSgzMiwgNDcpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg0OCwgMjQpLCBuZXcgRUNCJDEoMTQsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNDIsIDE1KSwgbmV3IEVDQiQxKDMyLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgzOSwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTQsIDgyLCAxMTAsIDEzOCwgMTY2XSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMjAsIDExNyksIG5ldyBFQ0IkMSg0LCAxMTgpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSg0MCwgNDcpLCBuZXcgRUNCJDEoNywgNDgpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg0MywgMjQpLCBuZXcgRUNCJDEoMjIsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTAsIDE1KSwgbmV3IEVDQiQxKDY3LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSg0MCwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTksIDExOCksIG5ldyBFQ0IkMSg2LCAxMTkpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxOCwgNDcpLCBuZXcgRUNCJDEoMzEsIDQ4KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMzQsIDI0KSwgbmV3IEVDQiQxKDM0LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDIwLCAxNSksIG5ldyBFQ0IkMSg2MSwgMTYpKSlcbiAgICBdO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICB2YXIgRGF0YU1hc2tWYWx1ZXM7XG4gICAgKGZ1bmN0aW9uIChEYXRhTWFza1ZhbHVlcykge1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18wMDBcIl0gPSAwXSA9IFwiREFUQV9NQVNLXzAwMFwiO1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18wMDFcIl0gPSAxXSA9IFwiREFUQV9NQVNLXzAwMVwiO1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18wMTBcIl0gPSAyXSA9IFwiREFUQV9NQVNLXzAxMFwiO1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18wMTFcIl0gPSAzXSA9IFwiREFUQV9NQVNLXzAxMVwiO1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18xMDBcIl0gPSA0XSA9IFwiREFUQV9NQVNLXzEwMFwiO1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18xMDFcIl0gPSA1XSA9IFwiREFUQV9NQVNLXzEwMVwiO1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18xMTBcIl0gPSA2XSA9IFwiREFUQV9NQVNLXzExMFwiO1xuICAgICAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18xMTFcIl0gPSA3XSA9IFwiREFUQV9NQVNLXzExMVwiO1xuICAgIH0pKERhdGFNYXNrVmFsdWVzIHx8IChEYXRhTWFza1ZhbHVlcyA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGRhdGEgbWFza3MgZm9yIHRoZSBkYXRhIGJpdHMgaW4gYSBRUiBjb2RlLCBwZXIgSVNPIDE4MDA0OjIwMDYgNi44LiBJbXBsZW1lbnRhdGlvbnNcbiAgICAgKiBvZiB0aGlzIGNsYXNzIGNhbiB1bi1tYXNrIGEgcmF3IEJpdE1hdHJpeC4gRm9yIHNpbXBsaWNpdHksIHRoZXkgd2lsbCB1bm1hc2sgdGhlIGVudGlyZSBCaXRNYXRyaXgsXG4gICAgICogaW5jbHVkaW5nIGFyZWFzIHVzZWQgZm9yIGZpbmRlciBwYXR0ZXJucywgdGltaW5nIHBhdHRlcm5zLCBldGMuIFRoZXNlIGFyZWFzIHNob3VsZCBiZSB1bnVzZWRcbiAgICAgKiBhZnRlciB0aGUgcG9pbnQgdGhleSBhcmUgdW5tYXNrZWQgYW55d2F5LjwvcD5cbiAgICAgKlxuICAgICAqIDxwPk5vdGUgdGhhdCB0aGUgZGlhZ3JhbSBpbiBzZWN0aW9uIDYuOC4xIGlzIG1pc2xlYWRpbmcgc2luY2UgaXQgaW5kaWNhdGVzIHRoYXQgaSBpcyBjb2x1bW4gcG9zaXRpb25cbiAgICAgKiBhbmQgaiBpcyByb3cgcG9zaXRpb24uIEluIGZhY3QsIGFzIHRoZSB0ZXh0IHNheXMsIGkgaXMgcm93IHBvc2l0aW9uIGFuZCBqIGlzIGNvbHVtbiBwb3NpdGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIERhdGFNYXNrIHtcbiAgICAgICAgLy8gU2VlIElTTyAxODAwNDoyMDA2IDYuOC4xXG4gICAgICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBpc01hc2tlZCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5pc01hc2tlZCA9IGlzTWFza2VkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuZCBvZiBlbnVtIGNvbnN0YW50cy5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkltcGxlbWVudGF0aW9ucyBvZiB0aGlzIG1ldGhvZCByZXZlcnNlIHRoZSBkYXRhIG1hc2tpbmcgcHJvY2VzcyBhcHBsaWVkIHRvIGEgUVIgQ29kZSBhbmRcbiAgICAgICAgICogbWFrZSBpdHMgYml0cyByZWFkeSB0byByZWFkLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJpdHMgcmVwcmVzZW50YXRpb24gb2YgUVIgQ29kZSBiaXRzXG4gICAgICAgICAqIEBwYXJhbSBkaW1lbnNpb24gZGltZW5zaW9uIG9mIFFSIENvZGUsIHJlcHJlc2VudGVkIGJ5IGJpdHMsIGJlaW5nIHVubWFza2VkXG4gICAgICAgICAqL1xuICAgICAgICB1bm1hc2tCaXRNYXRyaXgoYml0cywgZGltZW5zaW9uIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltZW5zaW9uOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRpbWVuc2lvbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTWFza2VkKGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRzLmZsaXAoaiwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGF0YU1hc2sudmFsdWVzID0gbmV3IE1hcChbXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAwMDA6IG1hc2sgYml0cyBmb3Igd2hpY2ggKHggKyB5KSBtb2QgMiA9PSAwXG4gICAgICAgICAqL1xuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAwMCwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMDAsIChpIC8qaW50Ki8sIGogLyppbnQqLykgPT4geyByZXR1cm4gKChpICsgaikgJiAweDAxKSA9PT0gMDsgfSldLFxuICAgICAgICAvKipcbiAgICAgICAgICogMDAxOiBtYXNrIGJpdHMgZm9yIHdoaWNoIHggbW9kIDIgPT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMDEsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDAxLCAoaSAvKmludCovLCBqIC8qaW50Ki8pID0+IHsgcmV0dXJuIChpICYgMHgwMSkgPT09IDA7IH0pXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDAxMDogbWFzayBiaXRzIGZvciB3aGljaCB5IG1vZCAzID09IDBcbiAgICAgICAgICovXG4gICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDEwLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAxMCwgKGkgLyppbnQqLywgaiAvKmludCovKSA9PiB7IHJldHVybiBqICUgMyA9PT0gMDsgfSldLFxuICAgICAgICAvKipcbiAgICAgICAgICogMDExOiBtYXNrIGJpdHMgZm9yIHdoaWNoICh4ICsgeSkgbW9kIDMgPT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMTEsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDExLCAoaSAvKmludCovLCBqIC8qaW50Ki8pID0+IHsgcmV0dXJuIChpICsgaikgJSAzID09PSAwOyB9KV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAxMDA6IG1hc2sgYml0cyBmb3Igd2hpY2ggKHgvMiArIHkvMykgbW9kIDIgPT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMDAsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTAwLCAoaSAvKmludCovLCBqIC8qaW50Ki8pID0+IHsgcmV0dXJuICgoTWF0aC5mbG9vcihpIC8gMikgKyBNYXRoLmZsb29yKGogLyAzKSkgJiAweDAxKSA9PT0gMDsgfSldLFxuICAgICAgICAvKipcbiAgICAgICAgICogMTAxOiBtYXNrIGJpdHMgZm9yIHdoaWNoIHh5IG1vZCAyICsgeHkgbW9kIDMgPT0gMFxuICAgICAgICAgKiBlcXVpdmFsZW50bHksIHN1Y2ggdGhhdCB4eSBtb2QgNiA9PSAwXG4gICAgICAgICAqL1xuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzEwMSwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMDEsIChpIC8qaW50Ki8sIGogLyppbnQqLykgPT4geyByZXR1cm4gKGkgKiBqKSAlIDYgPT09IDA7IH0pXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDExMDogbWFzayBiaXRzIGZvciB3aGljaCAoeHkgbW9kIDIgKyB4eSBtb2QgMykgbW9kIDIgPT0gMFxuICAgICAgICAgKiBlcXVpdmFsZW50bHksIHN1Y2ggdGhhdCB4eSBtb2QgNiA8IDNcbiAgICAgICAgICovXG4gICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTEwLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzExMCwgKGkgLyppbnQqLywgaiAvKmludCovKSA9PiB7IHJldHVybiAoKGkgKiBqKSAlIDYpIDwgMzsgfSldLFxuICAgICAgICAvKipcbiAgICAgICAgICogMTExOiBtYXNrIGJpdHMgZm9yIHdoaWNoICgoeCt5KW1vZCAyICsgeHkgbW9kIDMpIG1vZCAyID09IDBcbiAgICAgICAgICogZXF1aXZhbGVudGx5LCBzdWNoIHRoYXQgKHggKyB5ICsgeHkgbW9kIDMpIG1vZCAyID09IDBcbiAgICAgICAgICovXG4gICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTExLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzExMSwgKGkgLyppbnQqLywgaiAvKmludCovKSA9PiB7IHJldHVybiAoKGkgKyBqICsgKChpICogaikgJSAzKSkgJiAweDAxKSA9PT0gMDsgfSldLFxuICAgIF0pO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEJpdE1hdHJpeFBhcnNlciQxIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBiaXRNYXRyaXgge0BsaW5rIEJpdE1hdHJpeH0gdG8gcGFyc2VcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgZGltZW5zaW9uIGlzIG5vdCA+PSAyMSBhbmQgMSBtb2QgNFxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoYml0TWF0cml4KSB7XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb24gPSBiaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uIDwgMjEgfHwgKGRpbWVuc2lvbiAmIDB4MDMpICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iaXRNYXRyaXggPSBiaXRNYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlJlYWRzIGZvcm1hdCBpbmZvcm1hdGlvbiBmcm9tIG9uZSBvZiBpdHMgdHdvIGxvY2F0aW9ucyB3aXRoaW4gdGhlIFFSIENvZGUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBGb3JtYXRJbmZvcm1hdGlvbn0gZW5jYXBzdWxhdGluZyB0aGUgUVIgQ29kZSdzIGZvcm1hdCBpbmZvXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGJvdGggZm9ybWF0IGluZm9ybWF0aW9uIGxvY2F0aW9ucyBjYW5ub3QgYmUgcGFyc2VkIGFzXG4gICAgICAgICAqIHRoZSB2YWxpZCBlbmNvZGluZyBvZiBmb3JtYXQgaW5mb3JtYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHJlYWRGb3JtYXRJbmZvcm1hdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlZEZvcm1hdEluZm8gIT09IG51bGwgJiYgdGhpcy5wYXJzZWRGb3JtYXRJbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRGb3JtYXRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVhZCB0b3AtbGVmdCBmb3JtYXQgaW5mbyBiaXRzXG4gICAgICAgICAgICBsZXQgZm9ybWF0SW5mb0JpdHMxID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0SW5mb0JpdHMxID0gdGhpcy5jb3B5Qml0KGksIDgsIGZvcm1hdEluZm9CaXRzMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAuLiBhbmQgc2tpcCBhIGJpdCBpbiB0aGUgdGltaW5nIHBhdHRlcm4gLi4uXG4gICAgICAgICAgICBmb3JtYXRJbmZvQml0czEgPSB0aGlzLmNvcHlCaXQoNywgOCwgZm9ybWF0SW5mb0JpdHMxKTtcbiAgICAgICAgICAgIGZvcm1hdEluZm9CaXRzMSA9IHRoaXMuY29weUJpdCg4LCA4LCBmb3JtYXRJbmZvQml0czEpO1xuICAgICAgICAgICAgZm9ybWF0SW5mb0JpdHMxID0gdGhpcy5jb3B5Qml0KDgsIDcsIGZvcm1hdEluZm9CaXRzMSk7XG4gICAgICAgICAgICAvLyAuLiBhbmQgc2tpcCBhIGJpdCBpbiB0aGUgdGltaW5nIHBhdHRlcm4gLi4uXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRJbmZvQml0czEgPSB0aGlzLmNvcHlCaXQoOCwgaiwgZm9ybWF0SW5mb0JpdHMxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlYWQgdGhlIHRvcC1yaWdodC9ib3R0b20tbGVmdCBwYXR0ZXJuIHRvb1xuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5iaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBsZXQgZm9ybWF0SW5mb0JpdHMyID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGpNaW4gPSBkaW1lbnNpb24gLSA3O1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGRpbWVuc2lvbiAtIDE7IGogPj0gak1pbjsgai0tKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0SW5mb0JpdHMyID0gdGhpcy5jb3B5Qml0KDgsIGosIGZvcm1hdEluZm9CaXRzMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZGltZW5zaW9uIC0gODsgaSA8IGRpbWVuc2lvbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0SW5mb0JpdHMyID0gdGhpcy5jb3B5Qml0KGksIDgsIGZvcm1hdEluZm9CaXRzMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcnNlZEZvcm1hdEluZm8gPSBGb3JtYXRJbmZvcm1hdGlvbi5kZWNvZGVGb3JtYXRJbmZvcm1hdGlvbihmb3JtYXRJbmZvQml0czEsIGZvcm1hdEluZm9CaXRzMik7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZWRGb3JtYXRJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkRm9ybWF0SW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UmVhZHMgdmVyc2lvbiBpbmZvcm1hdGlvbiBmcm9tIG9uZSBvZiBpdHMgdHdvIGxvY2F0aW9ucyB3aXRoaW4gdGhlIFFSIENvZGUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBWZXJzaW9ufSBlbmNhcHN1bGF0aW5nIHRoZSBRUiBDb2RlJ3MgdmVyc2lvblxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBib3RoIHZlcnNpb24gaW5mb3JtYXRpb24gbG9jYXRpb25zIGNhbm5vdCBiZSBwYXJzZWQgYXNcbiAgICAgICAgICogdGhlIHZhbGlkIGVuY29kaW5nIG9mIHZlcnNpb24gaW5mb3JtYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHJlYWRWZXJzaW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VkVmVyc2lvbiAhPT0gbnVsbCAmJiB0aGlzLnBhcnNlZFZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlZFZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmJpdE1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3Zpc2lvbmFsVmVyc2lvbiA9IE1hdGguZmxvb3IoKGRpbWVuc2lvbiAtIDE3KSAvIDQpO1xuICAgICAgICAgICAgaWYgKHByb3Zpc2lvbmFsVmVyc2lvbiA8PSA2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlcnNpb24kMS5nZXRWZXJzaW9uRm9yTnVtYmVyKHByb3Zpc2lvbmFsVmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZWFkIHRvcC1yaWdodCB2ZXJzaW9uIGluZm86IDMgd2lkZSBieSA2IHRhbGxcbiAgICAgICAgICAgIGxldCB2ZXJzaW9uQml0cyA9IDA7XG4gICAgICAgICAgICBjb25zdCBpak1pbiA9IGRpbWVuc2lvbiAtIDExO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDU7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGRpbWVuc2lvbiAtIDk7IGkgPj0gaWpNaW47IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uQml0cyA9IHRoaXMuY29weUJpdChpLCBqLCB2ZXJzaW9uQml0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRoZVBhcnNlZFZlcnNpb24gPSBWZXJzaW9uJDEuZGVjb2RlVmVyc2lvbkluZm9ybWF0aW9uKHZlcnNpb25CaXRzKTtcbiAgICAgICAgICAgIGlmICh0aGVQYXJzZWRWZXJzaW9uICE9PSBudWxsICYmIHRoZVBhcnNlZFZlcnNpb24uZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpID09PSBkaW1lbnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlZFZlcnNpb24gPSB0aGVQYXJzZWRWZXJzaW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGVQYXJzZWRWZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSG1tLCBmYWlsZWQuIFRyeSBib3R0b20gbGVmdDogNiB3aWRlIGJ5IDMgdGFsbFxuICAgICAgICAgICAgdmVyc2lvbkJpdHMgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDU7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGRpbWVuc2lvbiAtIDk7IGogPj0gaWpNaW47IGotLSkge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uQml0cyA9IHRoaXMuY29weUJpdChpLCBqLCB2ZXJzaW9uQml0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhlUGFyc2VkVmVyc2lvbiA9IFZlcnNpb24kMS5kZWNvZGVWZXJzaW9uSW5mb3JtYXRpb24odmVyc2lvbkJpdHMpO1xuICAgICAgICAgICAgaWYgKHRoZVBhcnNlZFZlcnNpb24gIT09IG51bGwgJiYgdGhlUGFyc2VkVmVyc2lvbi5nZXREaW1lbnNpb25Gb3JWZXJzaW9uKCkgPT09IGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VkVmVyc2lvbiA9IHRoZVBhcnNlZFZlcnNpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoZVBhcnNlZFZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29weUJpdChpIC8qaW50Ki8sIGogLyppbnQqLywgdmVyc2lvbkJpdHMgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgYml0ID0gdGhpcy5pc01pcnJvciA/IHRoaXMuYml0TWF0cml4LmdldChqLCBpKSA6IHRoaXMuYml0TWF0cml4LmdldChpLCBqKTtcbiAgICAgICAgICAgIHJldHVybiBiaXQgPyAodmVyc2lvbkJpdHMgPDwgMSkgfCAweDEgOiB2ZXJzaW9uQml0cyA8PCAxO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5SZWFkcyB0aGUgYml0cyBpbiB0aGUge0BsaW5rIEJpdE1hdHJpeH0gcmVwcmVzZW50aW5nIHRoZSBmaW5kZXIgcGF0dGVybiBpbiB0aGVcbiAgICAgICAgICogY29ycmVjdCBvcmRlciBpbiBvcmRlciB0byByZWNvbnN0cnVjdCB0aGUgY29kZXdvcmRzIGJ5dGVzIGNvbnRhaW5lZCB3aXRoaW4gdGhlXG4gICAgICAgICAqIFFSIENvZGUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIGJ5dGVzIGVuY29kZWQgd2l0aGluIHRoZSBRUiBDb2RlXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIHRoZSBleGFjdCBudW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgaXMgbm90IHJlYWRcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXRJbmZvID0gdGhpcy5yZWFkRm9ybWF0SW5mb3JtYXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLnJlYWRWZXJzaW9uKCk7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGRhdGEgbWFzayBmb3IgdGhlIGZvcm1hdCB1c2VkIGluIHRoaXMgUVIgQ29kZS4gVGhpcyB3aWxsIGV4Y2x1ZGVcbiAgICAgICAgICAgIC8vIHNvbWUgYml0cyBmcm9tIHJlYWRpbmcgYXMgd2Ugd2luZCB0aHJvdWdoIHRoZSBiaXQgbWF0cml4LlxuICAgICAgICAgICAgY29uc3QgZGF0YU1hc2sgPSBEYXRhTWFzay52YWx1ZXMuZ2V0KGZvcm1hdEluZm8uZ2V0RGF0YU1hc2soKSk7XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmJpdE1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGRhdGFNYXNrLnVubWFza0JpdE1hdHJpeCh0aGlzLmJpdE1hdHJpeCwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUGF0dGVybiA9IHZlcnNpb24uYnVpbGRGdW5jdGlvblBhdHRlcm4oKTtcbiAgICAgICAgICAgIGxldCByZWFkaW5nVXAgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpKTtcbiAgICAgICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRCeXRlID0gMDtcbiAgICAgICAgICAgIGxldCBiaXRzUmVhZCA9IDA7XG4gICAgICAgICAgICAvLyBSZWFkIGNvbHVtbnMgaW4gcGFpcnMsIGZyb20gcmlnaHQgdG8gbGVmdFxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGRpbWVuc2lvbiAtIDE7IGogPiAwOyBqIC09IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHdob2xlIGNvbHVtbiB3aXRoIHZlcnRpY2FsIGFsaWdubWVudCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNhdmVzIHRpbWUgYW5kIG1ha2VzIHRoZSBvdGhlciBjb2RlIHByb2NlZWQgbW9yZSBjbGVhbmx5XG4gICAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVhZCBhbHRlcm5hdGluZ2x5IGZyb20gYm90dG9tIHRvIHRvcCB0aGVuIHRvcCB0byBib3R0b21cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb3VudCA9IDA7IGNvdW50IDwgZGltZW5zaW9uOyBjb3VudCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSByZWFkaW5nVXAgPyBkaW1lbnNpb24gLSAxIC0gY291bnQgOiBjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgMjsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBiaXRzIGNvdmVyZWQgYnkgdGhlIGZ1bmN0aW9uIHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZnVuY3Rpb25QYXR0ZXJuLmdldChqIC0gY29sLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgYSBiaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzUmVhZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJpdE1hdHJpeC5nZXQoaiAtIGNvbCwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgbWFkZSBhIHdob2xlIGJ5dGUsIHNhdmUgaXQgb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHNSZWFkID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSAvKihieXRlKSAqLyBjdXJyZW50Qnl0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0c1JlYWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlYWRpbmdVcCA9ICFyZWFkaW5nVXA7IC8vIHJlYWRpbmdVcCBePSB0cnVlOyAvLyByZWFkaW5nVXAgPSAhcmVhZGluZ1VwOyAvLyBzd2l0Y2ggZGlyZWN0aW9uc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdE9mZnNldCAhPT0gdmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV2ZXJ0IHRoZSBtYXNrIHJlbW92YWwgZG9uZSB3aGlsZSByZWFkaW5nIHRoZSBjb2RlIHdvcmRzLiBUaGUgYml0IG1hdHJpeCBzaG91bGQgcmV2ZXJ0IHRvIGl0cyBvcmlnaW5hbCBzdGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHJlbWFzaygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlZEZvcm1hdEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFdlIGhhdmUgbm8gZm9ybWF0IGluZm9ybWF0aW9uLCBhbmQgaGF2ZSBubyBkYXRhIG1hc2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGFNYXNrID0gRGF0YU1hc2sudmFsdWVzW3RoaXMucGFyc2VkRm9ybWF0SW5mby5nZXREYXRhTWFzaygpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuYml0TWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgZGF0YU1hc2sudW5tYXNrQml0TWF0cml4KHRoaXMuYml0TWF0cml4LCBkaW1lbnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmVwYXJlIHRoZSBwYXJzZXIgZm9yIGEgbWlycm9yZWQgb3BlcmF0aW9uLlxuICAgICAgICAgKiBUaGlzIGZsYWcgaGFzIGVmZmVjdCBvbmx5IG9uIHRoZSB7QGxpbmsgI3JlYWRGb3JtYXRJbmZvcm1hdGlvbigpfSBhbmQgdGhlXG4gICAgICAgICAqIHtAbGluayAjcmVhZFZlcnNpb24oKX0uIEJlZm9yZSBwcm9jZWVkaW5nIHdpdGgge0BsaW5rICNyZWFkQ29kZXdvcmRzKCl9IHRoZVxuICAgICAgICAgKiB7QGxpbmsgI21pcnJvcigpfSBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1pcnJvciBXaGV0aGVyIHRvIHJlYWQgdmVyc2lvbiBhbmQgZm9ybWF0IGluZm9ybWF0aW9uIG1pcnJvcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TWlycm9yKGlzTWlycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFZlcnNpb24gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRGb3JtYXRJbmZvID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaXNNaXJyb3IgPSBpc01pcnJvcjtcbiAgICAgICAgfVxuICAgICAgICAvKiogTWlycm9yIHRoZSBiaXQgbWF0cml4IGluIG9yZGVyIHRvIGF0dGVtcHQgYSBzZWNvbmQgcmVhZGluZy4gKi9cbiAgICAgICAgbWlycm9yKCkge1xuICAgICAgICAgICAgY29uc3QgYml0TWF0cml4ID0gdGhpcy5iaXRNYXRyaXg7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMCwgd2lkdGggPSBiaXRNYXRyaXguZ2V0V2lkdGgoKTsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0geCArIDEsIGhlaWdodCA9IGJpdE1hdHJpeC5nZXRIZWlnaHQoKTsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaXRNYXRyaXguZ2V0KHgsIHkpICE9PSBiaXRNYXRyaXguZ2V0KHksIHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRNYXRyaXguZmxpcCh5LCB4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5mbGlwKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgYSBibG9jayBvZiBkYXRhIHdpdGhpbiBhIFFSIENvZGUuIFFSIENvZGVzIG1heSBzcGxpdCB0aGVpciBkYXRhIGludG9cbiAgICAgKiBtdWx0aXBsZSBibG9ja3MsIGVhY2ggb2Ygd2hpY2ggaXMgYSB1bml0IG9mIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzLiBFYWNoXG4gICAgICogaXMgcmVwcmVzZW50ZWQgYnkgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIERhdGFCbG9jayQxIHtcbiAgICAgICAgY29uc3RydWN0b3IobnVtRGF0YUNvZGV3b3JkcyAvKmludCovLCBjb2Rld29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMubnVtRGF0YUNvZGV3b3JkcyA9IG51bURhdGFDb2Rld29yZHM7XG4gICAgICAgICAgICB0aGlzLmNvZGV3b3JkcyA9IGNvZGV3b3JkcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+V2hlbiBRUiBDb2RlcyB1c2UgbXVsdGlwbGUgZGF0YSBibG9ja3MsIHRoZXkgYXJlIGFjdHVhbGx5IGludGVybGVhdmVkLlxuICAgICAgICAgKiBUaGF0IGlzLCB0aGUgZmlyc3QgYnl0ZSBvZiBkYXRhIGJsb2NrIDEgdG8gbiBpcyB3cml0dGVuLCB0aGVuIHRoZSBzZWNvbmQgYnl0ZXMsIGFuZCBzbyBvbi4gVGhpc1xuICAgICAgICAgKiBtZXRob2Qgd2lsbCBzZXBhcmF0ZSB0aGUgZGF0YSBpbnRvIG9yaWdpbmFsIGJsb2Nrcy48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByYXdDb2Rld29yZHMgYnl0ZXMgYXMgcmVhZCBkaXJlY3RseSBmcm9tIHRoZSBRUiBDb2RlXG4gICAgICAgICAqIEBwYXJhbSB2ZXJzaW9uIHZlcnNpb24gb2YgdGhlIFFSIENvZGVcbiAgICAgICAgICogQHBhcmFtIGVjTGV2ZWwgZXJyb3ItY29ycmVjdGlvbiBsZXZlbCBvZiB0aGUgUVIgQ29kZVxuICAgICAgICAgKiBAcmV0dXJuIERhdGFCbG9ja3MgY29udGFpbmluZyBvcmlnaW5hbCBieXRlcywgXCJkZS1pbnRlcmxlYXZlZFwiIGZyb20gcmVwcmVzZW50YXRpb24gaW4gdGhlXG4gICAgICAgICAqICAgICAgICAgUVIgQ29kZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldERhdGFCbG9ja3MocmF3Q29kZXdvcmRzLCB2ZXJzaW9uLCBlY0xldmVsKSB7XG4gICAgICAgICAgICBpZiAocmF3Q29kZXdvcmRzLmxlbmd0aCAhPT0gdmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgbnVtYmVyIGFuZCBzaXplIG9mIGRhdGEgYmxvY2tzIHVzZWQgYnkgdGhpcyB2ZXJzaW9uIGFuZFxuICAgICAgICAgICAgLy8gZXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuICAgICAgICAgICAgY29uc3QgZWNCbG9ja3MgPSB2ZXJzaW9uLmdldEVDQmxvY2tzRm9yTGV2ZWwoZWNMZXZlbCk7XG4gICAgICAgICAgICAvLyBGaXJzdCBjb3VudCB0aGUgdG90YWwgbnVtYmVyIG9mIGRhdGEgYmxvY2tzXG4gICAgICAgICAgICBsZXQgdG90YWxCbG9ja3MgPSAwO1xuICAgICAgICAgICAgY29uc3QgZWNCbG9ja0FycmF5ID0gZWNCbG9ja3MuZ2V0RUNCbG9ja3MoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWNCbG9jayBvZiBlY0Jsb2NrQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0b3RhbEJsb2NrcyArPSBlY0Jsb2NrLmdldENvdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgZXN0YWJsaXNoIERhdGFCbG9ja3Mgb2YgdGhlIGFwcHJvcHJpYXRlIHNpemUgYW5kIG51bWJlciBvZiBkYXRhIGNvZGV3b3Jkc1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KHRvdGFsQmxvY2tzKTtcbiAgICAgICAgICAgIGxldCBudW1SZXN1bHRCbG9ja3MgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlY0Jsb2NrIG9mIGVjQmxvY2tBcnJheSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWNCbG9jay5nZXRDb3VudCgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtRGF0YUNvZGV3b3JkcyA9IGVjQmxvY2suZ2V0RGF0YUNvZGV3b3JkcygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1CbG9ja0NvZGV3b3JkcyA9IGVjQmxvY2tzLmdldEVDQ29kZXdvcmRzUGVyQmxvY2soKSArIG51bURhdGFDb2Rld29yZHM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtudW1SZXN1bHRCbG9ja3MrK10gPSBuZXcgRGF0YUJsb2NrJDEobnVtRGF0YUNvZGV3b3JkcywgbmV3IFVpbnQ4QXJyYXkobnVtQmxvY2tDb2Rld29yZHMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBbGwgYmxvY2tzIGhhdmUgdGhlIHNhbWUgYW1vdW50IG9mIGRhdGEsIGV4Y2VwdCB0aGF0IHRoZSBsYXN0IG5cbiAgICAgICAgICAgIC8vICh3aGVyZSBuIG1heSBiZSAwKSBoYXZlIDEgbW9yZSBieXRlLiBGaWd1cmUgb3V0IHdoZXJlIHRoZXNlIHN0YXJ0LlxuICAgICAgICAgICAgY29uc3Qgc2hvcnRlckJsb2Nrc1RvdGFsQ29kZXdvcmRzID0gcmVzdWx0WzBdLmNvZGV3b3Jkcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbG9uZ2VyQmxvY2tzU3RhcnRBdCA9IHJlc3VsdC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IGNoZWNrIGxlbmd0aCBpcyBjb3JyZWN0IGhlcmVcbiAgICAgICAgICAgIHdoaWxlIChsb25nZXJCbG9ja3NTdGFydEF0ID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1Db2Rld29yZHMgPSByZXN1bHRbbG9uZ2VyQmxvY2tzU3RhcnRBdF0uY29kZXdvcmRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobnVtQ29kZXdvcmRzID09PSBzaG9ydGVyQmxvY2tzVG90YWxDb2Rld29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvbmdlckJsb2Nrc1N0YXJ0QXQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvbmdlckJsb2Nrc1N0YXJ0QXQrKztcbiAgICAgICAgICAgIGNvbnN0IHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzID0gc2hvcnRlckJsb2Nrc1RvdGFsQ29kZXdvcmRzIC0gZWNCbG9ja3MuZ2V0RUNDb2Rld29yZHNQZXJCbG9jaygpO1xuICAgICAgICAgICAgLy8gVGhlIGxhc3QgZWxlbWVudHMgb2YgcmVzdWx0IG1heSBiZSAxIGVsZW1lbnQgbG9uZ2VyXG4gICAgICAgICAgICAvLyBmaXJzdCBmaWxsIG91dCBhcyBtYW55IGVsZW1lbnRzIGFzIGFsbCBvZiB0aGVtIGhhdmVcbiAgICAgICAgICAgIGxldCByYXdDb2Rld29yZHNPZmZzZXQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1SZXN1bHRCbG9ja3M7IGorKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbal0uY29kZXdvcmRzW2ldID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaWxsIG91dCB0aGUgbGFzdCBkYXRhIGJsb2NrIGluIHRoZSBsb25nZXIgb25lc1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGxvbmdlckJsb2Nrc1N0YXJ0QXQ7IGogPCBudW1SZXN1bHRCbG9ja3M7IGorKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtqXS5jb2Rld29yZHNbc2hvcnRlckJsb2Nrc051bURhdGFDb2Rld29yZHNdID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyBhZGQgaW4gZXJyb3IgY29ycmVjdGlvbiBibG9ja3NcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHJlc3VsdFswXS5jb2Rld29yZHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bVJlc3VsdEJsb2NrczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlPZmZzZXQgPSBqIDwgbG9uZ2VyQmxvY2tzU3RhcnRBdCA/IGkgOiBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2pdLmNvZGV3b3Jkc1tpT2Zmc2V0XSA9IHJhd0NvZGV3b3Jkc1tyYXdDb2Rld29yZHNPZmZzZXQrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBnZXROdW1EYXRhQ29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtRGF0YUNvZGV3b3JkcztcbiAgICAgICAgfVxuICAgICAgICBnZXRDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIHZhciBNb2RlVmFsdWVzO1xuICAgIChmdW5jdGlvbiAoTW9kZVZhbHVlcykge1xuICAgICAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJURVJNSU5BVE9SXCJdID0gMF0gPSBcIlRFUk1JTkFUT1JcIjtcbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiTlVNRVJJQ1wiXSA9IDFdID0gXCJOVU1FUklDXCI7XG4gICAgICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIkFMUEhBTlVNRVJJQ1wiXSA9IDJdID0gXCJBTFBIQU5VTUVSSUNcIjtcbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiU1RSVUNUVVJFRF9BUFBFTkRcIl0gPSAzXSA9IFwiU1RSVUNUVVJFRF9BUFBFTkRcIjtcbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiQllURVwiXSA9IDRdID0gXCJCWVRFXCI7XG4gICAgICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIkVDSVwiXSA9IDVdID0gXCJFQ0lcIjtcbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiS0FOSklcIl0gPSA2XSA9IFwiS0FOSklcIjtcbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiRk5DMV9GSVJTVF9QT1NJVElPTlwiXSA9IDddID0gXCJGTkMxX0ZJUlNUX1BPU0lUSU9OXCI7XG4gICAgICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIkZOQzFfU0VDT05EX1BPU0lUSU9OXCJdID0gOF0gPSBcIkZOQzFfU0VDT05EX1BPU0lUSU9OXCI7XG4gICAgICAgIC8qKiBTZWUgR0JUIDE4Mjg0LTIwMDA7IFwiSGFuemlcIiBpcyBhIHRyYW5zbGl0ZXJhdGlvbiBvZiB0aGlzIG1vZGUgbmFtZS4gKi9cbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiSEFOWklcIl0gPSA5XSA9IFwiSEFOWklcIjtcbiAgICB9KShNb2RlVmFsdWVzIHx8IChNb2RlVmFsdWVzID0ge30pKTtcbiAgICAvKipcbiAgICAgKiA8cD5TZWUgSVNPIDE4MDA0OjIwMDYsIDYuNC4xLCBUYWJsZXMgMiBhbmQgMy4gVGhpcyBlbnVtIGVuY2Fwc3VsYXRlcyB0aGUgdmFyaW91cyBtb2RlcyBpbiB3aGljaFxuICAgICAqIGRhdGEgY2FuIGJlIGVuY29kZWQgdG8gYml0cyBpbiB0aGUgUVIgY29kZSBzdGFuZGFyZC48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIE1vZGUkMSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBzdHJpbmdWYWx1ZSwgY2hhcmFjdGVyQ291bnRCaXRzRm9yVmVyc2lvbnMsIGJpdHMgLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdWYWx1ZSA9IHN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jaGFyYWN0ZXJDb3VudEJpdHNGb3JWZXJzaW9ucyA9IGNoYXJhY3RlckNvdW50Qml0c0ZvclZlcnNpb25zO1xuICAgICAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICAgICAgICAgIE1vZGUkMS5GT1JfQklUUy5zZXQoYml0cywgdGhpcyk7XG4gICAgICAgICAgICBNb2RlJDEuRk9SX1ZBTFVFLnNldCh2YWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBiaXRzIGZvdXIgYml0cyBlbmNvZGluZyBhIFFSIENvZGUgZGF0YSBtb2RlXG4gICAgICAgICAqIEByZXR1cm4gTW9kZSBlbmNvZGVkIGJ5IHRoZXNlIGJpdHNcbiAgICAgICAgICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgYml0cyBkbyBub3QgY29ycmVzcG9uZCB0byBhIGtub3duIG1vZGVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmb3JCaXRzKGJpdHMgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgbW9kZSA9IE1vZGUkMS5GT1JfQklUUy5nZXQoYml0cyk7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBtb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB2ZXJzaW9uIHZlcnNpb24gaW4gcXVlc3Rpb25cbiAgICAgICAgICogQHJldHVybiBudW1iZXIgb2YgYml0cyB1c2VkLCBpbiB0aGlzIFFSIENvZGUgc3ltYm9sIHtAbGluayBWZXJzaW9ufSwgdG8gZW5jb2RlIHRoZVxuICAgICAgICAgKiAgICAgICAgIGNvdW50IG9mIGNoYXJhY3RlcnMgdGhhdCB3aWxsIGZvbGxvdyBlbmNvZGVkIGluIHRoaXMgTW9kZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2hhcmFjdGVyQ291bnRCaXRzKHZlcnNpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb25OdW1iZXIgPSB2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAodmVyc2lvbk51bWJlciA8PSA5KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZlcnNpb25OdW1iZXIgPD0gMjYpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJhY3RlckNvdW50Qml0c0ZvclZlcnNpb25zW29mZnNldF07XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRCaXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYml0cztcbiAgICAgICAgfVxuICAgICAgICBlcXVhbHMobykge1xuICAgICAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIE1vZGUkMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvdGhlciA9IG87XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gb3RoZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBNb2RlJDEuRk9SX0JJVFMgPSBuZXcgTWFwKCk7XG4gICAgTW9kZSQxLkZPUl9WQUxVRSA9IG5ldyBNYXAoKTtcbiAgICBNb2RlJDEuVEVSTUlOQVRPUiA9IG5ldyBNb2RlJDEoTW9kZVZhbHVlcy5URVJNSU5BVE9SLCAnVEVSTUlOQVRPUicsIEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pLCAweDAwKTsgLy8gTm90IHJlYWxseSBhIG1vZGUuLi5cbiAgICBNb2RlJDEuTlVNRVJJQyA9IG5ldyBNb2RlJDEoTW9kZVZhbHVlcy5OVU1FUklDLCAnTlVNRVJJQycsIEludDMyQXJyYXkuZnJvbShbMTAsIDEyLCAxNF0pLCAweDAxKTtcbiAgICBNb2RlJDEuQUxQSEFOVU1FUklDID0gbmV3IE1vZGUkMShNb2RlVmFsdWVzLkFMUEhBTlVNRVJJQywgJ0FMUEhBTlVNRVJJQycsIEludDMyQXJyYXkuZnJvbShbOSwgMTEsIDEzXSksIDB4MDIpO1xuICAgIE1vZGUkMS5TVFJVQ1RVUkVEX0FQUEVORCA9IG5ldyBNb2RlJDEoTW9kZVZhbHVlcy5TVFJVQ1RVUkVEX0FQUEVORCwgJ1NUUlVDVFVSRURfQVBQRU5EJywgSW50MzJBcnJheS5mcm9tKFswLCAwLCAwXSksIDB4MDMpOyAvLyBOb3Qgc3VwcG9ydGVkXG4gICAgTW9kZSQxLkJZVEUgPSBuZXcgTW9kZSQxKE1vZGVWYWx1ZXMuQllURSwgJ0JZVEUnLCBJbnQzMkFycmF5LmZyb20oWzgsIDE2LCAxNl0pLCAweDA0KTtcbiAgICBNb2RlJDEuRUNJID0gbmV3IE1vZGUkMShNb2RlVmFsdWVzLkVDSSwgJ0VDSScsIEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pLCAweDA3KTsgLy8gY2hhcmFjdGVyIGNvdW50cyBkb24ndCBhcHBseVxuICAgIE1vZGUkMS5LQU5KSSA9IG5ldyBNb2RlJDEoTW9kZVZhbHVlcy5LQU5KSSwgJ0tBTkpJJywgSW50MzJBcnJheS5mcm9tKFs4LCAxMCwgMTJdKSwgMHgwOCk7XG4gICAgTW9kZSQxLkZOQzFfRklSU1RfUE9TSVRJT04gPSBuZXcgTW9kZSQxKE1vZGVWYWx1ZXMuRk5DMV9GSVJTVF9QT1NJVElPTiwgJ0ZOQzFfRklSU1RfUE9TSVRJT04nLCBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDBdKSwgMHgwNSk7XG4gICAgTW9kZSQxLkZOQzFfU0VDT05EX1BPU0lUSU9OID0gbmV3IE1vZGUkMShNb2RlVmFsdWVzLkZOQzFfU0VDT05EX1BPU0lUSU9OLCAnRk5DMV9TRUNPTkRfUE9TSVRJT04nLCBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDBdKSwgMHgwOSk7XG4gICAgLyoqIFNlZSBHQlQgMTgyODQtMjAwMDsgXCJIYW56aVwiIGlzIGEgdHJhbnNsaXRlcmF0aW9uIG9mIHRoaXMgbW9kZSBuYW1lLiAqL1xuICAgIE1vZGUkMS5IQU5aSSA9IG5ldyBNb2RlJDEoTW9kZVZhbHVlcy5IQU5aSSwgJ0hBTlpJJywgSW50MzJBcnJheS5mcm9tKFs4LCAxMCwgMTJdKSwgMHgwRCk7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qaW1wb3J0IGphdmEuaW8uVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbjsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbjsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5MaXN0OyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xuICAgIC8qKlxuICAgICAqIDxwPlFSIENvZGVzIGNhbiBlbmNvZGUgdGV4dCBhcyBiaXRzIGluIG9uZSBvZiBzZXZlcmFsIG1vZGVzLCBhbmQgY2FuIHVzZSBtdWx0aXBsZSBtb2Rlc1xuICAgICAqIGluIG9uZSBRUiBDb2RlLiBUaGlzIGNsYXNzIGRlY29kZXMgdGhlIGJpdHMgYmFjayBpbnRvIHRleHQuPC9wPlxuICAgICAqXG4gICAgICogPHA+U2VlIElTTyAxODAwNDoyMDA2LCA2LjQuMyAtIDYuNC43PC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEge1xuICAgICAgICBzdGF0aWMgZGVjb2RlKGJ5dGVzLCB2ZXJzaW9uLCBlY0xldmVsLCBoaW50cykge1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IG5ldyBCaXRTb3VyY2UoYnl0ZXMpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBieXRlU2VnbWVudHMgPSBuZXcgQXJyYXkoKTsgLy8gMVxuICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IEkgZG8gbm90IHVzZSBjb25zdHJ1Y3RvciB3aXRoIHNpemUgMSBhcyBpbiBvcmlnaW5hbCBKYXZhIG1lYW5zIGNhcGFjaXR5IGFuZCB0aGUgYXJyYXkgbGVuZ3RoIGlzIGNoZWNrZWQgYmVsb3dcbiAgICAgICAgICAgIGxldCBzeW1ib2xTZXF1ZW5jZSA9IC0xO1xuICAgICAgICAgICAgbGV0IHBhcml0eURhdGEgPSAtMTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRDaGFyYWN0ZXJTZXRFQ0kgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBmYzFJbkVmZmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBtb2RlO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hpbGUgc3RpbGwgYW5vdGhlciBzZWdtZW50IHRvIHJlYWQuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPSywgYXNzdW1lIHdlJ3JlIGRvbmUuIFJlYWxseSwgYSBURVJNSU5BVE9SIG1vZGUgc2hvdWxkIGhhdmUgYmVlbiByZWNvcmRlZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gTW9kZSQxLlRFUk1JTkFUT1I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RlQml0cyA9IGJpdHMucmVhZEJpdHMoNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gTW9kZSQxLmZvckJpdHMobW9kZUJpdHMpOyAvLyBtb2RlIGlzIGVuY29kZWQgYnkgNCBiaXRzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5URVJNSU5BVE9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuRk5DMV9GSVJTVF9QT1NJVElPTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLkZOQzFfU0VDT05EX1BPU0lUSU9OOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIGxpdHRsZSB3aXRoIEZOQzEgZXhjZXB0IGFsdGVyIHRoZSBwYXJzZWQgcmVzdWx0IGEgYml0IGFjY29yZGluZyB0byB0aGUgc3BlY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZjMUluRWZmZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLlNUUlVDVFVSRURfQVBQRU5EOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXF1ZW5jZSBudW1iZXIgYW5kIHBhcml0eSBpcyBhZGRlZCBsYXRlciB0byB0aGUgcmVzdWx0IG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCBuZXh0IDggYml0cyAoc3ltYm9sIHNlcXVlbmNlICMpIGFuZCA4IGJpdHMgKGRhdGE6IHBhcml0eSksIHRoZW4gY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xTZXF1ZW5jZSA9IGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyaXR5RGF0YSA9IGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5FQ0k6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bnQgZG9lc24ndCBhcHBseSB0byBFQ0lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5wYXJzZUVDSVZhbHVlKGJpdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyYWN0ZXJTZXRFQ0kgPSBDaGFyYWN0ZXJTZXRFQ0kuZ2V0Q2hhcmFjdGVyU2V0RUNJQnlWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXJTZXRFQ0kgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLkhBTlpJOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGhhbmRsZSBIYW56aSBtb2RlIHdoaWNoIGRvZXMgbm90IHN0YXJ0IHdpdGggY2hhcmFjdGVyIGNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hpbmVzZSBtb2RlIGNvbnRhaW5zIGEgc3ViIHNldCBpbmRpY2F0b3IgcmlnaHQgYWZ0ZXIgbW9kZSBpbmRpY2F0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJzZXQgPSBiaXRzLnJlYWRCaXRzKDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50SGFuemkgPSBiaXRzLnJlYWRCaXRzKG1vZGUuZ2V0Q2hhcmFjdGVyQ291bnRCaXRzKHZlcnNpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2V0ID09PSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuR0IyMzEyX1NVQlNFVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuZGVjb2RlSGFuemlTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnRIYW56aSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcIk5vcm1hbFwiIFFSIGNvZGUgbW9kZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG93IG1hbnkgY2hhcmFjdGVycyB3aWxsIGZvbGxvdywgZW5jb2RlZCBpbiB0aGlzIG1vZGU/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBiaXRzLnJlYWRCaXRzKG1vZGUuZ2V0Q2hhcmFjdGVyQ291bnRCaXRzKHZlcnNpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuTlVNRVJJQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5kZWNvZGVOdW1lcmljU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5BTFBIQU5VTUVSSUM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuZGVjb2RlQWxwaGFudW1lcmljU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50LCBmYzFJbkVmZmVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuQllURTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5kZWNvZGVCeXRlU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50LCBjdXJyZW50Q2hhcmFjdGVyU2V0RUNJLCBieXRlU2VnbWVudHMsIGhpbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5LQU5KSTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5kZWNvZGVLYW5qaVNlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChtb2RlICE9PSBNb2RlJDEuVEVSTUlOQVRPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWFlIC8qOiBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIC8vIGZyb20gcmVhZEJpdHMoKSBjYWxsc1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlclJlc3VsdChieXRlcywgcmVzdWx0LnRvU3RyaW5nKCksIGJ5dGVTZWdtZW50cy5sZW5ndGggPT09IDAgPyBudWxsIDogYnl0ZVNlZ21lbnRzLCBlY0xldmVsID09PSBudWxsID8gbnVsbCA6IGVjTGV2ZWwudG9TdHJpbmcoKSwgc3ltYm9sU2VxdWVuY2UsIHBhcml0eURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgc3BlY2lmaWNhdGlvbiBHQlQgMTgyODQtMjAwMFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZUhhbnppU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIC8vIERvbid0IGNyYXNoIHRyeWluZyB0byByZWFkIG1vcmUgYml0cyB0aGFuIHdlIGhhdmUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgaWYgKGNvdW50ICogMTMgPiBiaXRzLmF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRWFjaCBjaGFyYWN0ZXIgd2lsbCByZXF1aXJlIDIgYnl0ZXMuIFJlYWQgdGhlIGNoYXJhY3RlcnMgYXMgMi1ieXRlIHBhaXJzXG4gICAgICAgICAgICAvLyBhbmQgZGVjb2RlIGFzIEdCMjMxMiBhZnRlcndhcmRzXG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheSgyICogY291bnQpO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRWFjaCAxMyBiaXRzIGVuY29kZXMgYSAyLWJ5dGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgY29uc3QgdHdvQnl0ZXMgPSBiaXRzLnJlYWRCaXRzKDEzKTtcbiAgICAgICAgICAgICAgICBsZXQgYXNzZW1ibGVkVHdvQnl0ZXMgPSAoKCh0d29CeXRlcyAvIDB4MDYwKSA8PCA4KSAmIDB4RkZGRkZGRkYpIHwgKHR3b0J5dGVzICUgMHgwNjApO1xuICAgICAgICAgICAgICAgIGlmIChhc3NlbWJsZWRUd29CeXRlcyA8IDB4MDAzQkYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIDB4QTFBMSB0byAweEFBRkUgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgYXNzZW1ibGVkVHdvQnl0ZXMgKz0gMHgwQTFBMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHRoZSAweEIwQTEgdG8gMHhGQUZFIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIGFzc2VtYmxlZFR3b0J5dGVzICs9IDB4MEE2QTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gLyooYnl0ZSkgKi8gKChhc3NlbWJsZWRUd29CeXRlcyA+PiA4KSAmIDB4RkYpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAxXSA9IC8qKGJ5dGUpICovIChhc3NlbWJsZWRUd29CeXRlcyAmIDB4RkYpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nRW5jb2RpbmcuZGVjb2RlKGJ1ZmZlciwgU3RyaW5nVXRpbHMuR0IyMzEyKSk7XG4gICAgICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IFRPRE86IGltcGxlbWVudCBHQjIzMTIgZGVjb2RlLiBTdHJpbmdWaWV3IGZyb20gTUROIGNvdWxkIGJlIGEgc3RhcnRpbmcgcG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkIC8qOiBVbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKGlnbm9yZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWNvZGVLYW5qaVNlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCAvKmludCovKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBjcmFzaCB0cnlpbmcgdG8gcmVhZCBtb3JlIGJpdHMgdGhhbiB3ZSBoYXZlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIGlmIChjb3VudCAqIDEzID4gYml0cy5hdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVhY2ggY2hhcmFjdGVyIHdpbGwgcmVxdWlyZSAyIGJ5dGVzLiBSZWFkIHRoZSBjaGFyYWN0ZXJzIGFzIDItYnl0ZSBwYWlyc1xuICAgICAgICAgICAgLy8gYW5kIGRlY29kZSBhcyBTaGlmdF9KSVMgYWZ0ZXJ3YXJkc1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMiAqIGNvdW50KTtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIEVhY2ggMTMgYml0cyBlbmNvZGVzIGEgMi1ieXRlIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGNvbnN0IHR3b0J5dGVzID0gYml0cy5yZWFkQml0cygxMyk7XG4gICAgICAgICAgICAgICAgbGV0IGFzc2VtYmxlZFR3b0J5dGVzID0gKCgodHdvQnl0ZXMgLyAweDBDMCkgPDwgOCkgJiAweEZGRkZGRkZGKSB8ICh0d29CeXRlcyAlIDB4MEMwKTtcbiAgICAgICAgICAgICAgICBpZiAoYXNzZW1ibGVkVHdvQnl0ZXMgPCAweDAxRjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHRoZSAweDgxNDAgdG8gMHg5RkZDIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIGFzc2VtYmxlZFR3b0J5dGVzICs9IDB4MDgxNDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgMHhFMDQwIHRvIDB4RUJCRiByYW5nZVxuICAgICAgICAgICAgICAgICAgICBhc3NlbWJsZWRUd29CeXRlcyArPSAweDBDMTQwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IC8qKGJ5dGUpICovIChhc3NlbWJsZWRUd29CeXRlcyA+PiA4KTtcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSAvKihieXRlKSAqLyBhc3NlbWJsZWRUd29CeXRlcztcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2hpZnRfSklTIG1heSBub3QgYmUgc3VwcG9ydGVkIGluIHNvbWUgZW52aXJvbm1lbnRzOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZ0VuY29kaW5nLmRlY29kZShidWZmZXIsIFN0cmluZ1V0aWxzLlNISUZUX0pJUykpO1xuICAgICAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBUT0RPOiBpbXBsZW1lbnQgU0hJRlRfSklTIGRlY29kZS4gU3RyaW5nVmlldyBmcm9tIE1ETiBjb3VsZCBiZSBhIHN0YXJ0aW5nIHBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCAvKjogVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbihpZ25vcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGVjb2RlQnl0ZVNlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCAvKmludCovLCBjdXJyZW50Q2hhcmFjdGVyU2V0RUNJLCBieXRlU2VnbWVudHMsIGhpbnRzKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBjcmFzaCB0cnlpbmcgdG8gcmVhZCBtb3JlIGJpdHMgdGhhbiB3ZSBoYXZlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIGlmICg4ICogY291bnQgPiBiaXRzLmF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVhZEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVhZEJ5dGVzW2ldID0gLyooYnl0ZSkgKi8gYml0cy5yZWFkQml0cyg4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbmNvZGluZztcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhcmFjdGVyU2V0RUNJID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHNwZWMgaXNuJ3QgY2xlYXIgb24gdGhpcyBtb2RlOyBzZWVcbiAgICAgICAgICAgICAgICAvLyBzZWN0aW9uIDYuNC41OiB0IGRvZXMgbm90IHNheSB3aGljaCBlbmNvZGluZyB0byBhc3N1bWluZ1xuICAgICAgICAgICAgICAgIC8vIHVwb24gZGVjb2RpbmcuIEkgaGF2ZSBzZWVuIElTTy04ODU5LTEgdXNlZCBhcyB3ZWxsIGFzXG4gICAgICAgICAgICAgICAgLy8gU2hpZnRfSklTIC0tIHdpdGhvdXQgYW55dGhpbmcgbGlrZSBhbiBFQ0kgZGVzaWduYXRvciB0b1xuICAgICAgICAgICAgICAgIC8vIGdpdmUgYSBoaW50LlxuICAgICAgICAgICAgICAgIGVuY29kaW5nID0gU3RyaW5nVXRpbHMuZ3Vlc3NFbmNvZGluZyhyZWFkQnl0ZXMsIGhpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nID0gY3VycmVudENoYXJhY3RlclNldEVDSS5nZXROYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nRW5jb2RpbmcuZGVjb2RlKHJlYWRCeXRlcywgZW5jb2RpbmcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkIC8qOiBVbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKGlnbm9yZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnl0ZVNlZ21lbnRzLnB1c2gocmVhZEJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgdG9BbHBoYU51bWVyaWNDaGFyKHZhbHVlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuQUxQSEFOVU1FUklDX0NIQVJTLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuQUxQSEFOVU1FUklDX0NIQVJTW3ZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGVjb2RlQWxwaGFudW1lcmljU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50IC8qaW50Ki8sIGZjMUluRWZmZWN0KSB7XG4gICAgICAgICAgICAvLyBSZWFkIHR3byBjaGFyYWN0ZXJzIGF0IGEgdGltZVxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSByZXN1bHQubGVuZ3RoKCk7XG4gICAgICAgICAgICB3aGlsZSAoY291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCAxMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUd29DaGFyc0JpdHMgPSBiaXRzLnJlYWRCaXRzKDExKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS50b0FscGhhTnVtZXJpY0NoYXIoTWF0aC5mbG9vcihuZXh0VHdvQ2hhcnNCaXRzIC8gNDUpKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEudG9BbHBoYU51bWVyaWNDaGFyKG5leHRUd29DaGFyc0JpdHMgJSA0NSkpO1xuICAgICAgICAgICAgICAgIGNvdW50IC09IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IG9uZSBjaGFyYWN0ZXIgbGVmdFxuICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgNikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLnRvQWxwaGFOdW1lcmljQ2hhcihiaXRzLnJlYWRCaXRzKDYpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZWUgc2VjdGlvbiA2LjQuOC4xLCA2LjQuOC4yXG4gICAgICAgICAgICBpZiAoZmMxSW5FZmZlY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIG1hc3NhZ2UgdGhlIHJlc3VsdCBhIGJpdCBpZiBpbiBhbiBGTkMxIG1vZGU6XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgcmVzdWx0Lmxlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5jaGFyQXQoaSkgPT09ICclJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCByZXN1bHQubGVuZ3RoKCkgLSAxICYmIHJlc3VsdC5jaGFyQXQoaSArIDEpID09PSAnJScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAlJSBpcyByZW5kZXJlZCBhcyAlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRlbGV0ZUNoYXJBdChpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBhbHBoYSBtb2RlLCAlIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gRk5DMSBzZXBhcmF0b3IgMHgxRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRDaGFyQXQoaSwgU3RyaW5nLmZyb21DaGFyQ29kZSgweDFEKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlY29kZU51bWVyaWNTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQgLyppbnQqLykge1xuICAgICAgICAgICAgLy8gUmVhZCB0aHJlZSBkaWdpdHMgYXQgYSB0aW1lXG4gICAgICAgICAgICB3aGlsZSAoY291bnQgPj0gMykge1xuICAgICAgICAgICAgICAgIC8vIEVhY2ggMTAgYml0cyBlbmNvZGVzIHRocmVlIGRpZ2l0c1xuICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0aHJlZURpZ2l0c0JpdHMgPSBiaXRzLnJlYWRCaXRzKDEwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhyZWVEaWdpdHNCaXRzID49IDEwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS50b0FscGhhTnVtZXJpY0NoYXIoTWF0aC5mbG9vcih0aHJlZURpZ2l0c0JpdHMgLyAxMDApKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEudG9BbHBoYU51bWVyaWNDaGFyKE1hdGguZmxvb3IodGhyZWVEaWdpdHNCaXRzIC8gMTApICUgMTApKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS50b0FscGhhTnVtZXJpY0NoYXIodGhyZWVEaWdpdHNCaXRzICUgMTApKTtcbiAgICAgICAgICAgICAgICBjb3VudCAtPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gVHdvIGRpZ2l0cyBsZWZ0IG92ZXIgdG8gcmVhZCwgZW5jb2RlZCBpbiA3IGJpdHNcbiAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0d29EaWdpdHNCaXRzID0gYml0cy5yZWFkQml0cyg3KTtcbiAgICAgICAgICAgICAgICBpZiAodHdvRGlnaXRzQml0cyA+PSAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS50b0FscGhhTnVtZXJpY0NoYXIoTWF0aC5mbG9vcih0d29EaWdpdHNCaXRzIC8gMTApKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEudG9BbHBoYU51bWVyaWNDaGFyKHR3b0RpZ2l0c0JpdHMgJSAxMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmUgZGlnaXQgbGVmdCBvdmVyIHRvIHJlYWRcbiAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkaWdpdEJpdHMgPSBiaXRzLnJlYWRCaXRzKDQpO1xuICAgICAgICAgICAgICAgIGlmIChkaWdpdEJpdHMgPj0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS50b0FscGhhTnVtZXJpY0NoYXIoZGlnaXRCaXRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHBhcnNlRUNJVmFsdWUoYml0cykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gYml0cy5yZWFkQml0cyg4KTtcbiAgICAgICAgICAgIGlmICgoZmlyc3RCeXRlICYgMHg4MCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBqdXN0IG9uZSBieXRlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0Qnl0ZSAmIDB4N0Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGZpcnN0Qnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgLy8gdHdvIGJ5dGVzXG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vjb25kQnl0ZSA9IGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoKGZpcnN0Qnl0ZSAmIDB4M0YpIDw8IDgpICYgMHhGRkZGRkZGRikgfCBzZWNvbmRCeXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChmaXJzdEJ5dGUgJiAweEUwKSA9PT0gMHhDMCkge1xuICAgICAgICAgICAgICAgIC8vIHRocmVlIGJ5dGVzXG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vjb25kVGhpcmRCeXRlcyA9IGJpdHMucmVhZEJpdHMoMTYpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKChmaXJzdEJ5dGUgJiAweDFGKSA8PCAxNikgJiAweEZGRkZGRkZGKSB8IHNlY29uZFRoaXJkQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VlIElTTyAxODAwNDoyMDA2LCA2LjQuNCBUYWJsZSA1XG4gICAgICovXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLkFMUEhBTlVNRVJJQ19DSEFSUyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogJCUqKy0uLzonO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5HQjIzMTJfU1VCU0VUID0gMTtcbiAgICAvLyBmdW5jdGlvbiBVaW50OEFycmF5VG9TdHJpbmcoYTogVWludDhBcnJheSk6IHN0cmluZyB7XG4gICAgLy8gICAgIGNvbnN0IENIVU5LX1NaID0gMHg4MDAwO1xuICAgIC8vICAgICBjb25zdCBjID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAvLyAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGEubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IENIVU5LX1NaKSB7XG4gICAgLy8gICAgICAgICBjLmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGEuc3ViYXJyYXkoaSwgaSArIENIVU5LX1NaKSkpO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHJldHVybiBjLnRvU3RyaW5nKCk7XG4gICAgLy8gfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBNZXRhLWRhdGEgY29udGFpbmVyIGZvciBRUiBDb2RlIGRlY29kaW5nLiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBtYXkgYmUgdXNlZCB0byBjb252ZXkgaW5mb3JtYXRpb24gYmFjayB0byB0aGVcbiAgICAgKiBkZWNvZGluZyBjYWxsZXIuIENhbGxlcnMgYXJlIGV4cGVjdGVkIHRvIHByb2Nlc3MgdGhpcy5cbiAgICAgKlxuICAgICAqIEBzZWUgY29tLmdvb2dsZS56eGluZy5jb21tb24uRGVjb2RlclJlc3VsdCNnZXRPdGhlcigpXG4gICAgICovXG4gICAgY2xhc3MgUVJDb2RlRGVjb2Rlck1ldGFEYXRhIHtcbiAgICAgICAgY29uc3RydWN0b3IobWlycm9yZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWlycm9yZWQgPSBtaXJyb3JlZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIHRoZSBRUiBDb2RlIHdhcyBtaXJyb3JlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlzTWlycm9yZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taXJyb3JlZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgdGhlIHJlc3VsdCBwb2ludHMnIG9yZGVyIGNvcnJlY3Rpb24gZHVlIHRvIG1pcnJvcmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBvaW50cyBBcnJheSBvZiBwb2ludHMgdG8gYXBwbHkgbWlycm9yIGNvcnJlY3Rpb24gdG8uXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseU1pcnJvcmVkQ29ycmVjdGlvbihwb2ludHMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5taXJyb3JlZCB8fCBwb2ludHMgPT09IG51bGwgfHwgcG9pbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBib3R0b21MZWZ0ID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgcG9pbnRzWzBdID0gcG9pbnRzWzJdO1xuICAgICAgICAgICAgcG9pbnRzWzJdID0gYm90dG9tTGVmdDtcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gJ2ZpeCcgdG9wLWxlZnQgYW5kIGFsaWdubWVudCBwYXR0ZXJuLlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4gICAgLyoqXG4gICAgICogPHA+VGhlIG1haW4gY2xhc3Mgd2hpY2ggaW1wbGVtZW50cyBRUiBDb2RlIGRlY29kaW5nIC0tIGFzIG9wcG9zZWQgdG8gbG9jYXRpbmcgYW5kIGV4dHJhY3RpbmdcbiAgICAgKiB0aGUgUVIgQ29kZSBmcm9tIGFuIGltYWdlLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGVjb2RlciQyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLnJzRGVjb2RlciA9IG5ldyBSZWVkU29sb21vbkRlY29kZXIoR2VuZXJpY0dGLlFSX0NPREVfRklFTERfMjU2KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwdWJsaWMgZGVjb2RlKGltYWdlOiBib29sZWFuW11bXSk6IERlY29kZXJSZXN1bHQgLyp0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiovIHtcbiAgICAgICAgLy8gICByZXR1cm4gZGVjb2RlKGltYWdlLCBudWxsKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5Db252ZW5pZW5jZSBtZXRob2QgdGhhdCBjYW4gZGVjb2RlIGEgUVIgQ29kZSByZXByZXNlbnRlZCBhcyBhIDJEIGFycmF5IG9mIGJvb2xlYW5zLlxuICAgICAgICAgKiBcInRydWVcIiBpcyB0YWtlbiB0byBtZWFuIGEgYmxhY2sgbW9kdWxlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltYWdlIGJvb2xlYW5zIHJlcHJlc2VudGluZyB3aGl0ZS9ibGFjayBRUiBDb2RlIG1vZHVsZXNcbiAgICAgICAgICogQHBhcmFtIGhpbnRzIGRlY29kaW5nIGhpbnRzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gaW5mbHVlbmNlIGRlY29kaW5nXG4gICAgICAgICAqIEByZXR1cm4gdGV4dCBhbmQgYnl0ZXMgZW5jb2RlZCB3aXRoaW4gdGhlIFFSIENvZGVcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIFFSIENvZGUgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvciBjb3JyZWN0aW9uIGZhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVCb29sZWFuQXJyYXkoaW1hZ2UsIGhpbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVCaXRNYXRyaXgoQml0TWF0cml4LnBhcnNlRnJvbUJvb2xlYW5BcnJheShpbWFnZSksIGhpbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwdWJsaWMgZGVjb2RlQml0TWF0cml4KGJpdHM6IEJpdE1hdHJpeCk6IERlY29kZXJSZXN1bHQgLyp0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiovIHtcbiAgICAgICAgLy8gICByZXR1cm4gZGVjb2RlKGJpdHMsIG51bGwpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRlY29kZXMgYSBRUiBDb2RlIHJlcHJlc2VudGVkIGFzIGEge0BsaW5rIEJpdE1hdHJpeH0uIEEgMSBvciBcInRydWVcIiBpcyB0YWtlbiB0byBtZWFuIGEgYmxhY2sgbW9kdWxlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJpdHMgYm9vbGVhbnMgcmVwcmVzZW50aW5nIHdoaXRlL2JsYWNrIFFSIENvZGUgbW9kdWxlc1xuICAgICAgICAgKiBAcGFyYW0gaGludHMgZGVjb2RpbmcgaGludHMgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBpbmZsdWVuY2UgZGVjb2RpbmdcbiAgICAgICAgICogQHJldHVybiB0ZXh0IGFuZCBieXRlcyBlbmNvZGVkIHdpdGhpbiB0aGUgUVIgQ29kZVxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiB0aGUgUVIgQ29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHNcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUJpdE1hdHJpeChiaXRzLCBoaW50cykge1xuICAgICAgICAgICAgLy8gQ29uc3RydWN0IGEgcGFyc2VyIGFuZCByZWFkIHZlcnNpb24sIGVycm9yLWNvcnJlY3Rpb24gbGV2ZWxcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBCaXRNYXRyaXhQYXJzZXIkMShiaXRzKTtcbiAgICAgICAgICAgIGxldCBleCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUJpdE1hdHJpeFBhcnNlcihwYXJzZXIsIGhpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlIC8qOiBGb3JtYXRFeGNlcHRpb24sIENoZWNrc3VtRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICBleCA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgYml0IG1hdHJpeFxuICAgICAgICAgICAgICAgIHBhcnNlci5yZW1hc2soKTtcbiAgICAgICAgICAgICAgICAvLyBXaWxsIGJlIGF0dGVtcHRpbmcgYSBtaXJyb3JlZCByZWFkaW5nIG9mIHRoZSB2ZXJzaW9uIGFuZCBmb3JtYXQgaW5mby5cbiAgICAgICAgICAgICAgICBwYXJzZXIuc2V0TWlycm9yKHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIFByZWVtcHRpdmVseSByZWFkIHRoZSB2ZXJzaW9uLlxuICAgICAgICAgICAgICAgIHBhcnNlci5yZWFkVmVyc2lvbigpO1xuICAgICAgICAgICAgICAgIC8vIFByZWVtcHRpdmVseSByZWFkIHRoZSBmb3JtYXQgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICAgICAgcGFyc2VyLnJlYWRGb3JtYXRJbmZvcm1hdGlvbigpO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogU2luY2Ugd2UncmUgaGVyZSwgdGhpcyBtZWFucyB3ZSBoYXZlIHN1Y2Nlc3NmdWxseSBkZXRlY3RlZCBzb21lIGtpbmRcbiAgICAgICAgICAgICAgICAgKiBvZiB2ZXJzaW9uIGFuZCBmb3JtYXQgaW5mb3JtYXRpb24gd2hlbiBtaXJyb3JlZC4gVGhpcyBpcyBhIGdvb2Qgc2lnbixcbiAgICAgICAgICAgICAgICAgKiB0aGF0IHRoZSBRUiBjb2RlIG1heSBiZSBtaXJyb3JlZCwgYW5kIHdlIHNob3VsZCB0cnkgb25jZSBtb3JlIHdpdGggYVxuICAgICAgICAgICAgICAgICAqIG1pcnJvcmVkIGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLy8gUHJlcGFyZSBmb3IgYSBtaXJyb3JlZCByZWFkaW5nLlxuICAgICAgICAgICAgICAgIHBhcnNlci5taXJyb3IoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRlY29kZUJpdE1hdHJpeFBhcnNlcihwYXJzZXIsIGhpbnRzKTtcbiAgICAgICAgICAgICAgICAvLyBTdWNjZXNzISBOb3RpZnkgdGhlIGNhbGxlciB0aGF0IHRoZSBjb2RlIHdhcyBtaXJyb3JlZC5cbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0T3RoZXIobmV3IFFSQ29kZURlY29kZXJNZXRhRGF0YSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlIC8qRm9ybWF0RXhjZXB0aW9uIHwgQ2hlY2tzdW1FeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIC8vIFRocm93IHRoZSBleGNlcHRpb24gZnJvbSB0aGUgb3JpZ2luYWwgcmVhZGluZ1xuICAgICAgICAgICAgICAgIGlmIChleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVCaXRNYXRyaXhQYXJzZXIocGFyc2VyLCBoaW50cykge1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHBhcnNlci5yZWFkVmVyc2lvbigpO1xuICAgICAgICAgICAgY29uc3QgZWNMZXZlbCA9IHBhcnNlci5yZWFkRm9ybWF0SW5mb3JtYXRpb24oKS5nZXRFcnJvckNvcnJlY3Rpb25MZXZlbCgpO1xuICAgICAgICAgICAgLy8gUmVhZCBjb2Rld29yZHNcbiAgICAgICAgICAgIGNvbnN0IGNvZGV3b3JkcyA9IHBhcnNlci5yZWFkQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAvLyBTZXBhcmF0ZSBpbnRvIGRhdGEgYmxvY2tzXG4gICAgICAgICAgICBjb25zdCBkYXRhQmxvY2tzID0gRGF0YUJsb2NrJDEuZ2V0RGF0YUJsb2Nrcyhjb2Rld29yZHMsIHZlcnNpb24sIGVjTGV2ZWwpO1xuICAgICAgICAgICAgLy8gQ291bnQgdG90YWwgbnVtYmVyIG9mIGRhdGEgYnl0ZXNcbiAgICAgICAgICAgIGxldCB0b3RhbEJ5dGVzID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGF0YUJsb2NrIG9mIGRhdGFCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICB0b3RhbEJ5dGVzICs9IGRhdGFCbG9jay5nZXROdW1EYXRhQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsQnl0ZXMpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdE9mZnNldCA9IDA7XG4gICAgICAgICAgICAvLyBFcnJvci1jb3JyZWN0IGFuZCBjb3B5IGRhdGEgYmxvY2tzIHRvZ2V0aGVyIGludG8gYSBzdHJlYW0gb2YgYnl0ZXNcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGF0YUJsb2NrIG9mIGRhdGFCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2Rld29yZEJ5dGVzID0gZGF0YUJsb2NrLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bURhdGFDb2Rld29yZHMgPSBkYXRhQmxvY2suZ2V0TnVtRGF0YUNvZGV3b3JkcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ycmVjdEVycm9ycyhjb2Rld29yZEJ5dGVzLCBudW1EYXRhQ29kZXdvcmRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRCeXRlc1tyZXN1bHRPZmZzZXQrK10gPSBjb2Rld29yZEJ5dGVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlY29kZSB0aGUgY29udGVudHMgb2YgdGhhdCBzdHJlYW0gb2YgYnl0ZXNcbiAgICAgICAgICAgIHJldHVybiBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuZGVjb2RlKHJlc3VsdEJ5dGVzLCB2ZXJzaW9uLCBlY0xldmVsLCBoaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkdpdmVuIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzIHJlY2VpdmVkLCBwb3NzaWJseSBjb3JydXB0ZWQgYnkgZXJyb3JzLCBhdHRlbXB0cyB0b1xuICAgICAgICAgKiBjb3JyZWN0IHRoZSBlcnJvcnMgaW4tcGxhY2UgdXNpbmcgUmVlZC1Tb2xvbW9uIGVycm9yIGNvcnJlY3Rpb24uPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY29kZXdvcmRCeXRlcyBkYXRhIGFuZCBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgICAgICAgKiBAcGFyYW0gbnVtRGF0YUNvZGV3b3JkcyBudW1iZXIgb2YgY29kZXdvcmRzIHRoYXQgYXJlIGRhdGEgYnl0ZXNcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvciBjb3JyZWN0aW9uIGZhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBjb3JyZWN0RXJyb3JzKGNvZGV3b3JkQnl0ZXMsIG51bURhdGFDb2Rld29yZHMgLyppbnQqLykge1xuICAgICAgICAgICAgLy8gY29uc3QgbnVtQ29kZXdvcmRzID0gY29kZXdvcmRCeXRlcy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBGaXJzdCByZWFkIGludG8gYW4gYXJyYXkgb2YgaW50c1xuICAgICAgICAgICAgY29uc3QgY29kZXdvcmRzSW50cyA9IG5ldyBJbnQzMkFycmF5KGNvZGV3b3JkQnl0ZXMpO1xuICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IG5vdCByZWFseSBuZWNlc3NhcnkgdG8gdHJhbnNmb3JtIHRvIGludHM/IGNvdWxkIHJlZGVzaWduIGV2ZXJ5dGhpbmcgdG8gd29yayB3aXRoIHVuc2lnbmVkIGJ5dGVzP1xuICAgICAgICAgICAgLy8gY29uc3QgY29kZXdvcmRzSW50cyA9IG5ldyBJbnQzMkFycmF5KG51bUNvZGV3b3JkcylcbiAgICAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgIC8vICAgY29kZXdvcmRzSW50c1tpXSA9IGNvZGV3b3JkQnl0ZXNbaV0gJiAweEZGXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMucnNEZWNvZGVyLmRlY29kZShjb2Rld29yZHNJbnRzLCBjb2Rld29yZEJ5dGVzLmxlbmd0aCAtIG51bURhdGFDb2Rld29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyo6IFJlZWRTb2xvbW9uRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2hlY2tzdW1FeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvcHkgYmFjayBpbnRvIGFycmF5IG9mIGJ5dGVzIC0tIG9ubHkgbmVlZCB0byB3b3JyeSBhYm91dCB0aGUgYnl0ZXMgdGhhdCB3ZXJlIGRhdGFcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgZXJyb3JzIGluIHRoZSBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZEJ5dGVzW2ldID0gLyooYnl0ZSkgKi8gY29kZXdvcmRzSW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGFuIGFsaWdubWVudCBwYXR0ZXJuLCB3aGljaCBhcmUgdGhlIHNtYWxsZXIgc3F1YXJlIHBhdHRlcm5zIGZvdW5kIGluXG4gICAgICogYWxsIGJ1dCB0aGUgc2ltcGxlc3QgUVIgQ29kZXMuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBBbGlnbm1lbnRQYXR0ZXJuIGV4dGVuZHMgUmVzdWx0UG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3Rvcihwb3NYIC8qZmxvYXQqLywgcG9zWSAvKmZsb2F0Ki8sIGVzdGltYXRlZE1vZHVsZVNpemUgLypmbG9hdCovKSB7XG4gICAgICAgICAgICBzdXBlcihwb3NYLCBwb3NZKTtcbiAgICAgICAgICAgIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IGVzdGltYXRlZE1vZHVsZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRldGVybWluZXMgaWYgdGhpcyBhbGlnbm1lbnQgcGF0dGVybiBcImFib3V0IGVxdWFsc1wiIGFuIGFsaWdubWVudCBwYXR0ZXJuIGF0IHRoZSBzdGF0ZWRcbiAgICAgICAgICogcG9zaXRpb24gYW5kIHNpemUgLS0gbWVhbmluZywgaXQgaXMgYXQgbmVhcmx5IHRoZSBzYW1lIGNlbnRlciB3aXRoIG5lYXJseSB0aGUgc2FtZSBzaXplLjwvcD5cbiAgICAgICAgICovXG4gICAgICAgIGFib3V0RXF1YWxzKG1vZHVsZVNpemUgLypmbG9hdCovLCBpIC8qZmxvYXQqLywgaiAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhpIC0gdGhpcy5nZXRZKCkpIDw9IG1vZHVsZVNpemUgJiYgTWF0aC5hYnMoaiAtIHRoaXMuZ2V0WCgpKSA8PSBtb2R1bGVTaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlU2l6ZURpZmYgPSBNYXRoLmFicyhtb2R1bGVTaXplIC0gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlU2l6ZURpZmYgPD0gMS4wIHx8IG1vZHVsZVNpemVEaWZmIDw9IHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tYmluZXMgdGhpcyBvYmplY3QncyBjdXJyZW50IGVzdGltYXRlIG9mIGEgZmluZGVyIHBhdHRlcm4gcG9zaXRpb24gYW5kIG1vZHVsZSBzaXplXG4gICAgICAgICAqIHdpdGggYSBuZXcgZXN0aW1hdGUuIEl0IHJldHVybnMgYSBuZXcge0Bjb2RlIEZpbmRlclBhdHRlcm59IGNvbnRhaW5pbmcgYW4gYXZlcmFnZSBvZiB0aGUgdHdvLlxuICAgICAgICAgKi9cbiAgICAgICAgY29tYmluZUVzdGltYXRlKGkgLypmbG9hdCovLCBqIC8qZmxvYXQqLywgbmV3TW9kdWxlU2l6ZSAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkWCA9ICh0aGlzLmdldFgoKSArIGopIC8gMi4wO1xuICAgICAgICAgICAgY29uc3QgY29tYmluZWRZID0gKHRoaXMuZ2V0WSgpICsgaSkgLyAyLjA7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZE1vZHVsZVNpemUgPSAodGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplICsgbmV3TW9kdWxlU2l6ZSkgLyAyLjA7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsaWdubWVudFBhdHRlcm4oY29tYmluZWRYLCBjb21iaW5lZFksIGNvbWJpbmVkTW9kdWxlU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTGlzdDsqL1xuICAgIC8qKlxuICAgICAqIDxwPlRoaXMgY2xhc3MgYXR0ZW1wdHMgdG8gZmluZCBhbGlnbm1lbnQgcGF0dGVybnMgaW4gYSBRUiBDb2RlLiBBbGlnbm1lbnQgcGF0dGVybnMgbG9vayBsaWtlIGZpbmRlclxuICAgICAqIHBhdHRlcm5zIGJ1dCBhcmUgc21hbGxlciBhbmQgYXBwZWFyIGF0IHJlZ3VsYXIgaW50ZXJ2YWxzIHRocm91Z2hvdXQgdGhlIGltYWdlLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPkF0IHRoZSBtb21lbnQgdGhpcyBvbmx5IGxvb2tzIGZvciB0aGUgYm90dG9tLXJpZ2h0IGFsaWdubWVudCBwYXR0ZXJuLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRoaXMgaXMgbW9zdGx5IGEgc2ltcGxpZmllZCBjb3B5IG9mIHtAbGluayBGaW5kZXJQYXR0ZXJuRmluZGVyfS4gSXQgaXMgY29waWVkLFxuICAgICAqIHBhc3RlZCBhbmQgc3RyaXBwZWQgZG93biBoZXJlIGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlIGJ1dCBkb2VzIHVuZm9ydHVuYXRlbHkgZHVwbGljYXRlXG4gICAgICogc29tZSBjb2RlLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRoaXMgY2xhc3MgaXMgdGhyZWFkLXNhZmUgYnV0IG5vdCByZWVudHJhbnQuIEVhY2ggdGhyZWFkIG11c3QgYWxsb2NhdGUgaXRzIG93biBvYmplY3QuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkNyZWF0ZXMgYSBmaW5kZXIgdGhhdCB3aWxsIGxvb2sgaW4gYSBwb3J0aW9uIG9mIHRoZSB3aG9sZSBpbWFnZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBpbWFnZSB0byBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIHN0YXJ0WCBsZWZ0IGNvbHVtbiBmcm9tIHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICAgICAgICAgKiBAcGFyYW0gc3RhcnRZIHRvcCByb3cgZnJvbSB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAgICAgICAgICogQHBhcmFtIHdpZHRoIHdpZHRoIG9mIHJlZ2lvbiB0byBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIGhlaWdodCBoZWlnaHQgb2YgcmVnaW9uIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gbW9kdWxlU2l6ZSBlc3RpbWF0ZWQgbW9kdWxlIHNpemUgc28gZmFyXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihpbWFnZSwgc3RhcnRYIC8qaW50Ki8sIHN0YXJ0WSAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgbW9kdWxlU2l6ZSAvKmZsb2F0Ki8sIHJlc3VsdFBvaW50Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRYID0gc3RhcnRYO1xuICAgICAgICAgICAgdGhpcy5zdGFydFkgPSBzdGFydFk7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMubW9kdWxlU2l6ZSA9IG1vZHVsZVNpemU7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgPSByZXN1bHRQb2ludENhbGxiYWNrO1xuICAgICAgICAgICAgdGhpcy5wb3NzaWJsZUNlbnRlcnMgPSBbXTsgLy8gbmV3IEFycmF5PGFueT4oNSkpXG4gICAgICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogYXJyYXkgaW5pdGlhbGl6YXRpb24gd2l0aG91dCBzaXplIGFzIHRoZSBsZW5ndGggaXMgY2hlY2tlZCBiZWxvd1xuICAgICAgICAgICAgdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudCA9IG5ldyBJbnQzMkFycmF5KDMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5UaGlzIG1ldGhvZCBhdHRlbXB0cyB0byBmaW5kIHRoZSBib3R0b20tcmlnaHQgYWxpZ25tZW50IHBhdHRlcm4gaW4gdGhlIGltYWdlLiBJdCBpcyBhIGJpdCBtZXNzeSBzaW5jZVxuICAgICAgICAgKiBpdCdzIHByZXR0eSBwZXJmb3JtYW5jZS1jcml0aWNhbCBhbmQgc28gaXMgd3JpdHRlbiB0byBiZSBmYXN0IGZvcmVtb3N0LjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgQWxpZ25tZW50UGF0dGVybn0gaWYgZm91bmRcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBub3QgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIGZpbmQoKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFggPSB0aGlzLnN0YXJ0WDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgbWF4SiA9IHN0YXJ0WCArIHdpZHRoO1xuICAgICAgICAgICAgY29uc3QgbWlkZGxlSSA9IHRoaXMuc3RhcnRZICsgKGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgLy8gV2UgYXJlIGxvb2tpbmcgZm9yIGJsYWNrL3doaXRlL2JsYWNrIG1vZHVsZXMgaW4gMToxOjEgcmF0aW9cbiAgICAgICAgICAgIC8vIHRoaXMgdHJhY2tzIHRoZSBudW1iZXIgb2YgYmxhY2svd2hpdGUvYmxhY2sgbW9kdWxlcyBzZWVuIHNvIGZhclxuICAgICAgICAgICAgY29uc3Qgc3RhdGVDb3VudCA9IG5ldyBJbnQzMkFycmF5KDMpO1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICAgICAgZm9yIChsZXQgaUdlbiA9IDA7IGlHZW4gPCBoZWlnaHQ7IGlHZW4rKykge1xuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmcm9tIG1pZGRsZSBvdXR3YXJkc1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBtaWRkbGVJICsgKChpR2VuICYgMHgwMSkgPT09IDAgPyBNYXRoLmZsb29yKChpR2VuICsgMSkgLyAyKSA6IC1NYXRoLmZsb29yKChpR2VuICsgMSkgLyAyKSk7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IDA7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IDA7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGogPSBzdGFydFg7XG4gICAgICAgICAgICAgICAgLy8gQnVybiBvZmYgbGVhZGluZyB3aGl0ZSBwaXhlbHMgYmVmb3JlIGFueXRoaW5nIGVsc2U7IGlmIHdlIHN0YXJ0IGluIHRoZSBtaWRkbGUgb2ZcbiAgICAgICAgICAgICAgICAvLyBhIHdoaXRlIHJ1biwgaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIGNvdW50IGl0cyBsZW5ndGgsIHNpbmNlIHdlIGRvbid0IGtub3cgaWYgdGhlXG4gICAgICAgICAgICAgICAgLy8gd2hpdGUgcnVuIGNvbnRpbnVlZCB0byB0aGUgbGVmdCBvZiB0aGUgc3RhcnQgcG9pbnRcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IG1heEogJiYgIWltYWdlLmdldChqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbWF4Sikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGosIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFjayBwaXhlbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gMSkgeyAvLyBDb3VudGluZyBibGFjayBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gQ291bnRpbmcgd2hpdGUgcGl4ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gMikgeyAvLyBBIHdpbm5lcj9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHsgLy8gWWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25maXJtZWQgPSB0aGlzLmhhbmRsZVBvc3NpYmxlQ2VudGVyKHN0YXRlQ291bnQsIGksIGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maXJtZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IHN0YXRlQ291bnRbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbKytjdXJyZW50U3RhdGVdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBXaGl0ZSBwaXhlbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gMSkgeyAvLyBDb3VudGluZyBibGFjayBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbY3VycmVudFN0YXRlXSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlybWVkID0gdGhpcy5oYW5kbGVQb3NzaWJsZUNlbnRlcihzdGF0ZUNvdW50LCBpLCBtYXhKKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm1lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhtbSwgbm90aGluZyB3ZSBzYXcgd2FzIG9ic2VydmVkIGFuZCBjb25maXJtZWQgdHdpY2UuIElmIHdlIGhhZFxuICAgICAgICAgICAgLy8gYW55IGd1ZXNzIGF0IGFsbCwgcmV0dXJuIGl0LlxuICAgICAgICAgICAgaWYgKHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc3NpYmxlQ2VudGVyc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIGNvdW50IG9mIGJsYWNrL3doaXRlL2JsYWNrIHBpeGVscyBqdXN0IHNlZW4gYW5kIGFuIGVuZCBwb3NpdGlvbixcbiAgICAgICAgICogZmlndXJlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGlzIGJsYWNrL3doaXRlL2JsYWNrIHJ1bi5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGVuZCAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gKGVuZCAtIHN0YXRlQ291bnRbMl0pIC0gc3RhdGVDb3VudFsxXSAvIDIuMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHN0YXRlQ291bnQgY291bnQgb2YgYmxhY2svd2hpdGUvYmxhY2sgcGl4ZWxzIGp1c3QgcmVhZFxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWZmIHRoZSBwcm9wb3J0aW9ucyBvZiB0aGUgY291bnRzIGlzIGNsb3NlIGVub3VnaCB0byB0aGUgMS8xLzEgcmF0aW9zXG4gICAgICAgICAqICAgICAgICAgdXNlZCBieSBhbGlnbm1lbnQgcGF0dGVybnMgdG8gYmUgY29uc2lkZXJlZCBhIG1hdGNoXG4gICAgICAgICAqL1xuICAgICAgICBmb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVTaXplID0gdGhpcy5tb2R1bGVTaXplO1xuICAgICAgICAgICAgY29uc3QgbWF4VmFyaWFuY2UgPSBtb2R1bGVTaXplIC8gMi4wO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbaV0pID49IG1heFZhcmlhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+QWZ0ZXIgYSBob3Jpem9udGFsIHNjYW4gZmluZHMgYSBwb3RlbnRpYWwgYWxpZ25tZW50IHBhdHRlcm4sIHRoaXMgbWV0aG9kXG4gICAgICAgICAqIFwiY3Jvc3MtY2hlY2tzXCIgYnkgc2Nhbm5pbmcgZG93biB2ZXJ0aWNhbGx5IHRocm91Z2ggdGhlIGNlbnRlciBvZiB0aGUgcG9zc2libGVcbiAgICAgICAgICogYWxpZ25tZW50IHBhdHRlcm4gdG8gc2VlIGlmIHRoZSBzYW1lIHByb3BvcnRpb24gaXMgZGV0ZWN0ZWQuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3RhcnRJIHJvdyB3aGVyZSBhbiBhbGlnbm1lbnQgcGF0dGVybiB3YXMgZGV0ZWN0ZWRcbiAgICAgICAgICogQHBhcmFtIGNlbnRlckogY2VudGVyIG9mIHRoZSBzZWN0aW9uIHRoYXQgYXBwZWFycyB0byBjcm9zcyBhbiBhbGlnbm1lbnQgcGF0dGVyblxuICAgICAgICAgKiBAcGFyYW0gbWF4Q291bnQgbWF4aW11bSByZWFzb25hYmxlIG51bWJlciBvZiBtb2R1bGVzIHRoYXQgc2hvdWxkIGJlXG4gICAgICAgICAqIG9ic2VydmVkIGluIGFueSByZWFkaW5nIHN0YXRlLCBiYXNlZCBvbiB0aGUgcmVzdWx0cyBvZiB0aGUgaG9yaXpvbnRhbCBzY2FuXG4gICAgICAgICAqIEByZXR1cm4gdmVydGljYWwgY2VudGVyIG9mIGFsaWdubWVudCBwYXR0ZXJuLCBvciB7QGxpbmsgRmxvYXQjTmFOfSBpZiBub3QgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIGNyb3NzQ2hlY2tWZXJ0aWNhbChzdGFydEkgLyppbnQqLywgY2VudGVySiAvKmludCovLCBtYXhDb3VudCAvKmludCovLCBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgICAgICAgICBjb25zdCBtYXhJID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50ID0gdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudDtcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSAwO1xuICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IDA7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgICAgICAgIC8vIFN0YXJ0IGNvdW50aW5nIHVwIGZyb20gY2VudGVyXG4gICAgICAgICAgICBsZXQgaSA9IHN0YXJ0STtcbiAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbMV0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYWxyZWFkeSB0b28gbWFueSBtb2R1bGVzIGluIHRoaXMgc3RhdGUgb3IgcmFuIG9mZiB0aGUgZWRnZTpcbiAgICAgICAgICAgIGlmIChpIDwgMCB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiAhaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbMF0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgYWxzbyBjb3VudCBkb3duIGZyb20gY2VudGVyXG4gICAgICAgICAgICBpID0gc3RhcnRJICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbWF4SSAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0rKztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gbWF4SSB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmICFpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFsyXSA8PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0rKztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGVDb3VudFsyXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnRUb3RhbCA9IHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXTtcbiAgICAgICAgICAgIGlmICg1ICogTWF0aC5hYnMoc3RhdGVDb3VudFRvdGFsIC0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpID49IDIgKiBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSA/IEFsaWdubWVudFBhdHRlcm5GaW5kZXIuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBpKSA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+VGhpcyBpcyBjYWxsZWQgd2hlbiBhIGhvcml6b250YWwgc2NhbiBmaW5kcyBhIHBvc3NpYmxlIGFsaWdubWVudCBwYXR0ZXJuLiBJdCB3aWxsXG4gICAgICAgICAqIGNyb3NzIGNoZWNrIHdpdGggYSB2ZXJ0aWNhbCBzY2FuLCBhbmQgaWYgc3VjY2Vzc2Z1bCwgd2lsbCBzZWUgaWYgdGhpcyBwYXR0ZXJuIGhhZCBiZWVuXG4gICAgICAgICAqIGZvdW5kIG9uIGEgcHJldmlvdXMgaG9yaXpvbnRhbCBzY2FuLiBJZiBzbywgd2UgY29uc2lkZXIgaXQgY29uZmlybWVkIGFuZCBjb25jbHVkZSB3ZSBoYXZlXG4gICAgICAgICAqIGZvdW5kIHRoZSBhbGlnbm1lbnQgcGF0dGVybi48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdGF0ZUNvdW50IHJlYWRpbmcgc3RhdGUgbW9kdWxlIGNvdW50cyBmcm9tIGhvcml6b250YWwgc2NhblxuICAgICAgICAgKiBAcGFyYW0gaSByb3cgd2hlcmUgYWxpZ25tZW50IHBhdHRlcm4gbWF5IGJlIGZvdW5kXG4gICAgICAgICAqIEBwYXJhbSBqIGVuZCBvZiBwb3NzaWJsZSBhbGlnbm1lbnQgcGF0dGVybiBpbiByb3dcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgQWxpZ25tZW50UGF0dGVybn0gaWYgd2UgaGF2ZSBmb3VuZCB0aGUgc2FtZSBwYXR0ZXJuIHR3aWNlLCBvciBudWxsIGlmIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSAvKmludCovLCBqIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnRUb3RhbCA9IHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXTtcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlckogPSBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgaik7XG4gICAgICAgICAgICBjb25zdCBjZW50ZXJJID0gdGhpcy5jcm9zc0NoZWNrVmVydGljYWwoaSwgLyooaW50KSAqLyBjZW50ZXJKLCAyICogc3RhdGVDb3VudFsxXSwgc3RhdGVDb3VudFRvdGFsKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4oY2VudGVySSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlc3RpbWF0ZWRNb2R1bGVTaXplID0gKHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXSkgLyAzLjA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjZW50ZXIgb2YgdGhpcy5wb3NzaWJsZUNlbnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYWJvdXQgdGhlIHNhbWUgY2VudGVyIGFuZCBtb2R1bGUgc2l6ZTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbnRlci5hYm91dEVxdWFscyhlc3RpbWF0ZWRNb2R1bGVTaXplLCBjZW50ZXJJLCBjZW50ZXJKKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbnRlci5jb21iaW5lRXN0aW1hdGUoY2VudGVySSwgY2VudGVySiwgZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFkbid0IGZvdW5kIHRoaXMgYmVmb3JlOyBzYXZlIGl0XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgQWxpZ25tZW50UGF0dGVybihjZW50ZXJKLCBjZW50ZXJJLCBlc3RpbWF0ZWRNb2R1bGVTaXplKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc3NpYmxlQ2VudGVycy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bHRQb2ludENhbGxiYWNrICE9PSBudWxsICYmIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgYSBmaW5kZXIgcGF0dGVybiwgd2hpY2ggYXJlIHRoZSB0aHJlZSBzcXVhcmUgcGF0dGVybnMgZm91bmQgaW5cbiAgICAgKiB0aGUgY29ybmVycyBvZiBRUiBDb2Rlcy4gSXQgYWxzbyBlbmNhcHN1bGF0ZXMgYSBjb3VudCBvZiBzaW1pbGFyIGZpbmRlciBwYXR0ZXJucyxcbiAgICAgKiBhcyBhIGNvbnZlbmllbmNlIHRvIHRoZSBmaW5kZXIncyBib29ra2VlcGluZy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEZpbmRlclBhdHRlcm4kMSBleHRlbmRzIFJlc3VsdFBvaW50IHtcbiAgICAgICAgLy8gRmluZGVyUGF0dGVybihwb3NYOiBudW1iZXIvKmZsb2F0Ki8sIHBvc1k6IG51bWJlci8qZmxvYXQqLywgZXN0aW1hdGVkTW9kdWxlU2l6ZTogbnVtYmVyLypmbG9hdCovKSB7XG4gICAgICAgIC8vICAgdGhpcyhwb3NYLCBwb3NZLCBlc3RpbWF0ZWRNb2R1bGVTaXplLCAxKVxuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0cnVjdG9yKHBvc1ggLypmbG9hdCovLCBwb3NZIC8qZmxvYXQqLywgZXN0aW1hdGVkTW9kdWxlU2l6ZSAvKmZsb2F0Ki8sIGNvdW50IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHN1cGVyKHBvc1gsIHBvc1kpO1xuICAgICAgICAgICAgdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplID0gZXN0aW1hdGVkTW9kdWxlU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICB2b2lkIGluY3JlbWVudENvdW50KCkge1xuICAgICAgICAgIHRoaXMuY291bnQrK1xuICAgICAgICB9XG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RGV0ZXJtaW5lcyBpZiB0aGlzIGZpbmRlciBwYXR0ZXJuIFwiYWJvdXQgZXF1YWxzXCIgYSBmaW5kZXIgcGF0dGVybiBhdCB0aGUgc3RhdGVkXG4gICAgICAgICAqIHBvc2l0aW9uIGFuZCBzaXplIC0tIG1lYW5pbmcsIGl0IGlzIGF0IG5lYXJseSB0aGUgc2FtZSBjZW50ZXIgd2l0aCBuZWFybHkgdGhlIHNhbWUgc2l6ZS48L3A+XG4gICAgICAgICAqL1xuICAgICAgICBhYm91dEVxdWFscyhtb2R1bGVTaXplIC8qZmxvYXQqLywgaSAvKmZsb2F0Ki8sIGogLypmbG9hdCovKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoaSAtIHRoaXMuZ2V0WSgpKSA8PSBtb2R1bGVTaXplICYmIE1hdGguYWJzKGogLSB0aGlzLmdldFgoKSkgPD0gbW9kdWxlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNpemVEaWZmID0gTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVNpemVEaWZmIDw9IDEuMCB8fCBtb2R1bGVTaXplRGlmZiA8PSB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbWJpbmVzIHRoaXMgb2JqZWN0J3MgY3VycmVudCBlc3RpbWF0ZSBvZiBhIGZpbmRlciBwYXR0ZXJuIHBvc2l0aW9uIGFuZCBtb2R1bGUgc2l6ZVxuICAgICAgICAgKiB3aXRoIGEgbmV3IGVzdGltYXRlLiBJdCByZXR1cm5zIGEgbmV3IHtAY29kZSBGaW5kZXJQYXR0ZXJufSBjb250YWluaW5nIGEgd2VpZ2h0ZWQgYXZlcmFnZVxuICAgICAgICAgKiBiYXNlZCBvbiBjb3VudC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbWJpbmVFc3RpbWF0ZShpIC8qZmxvYXQqLywgaiAvKmZsb2F0Ki8sIG5ld01vZHVsZVNpemUgLypmbG9hdCovKSB7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZENvdW50ID0gdGhpcy5jb3VudCArIDE7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZFggPSAodGhpcy5jb3VudCAqIHRoaXMuZ2V0WCgpICsgaikgLyBjb21iaW5lZENvdW50O1xuICAgICAgICAgICAgY29uc3QgY29tYmluZWRZID0gKHRoaXMuY291bnQgKiB0aGlzLmdldFkoKSArIGkpIC8gY29tYmluZWRDb3VudDtcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkTW9kdWxlU2l6ZSA9ICh0aGlzLmNvdW50ICogdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplICsgbmV3TW9kdWxlU2l6ZSkgLyBjb21iaW5lZENvdW50O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaW5kZXJQYXR0ZXJuJDEoY29tYmluZWRYLCBjb21iaW5lZFksIGNvbWJpbmVkTW9kdWxlU2l6ZSwgY29tYmluZWRDb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBpbmZvcm1hdGlvbiBhYm91dCBmaW5kZXIgcGF0dGVybnMgaW4gYW4gaW1hZ2UsIGluY2x1ZGluZyB0aGUgbG9jYXRpb24gb2ZcbiAgICAgKiB0aGUgdGhyZWUgZmluZGVyIHBhdHRlcm5zLCBhbmQgdGhlaXIgZXN0aW1hdGVkIG1vZHVsZSBzaXplLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRmluZGVyUGF0dGVybkluZm8ge1xuICAgICAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuQ2VudGVycykge1xuICAgICAgICAgICAgdGhpcy5ib3R0b21MZWZ0ID0gcGF0dGVybkNlbnRlcnNbMF07XG4gICAgICAgICAgICB0aGlzLnRvcExlZnQgPSBwYXR0ZXJuQ2VudGVyc1sxXTtcbiAgICAgICAgICAgIHRoaXMudG9wUmlnaHQgPSBwYXR0ZXJuQ2VudGVyc1syXTtcbiAgICAgICAgfVxuICAgICAgICBnZXRCb3R0b21MZWZ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBnZXRUb3BMZWZ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9wTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBnZXRUb3BSaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcFJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKmltcG9ydCBqYXZhLmlvLlNlcmlhbGl6YWJsZTsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbnM7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuQ29tcGFyYXRvcjsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5MaXN0OyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xuICAgIC8qKlxuICAgICAqIDxwPlRoaXMgY2xhc3MgYXR0ZW1wdHMgdG8gZmluZCBmaW5kZXIgcGF0dGVybnMgaW4gYSBRUiBDb2RlLiBGaW5kZXIgcGF0dGVybnMgYXJlIHRoZSBzcXVhcmVcbiAgICAgKiBtYXJrZXJzIGF0IHRocmVlIGNvcm5lcnMgb2YgYSBRUiBDb2RlLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRoaXMgY2xhc3MgaXMgdGhyZWFkLXNhZmUgYnV0IG5vdCByZWVudHJhbnQuIEVhY2ggdGhyZWFkIG11c3QgYWxsb2NhdGUgaXRzIG93biBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEZpbmRlclBhdHRlcm5GaW5kZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogPHA+Q3JlYXRlcyBhIGZpbmRlciB0aGF0IHdpbGwgc2VhcmNoIHRoZSBpbWFnZSBmb3IgdGhyZWUgZmluZGVyIHBhdHRlcm5zLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltYWdlIGltYWdlIHRvIHNlYXJjaFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gcHVibGljIGNvbnN0cnVjdG9yKGltYWdlOiBCaXRNYXRyaXgpIHtcbiAgICAgICAgLy8gICB0aGlzKGltYWdlLCBudWxsKVxuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0cnVjdG9yKGltYWdlLCByZXN1bHRQb2ludENhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgPSByZXN1bHRQb2ludENhbGxiYWNrO1xuICAgICAgICAgICAgdGhpcy5wb3NzaWJsZUNlbnRlcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY3Jvc3NDaGVja1N0YXRlQ291bnQgPSBuZXcgSW50MzJBcnJheSg1KTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayA9IHJlc3VsdFBvaW50Q2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0SW1hZ2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbWFnZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRQb3NzaWJsZUNlbnRlcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NzaWJsZUNlbnRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZmluZChoaW50cykge1xuICAgICAgICAgICAgY29uc3QgdHJ5SGFyZGVyID0gKGhpbnRzICE9PSBudWxsICYmIGhpbnRzICE9PSB1bmRlZmluZWQpICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuVFJZX0hBUkRFUik7XG4gICAgICAgICAgICBjb25zdCBwdXJlQmFyY29kZSA9IChoaW50cyAhPT0gbnVsbCAmJiBoaW50cyAhPT0gdW5kZWZpbmVkKSAmJiB1bmRlZmluZWQgIT09IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlBVUkVfQkFSQ09ERSk7XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgICAgICAgICBjb25zdCBtYXhJID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBtYXhKID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBsb29raW5nIGZvciBibGFjay93aGl0ZS9ibGFjay93aGl0ZS9ibGFjayBtb2R1bGVzIGluXG4gICAgICAgICAgICAvLyAxOjE6MzoxOjEgcmF0aW87IHRoaXMgdHJhY2tzIHRoZSBudW1iZXIgb2Ygc3VjaCBtb2R1bGVzIHNlZW4gc28gZmFyXG4gICAgICAgICAgICAvLyBMZXQncyBhc3N1bWUgdGhhdCB0aGUgbWF4aW11bSB2ZXJzaW9uIFFSIENvZGUgd2Ugc3VwcG9ydCB0YWtlcyB1cCAxLzQgdGhlIGhlaWdodCBvZiB0aGVcbiAgICAgICAgICAgIC8vIGltYWdlLCBhbmQgdGhlbiBhY2NvdW50IGZvciB0aGUgY2VudGVyIGJlaW5nIDMgbW9kdWxlcyBpbiBzaXplLiBUaGlzIGdpdmVzIHRoZSBzbWFsbGVzdFxuICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHBpeGVscyB0aGUgY2VudGVyIGNvdWxkIGJlLCBzbyBza2lwIHRoaXMgb2Z0ZW4uIFdoZW4gdHJ5aW5nIGhhcmRlciwgbG9vayBmb3IgYWxsXG4gICAgICAgICAgICAvLyBRUiB2ZXJzaW9ucyByZWdhcmRsZXNzIG9mIGhvdyBkZW5zZSB0aGV5IGFyZS5cbiAgICAgICAgICAgIGxldCBpU2tpcCA9IE1hdGguZmxvb3IoKDMgKiBtYXhJKSAvICg0ICogRmluZGVyUGF0dGVybkZpbmRlci5NQVhfTU9EVUxFUykpO1xuICAgICAgICAgICAgaWYgKGlTa2lwIDwgRmluZGVyUGF0dGVybkZpbmRlci5NSU5fU0tJUCB8fCB0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICBpU2tpcCA9IEZpbmRlclBhdHRlcm5GaW5kZXIuTUlOX1NLSVA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVDb3VudCA9IG5ldyBJbnQzMkFycmF5KDUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGlTa2lwIC0gMTsgaSA8IG1heEkgJiYgIWRvbmU7IGkgKz0gaVNraXApIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IDA7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IDA7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSA9IDA7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXhKOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldChqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2sgcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY3VycmVudFN0YXRlICYgMSkgPT09IDEpIHsgLy8gQ291bnRpbmcgd2hpdGUgcGl4ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50W2N1cnJlbnRTdGF0ZV0rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gV2hpdGUgcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY3VycmVudFN0YXRlICYgMSkgPT09IDApIHsgLy8gQ291bnRpbmcgYmxhY2sgcGl4ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gNCkgeyAvLyBBIHdpbm5lcj9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHsgLy8gWWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25maXJtZWQgPSB0aGlzLmhhbmRsZVBvc3NpYmxlQ2VudGVyKHN0YXRlQ291bnQsIGksIGosIHB1cmVCYXJjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBleGFtaW5pbmcgZXZlcnkgb3RoZXIgbGluZS4gQ2hlY2tpbmcgZWFjaCBsaW5lIHR1cm5lZCBvdXQgdG8gYmUgdG9vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwZW5zaXZlIGFuZCBkaWRuJ3QgaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpU2tpcCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzU2tpcHBlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdGhpcy5oYXZlTXVsdGlwbHlDb25maXJtZWRDZW50ZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dTa2lwID0gdGhpcy5maW5kUm93U2tpcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93U2tpcCA+IHN0YXRlQ291bnRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcm93cyBiZXR3ZWVuIHJvdyBvZiBsb3dlciBjb25maXJtZWQgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdG9wIG9mIHByZXN1bWVkIHRoaXJkIGNvbmZpcm1lZCBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBiYWNrIHVwIGEgYml0IHRvIGdldCBhIGZ1bGwgY2hhbmNlIG9mIGRldGVjdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQsIGVudGlyZSB3aWR0aCBvZiBjZW50ZXIgb2YgZmluZGVyIHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgYnkgcm93U2tpcCwgYnV0IGJhY2sgb2ZmIGJ5IHN0YXRlQ291bnRbMl0gKHNpemUgb2YgbGFzdCBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHBhdHRlcm4gd2Ugc2F3KSB0byBiZSBjb25zZXJ2YXRpdmUsIGFuZCBhbHNvIGJhY2sgb2ZmIGJ5IGlTa2lwIHdoaWNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBhYm91dCB0byBiZSByZS1hZGRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSByb3dTa2lwIC0gc3RhdGVDb3VudFsyXSAtIGlTa2lwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IG1heEogLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IHN0YXRlQ291bnRbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IHN0YXRlQ291bnRbM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IHN0YXRlQ291bnRbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIHN0YXRlIHRvIHN0YXJ0IGxvb2tpbmcgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBObywgc2hpZnQgY291bnRzIGJhY2sgYnkgdHdvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gc3RhdGVDb3VudFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSBzdGF0ZUNvdW50WzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IHN0YXRlQ291bnRbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsrK2N1cnJlbnRTdGF0ZV0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gQ291bnRpbmcgd2hpdGUgcGl4ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFtjdXJyZW50U3RhdGVdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlybWVkID0gdGhpcy5oYW5kbGVQb3NzaWJsZUNlbnRlcihzdGF0ZUNvdW50LCBpLCBtYXhKLCBwdXJlQmFyY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlTa2lwID0gc3RhdGVDb3VudFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1NraXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIHRoaXJkIG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0aGlzLmhhdmVNdWx0aXBseUNvbmZpcm1lZENlbnRlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5JbmZvID0gdGhpcy5zZWxlY3RCZXN0UGF0dGVybnMoKTtcbiAgICAgICAgICAgIFJlc3VsdFBvaW50Lm9yZGVyQmVzdFBhdHRlcm5zKHBhdHRlcm5JbmZvKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmluZGVyUGF0dGVybkluZm8ocGF0dGVybkluZm8pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIGNvdW50IG9mIGJsYWNrL3doaXRlL2JsYWNrL3doaXRlL2JsYWNrIHBpeGVscyBqdXN0IHNlZW4gYW5kIGFuIGVuZCBwb3NpdGlvbixcbiAgICAgICAgICogZmlndXJlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGlzIHJ1bi5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGVuZCAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gKGVuZCAtIHN0YXRlQ291bnRbNF0gLSBzdGF0ZUNvdW50WzNdKSAtIHN0YXRlQ291bnRbMl0gLyAyLjA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBzdGF0ZUNvdW50IGNvdW50IG9mIGJsYWNrL3doaXRlL2JsYWNrL3doaXRlL2JsYWNrIHBpeGVscyBqdXN0IHJlYWRcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmZiB0aGUgcHJvcG9ydGlvbnMgb2YgdGhlIGNvdW50cyBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIDEvMS8zLzEvMSByYXRpb3NcbiAgICAgICAgICogICAgICAgICB1c2VkIGJ5IGZpbmRlciBwYXR0ZXJucyB0byBiZSBjb25zaWRlcmVkIGEgbWF0Y2hcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSB7XG4gICAgICAgICAgICBsZXQgdG90YWxNb2R1bGVTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBzdGF0ZUNvdW50W2ldO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvdGFsTW9kdWxlU2l6ZSArPSBjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3RhbE1vZHVsZVNpemUgPCA3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kdWxlU2l6ZSA9IHRvdGFsTW9kdWxlU2l6ZSAvIDcuMDtcbiAgICAgICAgICAgIGNvbnN0IG1heFZhcmlhbmNlID0gbW9kdWxlU2l6ZSAvIDIuMDtcbiAgICAgICAgICAgIC8vIEFsbG93IGxlc3MgdGhhbiA1MCUgdmFyaWFuY2UgZnJvbSAxLTEtMy0xLTEgcHJvcG9ydGlvbnNcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhtb2R1bGVTaXplIC0gc3RhdGVDb3VudFswXSkgPCBtYXhWYXJpYW5jZSAmJlxuICAgICAgICAgICAgICAgIE1hdGguYWJzKG1vZHVsZVNpemUgLSBzdGF0ZUNvdW50WzFdKSA8IG1heFZhcmlhbmNlICYmXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoMy4wICogbW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbMl0pIDwgMyAqIG1heFZhcmlhbmNlICYmXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbM10pIDwgbWF4VmFyaWFuY2UgJiZcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhtb2R1bGVTaXplIC0gc3RhdGVDb3VudFs0XSkgPCBtYXhWYXJpYW5jZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRDcm9zc0NoZWNrU3RhdGVDb3VudCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNyb3NzQ2hlY2tTdGF0ZUNvdW50ID0gdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudDtcbiAgICAgICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzBdID0gMDtcbiAgICAgICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzFdID0gMDtcbiAgICAgICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzNdID0gMDtcbiAgICAgICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzRdID0gMDtcbiAgICAgICAgICAgIHJldHVybiBjcm9zc0NoZWNrU3RhdGVDb3VudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQWZ0ZXIgYSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBzY2FuIGZpbmRzIGEgcG90ZW50aWFsIGZpbmRlciBwYXR0ZXJuLCB0aGlzIG1ldGhvZFxuICAgICAgICAgKiBcImNyb3NzLWNyb3NzLWNyb3NzLWNoZWNrc1wiIGJ5IHNjYW5uaW5nIGRvd24gZGlhZ29uYWxseSB0aHJvdWdoIHRoZSBjZW50ZXIgb2YgdGhlIHBvc3NpYmxlXG4gICAgICAgICAqIGZpbmRlciBwYXR0ZXJuIHRvIHNlZSBpZiB0aGUgc2FtZSBwcm9wb3J0aW9uIGlzIGRldGVjdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3RhcnRJIHJvdyB3aGVyZSBhIGZpbmRlciBwYXR0ZXJuIHdhcyBkZXRlY3RlZFxuICAgICAgICAgKiBAcGFyYW0gY2VudGVySiBjZW50ZXIgb2YgdGhlIHNlY3Rpb24gdGhhdCBhcHBlYXJzIHRvIGNyb3NzIGEgZmluZGVyIHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIG1heENvdW50IG1heGltdW0gcmVhc29uYWJsZSBudW1iZXIgb2YgbW9kdWxlcyB0aGF0IHNob3VsZCBiZVxuICAgICAgICAgKiAgb2JzZXJ2ZWQgaW4gYW55IHJlYWRpbmcgc3RhdGUsIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZSBob3Jpem9udGFsIHNjYW5cbiAgICAgICAgICogQHBhcmFtIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsIFRoZSBvcmlnaW5hbCBzdGF0ZSBjb3VudCB0b3RhbC5cbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIHByb3BvcnRpb25zIGFyZSB3aXRoaW5nIGV4cGVjdGVkIGxpbWl0c1xuICAgICAgICAgKi9cbiAgICAgICAgY3Jvc3NDaGVja0RpYWdvbmFsKHN0YXJ0SSAvKmludCovLCBjZW50ZXJKIC8qaW50Ki8sIG1heENvdW50IC8qaW50Ki8sIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnQgPSB0aGlzLmdldENyb3NzQ2hlY2tTdGF0ZUNvdW50KCk7XG4gICAgICAgICAgICAvLyBTdGFydCBjb3VudGluZyB1cCwgbGVmdCBmcm9tIGNlbnRlciBmaW5kaW5nIGJsYWNrIGNlbnRlciBtYXNzXG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJID49IGkgJiYgY2VudGVySiA+PSBpICYmIGltYWdlLmdldChjZW50ZXJKIC0gaSwgc3RhcnRJIC0gaSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0SSA8IGkgfHwgY2VudGVySiA8IGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb250aW51ZSB1cCwgbGVmdCBmaW5kaW5nIHdoaXRlIHNwYWNlXG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJID49IGkgJiYgY2VudGVySiA+PSBpICYmICFpbWFnZS5nZXQoY2VudGVySiAtIGksIHN0YXJ0SSAtIGkpICYmXG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0rKztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBhbHJlYWR5IHRvbyBtYW55IG1vZHVsZXMgaW4gdGhpcyBzdGF0ZSBvciByYW4gb2ZmIHRoZSBlZGdlOlxuICAgICAgICAgICAgaWYgKHN0YXJ0SSA8IGkgfHwgY2VudGVySiA8IGkgfHwgc3RhdGVDb3VudFsxXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29udGludWUgdXAsIGxlZnQgZmluZGluZyBibGFjayBib3JkZXJcbiAgICAgICAgICAgIHdoaWxlIChzdGFydEkgPj0gaSAmJiBjZW50ZXJKID49IGkgJiYgaW1hZ2UuZ2V0KGNlbnRlckogLSBpLCBzdGFydEkgLSBpKSAmJlxuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1heEkgPSBpbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IG1heEogPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgLy8gTm93IGFsc28gY291bnQgZG93biwgcmlnaHQgZnJvbSBjZW50ZXJcbiAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0SSArIGkgPCBtYXhJICYmIGNlbnRlckogKyBpIDwgbWF4SiAmJiBpbWFnZS5nZXQoY2VudGVySiArIGksIHN0YXJ0SSArIGkpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJhbiBvZmYgdGhlIGVkZ2U/XG4gICAgICAgICAgICBpZiAoc3RhcnRJICsgaSA+PSBtYXhJIHx8IGNlbnRlckogKyBpID49IG1heEopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJICsgaSA8IG1heEkgJiYgY2VudGVySiArIGkgPCBtYXhKICYmICFpbWFnZS5nZXQoY2VudGVySiArIGksIHN0YXJ0SSArIGkpICYmXG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSA8IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSsrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydEkgKyBpID49IG1heEkgfHwgY2VudGVySiArIGkgPj0gbWF4SiB8fCBzdGF0ZUNvdW50WzNdID49IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0SSArIGkgPCBtYXhJICYmIGNlbnRlckogKyBpIDwgbWF4SiAmJiBpbWFnZS5nZXQoY2VudGVySiArIGksIHN0YXJ0SSArIGkpICYmXG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA8IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSsrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZUNvdW50WzRdID49IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBmaW5kZXItcGF0dGVybi1saWtlIHNlY3Rpb24sIGJ1dCBpdHMgc2l6ZSBpcyBtb3JlIHRoYW4gMTAwJSBkaWZmZXJlbnQgdGhhblxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsLCBhc3N1bWUgaXQncyBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICsgc3RhdGVDb3VudFs0XTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhzdGF0ZUNvdW50VG90YWwgLSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkgPCAyICogb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgJiZcbiAgICAgICAgICAgICAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5BZnRlciBhIGhvcml6b250YWwgc2NhbiBmaW5kcyBhIHBvdGVudGlhbCBmaW5kZXIgcGF0dGVybiwgdGhpcyBtZXRob2RcbiAgICAgICAgICogXCJjcm9zcy1jaGVja3NcIiBieSBzY2FubmluZyBkb3duIHZlcnRpY2FsbHkgdGhyb3VnaCB0aGUgY2VudGVyIG9mIHRoZSBwb3NzaWJsZVxuICAgICAgICAgKiBmaW5kZXIgcGF0dGVybiB0byBzZWUgaWYgdGhlIHNhbWUgcHJvcG9ydGlvbiBpcyBkZXRlY3RlZC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdGFydEkgcm93IHdoZXJlIGEgZmluZGVyIHBhdHRlcm4gd2FzIGRldGVjdGVkXG4gICAgICAgICAqIEBwYXJhbSBjZW50ZXJKIGNlbnRlciBvZiB0aGUgc2VjdGlvbiB0aGF0IGFwcGVhcnMgdG8gY3Jvc3MgYSBmaW5kZXIgcGF0dGVyblxuICAgICAgICAgKiBAcGFyYW0gbWF4Q291bnQgbWF4aW11bSByZWFzb25hYmxlIG51bWJlciBvZiBtb2R1bGVzIHRoYXQgc2hvdWxkIGJlXG4gICAgICAgICAqIG9ic2VydmVkIGluIGFueSByZWFkaW5nIHN0YXRlLCBiYXNlZCBvbiB0aGUgcmVzdWx0cyBvZiB0aGUgaG9yaXpvbnRhbCBzY2FuXG4gICAgICAgICAqIEByZXR1cm4gdmVydGljYWwgY2VudGVyIG9mIGZpbmRlciBwYXR0ZXJuLCBvciB7QGxpbmsgRmxvYXQjTmFOfSBpZiBub3QgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIGNyb3NzQ2hlY2tWZXJ0aWNhbChzdGFydEkgLyppbnQqLywgY2VudGVySiAvKmludCovLCBtYXhDb3VudCAvKmludCovLCBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgICAgICAgICBjb25zdCBtYXhJID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50ID0gdGhpcy5nZXRDcm9zc0NoZWNrU3RhdGVDb3VudCgpO1xuICAgICAgICAgICAgLy8gU3RhcnQgY291bnRpbmcgdXAgZnJvbSBjZW50ZXJcbiAgICAgICAgICAgIGxldCBpID0gc3RhcnRJO1xuICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgIWltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSsrO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGFscmVhZHkgdG9vIG1hbnkgbW9kdWxlcyBpbiB0aGlzIHN0YXRlIG9yIHJhbiBvZmYgdGhlIGVkZ2U6XG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgc3RhdGVDb3VudFsxXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbMF0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgYWxzbyBjb3VudCBkb3duIGZyb20gY2VudGVyXG4gICAgICAgICAgICBpID0gc3RhcnRJICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbWF4SSAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IG1heEkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmICFpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFszXSA8IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSsrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSBtYXhJIHx8IHN0YXRlQ291bnRbM10gPj0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzRdIDwgbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdKys7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlQ291bnRbNF0gPj0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBmaW5kZXItcGF0dGVybi1saWtlIHNlY3Rpb24sIGJ1dCBpdHMgc2l6ZSBpcyBtb3JlIHRoYW4gNDAlIGRpZmZlcmVudCB0aGFuXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwsIGFzc3VtZSBpdCdzIGEgZmFsc2UgcG9zaXRpdmVcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnRUb3RhbCA9IHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXSArIHN0YXRlQ291bnRbM10gK1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF07XG4gICAgICAgICAgICBpZiAoNSAqIE1hdGguYWJzKHN0YXRlQ291bnRUb3RhbCAtIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSA+PSAyICogb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkgPyBGaW5kZXJQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgaSkgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkxpa2Uge0BsaW5rICNjcm9zc0NoZWNrVmVydGljYWwoaW50LCBpbnQsIGludCwgaW50KX0sIGFuZCBpbiBmYWN0IGlzIGJhc2ljYWxseSBpZGVudGljYWwsXG4gICAgICAgICAqIGV4Y2VwdCBpdCByZWFkcyBob3Jpem9udGFsbHkgaW5zdGVhZCBvZiB2ZXJ0aWNhbGx5LiBUaGlzIGlzIHVzZWQgdG8gY3Jvc3MtY3Jvc3NcbiAgICAgICAgICogY2hlY2sgYSB2ZXJ0aWNhbCBjcm9zcyBjaGVjayBhbmQgbG9jYXRlIHRoZSByZWFsIGNlbnRlciBvZiB0aGUgYWxpZ25tZW50IHBhdHRlcm4uPC9wPlxuICAgICAgICAgKi9cbiAgICAgICAgY3Jvc3NDaGVja0hvcml6b250YWwoc3RhcnRKIC8qaW50Ki8sIGNlbnRlckkgLyppbnQqLywgbWF4Q291bnQgLyppbnQqLywgb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICAgICAgY29uc3QgbWF4SiA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50ID0gdGhpcy5nZXRDcm9zc0NoZWNrU3RhdGVDb3VudCgpO1xuICAgICAgICAgICAgbGV0IGogPSBzdGFydEo7XG4gICAgICAgICAgICB3aGlsZSAoaiA+PSAwICYmIGltYWdlLmdldChqLCBjZW50ZXJJKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0rKztcbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaiA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGogPj0gMCAmJiAhaW1hZ2UuZ2V0KGosIGNlbnRlckkpICYmIHN0YXRlQ291bnRbMV0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPCAwIHx8IHN0YXRlQ291bnRbMV0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaiA+PSAwICYmIGltYWdlLmdldChqLCBjZW50ZXJJKSAmJiBzdGF0ZUNvdW50WzBdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSsrO1xuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZUNvdW50WzBdID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaiA9IHN0YXJ0SiArIDE7XG4gICAgICAgICAgICB3aGlsZSAoaiA8IG1heEogJiYgaW1hZ2UuZ2V0KGosIGNlbnRlckkpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqID09PSBtYXhKKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChqIDwgbWF4SiAmJiAhaW1hZ2UuZ2V0KGosIGNlbnRlckkpICYmIHN0YXRlQ291bnRbM10gPCBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10rKztcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaiA9PT0gbWF4SiB8fCBzdGF0ZUNvdW50WzNdID49IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChqIDwgbWF4SiAmJiBpbWFnZS5nZXQoaiwgY2VudGVySSkgJiYgc3RhdGVDb3VudFs0XSA8IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSsrO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZUNvdW50WzRdID49IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgZmluZGVyLXBhdHRlcm4tbGlrZSBzZWN0aW9uLCBidXQgaXRzIHNpemUgaXMgc2lnbmlmaWNhbnRseSBkaWZmZXJlbnQgdGhhblxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsLCBhc3N1bWUgaXQncyBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdO1xuICAgICAgICAgICAgaWYgKDUgKiBNYXRoLmFicyhzdGF0ZUNvdW50VG90YWwgLSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkgPj0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkgPyBGaW5kZXJQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgaikgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlRoaXMgaXMgY2FsbGVkIHdoZW4gYSBob3Jpem9udGFsIHNjYW4gZmluZHMgYSBwb3NzaWJsZSBhbGlnbm1lbnQgcGF0dGVybi4gSXQgd2lsbFxuICAgICAgICAgKiBjcm9zcyBjaGVjayB3aXRoIGEgdmVydGljYWwgc2NhbiwgYW5kIGlmIHN1Y2Nlc3NmdWwsIHdpbGwsIGFoLCBjcm9zcy1jcm9zcy1jaGVja1xuICAgICAgICAgKiB3aXRoIGFub3RoZXIgaG9yaXpvbnRhbCBzY2FuLiBUaGlzIGlzIG5lZWRlZCBwcmltYXJpbHkgdG8gbG9jYXRlIHRoZSByZWFsIGhvcml6b250YWxcbiAgICAgICAgICogY2VudGVyIG9mIHRoZSBwYXR0ZXJuIGluIGNhc2VzIG9mIGV4dHJlbWUgc2tldy5cbiAgICAgICAgICogQW5kIHRoZW4gd2UgY3Jvc3MtY3Jvc3MtY3Jvc3MgY2hlY2sgd2l0aCBhbm90aGVyIGRpYWdvbmFsIHNjYW4uPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5JZiB0aGF0IHN1Y2NlZWRzIHRoZSBmaW5kZXIgcGF0dGVybiBsb2NhdGlvbiBpcyBhZGRlZCB0byBhIGxpc3QgdGhhdCB0cmFja3NcbiAgICAgICAgICogdGhlIG51bWJlciBvZiB0aW1lcyBlYWNoIGxvY2F0aW9uIGhhcyBiZWVuIG5lYXJseS1tYXRjaGVkIGFzIGEgZmluZGVyIHBhdHRlcm4uXG4gICAgICAgICAqIEVhY2ggYWRkaXRpb25hbCBmaW5kIGlzIG1vcmUgZXZpZGVuY2UgdGhhdCB0aGUgbG9jYXRpb24gaXMgaW4gZmFjdCBhIGZpbmRlclxuICAgICAgICAgKiBwYXR0ZXJuIGNlbnRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3RhdGVDb3VudCByZWFkaW5nIHN0YXRlIG1vZHVsZSBjb3VudHMgZnJvbSBob3Jpem9udGFsIHNjYW5cbiAgICAgICAgICogQHBhcmFtIGkgcm93IHdoZXJlIGZpbmRlciBwYXR0ZXJuIG1heSBiZSBmb3VuZFxuICAgICAgICAgKiBAcGFyYW0gaiBlbmQgb2YgcG9zc2libGUgZmluZGVyIHBhdHRlcm4gaW4gcm93XG4gICAgICAgICAqIEBwYXJhbSBwdXJlQmFyY29kZSB0cnVlIGlmIGluIFwicHVyZSBiYXJjb2RlXCIgbW9kZVxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgYSBmaW5kZXIgcGF0dGVybiBjYW5kaWRhdGUgd2FzIGZvdW5kIHRoaXMgdGltZVxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSAvKmludCovLCBqIC8qaW50Ki8sIHB1cmVCYXJjb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdO1xuICAgICAgICAgICAgbGV0IGNlbnRlckogPSBGaW5kZXJQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgaik7XG4gICAgICAgICAgICBsZXQgY2VudGVySSA9IHRoaXMuY3Jvc3NDaGVja1ZlcnRpY2FsKGksIC8qKGludCkgKi8gTWF0aC5mbG9vcihjZW50ZXJKKSwgc3RhdGVDb3VudFsyXSwgc3RhdGVDb3VudFRvdGFsKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4oY2VudGVySSkpIHtcbiAgICAgICAgICAgICAgICAvLyBSZS1jcm9zcyBjaGVja1xuICAgICAgICAgICAgICAgIGNlbnRlckogPSB0aGlzLmNyb3NzQ2hlY2tIb3Jpem9udGFsKC8qKGludCkgKi8gTWF0aC5mbG9vcihjZW50ZXJKKSwgLyooaW50KSAqLyBNYXRoLmZsb29yKGNlbnRlckkpLCBzdGF0ZUNvdW50WzJdLCBzdGF0ZUNvdW50VG90YWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oY2VudGVySikgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFwdXJlQmFyY29kZSB8fCB0aGlzLmNyb3NzQ2hlY2tEaWFnb25hbCgvKihpbnQpICovIE1hdGguZmxvb3IoY2VudGVySSksIC8qKGludCkgKi8gTWF0aC5mbG9vcihjZW50ZXJKKSwgc3RhdGVDb3VudFsyXSwgc3RhdGVDb3VudFRvdGFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IHN0YXRlQ291bnRUb3RhbCAvIDcuMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlQ2VudGVycyA9IHRoaXMucG9zc2libGVDZW50ZXJzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IHBvc3NpYmxlQ2VudGVycy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXIgPSBwb3NzaWJsZUNlbnRlcnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYWJvdXQgdGhlIHNhbWUgY2VudGVyIGFuZCBtb2R1bGUgc2l6ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZW50ZXIuYWJvdXRFcXVhbHMoZXN0aW1hdGVkTW9kdWxlU2l6ZSwgY2VudGVySSwgY2VudGVySikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnNbaW5kZXhdID0gY2VudGVyLmNvbWJpbmVFc3RpbWF0ZShjZW50ZXJJLCBjZW50ZXJKLCBlc3RpbWF0ZWRNb2R1bGVTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgRmluZGVyUGF0dGVybiQxKGNlbnRlckosIGNlbnRlckksIGVzdGltYXRlZE1vZHVsZVNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayAhPT0gbnVsbCAmJiB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBudW1iZXIgb2Ygcm93cyB3ZSBjb3VsZCBzYWZlbHkgc2tpcCBkdXJpbmcgc2Nhbm5pbmcsIGJhc2VkIG9uIHRoZSBmaXJzdFxuICAgICAgICAgKiAgICAgICAgIHR3byBmaW5kZXIgcGF0dGVybnMgdGhhdCBoYXZlIGJlZW4gbG9jYXRlZC4gSW4gc29tZSBjYXNlcyB0aGVpciBwb3NpdGlvbiB3aWxsXG4gICAgICAgICAqICAgICAgICAgYWxsb3cgdXMgdG8gaW5mZXIgdGhhdCB0aGUgdGhpcmQgcGF0dGVybiBtdXN0IGxpZSBiZWxvdyBhIGNlcnRhaW4gcG9pbnQgZmFydGhlclxuICAgICAgICAgKiAgICAgICAgIGRvd24gaW4gdGhlIGltYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgZmluZFJvd1NraXAoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXggPSB0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobWF4IDw9IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmaXJzdENvbmZpcm1lZENlbnRlciA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNlbnRlciBvZiB0aGlzLnBvc3NpYmxlQ2VudGVycykge1xuICAgICAgICAgICAgICAgIGlmIChjZW50ZXIuZ2V0Q291bnQoKSA+PSBGaW5kZXJQYXR0ZXJuRmluZGVyLkNFTlRFUl9RVU9SVU0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0Q29uZmlybWVkQ2VudGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Q29uZmlybWVkQ2VudGVyID0gY2VudGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0d28gY29uZmlybWVkIGNlbnRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhvdyBmYXIgZG93biBjYW4gd2Ugc2tpcCBiZWZvcmUgcmVzdW1pbmcgbG9va2luZyBmb3IgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhdHRlcm4/IEluIHRoZSB3b3JzdCBjYXNlLCBvbmx5IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbmNlIGluIHRoZSB4IC8geSBjb29yZGluYXRlcyBvZiB0aGUgdHdvIGNlbnRlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZXJlIHlvdSBmaW5kIHRvcCBsZWZ0IGxhc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1NraXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8qKGludCkgKi8gTWF0aC5mbG9vcigoTWF0aC5hYnMoZmlyc3RDb25maXJtZWRDZW50ZXIuZ2V0WCgpIC0gY2VudGVyLmdldFgoKSkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGZpcnN0Q29uZmlybWVkQ2VudGVyLmdldFkoKSAtIGNlbnRlci5nZXRZKCkpKSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZmYgd2UgaGF2ZSBmb3VuZCBhdCBsZWFzdCAzIGZpbmRlciBwYXR0ZXJucyB0aGF0IGhhdmUgYmVlbiBkZXRlY3RlZFxuICAgICAgICAgKiAgICAgICAgIGF0IGxlYXN0IHtAbGluayAjQ0VOVEVSX1FVT1JVTX0gdGltZXMgZWFjaCwgYW5kLCB0aGUgZXN0aW1hdGVkIG1vZHVsZSBzaXplIG9mIHRoZVxuICAgICAgICAgKiAgICAgICAgIGNhbmRpZGF0ZXMgaXMgXCJwcmV0dHkgc2ltaWxhclwiXG4gICAgICAgICAqL1xuICAgICAgICBoYXZlTXVsdGlwbHlDb25maXJtZWRDZW50ZXJzKCkge1xuICAgICAgICAgICAgbGV0IGNvbmZpcm1lZENvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCB0b3RhbE1vZHVsZVNpemUgPSAwLjA7XG4gICAgICAgICAgICBjb25zdCBtYXggPSB0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdGhpcy5wb3NzaWJsZUNlbnRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybi5nZXRDb3VudCgpID49IEZpbmRlclBhdHRlcm5GaW5kZXIuQ0VOVEVSX1FVT1JVTSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maXJtZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbE1vZHVsZVNpemUgKz0gcGF0dGVybi5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpcm1lZENvdW50IDwgMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9LLCB3ZSBoYXZlIGF0IGxlYXN0IDMgY29uZmlybWVkIGNlbnRlcnMsIGJ1dCwgaXQncyBwb3NzaWJsZSB0aGF0IG9uZSBpcyBhIFwiZmFsc2UgcG9zaXRpdmVcIlxuICAgICAgICAgICAgLy8gYW5kIHRoYXQgd2UgbmVlZCB0byBrZWVwIGxvb2tpbmcuIFdlIGRldGVjdCB0aGlzIGJ5IGFza2luZyBpZiB0aGUgZXN0aW1hdGVkIG1vZHVsZSBzaXplc1xuICAgICAgICAgICAgLy8gdmFyeSB0b28gbXVjaC4gV2UgYXJiaXRyYXJpbHkgc2F5IHRoYXQgd2hlbiB0aGUgdG90YWwgZGV2aWF0aW9uIGZyb20gYXZlcmFnZSBleGNlZWRzXG4gICAgICAgICAgICAvLyA1JSBvZiB0aGUgdG90YWwgbW9kdWxlIHNpemUgZXN0aW1hdGVzLCBpdCdzIHRvbyBtdWNoLlxuICAgICAgICAgICAgY29uc3QgYXZlcmFnZSA9IHRvdGFsTW9kdWxlU2l6ZSAvIG1heDtcbiAgICAgICAgICAgIGxldCB0b3RhbERldmlhdGlvbiA9IDAuMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiB0aGlzLnBvc3NpYmxlQ2VudGVycykge1xuICAgICAgICAgICAgICAgIHRvdGFsRGV2aWF0aW9uICs9IE1hdGguYWJzKHBhdHRlcm4uZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIC0gYXZlcmFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG90YWxEZXZpYXRpb24gPD0gMC4wNSAqIHRvdGFsTW9kdWxlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0aGUgMyBiZXN0IHtAbGluayBGaW5kZXJQYXR0ZXJufXMgZnJvbSBvdXIgbGlzdCBvZiBjYW5kaWRhdGVzLiBUaGUgXCJiZXN0XCIgYXJlXG4gICAgICAgICAqICAgICAgICAgdGhvc2UgdGhhdCBoYXZlIGJlZW4gZGV0ZWN0ZWQgYXQgbGVhc3Qge0BsaW5rICNDRU5URVJfUVVPUlVNfSB0aW1lcywgYW5kIHdob3NlIG1vZHVsZVxuICAgICAgICAgKiAgICAgICAgIHNpemUgZGlmZmVycyBmcm9tIHRoZSBhdmVyYWdlIGFtb25nIHRob3NlIHBhdHRlcm5zIHRoZSBsZWFzdFxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIDMgc3VjaCBmaW5kZXIgcGF0dGVybnMgZG8gbm90IGV4aXN0XG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RCZXN0UGF0dGVybnMoKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFNpemUgPSB0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoc3RhcnRTaXplIDwgMykge1xuICAgICAgICAgICAgICAgIC8vIENvdWxkbid0IGZpbmQgZW5vdWdoIGZpbmRlciBwYXR0ZXJuc1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9zc2libGVDZW50ZXJzID0gdGhpcy5wb3NzaWJsZUNlbnRlcnM7XG4gICAgICAgICAgICBsZXQgYXZlcmFnZTtcbiAgICAgICAgICAgIC8vIEZpbHRlciBvdXRsaWVyIHBvc3NpYmlsaXRpZXMgd2hvc2UgbW9kdWxlIHNpemUgaXMgdG9vIGRpZmZlcmVudFxuICAgICAgICAgICAgaWYgKHN0YXJ0U2l6ZSA+IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBCdXQgd2UgY2FuIG9ubHkgYWZmb3JkIHRvIGRvIHNvIGlmIHdlIGhhdmUgYXQgbGVhc3QgNCBwb3NzaWJpbGl0aWVzIHRvIGNob29zZSBmcm9tXG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsTW9kdWxlU2l6ZSA9IDAuMDtcbiAgICAgICAgICAgICAgICBsZXQgc3F1YXJlID0gMC4wO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2VudGVyIG9mIHRoaXMucG9zc2libGVDZW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBjZW50ZXIuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbE1vZHVsZVNpemUgKz0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlICs9IHNpemUgKiBzaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdmVyYWdlID0gdG90YWxNb2R1bGVTaXplIC8gc3RhcnRTaXplO1xuICAgICAgICAgICAgICAgIGxldCBzdGREZXYgPSBNYXRoLnNxcnQoc3F1YXJlIC8gc3RhcnRTaXplIC0gYXZlcmFnZSAqIGF2ZXJhZ2UpO1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVycy5zb3J0KFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIDxwPk9yZGVycyBieSBmdXJ0aGVzdCBmcm9tIGF2ZXJhZ2U8L3A+XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLy8gRnVydGhlc3RGcm9tQXZlcmFnZUNvbXBhcmF0b3IgaW1wbGVtZW50cyBDb21wYXJhdG9yPEZpbmRlclBhdHRlcm4+XG4gICAgICAgICAgICAgICAgKGNlbnRlcjEsIGNlbnRlcjIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZEEgPSBNYXRoLmFicyhjZW50ZXIyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkQiA9IE1hdGguYWJzKGNlbnRlcjEuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIC0gYXZlcmFnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkQSA8IGRCID8gLTEgOiBkQSA+IGRCID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGltaXQgPSBNYXRoLm1heCgwLjIgKiBhdmVyYWdlLCBzdGREZXYpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zc2libGVDZW50ZXJzLmxlbmd0aCAmJiBwb3NzaWJsZUNlbnRlcnMubGVuZ3RoID4gMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBwb3NzaWJsZUNlbnRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhwYXR0ZXJuLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zc2libGVDZW50ZXJzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBhd2F5IGFsbCBidXQgdGhvc2UgZmlyc3Qgc2l6ZSBjYW5kaWRhdGUgcG9pbnRzIHdlIGZvdW5kLlxuICAgICAgICAgICAgICAgIGxldCB0b3RhbE1vZHVsZVNpemUgPSAwLjA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwb3NzaWJsZUNlbnRlciBvZiBwb3NzaWJsZUNlbnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxNb2R1bGVTaXplICs9IHBvc3NpYmxlQ2VudGVyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXZlcmFnZSA9IHRvdGFsTW9kdWxlU2l6ZSAvIHBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzLnNvcnQoXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogPHA+T3JkZXJzIGJ5IHtAbGluayBGaW5kZXJQYXR0ZXJuI2dldENvdW50KCl9LCBkZXNjZW5kaW5nLjwvcD5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAvLyBDZW50ZXJDb21wYXJhdG9yIGltcGxlbWVudHMgQ29tcGFyYXRvcjxGaW5kZXJQYXR0ZXJuPlxuICAgICAgICAgICAgICAgIChjZW50ZXIxLCBjZW50ZXIyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZW50ZXIyLmdldENvdW50KCkgPT09IGNlbnRlcjEuZ2V0Q291bnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZEEgPSBNYXRoLmFicyhjZW50ZXIyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZEIgPSBNYXRoLmFicyhjZW50ZXIxLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRBIDwgZEIgPyAxIDogZEEgPiBkQiA/IC0xIDogMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXIyLmdldENvdW50KCkgLSBjZW50ZXIxLmdldENvdW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnMuc3BsaWNlKDMpOyAvLyB0aGlzIGlzIG5vdCByZWFseSBuZWNlc3NhcnkgYXMgd2Ugb25seSByZXR1cm4gZmlyc3QgMyBhbnl3YXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzWzBdLFxuICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVyc1sxXSxcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnNbMl1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5DRU5URVJfUVVPUlVNID0gMjtcbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLk1JTl9TS0lQID0gMzsgLy8gMSBwaXhlbC9tb2R1bGUgdGltZXMgMyBtb2R1bGVzL2NlbnRlclxuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIuTUFYX01PRFVMRVMgPSA1NzsgLy8gc3VwcG9ydCB1cCB0byB2ZXJzaW9uIDEwIGZvciBtb2JpbGUgY2xpZW50c1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGxvZ2ljIHRoYXQgY2FuIGRldGVjdCBhIFFSIENvZGUgaW4gYW4gaW1hZ2UsIGV2ZW4gaWYgdGhlIFFSIENvZGVcbiAgICAgKiBpcyByb3RhdGVkIG9yIHNrZXdlZCwgb3IgcGFydGlhbGx5IG9ic2N1cmVkLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGV0ZWN0b3IkMiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGltYWdlKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0SW1hZ2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbWFnZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRSZXN1bHRQb2ludENhbGxiYWNrKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RGV0ZWN0cyBhIFFSIENvZGUgaW4gYW4gaW1hZ2UuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBEZXRlY3RvclJlc3VsdH0gZW5jYXBzdWxhdGluZyByZXN1bHRzIG9mIGRldGVjdGluZyBhIFFSIENvZGVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBRUiBDb2RlIGNhbm5vdCBiZSBmb3VuZFxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBhIFFSIENvZGUgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgICAgICovXG4gICAgICAgIC8vIHB1YmxpYyBkZXRlY3QoKTogRGV0ZWN0b3JSZXN1bHQgLyp0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiovIHtcbiAgICAgICAgLy8gICByZXR1cm4gZGV0ZWN0KG51bGwpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRldGVjdHMgYSBRUiBDb2RlIGluIGFuIGltYWdlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGhpbnRzIG9wdGlvbmFsIGhpbnRzIHRvIGRldGVjdG9yXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIERldGVjdG9yUmVzdWx0fSBlbmNhcHN1bGF0aW5nIHJlc3VsdHMgb2YgZGV0ZWN0aW5nIGEgUVIgQ29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIFFSIENvZGUgY2Fubm90IGJlIGZvdW5kXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgUVIgQ29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGV0ZWN0KGhpbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgPSAoaGludHMgPT09IG51bGwgfHwgaGludHMgPT09IHVuZGVmaW5lZCkgPyBudWxsIDpcbiAgICAgICAgICAgICAgICAvKihSZXN1bHRQb2ludENhbGxiYWNrKSAqLyBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XG4gICAgICAgICAgICBjb25zdCBmaW5kZXIgPSBuZXcgRmluZGVyUGF0dGVybkZpbmRlcih0aGlzLmltYWdlLCB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2spO1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IGZpbmRlci5maW5kKGhpbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NGaW5kZXJQYXR0ZXJuSW5mbyhpbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzRmluZGVyUGF0dGVybkluZm8oaW5mbykge1xuICAgICAgICAgICAgY29uc3QgdG9wTGVmdCA9IGluZm8uZ2V0VG9wTGVmdCgpO1xuICAgICAgICAgICAgY29uc3QgdG9wUmlnaHQgPSBpbmZvLmdldFRvcFJpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBib3R0b21MZWZ0ID0gaW5mby5nZXRCb3R0b21MZWZ0KCk7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVTaXplID0gdGhpcy5jYWxjdWxhdGVNb2R1bGVTaXplKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0KTtcbiAgICAgICAgICAgIGlmIChtb2R1bGVTaXplIDwgMS4wKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCdObyBwYXR0ZXJuIGZvdW5kIGluIHByb2NjZXNzIGZpbmRlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IERldGVjdG9yJDIuY29tcHV0ZURpbWVuc2lvbih0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgbW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBwcm92aXNpb25hbFZlcnNpb24gPSBWZXJzaW9uJDEuZ2V0UHJvdmlzaW9uYWxWZXJzaW9uRm9yRGltZW5zaW9uKGRpbWVuc2lvbik7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVzQmV0d2VlbkZQQ2VudGVycyA9IHByb3Zpc2lvbmFsVmVyc2lvbi5nZXREaW1lbnNpb25Gb3JWZXJzaW9uKCkgLSA3O1xuICAgICAgICAgICAgbGV0IGFsaWdubWVudFBhdHRlcm4gPSBudWxsO1xuICAgICAgICAgICAgLy8gQW55dGhpbmcgYWJvdmUgdmVyc2lvbiAxIGhhcyBhbiBhbGlnbm1lbnQgcGF0dGVyblxuICAgICAgICAgICAgaWYgKHByb3Zpc2lvbmFsVmVyc2lvbi5nZXRBbGlnbm1lbnRQYXR0ZXJuQ2VudGVycygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBHdWVzcyB3aGVyZSBhIFwiYm90dG9tIHJpZ2h0XCIgZmluZGVyIHBhdHRlcm4gd291bGQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAgICAgY29uc3QgYm90dG9tUmlnaHRYID0gdG9wUmlnaHQuZ2V0WCgpIC0gdG9wTGVmdC5nZXRYKCkgKyBib3R0b21MZWZ0LmdldFgoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBib3R0b21SaWdodFkgPSB0b3BSaWdodC5nZXRZKCkgLSB0b3BMZWZ0LmdldFkoKSArIGJvdHRvbUxlZnQuZ2V0WSgpO1xuICAgICAgICAgICAgICAgIC8vIEVzdGltYXRlIHRoYXQgYWxpZ25tZW50IHBhdHRlcm4gaXMgY2xvc2VyIGJ5IDMgbW9kdWxlc1xuICAgICAgICAgICAgICAgIC8vIGZyb20gXCJib3R0b20gcmlnaHRcIiB0byBrbm93biB0b3AgbGVmdCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb25Ub1RvcExlZnQgPSAxLjAgLSAzLjAgLyBtb2R1bGVzQmV0d2VlbkZQQ2VudGVycztcbiAgICAgICAgICAgICAgICBjb25zdCBlc3RBbGlnbm1lbnRYID0gLyooaW50KSAqLyBNYXRoLmZsb29yKHRvcExlZnQuZ2V0WCgpICsgY29ycmVjdGlvblRvVG9wTGVmdCAqIChib3R0b21SaWdodFggLSB0b3BMZWZ0LmdldFgoKSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVzdEFsaWdubWVudFkgPSAvKihpbnQpICovIE1hdGguZmxvb3IodG9wTGVmdC5nZXRZKCkgKyBjb3JyZWN0aW9uVG9Ub3BMZWZ0ICogKGJvdHRvbVJpZ2h0WSAtIHRvcExlZnQuZ2V0WSgpKSk7XG4gICAgICAgICAgICAgICAgLy8gS2luZCBvZiBhcmJpdHJhcnkgLS0gZXhwYW5kIHNlYXJjaCByYWRpdXMgYmVmb3JlIGdpdmluZyB1cFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSA0OyBpIDw9IDE2OyBpIDw8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRQYXR0ZXJuID0gdGhpcy5maW5kQWxpZ25tZW50SW5SZWdpb24obW9kdWxlU2l6ZSwgZXN0QWxpZ25tZW50WCwgZXN0QWxpZ25tZW50WSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAocmUgLypOb3RGb3VuZEV4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZSBpbnN0YW5jZW9mIE5vdEZvdW5kRXhjZXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IG5leHQgcm91bmRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbGlnbm1lbnQgcGF0dGVybi4uLiB3ZWxsIHRyeSBhbnl3YXkgd2l0aG91dCBpdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gRGV0ZWN0b3IkMi5jcmVhdGVUcmFuc2Zvcm0odG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGFsaWdubWVudFBhdHRlcm4sIGRpbWVuc2lvbik7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gRGV0ZWN0b3IkMi5zYW1wbGVHcmlkKHRoaXMuaW1hZ2UsIHRyYW5zZm9ybSwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIGxldCBwb2ludHM7XG4gICAgICAgICAgICBpZiAoYWxpZ25tZW50UGF0dGVybiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IFtib3R0b21MZWZ0LCB0b3BMZWZ0LCB0b3BSaWdodF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBbYm90dG9tTGVmdCwgdG9wTGVmdCwgdG9wUmlnaHQsIGFsaWdubWVudFBhdHRlcm5dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXRlY3RvclJlc3VsdChiaXRzLCBwb2ludHMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjcmVhdGVUcmFuc2Zvcm0odG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGFsaWdubWVudFBhdHRlcm4sIGRpbWVuc2lvbiAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBkaW1NaW51c1RocmVlID0gZGltZW5zaW9uIC0gMy41O1xuICAgICAgICAgICAgbGV0IGJvdHRvbVJpZ2h0WDsgLypmbG9hdCovXG4gICAgICAgICAgICBsZXQgYm90dG9tUmlnaHRZOyAvKmZsb2F0Ki9cbiAgICAgICAgICAgIGxldCBzb3VyY2VCb3R0b21SaWdodFg7IC8qZmxvYXQqL1xuICAgICAgICAgICAgbGV0IHNvdXJjZUJvdHRvbVJpZ2h0WTsgLypmbG9hdCovXG4gICAgICAgICAgICBpZiAoYWxpZ25tZW50UGF0dGVybiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0WCA9IGFsaWdubWVudFBhdHRlcm4uZ2V0WCgpO1xuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0WSA9IGFsaWdubWVudFBhdHRlcm4uZ2V0WSgpO1xuICAgICAgICAgICAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0WCA9IGRpbU1pbnVzVGhyZWUgLSAzLjA7XG4gICAgICAgICAgICAgICAgc291cmNlQm90dG9tUmlnaHRZID0gc291cmNlQm90dG9tUmlnaHRYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgaGF2ZSBhbiBhbGlnbm1lbnQgcGF0dGVybiwganVzdCBtYWtlIHVwIHRoZSBib3R0b20tcmlnaHQgcG9pbnRcbiAgICAgICAgICAgICAgICBib3R0b21SaWdodFggPSAodG9wUmlnaHQuZ2V0WCgpIC0gdG9wTGVmdC5nZXRYKCkpICsgYm90dG9tTGVmdC5nZXRYKCk7XG4gICAgICAgICAgICAgICAgYm90dG9tUmlnaHRZID0gKHRvcFJpZ2h0LmdldFkoKSAtIHRvcExlZnQuZ2V0WSgpKSArIGJvdHRvbUxlZnQuZ2V0WSgpO1xuICAgICAgICAgICAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0WCA9IGRpbU1pbnVzVGhyZWU7XG4gICAgICAgICAgICAgICAgc291cmNlQm90dG9tUmlnaHRZID0gZGltTWludXNUaHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5xdWFkcmlsYXRlcmFsVG9RdWFkcmlsYXRlcmFsKDMuNSwgMy41LCBkaW1NaW51c1RocmVlLCAzLjUsIHNvdXJjZUJvdHRvbVJpZ2h0WCwgc291cmNlQm90dG9tUmlnaHRZLCAzLjUsIGRpbU1pbnVzVGhyZWUsIHRvcExlZnQuZ2V0WCgpLCB0b3BMZWZ0LmdldFkoKSwgdG9wUmlnaHQuZ2V0WCgpLCB0b3BSaWdodC5nZXRZKCksIGJvdHRvbVJpZ2h0WCwgYm90dG9tUmlnaHRZLCBib3R0b21MZWZ0LmdldFgoKSwgYm90dG9tTGVmdC5nZXRZKCkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBzYW1wbGVHcmlkKGltYWdlLCB0cmFuc2Zvcm0sIGRpbWVuc2lvbiAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVyID0gR3JpZFNhbXBsZXJJbnN0YW5jZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZXIuc2FtcGxlR3JpZFdpdGhUcmFuc2Zvcm0oaW1hZ2UsIGRpbWVuc2lvbiwgZGltZW5zaW9uLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5Db21wdXRlcyB0aGUgZGltZW5zaW9uIChudW1iZXIgb2YgbW9kdWxlcyBvbiBhIHNpemUpIG9mIHRoZSBRUiBDb2RlIGJhc2VkIG9uIHRoZSBwb3NpdGlvblxuICAgICAgICAgKiBvZiB0aGUgZmluZGVyIHBhdHRlcm5zIGFuZCBlc3RpbWF0ZWQgbW9kdWxlIHNpemUuPC9wPlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNvbXB1dGVEaW1lbnNpb24odG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIG1vZHVsZVNpemUgLypmbG9hdCovKSB7XG4gICAgICAgICAgICBjb25zdCB0bHRyQ2VudGVyc0RpbWVuc2lvbiA9IE1hdGhVdGlscy5yb3VuZChSZXN1bHRQb2ludC5kaXN0YW5jZSh0b3BMZWZ0LCB0b3BSaWdodCkgLyBtb2R1bGVTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IHRsYmxDZW50ZXJzRGltZW5zaW9uID0gTWF0aFV0aWxzLnJvdW5kKFJlc3VsdFBvaW50LmRpc3RhbmNlKHRvcExlZnQsIGJvdHRvbUxlZnQpIC8gbW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICBsZXQgZGltZW5zaW9uID0gTWF0aC5mbG9vcigodGx0ckNlbnRlcnNEaW1lbnNpb24gKyB0bGJsQ2VudGVyc0RpbWVuc2lvbikgLyAyKSArIDc7XG4gICAgICAgICAgICBzd2l0Y2ggKGRpbWVuc2lvbiAmIDB4MDMpIHsgLy8gbW9kIDRcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbisrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyAxPyBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb24tLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oJ0RpbWVuc2lvbnMgY291bGQgYmUgbm90IGZvdW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpbWVuc2lvbjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+Q29tcHV0ZXMgYW4gYXZlcmFnZSBlc3RpbWF0ZWQgbW9kdWxlIHNpemUgYmFzZWQgb24gZXN0aW1hdGVkIGRlcml2ZWQgZnJvbSB0aGUgcG9zaXRpb25zXG4gICAgICAgICAqIG9mIHRoZSB0aHJlZSBmaW5kZXIgcGF0dGVybnMuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdG9wTGVmdCBkZXRlY3RlZCB0b3AtbGVmdCBmaW5kZXIgcGF0dGVybiBjZW50ZXJcbiAgICAgICAgICogQHBhcmFtIHRvcFJpZ2h0IGRldGVjdGVkIHRvcC1yaWdodCBmaW5kZXIgcGF0dGVybiBjZW50ZXJcbiAgICAgICAgICogQHBhcmFtIGJvdHRvbUxlZnQgZGV0ZWN0ZWQgYm90dG9tLWxlZnQgZmluZGVyIHBhdHRlcm4gY2VudGVyXG4gICAgICAgICAqIEByZXR1cm4gZXN0aW1hdGVkIG1vZHVsZSBzaXplXG4gICAgICAgICAqL1xuICAgICAgICBjYWxjdWxhdGVNb2R1bGVTaXplKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0KSB7XG4gICAgICAgICAgICAvLyBUYWtlIHRoZSBhdmVyYWdlXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuY2FsY3VsYXRlTW9kdWxlU2l6ZU9uZVdheSh0b3BMZWZ0LCB0b3BSaWdodCkgK1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlTW9kdWxlU2l6ZU9uZVdheSh0b3BMZWZ0LCBib3R0b21MZWZ0KSkgLyAyLjA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkVzdGltYXRlcyBtb2R1bGUgc2l6ZSBiYXNlZCBvbiB0d28gZmluZGVyIHBhdHRlcm5zIC0tIGl0IHVzZXNcbiAgICAgICAgICoge0BsaW5rICNzaXplT2ZCbGFja1doaXRlQmxhY2tSdW5Cb3RoV2F5cyhpbnQsIGludCwgaW50LCBpbnQpfSB0byBmaWd1cmUgdGhlXG4gICAgICAgICAqIHdpZHRoIG9mIGVhY2gsIG1lYXN1cmluZyBhbG9uZyB0aGUgYXhpcyBiZXR3ZWVuIHRoZWlyIGNlbnRlcnMuPC9wPlxuICAgICAgICAgKi9cbiAgICAgICAgY2FsY3VsYXRlTW9kdWxlU2l6ZU9uZVdheShwYXR0ZXJuLCBvdGhlclBhdHRlcm4pIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNpemVFc3QxID0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW5Cb3RoV2F5cygvKihpbnQpICovIE1hdGguZmxvb3IocGF0dGVybi5nZXRYKCkpLCBcbiAgICAgICAgICAgIC8qKGludCkgKi8gTWF0aC5mbG9vcihwYXR0ZXJuLmdldFkoKSksIFxuICAgICAgICAgICAgLyooaW50KSAqLyBNYXRoLmZsb29yKG90aGVyUGF0dGVybi5nZXRYKCkpLCBcbiAgICAgICAgICAgIC8qKGludCkgKi8gTWF0aC5mbG9vcihvdGhlclBhdHRlcm4uZ2V0WSgpKSk7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVTaXplRXN0MiA9IHRoaXMuc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuQm90aFdheXMoLyooaW50KSAqLyBNYXRoLmZsb29yKG90aGVyUGF0dGVybi5nZXRYKCkpLCBcbiAgICAgICAgICAgIC8qKGludCkgKi8gTWF0aC5mbG9vcihvdGhlclBhdHRlcm4uZ2V0WSgpKSwgXG4gICAgICAgICAgICAvKihpbnQpICovIE1hdGguZmxvb3IocGF0dGVybi5nZXRYKCkpLCBcbiAgICAgICAgICAgIC8qKGludCkgKi8gTWF0aC5mbG9vcihwYXR0ZXJuLmdldFkoKSkpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG1vZHVsZVNpemVFc3QxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGVTaXplRXN0MiAvIDcuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05hTihtb2R1bGVTaXplRXN0MikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlU2l6ZUVzdDEgLyA3LjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdmVyYWdlIHRoZW0sIGFuZCBkaXZpZGUgYnkgNyBzaW5jZSB3ZSd2ZSBjb3VudGVkIHRoZSB3aWR0aCBvZiAzIGJsYWNrIG1vZHVsZXMsXG4gICAgICAgICAgICAvLyBhbmQgMSB3aGl0ZSBhbmQgMSBibGFjayBtb2R1bGUgb24gZWl0aGVyIHNpZGUuIEVyZ28sIGRpdmlkZSBzdW0gYnkgMTQuXG4gICAgICAgICAgICByZXR1cm4gKG1vZHVsZVNpemVFc3QxICsgbW9kdWxlU2l6ZUVzdDIpIC8gMTQuMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIHtAbGluayAjc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKGludCwgaW50LCBpbnQsIGludCl9OyBjb21wdXRlcyB0aGUgdG90YWwgd2lkdGggb2ZcbiAgICAgICAgICogYSBmaW5kZXIgcGF0dGVybiBieSBsb29raW5nIGZvciBhIGJsYWNrLXdoaXRlLWJsYWNrIHJ1biBmcm9tIHRoZSBjZW50ZXIgaW4gdGhlIGRpcmVjdGlvblxuICAgICAgICAgKiBvZiBhbm90aGVyIHBvaW50IChhbm90aGVyIGZpbmRlciBwYXR0ZXJuIGNlbnRlciksIGFuZCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIHRvby5cbiAgICAgICAgICovXG4gICAgICAgIHNpemVPZkJsYWNrV2hpdGVCbGFja1J1bkJvdGhXYXlzKGZyb21YIC8qaW50Ki8sIGZyb21ZIC8qaW50Ki8sIHRvWCAvKmludCovLCB0b1kgLyppbnQqLykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKGZyb21YLCBmcm9tWSwgdG9YLCB0b1kpO1xuICAgICAgICAgICAgLy8gTm93IGNvdW50IG90aGVyIHdheSAtLSBkb24ndCBydW4gb2ZmIGltYWdlIHRob3VnaCBvZiBjb3Vyc2VcbiAgICAgICAgICAgIGxldCBzY2FsZSA9IDEuMDtcbiAgICAgICAgICAgIGxldCBvdGhlclRvWCA9IGZyb21YIC0gKHRvWCAtIGZyb21YKTtcbiAgICAgICAgICAgIGlmIChvdGhlclRvWCA8IDApIHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9IGZyb21YIC8gLyooZmxvYXQpICovIChmcm9tWCAtIG90aGVyVG9YKTtcbiAgICAgICAgICAgICAgICBvdGhlclRvWCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdGhlclRvWCA+PSB0aGlzLmltYWdlLmdldFdpZHRoKCkpIHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9ICh0aGlzLmltYWdlLmdldFdpZHRoKCkgLSAxIC0gZnJvbVgpIC8gLyooZmxvYXQpICovIChvdGhlclRvWCAtIGZyb21YKTtcbiAgICAgICAgICAgICAgICBvdGhlclRvWCA9IHRoaXMuaW1hZ2UuZ2V0V2lkdGgoKSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb3RoZXJUb1kgPSAvKihpbnQpICovIE1hdGguZmxvb3IoZnJvbVkgLSAodG9ZIC0gZnJvbVkpICogc2NhbGUpO1xuICAgICAgICAgICAgc2NhbGUgPSAxLjA7XG4gICAgICAgICAgICBpZiAob3RoZXJUb1kgPCAwKSB7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSBmcm9tWSAvIC8qKGZsb2F0KSAqLyAoZnJvbVkgLSBvdGhlclRvWSk7XG4gICAgICAgICAgICAgICAgb3RoZXJUb1kgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3RoZXJUb1kgPj0gdGhpcy5pbWFnZS5nZXRIZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgIHNjYWxlID0gKHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCkgLSAxIC0gZnJvbVkpIC8gLyooZmxvYXQpICovIChvdGhlclRvWSAtIGZyb21ZKTtcbiAgICAgICAgICAgICAgICBvdGhlclRvWSA9IHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCkgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3RoZXJUb1ggPSAvKihpbnQpICovIE1hdGguZmxvb3IoZnJvbVggKyAob3RoZXJUb1ggLSBmcm9tWCkgKiBzY2FsZSk7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW4oZnJvbVgsIGZyb21ZLCBvdGhlclRvWCwgb3RoZXJUb1kpO1xuICAgICAgICAgICAgLy8gTWlkZGxlIHBpeGVsIGlzIGRvdWJsZS1jb3VudGVkIHRoaXMgd2F5OyBzdWJ0cmFjdCAxXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0IC0gMS4wO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5UaGlzIG1ldGhvZCB0cmFjZXMgYSBsaW5lIGZyb20gYSBwb2ludCBpbiB0aGUgaW1hZ2UsIGluIHRoZSBkaXJlY3Rpb24gdG93YXJkcyBhbm90aGVyIHBvaW50LlxuICAgICAgICAgKiBJdCBiZWdpbnMgaW4gYSBibGFjayByZWdpb24sIGFuZCBrZWVwcyBnb2luZyB1bnRpbCBpdCBmaW5kcyB3aGl0ZSwgdGhlbiBibGFjaywgdGhlbiB3aGl0ZSBhZ2Fpbi5cbiAgICAgICAgICogSXQgcmVwb3J0cyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgc3RhcnQgdG8gdGhpcyBwb2ludC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlRoaXMgaXMgdXNlZCB3aGVuIGZpZ3VyaW5nIG91dCBob3cgd2lkZSBhIGZpbmRlciBwYXR0ZXJuIGlzLCB3aGVuIHRoZSBmaW5kZXIgcGF0dGVyblxuICAgICAgICAgKiBtYXkgYmUgc2tld2VkIG9yIHJvdGF0ZWQuPC9wPlxuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKGZyb21YIC8qaW50Ki8sIGZyb21ZIC8qaW50Ki8sIHRvWCAvKmludCovLCB0b1kgLyppbnQqLykge1xuICAgICAgICAgICAgLy8gTWlsZCB2YXJpYW50IG9mIEJyZXNlbmhhbSdzIGFsZ29yaXRobVxuICAgICAgICAgICAgLy8gc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJlc2VuaGFtJ3NfbGluZV9hbGdvcml0aG1cbiAgICAgICAgICAgIGNvbnN0IHN0ZWVwID0gTWF0aC5hYnModG9ZIC0gZnJvbVkpID4gTWF0aC5hYnModG9YIC0gZnJvbVgpO1xuICAgICAgICAgICAgaWYgKHN0ZWVwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBmcm9tWDtcbiAgICAgICAgICAgICAgICBmcm9tWCA9IGZyb21ZO1xuICAgICAgICAgICAgICAgIGZyb21ZID0gdGVtcDtcbiAgICAgICAgICAgICAgICB0ZW1wID0gdG9YO1xuICAgICAgICAgICAgICAgIHRvWCA9IHRvWTtcbiAgICAgICAgICAgICAgICB0b1kgPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZHggPSBNYXRoLmFicyh0b1ggLSBmcm9tWCk7XG4gICAgICAgICAgICBjb25zdCBkeSA9IE1hdGguYWJzKHRvWSAtIGZyb21ZKTtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IC1keCAvIDI7XG4gICAgICAgICAgICBjb25zdCB4c3RlcCA9IGZyb21YIDwgdG9YID8gMSA6IC0xO1xuICAgICAgICAgICAgY29uc3QgeXN0ZXAgPSBmcm9tWSA8IHRvWSA/IDEgOiAtMTtcbiAgICAgICAgICAgIC8vIEluIGJsYWNrIHBpeGVscywgbG9va2luZyBmb3Igd2hpdGUsIGZpcnN0IG9yIHNlY29uZCB0aW1lLlxuICAgICAgICAgICAgbGV0IHN0YXRlID0gMDtcbiAgICAgICAgICAgIC8vIExvb3AgdXAgdW50aWwgeCA9PSB0b1gsIGJ1dCBub3QgYmV5b25kXG4gICAgICAgICAgICBjb25zdCB4TGltaXQgPSB0b1ggKyB4c3RlcDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSBmcm9tWCwgeSA9IGZyb21ZOyB4ICE9PSB4TGltaXQ7IHggKz0geHN0ZXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFsWCA9IHN0ZWVwID8geSA6IHg7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhbFkgPSBzdGVlcCA/IHggOiB5O1xuICAgICAgICAgICAgICAgIC8vIERvZXMgY3VycmVudCBwaXhlbCBtZWFuIHdlIGhhdmUgbW92ZWQgd2hpdGUgdG8gYmxhY2sgb3IgdmljZSB2ZXJzYT9cbiAgICAgICAgICAgICAgICAvLyBTY2FubmluZyBibGFjayBpbiBzdGF0ZSAwLDIgYW5kIHdoaXRlIGluIHN0YXRlIDEsIHNvIGlmIHdlIGZpbmQgdGhlIHdyb25nXG4gICAgICAgICAgICAgICAgLy8gY29sb3IsIGFkdmFuY2UgdG8gbmV4dCBzdGF0ZSBvciBlbmQgaWYgd2UgYXJlIGluIHN0YXRlIDIgYWxyZWFkeVxuICAgICAgICAgICAgICAgIGlmICgoc3RhdGUgPT09IDEpID09PSB0aGlzLmltYWdlLmdldChyZWFsWCwgcmVhbFkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5kaXN0YW5jZSh4LCB5LCBmcm9tWCwgZnJvbVkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9yICs9IGR5O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPT09IHRvWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeSArPSB5c3RlcDtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgLT0gZHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm91bmQgYmxhY2std2hpdGUtYmxhY2s7IGdpdmUgdGhlIGJlbmVmaXQgb2YgdGhlIGRvdWJ0IHRoYXQgdGhlIG5leHQgcGl4ZWwgb3V0c2lkZSB0aGUgaW1hZ2VcbiAgICAgICAgICAgIC8vIGlzIFwid2hpdGVcIiBzbyB0aGlzIGxhc3QgcG9pbnQgYXQgKHRvWCt4U3RlcCx0b1kpIGlzIHRoZSByaWdodCBlbmRpbmcuIFRoaXMgaXMgcmVhbGx5IGFcbiAgICAgICAgICAgIC8vIHNtYWxsIGFwcHJveGltYXRpb247ICh0b1greFN0ZXAsdG9ZK3lTdGVwKSBtaWdodCBiZSByZWFsbHkgY29ycmVjdC4gSWdub3JlIHRoaXMuXG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzLmRpc3RhbmNlKHRvWCArIHhzdGVwLCB0b1ksIGZyb21YLCBmcm9tWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlIHdlIGRpZG4ndCBmaW5kIGV2ZW4gYmxhY2std2hpdGUtYmxhY2s7IG5vIGVzdGltYXRlIGlzIHJlYWxseSBwb3NzaWJsZVxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+QXR0ZW1wdHMgdG8gbG9jYXRlIGFuIGFsaWdubWVudCBwYXR0ZXJuIGluIGEgbGltaXRlZCByZWdpb24gb2YgdGhlIGltYWdlLCB3aGljaCBpc1xuICAgICAgICAgKiBndWVzc2VkIHRvIGNvbnRhaW4gaXQuIFRoaXMgbWV0aG9kIHVzZXMge0BsaW5rIEFsaWdubWVudFBhdHRlcm59LjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG92ZXJhbGxFc3RNb2R1bGVTaXplIGVzdGltYXRlZCBtb2R1bGUgc2l6ZSBzbyBmYXJcbiAgICAgICAgICogQHBhcmFtIGVzdEFsaWdubWVudFggeCBjb29yZGluYXRlIG9mIGNlbnRlciBvZiBhcmVhIHByb2JhYmx5IGNvbnRhaW5pbmcgYWxpZ25tZW50IHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIGVzdEFsaWdubWVudFkgeSBjb29yZGluYXRlIG9mIGFib3ZlXG4gICAgICAgICAqIEBwYXJhbSBhbGxvd2FuY2VGYWN0b3IgbnVtYmVyIG9mIHBpeGVscyBpbiBhbGwgZGlyZWN0aW9ucyB0byBzZWFyY2ggZnJvbSB0aGUgY2VudGVyXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIEFsaWdubWVudFBhdHRlcm59IGlmIGZvdW5kLCBvciBudWxsIG90aGVyd2lzZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJzIGR1cmluZyBkZXRlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGZpbmRBbGlnbm1lbnRJblJlZ2lvbihvdmVyYWxsRXN0TW9kdWxlU2l6ZSAvKmZsb2F0Ki8sIGVzdEFsaWdubWVudFggLyppbnQqLywgZXN0QWxpZ25tZW50WSAvKmludCovLCBhbGxvd2FuY2VGYWN0b3IgLypmbG9hdCovKSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciBhbiBhbGlnbm1lbnQgcGF0dGVybiAoMyBtb2R1bGVzIGluIHNpemUpIGFyb3VuZCB3aGVyZSBpdFxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlXG4gICAgICAgICAgICBjb25zdCBhbGxvd2FuY2UgPSAvKihpbnQpICovIE1hdGguZmxvb3IoYWxsb3dhbmNlRmFjdG9yICogb3ZlcmFsbEVzdE1vZHVsZVNpemUpO1xuICAgICAgICAgICAgY29uc3QgYWxpZ25tZW50QXJlYUxlZnRYID0gTWF0aC5tYXgoMCwgZXN0QWxpZ25tZW50WCAtIGFsbG93YW5jZSk7XG4gICAgICAgICAgICBjb25zdCBhbGlnbm1lbnRBcmVhUmlnaHRYID0gTWF0aC5taW4odGhpcy5pbWFnZS5nZXRXaWR0aCgpIC0gMSwgZXN0QWxpZ25tZW50WCArIGFsbG93YW5jZSk7XG4gICAgICAgICAgICBpZiAoYWxpZ25tZW50QXJlYVJpZ2h0WCAtIGFsaWdubWVudEFyZWFMZWZ0WCA8IG92ZXJhbGxFc3RNb2R1bGVTaXplICogMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbignQWxpZ25tZW50IHRvcCBleGNlZWRzIGVzdGltYXRlZCBtb2R1bGUgc2l6ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFsaWdubWVudEFyZWFUb3BZID0gTWF0aC5tYXgoMCwgZXN0QWxpZ25tZW50WSAtIGFsbG93YW5jZSk7XG4gICAgICAgICAgICBjb25zdCBhbGlnbm1lbnRBcmVhQm90dG9tWSA9IE1hdGgubWluKHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCkgLSAxLCBlc3RBbGlnbm1lbnRZICsgYWxsb3dhbmNlKTtcbiAgICAgICAgICAgIGlmIChhbGlnbm1lbnRBcmVhQm90dG9tWSAtIGFsaWdubWVudEFyZWFUb3BZIDwgb3ZlcmFsbEVzdE1vZHVsZVNpemUgKiAzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCdBbGlnbm1lbnQgYm90dG9tIGV4Y2VlZHMgZXN0aW1hdGVkIG1vZHVsZSBzaXplLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWxpZ25tZW50RmluZGVyID0gbmV3IEFsaWdubWVudFBhdHRlcm5GaW5kZXIodGhpcy5pbWFnZSwgYWxpZ25tZW50QXJlYUxlZnRYLCBhbGlnbm1lbnRBcmVhVG9wWSwgYWxpZ25tZW50QXJlYVJpZ2h0WCAtIGFsaWdubWVudEFyZWFMZWZ0WCwgYWxpZ25tZW50QXJlYUJvdHRvbVkgLSBhbGlnbm1lbnRBcmVhVG9wWSwgb3ZlcmFsbEVzdE1vZHVsZVNpemUsIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gYWxpZ25tZW50RmluZGVyLmZpbmQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkxpc3Q7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4gICAgLyoqXG4gICAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBjYW4gZGV0ZWN0IGFuZCBkZWNvZGUgUVIgQ29kZXMgaW4gYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIFFSQ29kZVJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IERlY29kZXIkMigpO1xuICAgICAgICB9XG4gICAgICAgIGdldERlY29kZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2NhdGVzIGFuZCBkZWNvZGVzIGEgUVIgY29kZSBpbiBhbiBpbWFnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBhIHJlcHJlc2VudGluZzogc3RyaW5nIHRoZSBjb250ZW50IGVuY29kZWQgYnkgdGhlIFFSIGNvZGVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBhIFFSIGNvZGUgY2Fubm90IGJlIGZvdW5kXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgUVIgY29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHNcbiAgICAgICAgICovXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgLy8gcHVibGljIGRlY29kZShpbWFnZTogQmluYXJ5Qml0bWFwKTogUmVzdWx0IC8qdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uLCBDaGVja3N1bUV4Y2VwdGlvbiwgRm9ybWF0RXhjZXB0aW9uICovIHtcbiAgICAgICAgLy8gICByZXR1cm4gdGhpcy5kZWNvZGUoaW1hZ2UsIG51bGwpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBkZWNvZGUoaW1hZ2UsIGhpbnRzKSB7XG4gICAgICAgICAgICBsZXQgZGVjb2RlclJlc3VsdDtcbiAgICAgICAgICAgIGxldCBwb2ludHM7XG4gICAgICAgICAgICBpZiAoaGludHMgIT09IHVuZGVmaW5lZCAmJiBoaW50cyAhPT0gbnVsbCAmJiB1bmRlZmluZWQgIT09IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlBVUkVfQkFSQ09ERSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaXRzID0gUVJDb2RlUmVhZGVyLmV4dHJhY3RQdXJlQml0cyhpbWFnZS5nZXRCbGFja01hdHJpeCgpKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVyUmVzdWx0ID0gdGhpcy5kZWNvZGVyLmRlY29kZUJpdE1hdHJpeChiaXRzLCBoaW50cyk7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gUVJDb2RlUmVhZGVyLk5PX1BPSU5UUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRldGVjdG9yUmVzdWx0ID0gbmV3IERldGVjdG9yJDIoaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKSkuZGV0ZWN0KGhpbnRzKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVyUmVzdWx0ID0gdGhpcy5kZWNvZGVyLmRlY29kZUJpdE1hdHJpeChkZXRlY3RvclJlc3VsdC5nZXRCaXRzKCksIGhpbnRzKTtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBkZXRlY3RvclJlc3VsdC5nZXRQb2ludHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBjb2RlIHdhcyBtaXJyb3JlZDogc3dhcCB0aGUgYm90dG9tLWxlZnQgYW5kIHRoZSB0b3AtcmlnaHQgcG9pbnRzLlxuICAgICAgICAgICAgaWYgKGRlY29kZXJSZXN1bHQuZ2V0T3RoZXIoKSBpbnN0YW5jZW9mIFFSQ29kZURlY29kZXJNZXRhRGF0YSkge1xuICAgICAgICAgICAgICAgIGRlY29kZXJSZXN1bHQuZ2V0T3RoZXIoKS5hcHBseU1pcnJvcmVkQ29ycmVjdGlvbihwb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFJlc3VsdChkZWNvZGVyUmVzdWx0LmdldFRleHQoKSwgZGVjb2RlclJlc3VsdC5nZXRSYXdCeXRlcygpLCB1bmRlZmluZWQsIHBvaW50cywgQmFyY29kZUZvcm1hdCQxLlFSX0NPREUsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCBieXRlU2VnbWVudHMgPSBkZWNvZGVyUmVzdWx0LmdldEJ5dGVTZWdtZW50cygpO1xuICAgICAgICAgICAgaWYgKGJ5dGVTZWdtZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5CWVRFX1NFR01FTlRTLCBieXRlU2VnbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZWNMZXZlbCA9IGRlY29kZXJSZXN1bHQuZ2V0RUNMZXZlbCgpO1xuICAgICAgICAgICAgaWYgKGVjTGV2ZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlJDEuRVJST1JfQ09SUkVDVElPTl9MRVZFTCwgZWNMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjb2RlclJlc3VsdC5oYXNTdHJ1Y3R1cmVkQXBwZW5kKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlJDEuU1RSVUNUVVJFRF9BUFBFTkRfU0VRVUVOQ0UsIGRlY29kZXJSZXN1bHQuZ2V0U3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5TVFJVQ1RVUkVEX0FQUEVORF9QQVJJVFksIGRlY29kZXJSZXN1bHQuZ2V0U3RydWN0dXJlZEFwcGVuZFBhcml0eSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgZGV0ZWN0cyBhIGNvZGUgaW4gYSBcInB1cmVcIiBpbWFnZSAtLSB0aGF0IGlzLCBwdXJlIG1vbm9jaHJvbWUgaW1hZ2VcbiAgICAgICAgICogd2hpY2ggY29udGFpbnMgb25seSBhbiB1bnJvdGF0ZWQsIHVuc2tld2VkLCBpbWFnZSBvZiBhIGNvZGUsIHdpdGggc29tZSB3aGl0ZSBib3JkZXJcbiAgICAgICAgICogYXJvdW5kIGl0LiBUaGlzIGlzIGEgc3BlY2lhbGl6ZWQgbWV0aG9kIHRoYXQgd29ya3MgZXhjZXB0aW9uYWxseSBmYXN0IGluIHRoaXMgc3BlY2lhbFxuICAgICAgICAgKiBjYXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc2VlIGNvbS5nb29nbGUuenhpbmcuZGF0YW1hdHJpeC5EYXRhTWF0cml4UmVhZGVyI2V4dHJhY3RQdXJlQml0cyhCaXRNYXRyaXgpXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZXh0cmFjdFB1cmVCaXRzKGltYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0VG9wQmxhY2sgPSBpbWFnZS5nZXRUb3BMZWZ0T25CaXQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0Qm90dG9tQmxhY2sgPSBpbWFnZS5nZXRCb3R0b21SaWdodE9uQml0KCk7XG4gICAgICAgICAgICBpZiAobGVmdFRvcEJsYWNrID09PSBudWxsIHx8IHJpZ2h0Qm90dG9tQmxhY2sgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNpemUgPSB0aGlzLm1vZHVsZVNpemUobGVmdFRvcEJsYWNrLCBpbWFnZSk7XG4gICAgICAgICAgICBsZXQgdG9wID0gbGVmdFRvcEJsYWNrWzFdO1xuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IHJpZ2h0Qm90dG9tQmxhY2tbMV07XG4gICAgICAgICAgICBsZXQgbGVmdCA9IGxlZnRUb3BCbGFja1swXTtcbiAgICAgICAgICAgIGxldCByaWdodCA9IHJpZ2h0Qm90dG9tQmxhY2tbMF07XG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2shXG4gICAgICAgICAgICBpZiAobGVmdCA+PSByaWdodCB8fCB0b3AgPj0gYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm90dG9tIC0gdG9wICE9PSByaWdodCAtIGxlZnQpIHtcbiAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UsIHdoZXJlIGJvdHRvbS1yaWdodCBtb2R1bGUgd2Fzbid0IGJsYWNrIHNvIHdlIGZvdW5kIHNvbWV0aGluZyBlbHNlIGluIHRoZSBsYXN0IHJvd1xuICAgICAgICAgICAgICAgIC8vIEFzc3VtZSBpdCdzIGEgc3F1YXJlLCBzbyB1c2UgaGVpZ2h0IGFzIHRoZSB3aWR0aFxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIChib3R0b20gLSB0b3ApO1xuICAgICAgICAgICAgICAgIGlmIChyaWdodCA+PSBpbWFnZS5nZXRXaWR0aCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFib3J0IGlmIHRoYXQgd291bGQgbm90IG1ha2Ugc2Vuc2UgLS0gb2ZmIGltYWdlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeFdpZHRoID0gTWF0aC5yb3VuZCgocmlnaHQgLSBsZWZ0ICsgMSkgLyBtb2R1bGVTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeEhlaWdodCA9IE1hdGgucm91bmQoKGJvdHRvbSAtIHRvcCArIDEpIC8gbW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICBpZiAobWF0cml4V2lkdGggPD0gMCB8fCBtYXRyaXhIZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdHJpeEhlaWdodCAhPT0gbWF0cml4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHBvc3NpYmx5IGRlY29kZSBzcXVhcmUgcmVnaW9uc1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHVzaCBpbiB0aGUgXCJib3JkZXJcIiBieSBoYWxmIHRoZSBtb2R1bGUgd2lkdGggc28gdGhhdCB3ZSBzdGFydFxuICAgICAgICAgICAgLy8gc2FtcGxpbmcgaW4gdGhlIG1pZGRsZSBvZiB0aGUgbW9kdWxlLiBKdXN0IGluIGNhc2UgdGhlIGltYWdlIGlzIGFcbiAgICAgICAgICAgIC8vIGxpdHRsZSBvZmYsIHRoaXMgd2lsbCBoZWxwIHJlY292ZXIuXG4gICAgICAgICAgICBjb25zdCBudWRnZSA9IC8qKGludCkgKi8gTWF0aC5mbG9vcihtb2R1bGVTaXplIC8gMi4wKTtcbiAgICAgICAgICAgIHRvcCArPSBudWRnZTtcbiAgICAgICAgICAgIGxlZnQgKz0gbnVkZ2U7XG4gICAgICAgICAgICAvLyBCdXQgY2FyZWZ1bCB0aGF0IHRoaXMgZG9lcyBub3Qgc2FtcGxlIG9mZiB0aGUgZWRnZVxuICAgICAgICAgICAgLy8gXCJyaWdodFwiIGlzIHRoZSBmYXJ0aGVzdC1yaWdodCB2YWxpZCBwaXhlbCBsb2NhdGlvbiAtLSByaWdodCsxIGlzIG5vdCBuZWNlc3NhcmlseVxuICAgICAgICAgICAgLy8gVGhpcyBpcyBwb3NpdGl2ZSBieSBob3cgbXVjaCB0aGUgaW5uZXIgeCBsb29wIGJlbG93IHdvdWxkIGJlIHRvbyBsYXJnZVxuICAgICAgICAgICAgY29uc3QgbnVkZ2VkVG9vRmFyUmlnaHQgPSBsZWZ0ICsgLyooaW50KSAqLyBNYXRoLmZsb29yKChtYXRyaXhXaWR0aCAtIDEpICogbW9kdWxlU2l6ZSkgLSByaWdodDtcbiAgICAgICAgICAgIGlmIChudWRnZWRUb29GYXJSaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobnVkZ2VkVG9vRmFyUmlnaHQgPiBudWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZWl0aGVyIHdheSBmaXRzOyBhYm9ydFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVmdCAtPSBudWRnZWRUb29GYXJSaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNlZSBsb2dpYyBhYm92ZVxuICAgICAgICAgICAgY29uc3QgbnVkZ2VkVG9vRmFyRG93biA9IHRvcCArIC8qKGludCkgKi8gTWF0aC5mbG9vcigobWF0cml4SGVpZ2h0IC0gMSkgKiBtb2R1bGVTaXplKSAtIGJvdHRvbTtcbiAgICAgICAgICAgIGlmIChudWRnZWRUb29GYXJEb3duID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChudWRnZWRUb29GYXJEb3duID4gbnVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmVpdGhlciB3YXkgZml0czsgYWJvcnRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvcCAtPSBudWRnZWRUb29GYXJEb3duO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IGp1c3QgcmVhZCBvZmYgdGhlIGJpdHNcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBuZXcgQml0TWF0cml4KG1hdHJpeFdpZHRoLCBtYXRyaXhIZWlnaHQpO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBtYXRyaXhIZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlPZmZzZXQgPSB0b3AgKyAvKihpbnQpICovIE1hdGguZmxvb3IoeSAqIG1vZHVsZVNpemUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbWF0cml4V2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGxlZnQgKyAvKihpbnQpICovIE1hdGguZmxvb3IoeCAqIG1vZHVsZVNpemUpLCBpT2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYml0cy5zZXQoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbW9kdWxlU2l6ZShsZWZ0VG9wQmxhY2ssIGltYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGxldCB4ID0gbGVmdFRvcEJsYWNrWzBdO1xuICAgICAgICAgICAgbGV0IHkgPSBsZWZ0VG9wQmxhY2tbMV07XG4gICAgICAgICAgICBsZXQgaW5CbGFjayA9IHRydWU7XG4gICAgICAgICAgICBsZXQgdHJhbnNpdGlvbnMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHggPCB3aWR0aCAmJiB5IDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGluQmxhY2sgIT09IGltYWdlLmdldCh4LCB5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKyt0cmFuc2l0aW9ucyA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5CbGFjayA9ICFpbkJsYWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4Kys7XG4gICAgICAgICAgICAgICAgeSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPT09IHdpZHRoIHx8IHkgPT09IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICh4IC0gbGVmdFRvcEJsYWNrWzBdKSAvIDcuMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBRUkNvZGVSZWFkZXIuTk9fUE9JTlRTID0gbmV3IEFycmF5KCk7XG5cbiAgICAvKlxuICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICpcbiAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAqXG4gICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICpcbiAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIFNJVEEgTGFiIChrZXZpbi5vc3VsbGl2YW5Ac2l0YS5hZXJvKVxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qcHVibGljIGZpbmFsKi8gY2xhc3MgUERGNDE3Q29tbW9uIHtcbiAgICAgICAgUERGNDE3Q29tbW9uKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gbW9kdWxlQml0Q291bnQgdmFsdWVzIHRvIHN1bVxuICAgICAgICAgKiBAcmV0dXJuIHN1bSBvZiB2YWx1ZXNcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgY2FsbCB7QGxpbmsgTWF0aFV0aWxzI3N1bShpbnRbXSl9XG4gICAgICAgICAqL1xuICAgICAgICAvLyBARGVwcmVjYXRlZFxuICAgICAgICBzdGF0aWMgZ2V0Qml0Q291bnRTdW0obW9kdWxlQml0Q291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMuc3VtKG1vZHVsZUJpdENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgdG9JbnRBcnJheShsaXN0KSB7XG4gICAgICAgICAgICBpZiAobGlzdCA9PSBudWxsIHx8ICFsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQREY0MTdDb21tb24uRU1QVFlfSU5UX0FSUkFZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkobGlzdC5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbnRlZ2VyIG9mIGxpc3QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IGludGVnZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gc3ltYm9sIGVuY29kZWQgc3ltYm9sIHRvIHRyYW5zbGF0ZSB0byBhIGNvZGV3b3JkXG4gICAgICAgICAqIEByZXR1cm4gdGhlIGNvZGV3b3JkIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHN5bWJvbC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRDb2Rld29yZChzeW1ib2wgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgaSA9IEFycmF5cy5iaW5hcnlTZWFyY2goUERGNDE3Q29tbW9uLlNZTUJPTF9UQUJMRSwgc3ltYm9sICYgMHgzRkZGRik7XG4gICAgICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFBERjQxN0NvbW1vbi5DT0RFV09SRF9UQUJMRVtpXSAtIDEpICUgUERGNDE3Q29tbW9uLk5VTUJFUl9PRl9DT0RFV09SRFM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUERGNDE3Q29tbW9uLk5VTUJFUl9PRl9DT0RFV09SRFMgPSA5Mjk7XG4gICAgLy8gTWF4aW11bSBDb2Rld29yZHMgKERhdGEgKyBFcnJvcikuXG4gICAgUERGNDE3Q29tbW9uLk1BWF9DT0RFV09SRFNfSU5fQkFSQ09ERSA9IFBERjQxN0NvbW1vbi5OVU1CRVJfT0ZfQ09ERVdPUkRTIC0gMTtcbiAgICBQREY0MTdDb21tb24uTUlOX1JPV1NfSU5fQkFSQ09ERSA9IDM7XG4gICAgUERGNDE3Q29tbW9uLk1BWF9ST1dTX0lOX0JBUkNPREUgPSA5MDtcbiAgICAvLyBPbmUgbGVmdCByb3cgaW5kaWNhdGlvbiBjb2x1bW4gKyBtYXggMzAgZGF0YSBjb2x1bW5zICsgb25lIHJpZ2h0IHJvdyBpbmRpY2F0b3IgY29sdW1uXG4gICAgLy8gcHVibGljIHN0YXRpYyAvKmZpbmFsKi8gTUFYX0NPREVXT1JEU19JTl9ST1c6IC8qaW50Ki8gbnVtYmVyID0gMzI7XG4gICAgUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fQ09ERVdPUkQgPSAxNztcbiAgICBQREY0MTdDb21tb24uTU9EVUxFU19JTl9TVE9QX1BBVFRFUk4gPSAxODtcbiAgICBQREY0MTdDb21tb24uQkFSU19JTl9NT0RVTEUgPSA4O1xuICAgIFBERjQxN0NvbW1vbi5FTVBUWV9JTlRfQVJSQVkgPSBuZXcgSW50MzJBcnJheShbXSk7XG4gICAgLyoqXG4gICAgICogVGhlIHNvcnRlZCB0YWJsZSBvZiBhbGwgcG9zc2libGUgc3ltYm9scy4gRXh0cmFjdGVkIGZyb20gdGhlIFBERjQxN1xuICAgICAqIHNwZWNpZmljYXRpb24uIFRoZSBpbmRleCBvZiBhIHN5bWJvbCBpbiB0aGlzIHRhYmxlIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgICAqIGluZGV4IGludG8gdGhlIGNvZGV3b3JkIHRhYmxlLlxuICAgICAqL1xuICAgIFBERjQxN0NvbW1vbi5TWU1CT0xfVEFCTEUgPSBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAweDEwMjVlLCAweDEwMjdhLCAweDEwMjllLCAweDEwMmJjLCAweDEwMmYyLCAweDEwMmY0LCAweDEwMzJlLCAweDEwMzRlLCAweDEwMzVjLCAweDEwMzk2LCAweDEwM2E2LCAweDEwM2FjLFxuICAgICAgICAweDEwNDIyLCAweDEwNDI4LCAweDEwNDM2LCAweDEwNDQyLCAweDEwNDQ0LCAweDEwNDQ4LCAweDEwNDUwLCAweDEwNDVlLCAweDEwNDY2LCAweDEwNDZjLCAweDEwNDdhLCAweDEwNDgyLFxuICAgICAgICAweDEwNDllLCAweDEwNGEwLCAweDEwNGJjLCAweDEwNGM2LCAweDEwNGQ4LCAweDEwNGVlLCAweDEwNGYyLCAweDEwNGY0LCAweDEwNTA0LCAweDEwNTA4LCAweDEwNTEwLCAweDEwNTFlLFxuICAgICAgICAweDEwNTIwLCAweDEwNTNjLCAweDEwNTQwLCAweDEwNTc4LCAweDEwNTg2LCAweDEwNThjLCAweDEwNTk4LCAweDEwNWIwLCAweDEwNWJlLCAweDEwNWNlLCAweDEwNWRjLCAweDEwNWUyLFxuICAgICAgICAweDEwNWU0LCAweDEwNWU4LCAweDEwNWY2LCAweDEwNjJlLCAweDEwNjRlLCAweDEwNjVjLCAweDEwNjhlLCAweDEwNjljLCAweDEwNmI4LCAweDEwNmRlLCAweDEwNmZhLCAweDEwNzE2LFxuICAgICAgICAweDEwNzI2LCAweDEwNzJjLCAweDEwNzQ2LCAweDEwNzRjLCAweDEwNzU4LCAweDEwNzZlLCAweDEwNzkyLCAweDEwNzk0LCAweDEwN2EyLCAweDEwN2E0LCAweDEwN2E4LCAweDEwN2I2LFxuICAgICAgICAweDEwODIyLCAweDEwODI4LCAweDEwODQyLCAweDEwODQ4LCAweDEwODUwLCAweDEwODVlLCAweDEwODY2LCAweDEwODZjLCAweDEwODdhLCAweDEwODgyLCAweDEwODg0LCAweDEwODkwLFxuICAgICAgICAweDEwODllLCAweDEwOGEwLCAweDEwOGJjLCAweDEwOGM2LCAweDEwOGNjLCAweDEwOGQ4LCAweDEwOGVlLCAweDEwOGYyLCAweDEwOGY0LCAweDEwOTAyLCAweDEwOTA4LCAweDEwOTFlLFxuICAgICAgICAweDEwOTIwLCAweDEwOTNjLCAweDEwOTQwLCAweDEwOTc4LCAweDEwOTg2LCAweDEwOTk4LCAweDEwOWIwLCAweDEwOWJlLCAweDEwOWNlLCAweDEwOWRjLCAweDEwOWUyLCAweDEwOWU0LFxuICAgICAgICAweDEwOWU4LCAweDEwOWY2LCAweDEwYTA4LCAweDEwYTEwLCAweDEwYTFlLCAweDEwYTIwLCAweDEwYTNjLCAweDEwYTQwLCAweDEwYTc4LCAweDEwYWYwLCAweDEwYjA2LCAweDEwYjBjLFxuICAgICAgICAweDEwYjE4LCAweDEwYjMwLCAweDEwYjNlLCAweDEwYjYwLCAweDEwYjdjLCAweDEwYjhlLCAweDEwYjljLCAweDEwYmI4LCAweDEwYmMyLCAweDEwYmM0LCAweDEwYmM4LCAweDEwYmQwLFxuICAgICAgICAweDEwYmRlLCAweDEwYmU2LCAweDEwYmVjLCAweDEwYzJlLCAweDEwYzRlLCAweDEwYzVjLCAweDEwYzYyLCAweDEwYzY0LCAweDEwYzY4LCAweDEwYzc2LCAweDEwYzhlLCAweDEwYzljLFxuICAgICAgICAweDEwY2I4LCAweDEwY2MyLCAweDEwY2M0LCAweDEwY2M4LCAweDEwY2QwLCAweDEwY2RlLCAweDEwY2U2LCAweDEwY2VjLCAweDEwY2ZhLCAweDEwZDBlLCAweDEwZDFjLCAweDEwZDM4LFxuICAgICAgICAweDEwZDcwLCAweDEwZDdlLCAweDEwZDgyLCAweDEwZDg0LCAweDEwZDg4LCAweDEwZDkwLCAweDEwZDllLCAweDEwZGEwLCAweDEwZGJjLCAweDEwZGM2LCAweDEwZGNjLCAweDEwZGQ4LFxuICAgICAgICAweDEwZGVlLCAweDEwZGYyLCAweDEwZGY0LCAweDEwZTE2LCAweDEwZTI2LCAweDEwZTJjLCAweDEwZTQ2LCAweDEwZTU4LCAweDEwZTZlLCAweDEwZTg2LCAweDEwZThjLCAweDEwZTk4LFxuICAgICAgICAweDEwZWIwLCAweDEwZWJlLCAweDEwZWNlLCAweDEwZWRjLCAweDEwZjBhLCAweDEwZjEyLCAweDEwZjE0LCAweDEwZjIyLCAweDEwZjI4LCAweDEwZjM2LCAweDEwZjQyLCAweDEwZjQ0LFxuICAgICAgICAweDEwZjQ4LCAweDEwZjUwLCAweDEwZjVlLCAweDEwZjY2LCAweDEwZjZjLCAweDEwZmIyLCAweDEwZmI0LCAweDExMDIyLCAweDExMDI4LCAweDExMDQyLCAweDExMDQ4LCAweDExMDUwLFxuICAgICAgICAweDExMDVlLCAweDExMDdhLCAweDExMDgyLCAweDExMDg0LCAweDExMDkwLCAweDExMDllLCAweDExMGEwLCAweDExMGJjLCAweDExMGM2LCAweDExMGNjLCAweDExMGQ4LCAweDExMGVlLFxuICAgICAgICAweDExMGYyLCAweDExMGY0LCAweDExMTAyLCAweDExMTFlLCAweDExMTIwLCAweDExMTNjLCAweDExMTQwLCAweDExMTc4LCAweDExMTg2LCAweDExMTk4LCAweDExMWIwLCAweDExMWJlLFxuICAgICAgICAweDExMWNlLCAweDExMWRjLCAweDExMWUyLCAweDExMWU0LCAweDExMWU4LCAweDExMWY2LCAweDExMjA4LCAweDExMjFlLCAweDExMjIwLCAweDExMjc4LCAweDExMmYwLCAweDExMzBjLFxuICAgICAgICAweDExMzMwLCAweDExMzNlLCAweDExMzYwLCAweDExMzdjLCAweDExMzhlLCAweDExMzljLCAweDExM2I4LCAweDExM2MyLCAweDExM2M4LCAweDExM2QwLCAweDExM2RlLCAweDExM2U2LFxuICAgICAgICAweDExM2VjLCAweDExNDA4LCAweDExNDEwLCAweDExNDFlLCAweDExNDIwLCAweDExNDNjLCAweDExNDQwLCAweDExNDc4LCAweDExNGYwLCAweDExNWUwLCAweDExNjBjLCAweDExNjE4LFxuICAgICAgICAweDExNjMwLCAweDExNjNlLCAweDExNjYwLCAweDExNjdjLCAweDExNmMwLCAweDExNmY4LCAweDExNzFjLCAweDExNzM4LCAweDExNzcwLCAweDExNzdlLCAweDExNzgyLCAweDExNzg0LFxuICAgICAgICAweDExNzg4LCAweDExNzkwLCAweDExNzllLCAweDExN2EwLCAweDExN2JjLCAweDExN2M2LCAweDExN2NjLCAweDExN2Q4LCAweDExN2VlLCAweDExODJlLCAweDExODM0LCAweDExODRlLFxuICAgICAgICAweDExODVjLCAweDExODYyLCAweDExODY0LCAweDExODY4LCAweDExODc2LCAweDExODhlLCAweDExODljLCAweDExOGI4LCAweDExOGMyLCAweDExOGM4LCAweDExOGQwLCAweDExOGRlLFxuICAgICAgICAweDExOGU2LCAweDExOGVjLCAweDExOGZhLCAweDExOTBlLCAweDExOTFjLCAweDExOTM4LCAweDExOTcwLCAweDExOTdlLCAweDExOTgyLCAweDExOTg0LCAweDExOTkwLCAweDExOTllLFxuICAgICAgICAweDExOWEwLCAweDExOWJjLCAweDExOWM2LCAweDExOWNjLCAweDExOWQ4LCAweDExOWVlLCAweDExOWYyLCAweDExOWY0LCAweDExYTBlLCAweDExYTFjLCAweDExYTM4LCAweDExYTcwLFxuICAgICAgICAweDExYTdlLCAweDExYWUwLCAweDExYWZjLCAweDExYjA4LCAweDExYjEwLCAweDExYjFlLCAweDExYjIwLCAweDExYjNjLCAweDExYjQwLCAweDExYjc4LCAweDExYjhjLCAweDExYjk4LFxuICAgICAgICAweDExYmIwLCAweDExYmJlLCAweDExYmNlLCAweDExYmRjLCAweDExYmUyLCAweDExYmU0LCAweDExYmU4LCAweDExYmY2LCAweDExYzE2LCAweDExYzI2LCAweDExYzJjLCAweDExYzQ2LFxuICAgICAgICAweDExYzRjLCAweDExYzU4LCAweDExYzZlLCAweDExYzg2LCAweDExYzk4LCAweDExY2IwLCAweDExY2JlLCAweDExY2NlLCAweDExY2RjLCAweDExY2UyLCAweDExY2U0LCAweDExY2U4LFxuICAgICAgICAweDExY2Y2LCAweDExZDA2LCAweDExZDBjLCAweDExZDE4LCAweDExZDMwLCAweDExZDNlLCAweDExZDYwLCAweDExZDdjLCAweDExZDhlLCAweDExZDljLCAweDExZGI4LCAweDExZGM0LFxuICAgICAgICAweDExZGM4LCAweDExZGQwLCAweDExZGRlLCAweDExZGU2LCAweDExZGVjLCAweDExZGZhLCAweDExZTBhLCAweDExZTEyLCAweDExZTE0LCAweDExZTIyLCAweDExZTI0LCAweDExZTI4LFxuICAgICAgICAweDExZTM2LCAweDExZTQyLCAweDExZTQ0LCAweDExZTUwLCAweDExZTVlLCAweDExZTY2LCAweDExZTZjLCAweDExZTgyLCAweDExZTg0LCAweDExZTg4LCAweDExZTkwLCAweDExZTllLFxuICAgICAgICAweDExZWEwLCAweDExZWJjLCAweDExZWM2LCAweDExZWNjLCAweDExZWQ4LCAweDExZWVlLCAweDExZjFhLCAweDExZjJlLCAweDExZjMyLCAweDExZjM0LCAweDExZjRlLCAweDExZjVjLFxuICAgICAgICAweDExZjYyLCAweDExZjY0LCAweDExZjY4LCAweDExZjc2LCAweDEyMDQ4LCAweDEyMDVlLCAweDEyMDgyLCAweDEyMDg0LCAweDEyMDkwLCAweDEyMDllLCAweDEyMGEwLCAweDEyMGJjLFxuICAgICAgICAweDEyMGQ4LCAweDEyMGYyLCAweDEyMGY0LCAweDEyMTA4LCAweDEyMTFlLCAweDEyMTIwLCAweDEyMTNjLCAweDEyMTQwLCAweDEyMTc4LCAweDEyMTg2LCAweDEyMTk4LCAweDEyMWIwLFxuICAgICAgICAweDEyMWJlLCAweDEyMWUyLCAweDEyMWU0LCAweDEyMWU4LCAweDEyMWY2LCAweDEyMjA0LCAweDEyMjEwLCAweDEyMjFlLCAweDEyMjIwLCAweDEyMjc4LCAweDEyMmYwLCAweDEyMzA2LFxuICAgICAgICAweDEyMzBjLCAweDEyMzMwLCAweDEyMzNlLCAweDEyMzYwLCAweDEyMzdjLCAweDEyMzhlLCAweDEyMzljLCAweDEyM2I4LCAweDEyM2MyLCAweDEyM2M4LCAweDEyM2QwLCAweDEyM2U2LFxuICAgICAgICAweDEyM2VjLCAweDEyNDFlLCAweDEyNDIwLCAweDEyNDNjLCAweDEyNGYwLCAweDEyNWUwLCAweDEyNjE4LCAweDEyNjNlLCAweDEyNjYwLCAweDEyNjdjLCAweDEyNmMwLCAweDEyNmY4LFxuICAgICAgICAweDEyNzM4LCAweDEyNzcwLCAweDEyNzdlLCAweDEyNzgyLCAweDEyNzg0LCAweDEyNzkwLCAweDEyNzllLCAweDEyN2EwLCAweDEyN2JjLCAweDEyN2M2LCAweDEyN2NjLCAweDEyN2Q4LFxuICAgICAgICAweDEyN2VlLCAweDEyODIwLCAweDEyODNjLCAweDEyODQwLCAweDEyODc4LCAweDEyOGYwLCAweDEyOWUwLCAweDEyYmMwLCAweDEyYzE4LCAweDEyYzMwLCAweDEyYzNlLCAweDEyYzYwLFxuICAgICAgICAweDEyYzdjLCAweDEyY2MwLCAweDEyY2Y4LCAweDEyZGYwLCAweDEyZTFjLCAweDEyZTM4LCAweDEyZTcwLCAweDEyZTdlLCAweDEyZWUwLCAweDEyZWZjLCAweDEyZjA0LCAweDEyZjA4LFxuICAgICAgICAweDEyZjEwLCAweDEyZjIwLCAweDEyZjNjLCAweDEyZjQwLCAweDEyZjc4LCAweDEyZjg2LCAweDEyZjhjLCAweDEyZjk4LCAweDEyZmIwLCAweDEyZmJlLCAweDEyZmNlLCAweDEyZmRjLFxuICAgICAgICAweDEzMDJlLCAweDEzMDRlLCAweDEzMDVjLCAweDEzMDYyLCAweDEzMDY4LCAweDEzMDhlLCAweDEzMDljLCAweDEzMGI4LCAweDEzMGMyLCAweDEzMGM4LCAweDEzMGQwLCAweDEzMGRlLFxuICAgICAgICAweDEzMGVjLCAweDEzMGZhLCAweDEzMTBlLCAweDEzMTM4LCAweDEzMTcwLCAweDEzMTdlLCAweDEzMTgyLCAweDEzMTg0LCAweDEzMTkwLCAweDEzMTllLCAweDEzMWEwLCAweDEzMWJjLFxuICAgICAgICAweDEzMWM2LCAweDEzMWNjLCAweDEzMWQ4LCAweDEzMWYyLCAweDEzMWY0LCAweDEzMjBlLCAweDEzMjFjLCAweDEzMjcwLCAweDEzMjdlLCAweDEzMmUwLCAweDEzMmZjLCAweDEzMzA4LFxuICAgICAgICAweDEzMzFlLCAweDEzMzIwLCAweDEzMzNjLCAweDEzMzQwLCAweDEzMzc4LCAweDEzMzg2LCAweDEzMzk4LCAweDEzM2IwLCAweDEzM2JlLCAweDEzM2NlLCAweDEzM2RjLCAweDEzM2UyLFxuICAgICAgICAweDEzM2U0LCAweDEzM2U4LCAweDEzM2Y2LCAweDEzNDBlLCAweDEzNDFjLCAweDEzNDM4LCAweDEzNDcwLCAweDEzNDdlLCAweDEzNGUwLCAweDEzNGZjLCAweDEzNWMwLCAweDEzNWY4LFxuICAgICAgICAweDEzNjA4LCAweDEzNjEwLCAweDEzNjFlLCAweDEzNjIwLCAweDEzNjNjLCAweDEzNjQwLCAweDEzNjc4LCAweDEzNmYwLCAweDEzNzBjLCAweDEzNzE4LCAweDEzNzMwLCAweDEzNzNlLFxuICAgICAgICAweDEzNzYwLCAweDEzNzdjLCAweDEzNzljLCAweDEzN2I4LCAweDEzN2MyLCAweDEzN2M0LCAweDEzN2M4LCAweDEzN2QwLCAweDEzN2RlLCAweDEzN2U2LCAweDEzN2VjLCAweDEzODE2LFxuICAgICAgICAweDEzODI2LCAweDEzODJjLCAweDEzODQ2LCAweDEzODRjLCAweDEzODU4LCAweDEzODZlLCAweDEzODc0LCAweDEzODg2LCAweDEzODk4LCAweDEzOGIwLCAweDEzOGJlLCAweDEzOGNlLFxuICAgICAgICAweDEzOGRjLCAweDEzOGUyLCAweDEzOGU0LCAweDEzOGU4LCAweDEzOTA2LCAweDEzOTBjLCAweDEzOTMwLCAweDEzOTNlLCAweDEzOTYwLCAweDEzOTdjLCAweDEzOThlLCAweDEzOTljLFxuICAgICAgICAweDEzOWI4LCAweDEzOWM4LCAweDEzOWQwLCAweDEzOWRlLCAweDEzOWU2LCAweDEzOWVjLCAweDEzOWZhLCAweDEzYTA2LCAweDEzYTBjLCAweDEzYTE4LCAweDEzYTMwLCAweDEzYTNlLFxuICAgICAgICAweDEzYTYwLCAweDEzYTdjLCAweDEzYWMwLCAweDEzYWY4LCAweDEzYjBlLCAweDEzYjFjLCAweDEzYjM4LCAweDEzYjcwLCAweDEzYjdlLCAweDEzYjg4LCAweDEzYjkwLCAweDEzYjllLFxuICAgICAgICAweDEzYmEwLCAweDEzYmJjLCAweDEzYmNjLCAweDEzYmQ4LCAweDEzYmVlLCAweDEzYmYyLCAweDEzYmY0LCAweDEzYzEyLCAweDEzYzE0LCAweDEzYzIyLCAweDEzYzI0LCAweDEzYzI4LFxuICAgICAgICAweDEzYzM2LCAweDEzYzQyLCAweDEzYzQ4LCAweDEzYzUwLCAweDEzYzVlLCAweDEzYzY2LCAweDEzYzZjLCAweDEzYzgyLCAweDEzYzg0LCAweDEzYzkwLCAweDEzYzllLCAweDEzY2EwLFxuICAgICAgICAweDEzY2JjLCAweDEzY2M2LCAweDEzY2NjLCAweDEzY2Q4LCAweDEzY2VlLCAweDEzZDAyLCAweDEzZDA0LCAweDEzZDA4LCAweDEzZDEwLCAweDEzZDFlLCAweDEzZDIwLCAweDEzZDNjLFxuICAgICAgICAweDEzZDQwLCAweDEzZDc4LCAweDEzZDg2LCAweDEzZDhjLCAweDEzZDk4LCAweDEzZGIwLCAweDEzZGJlLCAweDEzZGNlLCAweDEzZGRjLCAweDEzZGU0LCAweDEzZGU4LCAweDEzZGY2LFxuICAgICAgICAweDEzZTFhLCAweDEzZTJlLCAweDEzZTMyLCAweDEzZTM0LCAweDEzZTRlLCAweDEzZTVjLCAweDEzZTYyLCAweDEzZTY0LCAweDEzZTY4LCAweDEzZTc2LCAweDEzZThlLCAweDEzZTljLFxuICAgICAgICAweDEzZWI4LCAweDEzZWMyLCAweDEzZWM0LCAweDEzZWM4LCAweDEzZWQwLCAweDEzZWRlLCAweDEzZWU2LCAweDEzZWVjLCAweDEzZjI2LCAweDEzZjJjLCAweDEzZjNhLCAweDEzZjQ2LFxuICAgICAgICAweDEzZjRjLCAweDEzZjU4LCAweDEzZjZlLCAweDEzZjcyLCAweDEzZjc0LCAweDE0MDgyLCAweDE0MDllLCAweDE0MGEwLCAweDE0MGJjLCAweDE0MTA0LCAweDE0MTA4LCAweDE0MTEwLFxuICAgICAgICAweDE0MTFlLCAweDE0MTIwLCAweDE0MTNjLCAweDE0MTQwLCAweDE0MTc4LCAweDE0MThjLCAweDE0MTk4LCAweDE0MWIwLCAweDE0MWJlLCAweDE0MWUyLCAweDE0MWU0LCAweDE0MWU4LFxuICAgICAgICAweDE0MjA4LCAweDE0MjEwLCAweDE0MjFlLCAweDE0MjIwLCAweDE0MjNjLCAweDE0MjQwLCAweDE0Mjc4LCAweDE0MmYwLCAweDE0MzA2LCAweDE0MzBjLCAweDE0MzE4LCAweDE0MzMwLFxuICAgICAgICAweDE0MzNlLCAweDE0MzYwLCAweDE0MzdjLCAweDE0MzhlLCAweDE0M2MyLCAweDE0M2M0LCAweDE0M2M4LCAweDE0M2QwLCAweDE0M2U2LCAweDE0M2VjLCAweDE0NDA4LCAweDE0NDEwLFxuICAgICAgICAweDE0NDFlLCAweDE0NDIwLCAweDE0NDNjLCAweDE0NDQwLCAweDE0NDc4LCAweDE0NGYwLCAweDE0NWUwLCAweDE0NjBjLCAweDE0NjE4LCAweDE0NjMwLCAweDE0NjNlLCAweDE0NjYwLFxuICAgICAgICAweDE0NjdjLCAweDE0NmMwLCAweDE0NmY4LCAweDE0NzFjLCAweDE0NzM4LCAweDE0NzcwLCAweDE0NzdlLCAweDE0NzgyLCAweDE0Nzg0LCAweDE0Nzg4LCAweDE0NzkwLCAweDE0N2EwLFxuICAgICAgICAweDE0N2JjLCAweDE0N2M2LCAweDE0N2NjLCAweDE0N2Q4LCAweDE0N2VlLCAweDE0ODEwLCAweDE0ODIwLCAweDE0ODNjLCAweDE0ODQwLCAweDE0ODc4LCAweDE0OGYwLCAweDE0OWUwLFxuICAgICAgICAweDE0YmMwLCAweDE0YzMwLCAweDE0YzNlLCAweDE0YzYwLCAweDE0YzdjLCAweDE0Y2MwLCAweDE0Y2Y4LCAweDE0ZGYwLCAweDE0ZTM4LCAweDE0ZTcwLCAweDE0ZTdlLCAweDE0ZWUwLFxuICAgICAgICAweDE0ZWZjLCAweDE0ZjA0LCAweDE0ZjA4LCAweDE0ZjEwLCAweDE0ZjFlLCAweDE0ZjIwLCAweDE0ZjNjLCAweDE0ZjQwLCAweDE0Zjc4LCAweDE0Zjg2LCAweDE0ZjhjLCAweDE0Zjk4LFxuICAgICAgICAweDE0ZmIwLCAweDE0ZmNlLCAweDE0ZmRjLCAweDE1MDIwLCAweDE1MDQwLCAweDE1MDc4LCAweDE1MGYwLCAweDE1MWUwLCAweDE1M2MwLCAweDE1ODYwLCAweDE1ODdjLCAweDE1OGMwLFxuICAgICAgICAweDE1OGY4LCAweDE1OWYwLCAweDE1YmUwLCAweDE1YzcwLCAweDE1YzdlLCAweDE1Y2UwLCAweDE1Y2ZjLCAweDE1ZGMwLCAweDE1ZGY4LCAweDE1ZTA4LCAweDE1ZTEwLCAweDE1ZTIwLFxuICAgICAgICAweDE1ZTQwLCAweDE1ZTc4LCAweDE1ZWYwLCAweDE1ZjBjLCAweDE1ZjE4LCAweDE1ZjMwLCAweDE1ZjYwLCAweDE1ZjdjLCAweDE1ZjhlLCAweDE1ZjljLCAweDE1ZmI4LCAweDE2MDRlLFxuICAgICAgICAweDE2MDVjLCAweDE2MDhlLCAweDE2MDljLCAweDE2MGI4LCAweDE2MGMyLCAweDE2MGM0LCAweDE2MGM4LCAweDE2MGRlLCAweDE2MTBlLCAweDE2MTFjLCAweDE2MTM4LCAweDE2MTcwLFxuICAgICAgICAweDE2MTdlLCAweDE2MTg0LCAweDE2MTg4LCAweDE2MTkwLCAweDE2MTllLCAweDE2MWEwLCAweDE2MWJjLCAweDE2MWM2LCAweDE2MWNjLCAweDE2MWQ4LCAweDE2MWYyLCAweDE2MWY0LFxuICAgICAgICAweDE2MjBlLCAweDE2MjFjLCAweDE2MjM4LCAweDE2MjcwLCAweDE2MjdlLCAweDE2MmUwLCAweDE2MmZjLCAweDE2MzA0LCAweDE2MzA4LCAweDE2MzEwLCAweDE2MzFlLCAweDE2MzIwLFxuICAgICAgICAweDE2MzNjLCAweDE2MzQwLCAweDE2Mzc4LCAweDE2Mzg2LCAweDE2MzhjLCAweDE2Mzk4LCAweDE2M2IwLCAweDE2M2JlLCAweDE2M2NlLCAweDE2M2RjLCAweDE2M2UyLCAweDE2M2U0LFxuICAgICAgICAweDE2M2U4LCAweDE2M2Y2LCAweDE2NDBlLCAweDE2NDFjLCAweDE2NDM4LCAweDE2NDcwLCAweDE2NDdlLCAweDE2NGUwLCAweDE2NGZjLCAweDE2NWMwLCAweDE2NWY4LCAweDE2NjEwLFxuICAgICAgICAweDE2NjFlLCAweDE2NjIwLCAweDE2NjNjLCAweDE2NjQwLCAweDE2Njc4LCAweDE2NmYwLCAweDE2NzE4LCAweDE2NzMwLCAweDE2NzNlLCAweDE2NzYwLCAweDE2NzdjLCAweDE2NzhlLFxuICAgICAgICAweDE2NzljLCAweDE2N2I4LCAweDE2N2MyLCAweDE2N2M0LCAweDE2N2M4LCAweDE2N2QwLCAweDE2N2RlLCAweDE2N2U2LCAweDE2N2VjLCAweDE2ODFjLCAweDE2ODM4LCAweDE2ODcwLFxuICAgICAgICAweDE2OGUwLCAweDE2OGZjLCAweDE2OWMwLCAweDE2OWY4LCAweDE2YmYwLCAweDE2YzEwLCAweDE2YzFlLCAweDE2YzIwLCAweDE2YzNjLCAweDE2YzQwLCAweDE2Yzc4LCAweDE2Y2YwLFxuICAgICAgICAweDE2ZGUwLCAweDE2ZTE4LCAweDE2ZTMwLCAweDE2ZTNlLCAweDE2ZTYwLCAweDE2ZTdjLCAweDE2ZWMwLCAweDE2ZWY4LCAweDE2ZjFjLCAweDE2ZjM4LCAweDE2ZjcwLCAweDE2ZjdlLFxuICAgICAgICAweDE2Zjg0LCAweDE2Zjg4LCAweDE2ZjkwLCAweDE2ZjllLCAweDE2ZmEwLCAweDE2ZmJjLCAweDE2ZmM2LCAweDE2ZmNjLCAweDE2ZmQ4LCAweDE3MDI2LCAweDE3MDJjLCAweDE3MDQ2LFxuICAgICAgICAweDE3MDRjLCAweDE3MDU4LCAweDE3MDZlLCAweDE3MDg2LCAweDE3MDhjLCAweDE3MDk4LCAweDE3MGIwLCAweDE3MGJlLCAweDE3MGNlLCAweDE3MGRjLCAweDE3MGU4LCAweDE3MTA2LFxuICAgICAgICAweDE3MTBjLCAweDE3MTE4LCAweDE3MTMwLCAweDE3MTNlLCAweDE3MTYwLCAweDE3MTdjLCAweDE3MThlLCAweDE3MTljLCAweDE3MWI4LCAweDE3MWMyLCAweDE3MWM0LCAweDE3MWM4LFxuICAgICAgICAweDE3MWQwLCAweDE3MWRlLCAweDE3MWU2LCAweDE3MWVjLCAweDE3MWZhLCAweDE3MjA2LCAweDE3MjBjLCAweDE3MjE4LCAweDE3MjMwLCAweDE3MjNlLCAweDE3MjYwLCAweDE3MjdjLFxuICAgICAgICAweDE3MmMwLCAweDE3MmY4LCAweDE3MzBlLCAweDE3MzFjLCAweDE3MzM4LCAweDE3MzcwLCAweDE3MzdlLCAweDE3Mzg4LCAweDE3MzkwLCAweDE3MzllLCAweDE3M2EwLCAweDE3M2JjLFxuICAgICAgICAweDE3M2NjLCAweDE3M2Q4LCAweDE3M2VlLCAweDE3M2YyLCAweDE3M2Y0LCAweDE3NDBjLCAweDE3NDE4LCAweDE3NDMwLCAweDE3NDNlLCAweDE3NDYwLCAweDE3NDdjLCAweDE3NGMwLFxuICAgICAgICAweDE3NGY4LCAweDE3NWYwLCAweDE3NjBlLCAweDE3NjFjLCAweDE3NjM4LCAweDE3NjcwLCAweDE3NjdlLCAweDE3NmUwLCAweDE3NmZjLCAweDE3NzA4LCAweDE3NzEwLCAweDE3NzFlLFxuICAgICAgICAweDE3NzIwLCAweDE3NzNjLCAweDE3NzQwLCAweDE3Nzc4LCAweDE3Nzk4LCAweDE3N2IwLCAweDE3N2JlLCAweDE3N2RjLCAweDE3N2UyLCAweDE3N2U0LCAweDE3N2U4LCAweDE3ODIyLFxuICAgICAgICAweDE3ODI0LCAweDE3ODI4LCAweDE3ODM2LCAweDE3ODQyLCAweDE3ODQ0LCAweDE3ODQ4LCAweDE3ODUwLCAweDE3ODVlLCAweDE3ODY2LCAweDE3ODZjLCAweDE3ODgyLCAweDE3ODg0LFxuICAgICAgICAweDE3ODg4LCAweDE3ODkwLCAweDE3ODllLCAweDE3OGEwLCAweDE3OGJjLCAweDE3OGM2LCAweDE3OGNjLCAweDE3OGQ4LCAweDE3OGVlLCAweDE3OGYyLCAweDE3OGY0LCAweDE3OTAyLFxuICAgICAgICAweDE3OTA0LCAweDE3OTA4LCAweDE3OTEwLCAweDE3OTFlLCAweDE3OTIwLCAweDE3OTNjLCAweDE3OTQwLCAweDE3OTc4LCAweDE3OTg2LCAweDE3OThjLCAweDE3OTk4LCAweDE3OWIwLFxuICAgICAgICAweDE3OWJlLCAweDE3OWNlLCAweDE3OWRjLCAweDE3OWUyLCAweDE3OWU0LCAweDE3OWU4LCAweDE3OWY2LCAweDE3YTA0LCAweDE3YTA4LCAweDE3YTEwLCAweDE3YTFlLCAweDE3YTIwLFxuICAgICAgICAweDE3YTNjLCAweDE3YTQwLCAweDE3YTc4LCAweDE3YWYwLCAweDE3YjA2LCAweDE3YjBjLCAweDE3YjE4LCAweDE3YjMwLCAweDE3YjNlLCAweDE3YjYwLCAweDE3YjdjLCAweDE3YjhlLFxuICAgICAgICAweDE3YjljLCAweDE3YmI4LCAweDE3YmM0LCAweDE3YmM4LCAweDE3YmQwLCAweDE3YmRlLCAweDE3YmU2LCAweDE3YmVjLCAweDE3YzJlLCAweDE3YzMyLCAweDE3YzM0LCAweDE3YzRlLFxuICAgICAgICAweDE3YzVjLCAweDE3YzYyLCAweDE3YzY0LCAweDE3YzY4LCAweDE3Yzc2LCAweDE3YzhlLCAweDE3YzljLCAweDE3Y2I4LCAweDE3Y2MyLCAweDE3Y2M0LCAweDE3Y2M4LCAweDE3Y2QwLFxuICAgICAgICAweDE3Y2RlLCAweDE3Y2U2LCAweDE3Y2VjLCAweDE3ZDBlLCAweDE3ZDFjLCAweDE3ZDM4LCAweDE3ZDcwLCAweDE3ZDgyLCAweDE3ZDg0LCAweDE3ZDg4LCAweDE3ZDkwLCAweDE3ZDllLFxuICAgICAgICAweDE3ZGEwLCAweDE3ZGJjLCAweDE3ZGM2LCAweDE3ZGNjLCAweDE3ZGQ4LCAweDE3ZGVlLCAweDE3ZTI2LCAweDE3ZTJjLCAweDE3ZTNhLCAweDE3ZTQ2LCAweDE3ZTRjLCAweDE3ZTU4LFxuICAgICAgICAweDE3ZTZlLCAweDE3ZTcyLCAweDE3ZTc0LCAweDE3ZTg2LCAweDE3ZThjLCAweDE3ZTk4LCAweDE3ZWIwLCAweDE3ZWNlLCAweDE3ZWRjLCAweDE3ZWUyLCAweDE3ZWU0LCAweDE3ZWU4LFxuICAgICAgICAweDE3ZWY2LCAweDE4MTNhLCAweDE4MTcyLCAweDE4MTc0LCAweDE4MjE2LCAweDE4MjI2LCAweDE4MjNhLCAweDE4MjRjLCAweDE4MjU4LCAweDE4MjZlLCAweDE4MjcyLCAweDE4Mjc0LFxuICAgICAgICAweDE4Mjk4LCAweDE4MmJlLCAweDE4MmUyLCAweDE4MmU0LCAweDE4MmU4LCAweDE4MmY2LCAweDE4MzVlLCAweDE4MzdhLCAweDE4M2FlLCAweDE4M2Q2LCAweDE4NDE2LCAweDE4NDI2LFxuICAgICAgICAweDE4NDJjLCAweDE4NDNhLCAweDE4NDQ2LCAweDE4NDU4LCAweDE4NDZlLCAweDE4NDcyLCAweDE4NDc0LCAweDE4NDg2LCAweDE4NGIwLCAweDE4NGJlLCAweDE4NGNlLCAweDE4NGRjLFxuICAgICAgICAweDE4NGUyLCAweDE4NGU0LCAweDE4NGU4LCAweDE4NGY2LCAweDE4NTA2LCAweDE4NTBjLCAweDE4NTE4LCAweDE4NTMwLCAweDE4NTNlLCAweDE4NTYwLCAweDE4NTdjLCAweDE4NThlLFxuICAgICAgICAweDE4NTljLCAweDE4NWI4LCAweDE4NWMyLCAweDE4NWM0LCAweDE4NWM4LCAweDE4NWQwLCAweDE4NWRlLCAweDE4NWU2LCAweDE4NWVjLCAweDE4NWZhLCAweDE4NjEyLCAweDE4NjE0LFxuICAgICAgICAweDE4NjIyLCAweDE4NjI4LCAweDE4NjM2LCAweDE4NjQyLCAweDE4NjUwLCAweDE4NjVlLCAweDE4NjdhLCAweDE4NjgyLCAweDE4Njg0LCAweDE4Njg4LCAweDE4NjkwLCAweDE4NjllLFxuICAgICAgICAweDE4NmEwLCAweDE4NmJjLCAweDE4NmM2LCAweDE4NmNjLCAweDE4NmQ4LCAweDE4NmVlLCAweDE4NmYyLCAweDE4NmY0LCAweDE4NzJlLCAweDE4NzRlLCAweDE4NzVjLCAweDE4Nzk2LFxuICAgICAgICAweDE4N2E2LCAweDE4N2FjLCAweDE4N2QyLCAweDE4N2Q0LCAweDE4ODI2LCAweDE4ODJjLCAweDE4ODNhLCAweDE4ODQ2LCAweDE4ODRjLCAweDE4ODU4LCAweDE4ODZlLCAweDE4ODcyLFxuICAgICAgICAweDE4ODc0LCAweDE4ODg2LCAweDE4ODk4LCAweDE4OGIwLCAweDE4OGJlLCAweDE4OGNlLCAweDE4OGRjLCAweDE4OGUyLCAweDE4OGU0LCAweDE4OGU4LCAweDE4OGY2LCAweDE4OTBjLFxuICAgICAgICAweDE4OTMwLCAweDE4OTNlLCAweDE4OTYwLCAweDE4OTdjLCAweDE4OThlLCAweDE4OWI4LCAweDE4OWMyLCAweDE4OWM4LCAweDE4OWQwLCAweDE4OWRlLCAweDE4OWU2LCAweDE4OWVjLFxuICAgICAgICAweDE4OWZhLCAweDE4YTE4LCAweDE4YTMwLCAweDE4YTNlLCAweDE4YTYwLCAweDE4YTdjLCAweDE4YWMwLCAweDE4YWY4LCAweDE4YjFjLCAweDE4YjM4LCAweDE4YjcwLCAweDE4YjdlLFxuICAgICAgICAweDE4YjgyLCAweDE4Yjg0LCAweDE4Yjg4LCAweDE4YjkwLCAweDE4YjllLCAweDE4YmEwLCAweDE4YmJjLCAweDE4YmM2LCAweDE4YmNjLCAweDE4YmQ4LCAweDE4YmVlLCAweDE4YmYyLFxuICAgICAgICAweDE4YmY0LCAweDE4YzIyLCAweDE4YzI0LCAweDE4YzI4LCAweDE4YzM2LCAweDE4YzQyLCAweDE4YzQ4LCAweDE4YzUwLCAweDE4YzVlLCAweDE4YzY2LCAweDE4YzdhLCAweDE4YzgyLFxuICAgICAgICAweDE4Yzg0LCAweDE4YzkwLCAweDE4YzllLCAweDE4Y2EwLCAweDE4Y2JjLCAweDE4Y2NjLCAweDE4Y2YyLCAweDE4Y2Y0LCAweDE4ZDA0LCAweDE4ZDA4LCAweDE4ZDEwLCAweDE4ZDFlLFxuICAgICAgICAweDE4ZDIwLCAweDE4ZDNjLCAweDE4ZDQwLCAweDE4ZDc4LCAweDE4ZDg2LCAweDE4ZDk4LCAweDE4ZGNlLCAweDE4ZGUyLCAweDE4ZGU0LCAweDE4ZGU4LCAweDE4ZTJlLCAweDE4ZTMyLFxuICAgICAgICAweDE4ZTM0LCAweDE4ZTRlLCAweDE4ZTVjLCAweDE4ZTYyLCAweDE4ZTY0LCAweDE4ZTY4LCAweDE4ZThlLCAweDE4ZTljLCAweDE4ZWI4LCAweDE4ZWMyLCAweDE4ZWM0LCAweDE4ZWM4LFxuICAgICAgICAweDE4ZWQwLCAweDE4ZWZhLCAweDE4ZjE2LCAweDE4ZjI2LCAweDE4ZjJjLCAweDE4ZjQ2LCAweDE4ZjRjLCAweDE4ZjU4LCAweDE4ZjZlLCAweDE4ZjhhLCAweDE4ZjkyLCAweDE4Zjk0LFxuICAgICAgICAweDE4ZmEyLCAweDE4ZmE0LCAweDE4ZmE4LCAweDE4ZmI2LCAweDE5MDJjLCAweDE5MDNhLCAweDE5MDQ2LCAweDE5MDRjLCAweDE5MDU4LCAweDE5MDcyLCAweDE5MDc0LCAweDE5MDg2LFxuICAgICAgICAweDE5MDk4LCAweDE5MGIwLCAweDE5MGJlLCAweDE5MGNlLCAweDE5MGRjLCAweDE5MGUyLCAweDE5MGU4LCAweDE5MGY2LCAweDE5MTA2LCAweDE5MTBjLCAweDE5MTMwLCAweDE5MTNlLFxuICAgICAgICAweDE5MTYwLCAweDE5MTdjLCAweDE5MThlLCAweDE5MTljLCAweDE5MWI4LCAweDE5MWMyLCAweDE5MWM4LCAweDE5MWQwLCAweDE5MWRlLCAweDE5MWU2LCAweDE5MWVjLCAweDE5MWZhLFxuICAgICAgICAweDE5MjE4LCAweDE5MjNlLCAweDE5MjYwLCAweDE5MjdjLCAweDE5MmMwLCAweDE5MmY4LCAweDE5MzM4LCAweDE5MzcwLCAweDE5MzdlLCAweDE5MzgyLCAweDE5Mzg0LCAweDE5MzkwLFxuICAgICAgICAweDE5MzllLCAweDE5M2EwLCAweDE5M2JjLCAweDE5M2M2LCAweDE5M2NjLCAweDE5M2Q4LCAweDE5M2VlLCAweDE5M2YyLCAweDE5M2Y0LCAweDE5NDMwLCAweDE5NDNlLCAweDE5NDYwLFxuICAgICAgICAweDE5NDdjLCAweDE5NGMwLCAweDE5NGY4LCAweDE5NWYwLCAweDE5NjM4LCAweDE5NjcwLCAweDE5NjdlLCAweDE5NmUwLCAweDE5NmZjLCAweDE5NzAyLCAweDE5NzA0LCAweDE5NzA4LFxuICAgICAgICAweDE5NzEwLCAweDE5NzIwLCAweDE5NzNjLCAweDE5NzQwLCAweDE5Nzc4LCAweDE5Nzg2LCAweDE5NzhjLCAweDE5Nzk4LCAweDE5N2IwLCAweDE5N2JlLCAweDE5N2NlLCAweDE5N2RjLFxuICAgICAgICAweDE5N2UyLCAweDE5N2U0LCAweDE5N2U4LCAweDE5ODIyLCAweDE5ODI0LCAweDE5ODQyLCAweDE5ODQ4LCAweDE5ODUwLCAweDE5ODVlLCAweDE5ODY2LCAweDE5ODdhLCAweDE5ODgyLFxuICAgICAgICAweDE5ODg0LCAweDE5ODkwLCAweDE5ODllLCAweDE5OGEwLCAweDE5OGJjLCAweDE5OGNjLCAweDE5OGYyLCAweDE5OGY0LCAweDE5OTAyLCAweDE5OTA4LCAweDE5OTFlLCAweDE5OTIwLFxuICAgICAgICAweDE5OTNjLCAweDE5OTQwLCAweDE5OTc4LCAweDE5OTg2LCAweDE5OTk4LCAweDE5OWNlLCAweDE5OWUyLCAweDE5OWU0LCAweDE5OWU4LCAweDE5YTA4LCAweDE5YTEwLCAweDE5YTFlLFxuICAgICAgICAweDE5YTIwLCAweDE5YTNjLCAweDE5YTQwLCAweDE5YTc4LCAweDE5YWYwLCAweDE5YjE4LCAweDE5YjNlLCAweDE5YjYwLCAweDE5YjljLCAweDE5YmMyLCAweDE5YmM0LCAweDE5YmM4LFxuICAgICAgICAweDE5YmQwLCAweDE5YmU2LCAweDE5YzJlLCAweDE5YzM0LCAweDE5YzRlLCAweDE5YzVjLCAweDE5YzYyLCAweDE5YzY0LCAweDE5YzY4LCAweDE5YzhlLCAweDE5YzljLCAweDE5Y2I4LFxuICAgICAgICAweDE5Y2MyLCAweDE5Y2M4LCAweDE5Y2QwLCAweDE5Y2U2LCAweDE5Y2ZhLCAweDE5ZDBlLCAweDE5ZDFjLCAweDE5ZDM4LCAweDE5ZDcwLCAweDE5ZDdlLCAweDE5ZDgyLCAweDE5ZDg0LFxuICAgICAgICAweDE5ZDg4LCAweDE5ZDkwLCAweDE5ZGEwLCAweDE5ZGNjLCAweDE5ZGYyLCAweDE5ZGY0LCAweDE5ZTE2LCAweDE5ZTI2LCAweDE5ZTJjLCAweDE5ZTQ2LCAweDE5ZTRjLCAweDE5ZTU4LFxuICAgICAgICAweDE5ZTc0LCAweDE5ZTg2LCAweDE5ZThjLCAweDE5ZTk4LCAweDE5ZWIwLCAweDE5ZWJlLCAweDE5ZWNlLCAweDE5ZWUyLCAweDE5ZWU0LCAweDE5ZWU4LCAweDE5ZjBhLCAweDE5ZjEyLFxuICAgICAgICAweDE5ZjE0LCAweDE5ZjIyLCAweDE5ZjI0LCAweDE5ZjI4LCAweDE5ZjQyLCAweDE5ZjQ0LCAweDE5ZjQ4LCAweDE5ZjUwLCAweDE5ZjVlLCAweDE5ZjZjLCAweDE5ZjlhLCAweDE5ZmFlLFxuICAgICAgICAweDE5ZmIyLCAweDE5ZmI0LCAweDFhMDQ2LCAweDFhMDRjLCAweDFhMDcyLCAweDFhMDc0LCAweDFhMDg2LCAweDFhMDhjLCAweDFhMDk4LCAweDFhMGIwLCAweDFhMGJlLCAweDFhMGUyLFxuICAgICAgICAweDFhMGU0LCAweDFhMGU4LCAweDFhMGY2LCAweDFhMTA2LCAweDFhMTBjLCAweDFhMTE4LCAweDFhMTMwLCAweDFhMTNlLCAweDFhMTYwLCAweDFhMTdjLCAweDFhMThlLCAweDFhMTljLFxuICAgICAgICAweDFhMWI4LCAweDFhMWMyLCAweDFhMWM0LCAweDFhMWM4LCAweDFhMWQwLCAweDFhMWRlLCAweDFhMWU2LCAweDFhMWVjLCAweDFhMjE4LCAweDFhMjMwLCAweDFhMjNlLCAweDFhMjYwLFxuICAgICAgICAweDFhMjdjLCAweDFhMmMwLCAweDFhMmY4LCAweDFhMzFjLCAweDFhMzM4LCAweDFhMzcwLCAweDFhMzdlLCAweDFhMzgyLCAweDFhMzg0LCAweDFhMzg4LCAweDFhMzkwLCAweDFhMzllLFxuICAgICAgICAweDFhM2EwLCAweDFhM2JjLCAweDFhM2M2LCAweDFhM2NjLCAweDFhM2Q4LCAweDFhM2VlLCAweDFhM2YyLCAweDFhM2Y0LCAweDFhNDE4LCAweDFhNDMwLCAweDFhNDNlLCAweDFhNDYwLFxuICAgICAgICAweDFhNDdjLCAweDFhNGMwLCAweDFhNGY4LCAweDFhNWYwLCAweDFhNjFjLCAweDFhNjM4LCAweDFhNjcwLCAweDFhNjdlLCAweDFhNmUwLCAweDFhNmZjLCAweDFhNzAyLCAweDFhNzA0LFxuICAgICAgICAweDFhNzA4LCAweDFhNzEwLCAweDFhNzFlLCAweDFhNzIwLCAweDFhNzNjLCAweDFhNzQwLCAweDFhNzc4LCAweDFhNzg2LCAweDFhNzhjLCAweDFhNzk4LCAweDFhN2IwLCAweDFhN2JlLFxuICAgICAgICAweDFhN2NlLCAweDFhN2RjLCAweDFhN2UyLCAweDFhN2U0LCAweDFhN2U4LCAweDFhODMwLCAweDFhODYwLCAweDFhODdjLCAweDFhOGMwLCAweDFhOGY4LCAweDFhOWYwLCAweDFhYmUwLFxuICAgICAgICAweDFhYzcwLCAweDFhYzdlLCAweDFhY2UwLCAweDFhY2ZjLCAweDFhZGMwLCAweDFhZGY4LCAweDFhZTA0LCAweDFhZTA4LCAweDFhZTEwLCAweDFhZTIwLCAweDFhZTNjLCAweDFhZTQwLFxuICAgICAgICAweDFhZTc4LCAweDFhZWYwLCAweDFhZjA2LCAweDFhZjBjLCAweDFhZjE4LCAweDFhZjMwLCAweDFhZjNlLCAweDFhZjYwLCAweDFhZjdjLCAweDFhZjhlLCAweDFhZjljLCAweDFhZmI4LFxuICAgICAgICAweDFhZmM0LCAweDFhZmM4LCAweDFhZmQwLCAweDFhZmRlLCAweDFiMDQyLCAweDFiMDVlLCAweDFiMDdhLCAweDFiMDgyLCAweDFiMDg0LCAweDFiMDg4LCAweDFiMDkwLCAweDFiMDllLFxuICAgICAgICAweDFiMGEwLCAweDFiMGJjLCAweDFiMGNjLCAweDFiMGYyLCAweDFiMGY0LCAweDFiMTAyLCAweDFiMTA0LCAweDFiMTA4LCAweDFiMTEwLCAweDFiMTFlLCAweDFiMTIwLCAweDFiMTNjLFxuICAgICAgICAweDFiMTQwLCAweDFiMTc4LCAweDFiMTg2LCAweDFiMTk4LCAweDFiMWNlLCAweDFiMWUyLCAweDFiMWU0LCAweDFiMWU4LCAweDFiMjA0LCAweDFiMjA4LCAweDFiMjEwLCAweDFiMjFlLFxuICAgICAgICAweDFiMjIwLCAweDFiMjNjLCAweDFiMjQwLCAweDFiMjc4LCAweDFiMmYwLCAweDFiMzBjLCAweDFiMzNlLCAweDFiMzYwLCAweDFiMzljLCAweDFiM2MyLCAweDFiM2M0LCAweDFiM2M4LFxuICAgICAgICAweDFiM2QwLCAweDFiM2U2LCAweDFiNDEwLCAweDFiNDFlLCAweDFiNDIwLCAweDFiNDNjLCAweDFiNDQwLCAweDFiNDc4LCAweDFiNGYwLCAweDFiNWUwLCAweDFiNjE4LCAweDFiNjYwLFxuICAgICAgICAweDFiNjdjLCAweDFiNmMwLCAweDFiNzM4LCAweDFiNzgyLCAweDFiNzg0LCAweDFiNzg4LCAweDFiNzkwLCAweDFiNzllLCAweDFiN2EwLCAweDFiN2NjLCAweDFiODJlLCAweDFiODRlLFxuICAgICAgICAweDFiODVjLCAweDFiODhlLCAweDFiODljLCAweDFiOGI4LCAweDFiOGMyLCAweDFiOGM0LCAweDFiOGM4LCAweDFiOGQwLCAweDFiOGU2LCAweDFiOGZhLCAweDFiOTBlLCAweDFiOTFjLFxuICAgICAgICAweDFiOTM4LCAweDFiOTcwLCAweDFiOTdlLCAweDFiOTgyLCAweDFiOTg0LCAweDFiOTg4LCAweDFiOTkwLCAweDFiOTllLCAweDFiOWEwLCAweDFiOWNjLCAweDFiOWYyLCAweDFiOWY0LFxuICAgICAgICAweDFiYTBlLCAweDFiYTFjLCAweDFiYTM4LCAweDFiYTcwLCAweDFiYTdlLCAweDFiYWUwLCAweDFiYWZjLCAweDFiYjA4LCAweDFiYjEwLCAweDFiYjIwLCAweDFiYjNjLCAweDFiYjQwLFxuICAgICAgICAweDFiYjk4LCAweDFiYmNlLCAweDFiYmUyLCAweDFiYmU0LCAweDFiYmU4LCAweDFiYzE2LCAweDFiYzI2LCAweDFiYzJjLCAweDFiYzQ2LCAweDFiYzRjLCAweDFiYzU4LCAweDFiYzcyLFxuICAgICAgICAweDFiYzc0LCAweDFiYzg2LCAweDFiYzhjLCAweDFiYzk4LCAweDFiY2IwLCAweDFiY2JlLCAweDFiY2NlLCAweDFiY2UyLCAweDFiY2U0LCAweDFiY2U4LCAweDFiZDA2LCAweDFiZDBjLFxuICAgICAgICAweDFiZDE4LCAweDFiZDMwLCAweDFiZDNlLCAweDFiZDYwLCAweDFiZDdjLCAweDFiZDljLCAweDFiZGMyLCAweDFiZGM0LCAweDFiZGM4LCAweDFiZGQwLCAweDFiZGU2LCAweDFiZGZhLFxuICAgICAgICAweDFiZTEyLCAweDFiZTE0LCAweDFiZTIyLCAweDFiZTI0LCAweDFiZTI4LCAweDFiZTQyLCAweDFiZTQ0LCAweDFiZTQ4LCAweDFiZTUwLCAweDFiZTVlLCAweDFiZTY2LCAweDFiZTgyLFxuICAgICAgICAweDFiZTg0LCAweDFiZTg4LCAweDFiZTkwLCAweDFiZTllLCAweDFiZWEwLCAweDFiZWJjLCAweDFiZWNjLCAweDFiZWY0LCAweDFiZjFhLCAweDFiZjJlLCAweDFiZjMyLCAweDFiZjM0LFxuICAgICAgICAweDFiZjRlLCAweDFiZjVjLCAweDFiZjYyLCAweDFiZjY0LCAweDFiZjY4LCAweDFjMDlhLCAweDFjMGIyLCAweDFjMGI0LCAweDFjMTFhLCAweDFjMTMyLCAweDFjMTM0LCAweDFjMTYyLFxuICAgICAgICAweDFjMTY0LCAweDFjMTY4LCAweDFjMTc2LCAweDFjMWJhLCAweDFjMjFhLCAweDFjMjMyLCAweDFjMjM0LCAweDFjMjRlLCAweDFjMjVjLCAweDFjMjYyLCAweDFjMjY0LCAweDFjMjY4LFxuICAgICAgICAweDFjMjc2LCAweDFjMjhlLCAweDFjMmMyLCAweDFjMmM0LCAweDFjMmM4LCAweDFjMmQwLCAweDFjMmRlLCAweDFjMmU2LCAweDFjMmVjLCAweDFjMmZhLCAweDFjMzE2LCAweDFjMzI2LFxuICAgICAgICAweDFjMzNhLCAweDFjMzQ2LCAweDFjMzRjLCAweDFjMzcyLCAweDFjMzc0LCAweDFjNDFhLCAweDFjNDJlLCAweDFjNDMyLCAweDFjNDM0LCAweDFjNDRlLCAweDFjNDVjLCAweDFjNDYyLFxuICAgICAgICAweDFjNDY0LCAweDFjNDY4LCAweDFjNDc2LCAweDFjNDhlLCAweDFjNDljLCAweDFjNGI4LCAweDFjNGMyLCAweDFjNGM4LCAweDFjNGQwLCAweDFjNGRlLCAweDFjNGU2LCAweDFjNGVjLFxuICAgICAgICAweDFjNGZhLCAweDFjNTFjLCAweDFjNTM4LCAweDFjNTcwLCAweDFjNTdlLCAweDFjNTgyLCAweDFjNTg0LCAweDFjNTg4LCAweDFjNTkwLCAweDFjNTllLCAweDFjNWEwLCAweDFjNWJjLFxuICAgICAgICAweDFjNWM2LCAweDFjNWNjLCAweDFjNWQ4LCAweDFjNWVlLCAweDFjNWYyLCAweDFjNWY0LCAweDFjNjE2LCAweDFjNjI2LCAweDFjNjJjLCAweDFjNjNhLCAweDFjNjQ2LCAweDFjNjRjLFxuICAgICAgICAweDFjNjU4LCAweDFjNjZlLCAweDFjNjcyLCAweDFjNjc0LCAweDFjNjg2LCAweDFjNjhjLCAweDFjNjk4LCAweDFjNmIwLCAweDFjNmJlLCAweDFjNmNlLCAweDFjNmRjLCAweDFjNmUyLFxuICAgICAgICAweDFjNmU0LCAweDFjNmU4LCAweDFjNzEyLCAweDFjNzE0LCAweDFjNzIyLCAweDFjNzI4LCAweDFjNzM2LCAweDFjNzQyLCAweDFjNzQ0LCAweDFjNzQ4LCAweDFjNzUwLCAweDFjNzVlLFxuICAgICAgICAweDFjNzY2LCAweDFjNzZjLCAweDFjNzdhLCAweDFjN2FlLCAweDFjN2Q2LCAweDFjN2VhLCAweDFjODFhLCAweDFjODJlLCAweDFjODMyLCAweDFjODM0LCAweDFjODRlLCAweDFjODVjLFxuICAgICAgICAweDFjODYyLCAweDFjODY0LCAweDFjODY4LCAweDFjODc2LCAweDFjODhlLCAweDFjODljLCAweDFjOGI4LCAweDFjOGMyLCAweDFjOGM4LCAweDFjOGQwLCAweDFjOGRlLCAweDFjOGU2LFxuICAgICAgICAweDFjOGVjLCAweDFjOGZhLCAweDFjOTBlLCAweDFjOTM4LCAweDFjOTcwLCAweDFjOTdlLCAweDFjOTgyLCAweDFjOTg0LCAweDFjOTkwLCAweDFjOTllLCAweDFjOWEwLCAweDFjOWJjLFxuICAgICAgICAweDFjOWM2LCAweDFjOWNjLCAweDFjOWQ4LCAweDFjOWVlLCAweDFjOWYyLCAweDFjOWY0LCAweDFjYTM4LCAweDFjYTcwLCAweDFjYTdlLCAweDFjYWUwLCAweDFjYWZjLCAweDFjYjAyLFxuICAgICAgICAweDFjYjA0LCAweDFjYjA4LCAweDFjYjEwLCAweDFjYjIwLCAweDFjYjNjLCAweDFjYjQwLCAweDFjYjc4LCAweDFjYjg2LCAweDFjYjhjLCAweDFjYjk4LCAweDFjYmIwLCAweDFjYmJlLFxuICAgICAgICAweDFjYmNlLCAweDFjYmRjLCAweDFjYmUyLCAweDFjYmU0LCAweDFjYmU4LCAweDFjYmY2LCAweDFjYzE2LCAweDFjYzI2LCAweDFjYzJjLCAweDFjYzNhLCAweDFjYzQ2LCAweDFjYzU4LFxuICAgICAgICAweDFjYzcyLCAweDFjYzc0LCAweDFjYzg2LCAweDFjY2IwLCAweDFjY2JlLCAweDFjY2NlLCAweDFjY2UyLCAweDFjY2U0LCAweDFjY2U4LCAweDFjZDA2LCAweDFjZDBjLCAweDFjZDE4LFxuICAgICAgICAweDFjZDMwLCAweDFjZDNlLCAweDFjZDYwLCAweDFjZDdjLCAweDFjZDljLCAweDFjZGMyLCAweDFjZGM0LCAweDFjZGM4LCAweDFjZGQwLCAweDFjZGRlLCAweDFjZGU2LCAweDFjZGZhLFxuICAgICAgICAweDFjZTIyLCAweDFjZTI4LCAweDFjZTQyLCAweDFjZTUwLCAweDFjZTVlLCAweDFjZTY2LCAweDFjZTdhLCAweDFjZTgyLCAweDFjZTg0LCAweDFjZTg4LCAweDFjZTkwLCAweDFjZTllLFxuICAgICAgICAweDFjZWEwLCAweDFjZWJjLCAweDFjZWNjLCAweDFjZWYyLCAweDFjZWY0LCAweDFjZjJlLCAweDFjZjMyLCAweDFjZjM0LCAweDFjZjRlLCAweDFjZjVjLCAweDFjZjYyLCAweDFjZjY0LFxuICAgICAgICAweDFjZjY4LCAweDFjZjk2LCAweDFjZmE2LCAweDFjZmFjLCAweDFjZmNhLCAweDFjZmQyLCAweDFjZmQ0LCAweDFkMDJlLCAweDFkMDMyLCAweDFkMDM0LCAweDFkMDRlLCAweDFkMDVjLFxuICAgICAgICAweDFkMDYyLCAweDFkMDY0LCAweDFkMDY4LCAweDFkMDc2LCAweDFkMDhlLCAweDFkMDljLCAweDFkMGI4LCAweDFkMGMyLCAweDFkMGM0LCAweDFkMGM4LCAweDFkMGQwLCAweDFkMGRlLFxuICAgICAgICAweDFkMGU2LCAweDFkMGVjLCAweDFkMGZhLCAweDFkMTFjLCAweDFkMTM4LCAweDFkMTcwLCAweDFkMTdlLCAweDFkMTgyLCAweDFkMTg0LCAweDFkMTg4LCAweDFkMTkwLCAweDFkMTllLFxuICAgICAgICAweDFkMWEwLCAweDFkMWJjLCAweDFkMWM2LCAweDFkMWNjLCAweDFkMWQ4LCAweDFkMWVlLCAweDFkMWYyLCAweDFkMWY0LCAweDFkMjFjLCAweDFkMjM4LCAweDFkMjcwLCAweDFkMjdlLFxuICAgICAgICAweDFkMmUwLCAweDFkMmZjLCAweDFkMzAyLCAweDFkMzA0LCAweDFkMzA4LCAweDFkMzEwLCAweDFkMzFlLCAweDFkMzIwLCAweDFkMzNjLCAweDFkMzQwLCAweDFkMzc4LCAweDFkMzg2LFxuICAgICAgICAweDFkMzhjLCAweDFkMzk4LCAweDFkM2IwLCAweDFkM2JlLCAweDFkM2NlLCAweDFkM2RjLCAweDFkM2UyLCAweDFkM2U0LCAweDFkM2U4LCAweDFkM2Y2LCAweDFkNDcwLCAweDFkNDdlLFxuICAgICAgICAweDFkNGUwLCAweDFkNGZjLCAweDFkNWMwLCAweDFkNWY4LCAweDFkNjA0LCAweDFkNjA4LCAweDFkNjEwLCAweDFkNjIwLCAweDFkNjQwLCAweDFkNjc4LCAweDFkNmYwLCAweDFkNzA2LFxuICAgICAgICAweDFkNzBjLCAweDFkNzE4LCAweDFkNzMwLCAweDFkNzNlLCAweDFkNzYwLCAweDFkNzdjLCAweDFkNzhlLCAweDFkNzljLCAweDFkN2I4LCAweDFkN2MyLCAweDFkN2M0LCAweDFkN2M4LFxuICAgICAgICAweDFkN2QwLCAweDFkN2RlLCAweDFkN2U2LCAweDFkN2VjLCAweDFkODI2LCAweDFkODJjLCAweDFkODNhLCAweDFkODQ2LCAweDFkODRjLCAweDFkODU4LCAweDFkODcyLCAweDFkODc0LFxuICAgICAgICAweDFkODg2LCAweDFkODhjLCAweDFkODk4LCAweDFkOGIwLCAweDFkOGJlLCAweDFkOGNlLCAweDFkOGUyLCAweDFkOGU0LCAweDFkOGU4LCAweDFkOGY2LCAweDFkOTBjLCAweDFkOTE4LFxuICAgICAgICAweDFkOTMwLCAweDFkOTNlLCAweDFkOTYwLCAweDFkOTdjLCAweDFkOTljLCAweDFkOWMyLCAweDFkOWM0LCAweDFkOWM4LCAweDFkOWQwLCAweDFkOWU2LCAweDFkOWZhLCAweDFkYTBjLFxuICAgICAgICAweDFkYTE4LCAweDFkYTMwLCAweDFkYTNlLCAweDFkYTYwLCAweDFkYTdjLCAweDFkYWMwLCAweDFkYWY4LCAweDFkYjM4LCAweDFkYjgyLCAweDFkYjg0LCAweDFkYjg4LCAweDFkYjkwLFxuICAgICAgICAweDFkYjllLCAweDFkYmEwLCAweDFkYmNjLCAweDFkYmYyLCAweDFkYmY0LCAweDFkYzIyLCAweDFkYzQyLCAweDFkYzQ0LCAweDFkYzQ4LCAweDFkYzUwLCAweDFkYzVlLCAweDFkYzY2LFxuICAgICAgICAweDFkYzdhLCAweDFkYzgyLCAweDFkYzg0LCAweDFkYzg4LCAweDFkYzkwLCAweDFkYzllLCAweDFkY2EwLCAweDFkY2JjLCAweDFkY2NjLCAweDFkY2YyLCAweDFkY2Y0LCAweDFkZDA0LFxuICAgICAgICAweDFkZDA4LCAweDFkZDEwLCAweDFkZDFlLCAweDFkZDIwLCAweDFkZDNjLCAweDFkZDQwLCAweDFkZDc4LCAweDFkZDg2LCAweDFkZDk4LCAweDFkZGNlLCAweDFkZGUyLCAweDFkZGU0LFxuICAgICAgICAweDFkZGU4LCAweDFkZTJlLCAweDFkZTMyLCAweDFkZTM0LCAweDFkZTRlLCAweDFkZTVjLCAweDFkZTYyLCAweDFkZTY0LCAweDFkZTY4LCAweDFkZThlLCAweDFkZTljLCAweDFkZWI4LFxuICAgICAgICAweDFkZWMyLCAweDFkZWM0LCAweDFkZWM4LCAweDFkZWQwLCAweDFkZWU2LCAweDFkZWZhLCAweDFkZjE2LCAweDFkZjI2LCAweDFkZjJjLCAweDFkZjQ2LCAweDFkZjRjLCAweDFkZjU4LFxuICAgICAgICAweDFkZjcyLCAweDFkZjc0LCAweDFkZjhhLCAweDFkZjkyLCAweDFkZjk0LCAweDFkZmEyLCAweDFkZmE0LCAweDFkZmE4LCAweDFlMDhhLCAweDFlMDkyLCAweDFlMDk0LCAweDFlMGEyLFxuICAgICAgICAweDFlMGE0LCAweDFlMGE4LCAweDFlMGI2LCAweDFlMGRhLCAweDFlMTBhLCAweDFlMTEyLCAweDFlMTE0LCAweDFlMTIyLCAweDFlMTI0LCAweDFlMTI4LCAweDFlMTM2LCAweDFlMTQyLFxuICAgICAgICAweDFlMTQ0LCAweDFlMTQ4LCAweDFlMTUwLCAweDFlMTY2LCAweDFlMTZjLCAweDFlMTdhLCAweDFlMTlhLCAweDFlMWIyLCAweDFlMWI0LCAweDFlMjBhLCAweDFlMjEyLCAweDFlMjE0LFxuICAgICAgICAweDFlMjIyLCAweDFlMjI0LCAweDFlMjI4LCAweDFlMjM2LCAweDFlMjQyLCAweDFlMjQ4LCAweDFlMjUwLCAweDFlMjVlLCAweDFlMjY2LCAweDFlMjZjLCAweDFlMjdhLCAweDFlMjgyLFxuICAgICAgICAweDFlMjg0LCAweDFlMjg4LCAweDFlMjkwLCAweDFlMmEwLCAweDFlMmJjLCAweDFlMmM2LCAweDFlMmNjLCAweDFlMmQ4LCAweDFlMmVlLCAweDFlMmYyLCAweDFlMmY0LCAweDFlMzFhLFxuICAgICAgICAweDFlMzMyLCAweDFlMzM0LCAweDFlMzVjLCAweDFlMzYyLCAweDFlMzY0LCAweDFlMzY4LCAweDFlM2JhLCAweDFlNDBhLCAweDFlNDEyLCAweDFlNDE0LCAweDFlNDIyLCAweDFlNDI4LFxuICAgICAgICAweDFlNDM2LCAweDFlNDQyLCAweDFlNDQ4LCAweDFlNDUwLCAweDFlNDVlLCAweDFlNDY2LCAweDFlNDZjLCAweDFlNDdhLCAweDFlNDgyLCAweDFlNDg0LCAweDFlNDkwLCAweDFlNDllLFxuICAgICAgICAweDFlNGEwLCAweDFlNGJjLCAweDFlNGM2LCAweDFlNGNjLCAweDFlNGQ4LCAweDFlNGVlLCAweDFlNGYyLCAweDFlNGY0LCAweDFlNTAyLCAweDFlNTA0LCAweDFlNTA4LCAweDFlNTEwLFxuICAgICAgICAweDFlNTFlLCAweDFlNTIwLCAweDFlNTNjLCAweDFlNTQwLCAweDFlNTc4LCAweDFlNTg2LCAweDFlNThjLCAweDFlNTk4LCAweDFlNWIwLCAweDFlNWJlLCAweDFlNWNlLCAweDFlNWRjLFxuICAgICAgICAweDFlNWUyLCAweDFlNWU0LCAweDFlNWU4LCAweDFlNWY2LCAweDFlNjFhLCAweDFlNjJlLCAweDFlNjMyLCAweDFlNjM0LCAweDFlNjRlLCAweDFlNjVjLCAweDFlNjYyLCAweDFlNjY4LFxuICAgICAgICAweDFlNjhlLCAweDFlNjljLCAweDFlNmI4LCAweDFlNmMyLCAweDFlNmM0LCAweDFlNmM4LCAweDFlNmQwLCAweDFlNmU2LCAweDFlNmZhLCAweDFlNzE2LCAweDFlNzI2LCAweDFlNzJjLFxuICAgICAgICAweDFlNzNhLCAweDFlNzQ2LCAweDFlNzRjLCAweDFlNzU4LCAweDFlNzcyLCAweDFlNzc0LCAweDFlNzkyLCAweDFlNzk0LCAweDFlN2EyLCAweDFlN2E0LCAweDFlN2E4LCAweDFlN2I2LFxuICAgICAgICAweDFlODEyLCAweDFlODE0LCAweDFlODIyLCAweDFlODI0LCAweDFlODI4LCAweDFlODM2LCAweDFlODQyLCAweDFlODQ0LCAweDFlODQ4LCAweDFlODUwLCAweDFlODVlLCAweDFlODY2LFxuICAgICAgICAweDFlODZjLCAweDFlODdhLCAweDFlODgyLCAweDFlODg0LCAweDFlODg4LCAweDFlODkwLCAweDFlODllLCAweDFlOGEwLCAweDFlOGJjLCAweDFlOGM2LCAweDFlOGNjLCAweDFlOGQ4LFxuICAgICAgICAweDFlOGVlLCAweDFlOGYyLCAweDFlOGY0LCAweDFlOTAyLCAweDFlOTA0LCAweDFlOTA4LCAweDFlOTEwLCAweDFlOTIwLCAweDFlOTNjLCAweDFlOTQwLCAweDFlOTc4LCAweDFlOTg2LFxuICAgICAgICAweDFlOThjLCAweDFlOTk4LCAweDFlOWIwLCAweDFlOWJlLCAweDFlOWNlLCAweDFlOWRjLCAweDFlOWUyLCAweDFlOWU0LCAweDFlOWU4LCAweDFlOWY2LCAweDFlYTA0LCAweDFlYTA4LFxuICAgICAgICAweDFlYTEwLCAweDFlYTIwLCAweDFlYTQwLCAweDFlYTc4LCAweDFlYWYwLCAweDFlYjA2LCAweDFlYjBjLCAweDFlYjE4LCAweDFlYjMwLCAweDFlYjNlLCAweDFlYjYwLCAweDFlYjdjLFxuICAgICAgICAweDFlYjhlLCAweDFlYjljLCAweDFlYmI4LCAweDFlYmMyLCAweDFlYmM0LCAweDFlYmM4LCAweDFlYmQwLCAweDFlYmRlLCAweDFlYmU2LCAweDFlYmVjLCAweDFlYzFhLCAweDFlYzJlLFxuICAgICAgICAweDFlYzMyLCAweDFlYzM0LCAweDFlYzRlLCAweDFlYzVjLCAweDFlYzYyLCAweDFlYzY0LCAweDFlYzY4LCAweDFlYzhlLCAweDFlYzljLCAweDFlY2I4LCAweDFlY2MyLCAweDFlY2M0LFxuICAgICAgICAweDFlY2M4LCAweDFlY2QwLCAweDFlY2U2LCAweDFlY2ZhLCAweDFlZDBlLCAweDFlZDFjLCAweDFlZDM4LCAweDFlZDcwLCAweDFlZDdlLCAweDFlZDgyLCAweDFlZDg0LCAweDFlZDg4LFxuICAgICAgICAweDFlZDkwLCAweDFlZDllLCAweDFlZGEwLCAweDFlZGNjLCAweDFlZGYyLCAweDFlZGY0LCAweDFlZTE2LCAweDFlZTI2LCAweDFlZTJjLCAweDFlZTNhLCAweDFlZTQ2LCAweDFlZTRjLFxuICAgICAgICAweDFlZTU4LCAweDFlZTZlLCAweDFlZTcyLCAweDFlZTc0LCAweDFlZTg2LCAweDFlZThjLCAweDFlZTk4LCAweDFlZWIwLCAweDFlZWJlLCAweDFlZWNlLCAweDFlZWRjLCAweDFlZWUyLFxuICAgICAgICAweDFlZWU0LCAweDFlZWU4LCAweDFlZjEyLCAweDFlZjIyLCAweDFlZjI0LCAweDFlZjI4LCAweDFlZjM2LCAweDFlZjQyLCAweDFlZjQ0LCAweDFlZjQ4LCAweDFlZjUwLCAweDFlZjVlLFxuICAgICAgICAweDFlZjY2LCAweDFlZjZjLCAweDFlZjdhLCAweDFlZmFlLCAweDFlZmIyLCAweDFlZmI0LCAweDFlZmQ2LCAweDFmMDk2LCAweDFmMGE2LCAweDFmMGFjLCAweDFmMGJhLCAweDFmMGNhLFxuICAgICAgICAweDFmMGQyLCAweDFmMGQ0LCAweDFmMTE2LCAweDFmMTI2LCAweDFmMTJjLCAweDFmMTNhLCAweDFmMTQ2LCAweDFmMTRjLCAweDFmMTU4LCAweDFmMTZlLCAweDFmMTcyLCAweDFmMTc0LFxuICAgICAgICAweDFmMThhLCAweDFmMTkyLCAweDFmMTk0LCAweDFmMWEyLCAweDFmMWE0LCAweDFmMWE4LCAweDFmMWRhLCAweDFmMjE2LCAweDFmMjI2LCAweDFmMjJjLCAweDFmMjNhLCAweDFmMjQ2LFxuICAgICAgICAweDFmMjU4LCAweDFmMjZlLCAweDFmMjcyLCAweDFmMjc0LCAweDFmMjg2LCAweDFmMjhjLCAweDFmMjk4LCAweDFmMmIwLCAweDFmMmJlLCAweDFmMmNlLCAweDFmMmRjLCAweDFmMmUyLFxuICAgICAgICAweDFmMmU0LCAweDFmMmU4LCAweDFmMmY2LCAweDFmMzBhLCAweDFmMzEyLCAweDFmMzE0LCAweDFmMzIyLCAweDFmMzI4LCAweDFmMzQyLCAweDFmMzQ0LCAweDFmMzQ4LCAweDFmMzUwLFxuICAgICAgICAweDFmMzVlLCAweDFmMzY2LCAweDFmMzdhLCAweDFmMzlhLCAweDFmM2FlLCAweDFmM2IyLCAweDFmM2I0LCAweDFmNDE2LCAweDFmNDI2LCAweDFmNDJjLCAweDFmNDNhLCAweDFmNDQ2LFxuICAgICAgICAweDFmNDRjLCAweDFmNDU4LCAweDFmNDZlLCAweDFmNDcyLCAweDFmNDc0LCAweDFmNDg2LCAweDFmNDhjLCAweDFmNDk4LCAweDFmNGIwLCAweDFmNGJlLCAweDFmNGNlLCAweDFmNGRjLFxuICAgICAgICAweDFmNGUyLCAweDFmNGU0LCAweDFmNGU4LCAweDFmNGY2LCAweDFmNTA2LCAweDFmNTBjLCAweDFmNTE4LCAweDFmNTMwLCAweDFmNTNlLCAweDFmNTYwLCAweDFmNTdjLCAweDFmNThlLFxuICAgICAgICAweDFmNTljLCAweDFmNWI4LCAweDFmNWMyLCAweDFmNWM0LCAweDFmNWM4LCAweDFmNWQwLCAweDFmNWRlLCAweDFmNWU2LCAweDFmNWVjLCAweDFmNWZhLCAweDFmNjBhLCAweDFmNjEyLFxuICAgICAgICAweDFmNjE0LCAweDFmNjIyLCAweDFmNjI0LCAweDFmNjI4LCAweDFmNjM2LCAweDFmNjQyLCAweDFmNjQ0LCAweDFmNjQ4LCAweDFmNjUwLCAweDFmNjVlLCAweDFmNjY2LCAweDFmNjdhLFxuICAgICAgICAweDFmNjgyLCAweDFmNjg0LCAweDFmNjg4LCAweDFmNjkwLCAweDFmNjllLCAweDFmNmEwLCAweDFmNmJjLCAweDFmNmNjLCAweDFmNmYyLCAweDFmNmY0LCAweDFmNzFhLCAweDFmNzJlLFxuICAgICAgICAweDFmNzMyLCAweDFmNzM0LCAweDFmNzRlLCAweDFmNzVjLCAweDFmNzYyLCAweDFmNzY0LCAweDFmNzY4LCAweDFmNzc2LCAweDFmNzk2LCAweDFmN2E2LCAweDFmN2FjLCAweDFmN2JhLFxuICAgICAgICAweDFmN2QyLCAweDFmN2Q0LCAweDFmODlhLCAweDFmOGFlLCAweDFmOGIyLCAweDFmOGI0LCAweDFmOGQ2LCAweDFmOGVhLCAweDFmOTFhLCAweDFmOTJlLCAweDFmOTMyLCAweDFmOTM0LFxuICAgICAgICAweDFmOTRlLCAweDFmOTVjLCAweDFmOTYyLCAweDFmOTY0LCAweDFmOTY4LCAweDFmOTc2LCAweDFmOTk2LCAweDFmOWE2LCAweDFmOWFjLCAweDFmOWJhLCAweDFmOWNhLCAweDFmOWQyLFxuICAgICAgICAweDFmOWQ0LCAweDFmYTFhLCAweDFmYTJlLCAweDFmYTMyLCAweDFmYTM0LCAweDFmYTRlLCAweDFmYTVjLCAweDFmYTYyLCAweDFmYTY0LCAweDFmYTY4LCAweDFmYTc2LCAweDFmYThlLFxuICAgICAgICAweDFmYTljLCAweDFmYWI4LCAweDFmYWMyLCAweDFmYWM0LCAweDFmYWM4LCAweDFmYWQwLCAweDFmYWRlLCAweDFmYWU2LCAweDFmYWVjLCAweDFmYjE2LCAweDFmYjI2LCAweDFmYjJjLFxuICAgICAgICAweDFmYjNhLCAweDFmYjQ2LCAweDFmYjRjLCAweDFmYjU4LCAweDFmYjZlLCAweDFmYjcyLCAweDFmYjc0LCAweDFmYjhhLCAweDFmYjkyLCAweDFmYjk0LCAweDFmYmEyLCAweDFmYmE0LFxuICAgICAgICAweDFmYmE4LCAweDFmYmI2LCAweDFmYmRhXG4gICAgXSk7XG4gICAgLyoqXG4gICAgICogVGhpcyB0YWJsZSBjb250YWlucyB0byBjb2Rld29yZHMgZm9yIGFsbCBzeW1ib2xzLlxuICAgICAqL1xuICAgIFBERjQxN0NvbW1vbi5DT0RFV09SRF9UQUJMRSA9IEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgIDI2MjcsIDE4MTksIDI2MjIsIDI2MjEsIDE4MTMsIDE4MTIsIDI3MjksIDI3MjQsIDI3MjMsIDI3NzksIDI3NzQsIDI3NzMsIDkwMiwgODk2LCA5MDgsIDg2OCwgODY1LCA4NjEsIDg1OSwgMjUxMSxcbiAgICAgICAgODczLCA4NzEsIDE3ODAsIDgzNSwgMjQ5MywgODI1LCAyNDkxLCA4NDIsIDgzNywgODQ0LCAxNzY0LCAxNzYyLCA4MTEsIDgxMCwgODA5LCAyNDgzLCA4MDcsIDI0ODIsIDgwNiwgMjQ4MCwgODE1LFxuICAgICAgICA4MTQsIDgxMywgODEyLCAyNDg0LCA4MTcsIDgxNiwgMTc0NSwgMTc0NCwgMTc0MiwgMTc0NiwgMjY1NSwgMjYzNywgMjYzNSwgMjYyNiwgMjYyNSwgMjYyMywgMjYyOCwgMTgyMCwgMjc1MixcbiAgICAgICAgMjczOSwgMjczNywgMjcyOCwgMjcyNywgMjcyNSwgMjczMCwgMjc4NSwgMjc4MywgMjc3OCwgMjc3NywgMjc3NSwgMjc4MCwgNzg3LCA3ODEsIDc0NywgNzM5LCA3MzYsIDI0MTMsIDc1NCwgNzUyLFxuICAgICAgICAxNzE5LCA2OTIsIDY4OSwgNjgxLCAyMzcxLCA2NzgsIDIzNjksIDcwMCwgNjk3LCA2OTQsIDcwMywgMTY4OCwgMTY4NiwgNjQyLCA2MzgsIDIzNDMsIDYzMSwgMjM0MSwgNjI3LCAyMzM4LCA2NTEsXG4gICAgICAgIDY0NiwgNjQzLCAyMzQ1LCA2NTQsIDY1MiwgMTY1MiwgMTY1MCwgMTY0NywgMTY1NCwgNjAxLCA1OTksIDIzMjIsIDU5NiwgMjMyMSwgNTk0LCAyMzE5LCAyMzE3LCA2MTEsIDYxMCwgNjA4LCA2MDYsXG4gICAgICAgIDIzMjQsIDYwMywgMjMyMywgNjE1LCA2MTQsIDYxMiwgMTYxNywgMTYxNiwgMTYxNCwgMTYxMiwgNjE2LCAxNjE5LCAxNjE4LCAyNTc1LCAyNTM4LCAyNTM2LCA5MDUsIDkwMSwgODk4LCA5MDksXG4gICAgICAgIDI1MDksIDI1MDcsIDI1MDQsIDg3MCwgODY3LCA4NjQsIDg2MCwgMjUxMiwgODc1LCA4NzIsIDE3ODEsIDI0OTAsIDI0ODksIDI0ODcsIDI0ODUsIDE3NDgsIDgzNiwgODM0LCA4MzIsIDgzMCxcbiAgICAgICAgMjQ5NCwgODI3LCAyNDkyLCA4NDMsIDg0MSwgODM5LCA4NDUsIDE3NjUsIDE3NjMsIDI3MDEsIDI2NzYsIDI2NzQsIDI2NTMsIDI2NDgsIDI2NTYsIDI2MzQsIDI2MzMsIDI2MzEsIDI2MjksXG4gICAgICAgIDE4MjEsIDI2MzgsIDI2MzYsIDI3NzAsIDI3NjMsIDI3NjEsIDI3NTAsIDI3NDUsIDI3NTMsIDI3MzYsIDI3MzUsIDI3MzMsIDI3MzEsIDE4NDgsIDI3NDAsIDI3MzgsIDI3ODYsIDI3ODQsIDU5MSxcbiAgICAgICAgNTg4LCA1NzYsIDU2OSwgNTY2LCAyMjk2LCAxNTkwLCA1MzcsIDUzNCwgNTI2LCAyMjc2LCA1MjIsIDIyNzQsIDU0NSwgNTQyLCA1MzksIDU0OCwgMTU3MiwgMTU3MCwgNDgxLCAyMjQ1LCA0NjYsXG4gICAgICAgIDIyNDIsIDQ2MiwgMjIzOSwgNDkyLCA0ODUsIDQ4MiwgMjI0OSwgNDk2LCA0OTQsIDE1MzQsIDE1MzEsIDE1MjgsIDE1MzgsIDQxMywgMjE5NiwgNDA2LCAyMTkxLCAyMTg4LCA0MjUsIDQxOSxcbiAgICAgICAgMjIwMiwgNDE1LCAyMTk5LCA0MzIsIDQzMCwgNDI3LCAxNDcyLCAxNDY3LCAxNDY0LCA0MzMsIDE0NzYsIDE0NzQsIDM2OCwgMzY3LCAyMTYwLCAzNjUsIDIxNTksIDM2MiwgMjE1NywgMjE1NSxcbiAgICAgICAgMjE1MiwgMzc4LCAzNzcsIDM3NSwgMjE2NiwgMzcyLCAyMTY1LCAzNjksIDIxNjIsIDM4MywgMzgxLCAzNzksIDIxNjgsIDE0MTksIDE0MTgsIDE0MTYsIDE0MTQsIDM4NSwgMTQxMSwgMzg0LFxuICAgICAgICAxNDIzLCAxNDIyLCAxNDIwLCAxNDI0LCAyNDYxLCA4MDIsIDI0NDEsIDI0MzksIDc5MCwgNzg2LCA3ODMsIDc5NCwgMjQwOSwgMjQwNiwgMjQwMywgNzUwLCA3NDIsIDczOCwgMjQxNCwgNzU2LFxuICAgICAgICA3NTMsIDE3MjAsIDIzNjcsIDIzNjUsIDIzNjIsIDIzNTksIDE2NjMsIDY5MywgNjkxLCA2ODQsIDIzNzMsIDY4MCwgMjM3MCwgNzAyLCA2OTksIDY5NiwgNzA0LCAxNjkwLCAxNjg3LCAyMzM3LFxuICAgICAgICAyMzM2LCAyMzM0LCAyMzMyLCAxNjI0LCAyMzI5LCAxNjIyLCA2NDAsIDYzNywgMjM0NCwgNjM0LCAyMzQyLCA2MzAsIDIzNDAsIDY1MCwgNjQ4LCA2NDUsIDIzNDYsIDY1NSwgNjUzLCAxNjUzLFxuICAgICAgICAxNjUxLCAxNjQ5LCAxNjU1LCAyNjEyLCAyNTk3LCAyNTk1LCAyNTcxLCAyNTY4LCAyNTY1LCAyNTc2LCAyNTM0LCAyNTI5LCAyNTI2LCAxNzg3LCAyNTQwLCAyNTM3LCA5MDcsIDkwNCwgOTAwLFxuICAgICAgICA5MTAsIDI1MDMsIDI1MDIsIDI1MDAsIDI0OTgsIDE3NjgsIDI0OTUsIDE3NjcsIDI1MTAsIDI1MDgsIDI1MDYsIDg2OSwgODY2LCA4NjMsIDI1MTMsIDg3NiwgODc0LCAxNzgyLCAyNzIwLCAyNzEzLFxuICAgICAgICAyNzExLCAyNjk3LCAyNjk0LCAyNjkxLCAyNzAyLCAyNjcyLCAyNjcwLCAyNjY0LCAxODI4LCAyNjc4LCAyNjc1LCAyNjQ3LCAyNjQ2LCAyNjQ0LCAyNjQyLCAxODIzLCAyNjM5LCAxODIyLCAyNjU0LFxuICAgICAgICAyNjUyLCAyNjUwLCAyNjU3LCAyNzcxLCAxODU1LCAyNzY1LCAyNzYyLCAxODUwLCAxODQ5LCAyNzUxLCAyNzQ5LCAyNzQ3LCAyNzU0LCAzNTMsIDIxNDgsIDM0NCwgMzQyLCAzMzYsIDIxNDIsXG4gICAgICAgIDMzMiwgMjE0MCwgMzQ1LCAxMzc1LCAxMzczLCAzMDYsIDIxMzAsIDI5OSwgMjEyOCwgMjk1LCAyMTI1LCAzMTksIDMxNCwgMzExLCAyMTMyLCAxMzU0LCAxMzUyLCAxMzQ5LCAxMzU2LCAyNjIsXG4gICAgICAgIDI1NywgMjEwMSwgMjUzLCAyMDk2LCAyMDkzLCAyNzQsIDI3MywgMjY3LCAyMTA3LCAyNjMsIDIxMDQsIDI4MCwgMjc4LCAyNzUsIDEzMTYsIDEzMTEsIDEzMDgsIDEzMjAsIDEzMTgsIDIwNTIsXG4gICAgICAgIDIwMiwgMjA1MCwgMjA0NCwgMjA0MCwgMjE5LCAyMDYzLCAyMTIsIDIwNjAsIDIwOCwgMjA1NSwgMjI0LCAyMjEsIDIwNjYsIDEyNjAsIDEyNTgsIDEyNTIsIDIzMSwgMTI0OCwgMjI5LCAxMjY2LFxuICAgICAgICAxMjY0LCAxMjYxLCAxMjY4LCAxNTUsIDE5OTgsIDE1MywgMTk5NiwgMTk5NCwgMTk5MSwgMTk4OCwgMTY1LCAxNjQsIDIwMDcsIDE2MiwgMjAwNiwgMTU5LCAyMDAzLCAyMDAwLCAxNzIsIDE3MSxcbiAgICAgICAgMTY5LCAyMDEyLCAxNjYsIDIwMTAsIDExODYsIDExODQsIDExODIsIDExNzksIDE3NSwgMTE3NiwgMTczLCAxMTkyLCAxMTkxLCAxMTg5LCAxMTg3LCAxNzYsIDExOTQsIDExOTMsIDIzMTMsXG4gICAgICAgIDIzMDcsIDIzMDUsIDU5MiwgNTg5LCAyMjk0LCAyMjkyLCAyMjg5LCA1NzgsIDU3MiwgNTY4LCAyMjk3LCA1ODAsIDE1OTEsIDIyNzIsIDIyNjcsIDIyNjQsIDE1NDcsIDUzOCwgNTM2LCA1MjksXG4gICAgICAgIDIyNzgsIDUyNSwgMjI3NSwgNTQ3LCA1NDQsIDU0MSwgMTU3NCwgMTU3MSwgMjIzNywgMjIzNSwgMjIyOSwgMTQ5MywgMjIyNSwgMTQ4OSwgNDc4LCAyMjQ3LCA0NzAsIDIyNDQsIDQ2NSwgMjI0MSxcbiAgICAgICAgNDkzLCA0ODgsIDQ4NCwgMjI1MCwgNDk4LCA0OTUsIDE1MzYsIDE1MzMsIDE1MzAsIDE1MzksIDIxODcsIDIxODYsIDIxODQsIDIxODIsIDE0MzIsIDIxNzksIDE0MzAsIDIxNzYsIDE0MjcsIDQxNCxcbiAgICAgICAgNDEyLCAyMTk3LCA0MDksIDIxOTUsIDQwNSwgMjE5MywgMjE5MCwgNDI2LCA0MjQsIDQyMSwgMjIwMywgNDE4LCAyMjAxLCA0MzEsIDQyOSwgMTQ3MywgMTQ3MSwgMTQ2OSwgMTQ2NiwgNDM0LFxuICAgICAgICAxNDc3LCAxNDc1LCAyNDc4LCAyNDcyLCAyNDcwLCAyNDU5LCAyNDU3LCAyNDU0LCAyNDYyLCA4MDMsIDI0MzcsIDI0MzIsIDI0MjksIDE3MjYsIDI0NDMsIDI0NDAsIDc5MiwgNzg5LCA3ODUsXG4gICAgICAgIDI0MDEsIDIzOTksIDIzOTMsIDE3MDIsIDIzODksIDE2OTksIDI0MTEsIDI0MDgsIDI0MDUsIDc0NSwgNzQxLCAyNDE1LCA3NTgsIDc1NSwgMTcyMSwgMjM1OCwgMjM1NywgMjM1NSwgMjM1MyxcbiAgICAgICAgMTY2MSwgMjM1MCwgMTY2MCwgMjM0NywgMTY1NywgMjM2OCwgMjM2NiwgMjM2NCwgMjM2MSwgMTY2NiwgNjkwLCA2ODcsIDIzNzQsIDY4MywgMjM3MiwgNzAxLCA2OTgsIDcwNSwgMTY5MSwgMTY4OSxcbiAgICAgICAgMjYxOSwgMjYxNywgMjYxMCwgMjYwOCwgMjYwNSwgMjYxMywgMjU5MywgMjU4OCwgMjU4NSwgMTgwMywgMjU5OSwgMjU5NiwgMjU2MywgMjU2MSwgMjU1NSwgMTc5NywgMjU1MSwgMTc5NSwgMjU3MyxcbiAgICAgICAgMjU3MCwgMjU2NywgMjU3NywgMjUyNSwgMjUyNCwgMjUyMiwgMjUyMCwgMTc4NiwgMjUxNywgMTc4NSwgMjUxNCwgMTc4MywgMjUzNSwgMjUzMywgMjUzMSwgMjUyOCwgMTc4OCwgMjU0MSwgMjUzOSxcbiAgICAgICAgOTA2LCA5MDMsIDkxMSwgMjcyMSwgMTg0NCwgMjcxNSwgMjcxMiwgMTgzOCwgMTgzNiwgMjY5OSwgMjY5NiwgMjY5MywgMjcwMywgMTgyNywgMTgyNiwgMTgyNCwgMjY3MywgMjY3MSwgMjY2OSxcbiAgICAgICAgMjY2NiwgMTgyOSwgMjY3OSwgMjY3NywgMTg1OCwgMTg1NywgMjc3MiwgMTg1NCwgMTg1MywgMTg1MSwgMTg1NiwgMjc2NiwgMjc2NCwgMTQzLCAxOTg3LCAxMzksIDE5ODYsIDEzNSwgMTMzLFxuICAgICAgICAxMzEsIDE5ODQsIDEyOCwgMTk4MywgMTI1LCAxOTgxLCAxMzgsIDEzNywgMTM2LCAxOTg1LCAxMTMzLCAxMTMyLCAxMTMwLCAxMTIsIDExMCwgMTk3NCwgMTA3LCAxOTczLCAxMDQsIDE5NzEsXG4gICAgICAgIDE5NjksIDEyMiwgMTIxLCAxMTksIDExNywgMTk3NywgMTE0LCAxOTc2LCAxMjQsIDExMTUsIDExMTQsIDExMTIsIDExMTAsIDExMTcsIDExMTYsIDg0LCA4MywgMTk1MywgODEsIDE5NTIsIDc4LFxuICAgICAgICAxOTUwLCAxOTQ4LCAxOTQ1LCA5NCwgOTMsIDkxLCAxOTU5LCA4OCwgMTk1OCwgODUsIDE5NTUsIDk5LCA5NywgOTUsIDE5NjEsIDEwODYsIDEwODUsIDEwODMsIDEwODEsIDEwNzgsIDEwMCxcbiAgICAgICAgMTA5MCwgMTA4OSwgMTA4NywgMTA5MSwgNDksIDQ3LCAxOTE3LCA0NCwgMTkxNSwgMTkxMywgMTkxMCwgMTkwNywgNTksIDE5MjYsIDU2LCAxOTI1LCA1MywgMTkyMiwgMTkxOSwgNjYsIDY0LFxuICAgICAgICAxOTMxLCA2MSwgMTkyOSwgMTA0MiwgMTA0MCwgMTAzOCwgNzEsIDEwMzUsIDcwLCAxMDMyLCA2OCwgMTA0OCwgMTA0NywgMTA0NSwgMTA0MywgMTA1MCwgMTA0OSwgMTIsIDEwLCAxODY5LCAxODY3LFxuICAgICAgICAxODY0LCAxODYxLCAyMSwgMTg4MCwgMTksIDE4NzcsIDE4NzQsIDE4NzEsIDI4LCAxODg4LCAyNSwgMTg4NiwgMjIsIDE4ODMsIDk4MiwgOTgwLCA5NzcsIDk3NCwgMzIsIDMwLCA5OTEsIDk4OSxcbiAgICAgICAgOTg3LCA5ODQsIDM0LCA5OTUsIDk5NCwgOTkyLCAyMTUxLCAyMTUwLCAyMTQ3LCAyMTQ2LCAyMTQ0LCAzNTYsIDM1NSwgMzU0LCAyMTQ5LCAyMTM5LCAyMTM4LCAyMTM2LCAyMTM0LCAxMzU5LFxuICAgICAgICAzNDMsIDM0MSwgMzM4LCAyMTQzLCAzMzUsIDIxNDEsIDM0OCwgMzQ3LCAzNDYsIDEzNzYsIDEzNzQsIDIxMjQsIDIxMjMsIDIxMjEsIDIxMTksIDEzMjYsIDIxMTYsIDEzMjQsIDMxMCwgMzA4LFxuICAgICAgICAzMDUsIDIxMzEsIDMwMiwgMjEyOSwgMjk4LCAyMTI3LCAzMjAsIDMxOCwgMzE2LCAzMTMsIDIxMzMsIDMyMiwgMzIxLCAxMzU1LCAxMzUzLCAxMzUxLCAxMzU3LCAyMDkyLCAyMDkxLCAyMDg5LFxuICAgICAgICAyMDg3LCAxMjc2LCAyMDg0LCAxMjc0LCAyMDgxLCAxMjcxLCAyNTksIDIxMDIsIDI1NiwgMjEwMCwgMjUyLCAyMDk4LCAyMDk1LCAyNzIsIDI2OSwgMjEwOCwgMjY2LCAyMTA2LCAyODEsIDI3OSxcbiAgICAgICAgMjc3LCAxMzE3LCAxMzE1LCAxMzEzLCAxMzEwLCAyODIsIDEzMjEsIDEzMTksIDIwMzksIDIwMzcsIDIwMzUsIDIwMzIsIDEyMDMsIDIwMjksIDEyMDAsIDExOTcsIDIwNywgMjA1MywgMjA1LFxuICAgICAgICAyMDUxLCAyMDEsIDIwNDksIDIwNDYsIDIwNDMsIDIyMCwgMjE4LCAyMDY0LCAyMTUsIDIwNjIsIDIxMSwgMjA1OSwgMjI4LCAyMjYsIDIyMywgMjA2OSwgMTI1OSwgMTI1NywgMTI1NCwgMjMyLFxuICAgICAgICAxMjUxLCAyMzAsIDEyNjcsIDEyNjUsIDEyNjMsIDIzMTYsIDIzMTUsIDIzMTIsIDIzMTEsIDIzMDksIDIzMTQsIDIzMDQsIDIzMDMsIDIzMDEsIDIyOTksIDE1OTMsIDIzMDgsIDIzMDYsIDU5MCxcbiAgICAgICAgMjI4OCwgMjI4NywgMjI4NSwgMjI4MywgMTU3OCwgMjI4MCwgMTU3NywgMjI5NSwgMjI5MywgMjI5MSwgNTc5LCA1NzcsIDU3NCwgNTcxLCAyMjk4LCA1ODIsIDU4MSwgMTU5MiwgMjI2MywgMjI2MixcbiAgICAgICAgMjI2MCwgMjI1OCwgMTU0NSwgMjI1NSwgMTU0NCwgMjI1MiwgMTU0MSwgMjI3MywgMjI3MSwgMjI2OSwgMjI2NiwgMTU1MCwgNTM1LCA1MzIsIDIyNzksIDUyOCwgMjI3NywgNTQ2LCA1NDMsIDU0OSxcbiAgICAgICAgMTU3NSwgMTU3MywgMjIyNCwgMjIyMiwgMjIyMCwgMTQ4NiwgMjIxNywgMTQ4NSwgMjIxNCwgMTQ4MiwgMTQ3OSwgMjIzOCwgMjIzNiwgMjIzNCwgMjIzMSwgMTQ5NiwgMjIyOCwgMTQ5MiwgNDgwLFxuICAgICAgICA0NzcsIDIyNDgsIDQ3MywgMjI0NiwgNDY5LCAyMjQzLCA0OTAsIDQ4NywgMjI1MSwgNDk3LCAxNTM3LCAxNTM1LCAxNTMyLCAyNDc3LCAyNDc2LCAyNDc0LCAyNDc5LCAyNDY5LCAyNDY4LCAyNDY2LFxuICAgICAgICAyNDY0LCAxNzMwLCAyNDczLCAyNDcxLCAyNDUzLCAyNDUyLCAyNDUwLCAyNDQ4LCAxNzI5LCAyNDQ1LCAxNzI4LCAyNDYwLCAyNDU4LCAyNDU2LCAyNDYzLCA4MDUsIDgwNCwgMjQyOCwgMjQyNyxcbiAgICAgICAgMjQyNSwgMjQyMywgMTcyNSwgMjQyMCwgMTcyNCwgMjQxNywgMTcyMiwgMjQzOCwgMjQzNiwgMjQzNCwgMjQzMSwgMTcyNywgMjQ0NCwgMjQ0MiwgNzkzLCA3OTEsIDc4OCwgNzk1LCAyMzg4LFxuICAgICAgICAyMzg2LCAyMzg0LCAxNjk3LCAyMzgxLCAxNjk2LCAyMzc4LCAxNjk0LCAxNjkyLCAyNDAyLCAyNDAwLCAyMzk4LCAyMzk1LCAxNzAzLCAyMzkyLCAxNzAxLCAyNDEyLCAyNDEwLCAyNDA3LCA3NTEsXG4gICAgICAgIDc0OCwgNzQ0LCAyNDE2LCA3NTksIDc1NywgMTgwNywgMjYyMCwgMjYxOCwgMTgwNiwgMTgwNSwgMjYxMSwgMjYwOSwgMjYwNywgMjYxNCwgMTgwMiwgMTgwMSwgMTc5OSwgMjU5NCwgMjU5MixcbiAgICAgICAgMjU5MCwgMjU4NywgMTgwNCwgMjYwMCwgMjU5OCwgMTc5NCwgMTc5MywgMTc5MSwgMTc4OSwgMjU2NCwgMjU2MiwgMjU2MCwgMjU1NywgMTc5OCwgMjU1NCwgMTc5NiwgMjU3NCwgMjU3MiwgMjU2OSxcbiAgICAgICAgMjU3OCwgMTg0NywgMTg0NiwgMjcyMiwgMTg0MywgMTg0MiwgMTg0MCwgMTg0NSwgMjcxNiwgMjcxNCwgMTgzNSwgMTgzNCwgMTgzMiwgMTgzMCwgMTgzOSwgMTgzNywgMjcwMCwgMjY5OCwgMjY5NSxcbiAgICAgICAgMjcwNCwgMTgxNywgMTgxMSwgMTgxMCwgODk3LCA4NjIsIDE3NzcsIDgyOSwgODI2LCA4MzgsIDE3NjAsIDE3NTgsIDgwOCwgMjQ4MSwgMTc0MSwgMTc0MCwgMTczOCwgMTc0MywgMjYyNCwgMTgxOCxcbiAgICAgICAgMjcyNiwgMjc3NiwgNzgyLCA3NDAsIDczNywgMTcxNSwgNjg2LCA2NzksIDY5NSwgMTY4MiwgMTY4MCwgNjM5LCA2MjgsIDIzMzksIDY0NywgNjQ0LCAxNjQ1LCAxNjQzLCAxNjQwLCAxNjQ4LFxuICAgICAgICA2MDIsIDYwMCwgNTk3LCA1OTUsIDIzMjAsIDU5MywgMjMxOCwgNjA5LCA2MDcsIDYwNCwgMTYxMSwgMTYxMCwgMTYwOCwgMTYwNiwgNjEzLCAxNjE1LCAxNjEzLCAyMzI4LCA5MjYsIDkyNCwgODkyLFxuICAgICAgICA4ODYsIDg5OSwgODU3LCA4NTAsIDI1MDUsIDE3NzgsIDgyNCwgODIzLCA4MjEsIDgxOSwgMjQ4OCwgODE4LCAyNDg2LCA4MzMsIDgzMSwgODI4LCA4NDAsIDE3NjEsIDE3NTksIDI2NDksIDI2MzIsXG4gICAgICAgIDI2MzAsIDI3NDYsIDI3MzQsIDI3MzIsIDI3ODIsIDI3ODEsIDU3MCwgNTY3LCAxNTg3LCA1MzEsIDUyNywgNTIzLCA1NDAsIDE1NjYsIDE1NjQsIDQ3NiwgNDY3LCA0NjMsIDIyNDAsIDQ4NixcbiAgICAgICAgNDgzLCAxNTI0LCAxNTIxLCAxNTE4LCAxNTI5LCA0MTEsIDQwMywgMjE5MiwgMzk5LCAyMTg5LCA0MjMsIDQxNiwgMTQ2MiwgMTQ1NywgMTQ1NCwgNDI4LCAxNDY4LCAxNDY1LCAyMjEwLCAzNjYsXG4gICAgICAgIDM2MywgMjE1OCwgMzYwLCAyMTU2LCAzNTcsIDIxNTMsIDM3NiwgMzczLCAzNzAsIDIxNjMsIDE0MTAsIDE0MDksIDE0MDcsIDE0MDUsIDM4MiwgMTQwMiwgMzgwLCAxNDE3LCAxNDE1LCAxNDEyLFxuICAgICAgICAxNDIxLCAyMTc1LCAyMTc0LCA3NzcsIDc3NCwgNzcxLCA3ODQsIDczMiwgNzI1LCA3MjIsIDI0MDQsIDc0MywgMTcxNiwgNjc2LCA2NzQsIDY2OCwgMjM2MywgNjY1LCAyMzYwLCA2ODUsIDE2ODQsXG4gICAgICAgIDE2ODEsIDYyNiwgNjI0LCA2MjIsIDIzMzUsIDYyMCwgMjMzMywgNjE3LCAyMzMwLCA2NDEsIDYzNSwgNjQ5LCAxNjQ2LCAxNjQ0LCAxNjQyLCAyNTY2LCA5MjgsIDkyNSwgMjUzMCwgMjUyNyxcbiAgICAgICAgODk0LCA4OTEsIDg4OCwgMjUwMSwgMjQ5OSwgMjQ5NiwgODU4LCA4NTYsIDg1NCwgODUxLCAxNzc5LCAyNjkyLCAyNjY4LCAyNjY1LCAyNjQ1LCAyNjQzLCAyNjQwLCAyNjUxLCAyNzY4LCAyNzU5LFxuICAgICAgICAyNzU3LCAyNzQ0LCAyNzQzLCAyNzQxLCAyNzQ4LCAzNTIsIDEzODIsIDM0MCwgMzM3LCAzMzMsIDEzNzEsIDEzNjksIDMwNywgMzAwLCAyOTYsIDIxMjYsIDMxNSwgMzEyLCAxMzQ3LCAxMzQyLFxuICAgICAgICAxMzUwLCAyNjEsIDI1OCwgMjUwLCAyMDk3LCAyNDYsIDIwOTQsIDI3MSwgMjY4LCAyNjQsIDEzMDYsIDEzMDEsIDEyOTgsIDI3NiwgMTMxMiwgMTMwOSwgMjExNSwgMjAzLCAyMDQ4LCAxOTUsXG4gICAgICAgIDIwNDUsIDE5MSwgMjA0MSwgMjEzLCAyMDksIDIwNTYsIDEyNDYsIDEyNDQsIDEyMzgsIDIyNSwgMTIzNCwgMjIyLCAxMjU2LCAxMjUzLCAxMjQ5LCAxMjYyLCAyMDgwLCAyMDc5LCAxNTQsIDE5OTcsXG4gICAgICAgIDE1MCwgMTk5NSwgMTQ3LCAxOTkyLCAxOTg5LCAxNjMsIDE2MCwgMjAwNCwgMTU2LCAyMDAxLCAxMTc1LCAxMTc0LCAxMTcyLCAxMTcwLCAxMTY3LCAxNzAsIDExNjQsIDE2NywgMTE4NSwgMTE4MyxcbiAgICAgICAgMTE4MCwgMTE3NywgMTc0LCAxMTkwLCAxMTg4LCAyMDI1LCAyMDI0LCAyMDIyLCA1ODcsIDU4NiwgNTY0LCA1NTksIDU1NiwgMjI5MCwgNTczLCAxNTg4LCA1MjAsIDUxOCwgNTEyLCAyMjY4LFxuICAgICAgICA1MDgsIDIyNjUsIDUzMCwgMTU2OCwgMTU2NSwgNDYxLCA0NTcsIDIyMzMsIDQ1MCwgMjIzMCwgNDQ2LCAyMjI2LCA0NzksIDQ3MSwgNDg5LCAxNTI2LCAxNTIzLCAxNTIwLCAzOTcsIDM5NSxcbiAgICAgICAgMjE4NSwgMzkyLCAyMTgzLCAzODksIDIxODAsIDIxNzcsIDQxMCwgMjE5NCwgNDAyLCA0MjIsIDE0NjMsIDE0NjEsIDE0NTksIDE0NTYsIDE0NzAsIDI0NTUsIDc5OSwgMjQzMywgMjQzMCwgNzc5LFxuICAgICAgICA3NzYsIDc3MywgMjM5NywgMjM5NCwgMjM5MCwgNzM0LCA3MjgsIDcyNCwgNzQ2LCAxNzE3LCAyMzU2LCAyMzU0LCAyMzUxLCAyMzQ4LCAxNjU4LCA2NzcsIDY3NSwgNjczLCA2NzAsIDY2NywgNjg4LFxuICAgICAgICAxNjg1LCAxNjgzLCAyNjA2LCAyNTg5LCAyNTg2LCAyNTU5LCAyNTU2LCAyNTUyLCA5MjcsIDI1MjMsIDI1MjEsIDI1MTgsIDI1MTUsIDE3ODQsIDI1MzIsIDg5NSwgODkzLCA4OTAsIDI3MTgsXG4gICAgICAgIDI3MDksIDI3MDcsIDI2ODksIDI2ODcsIDI2ODQsIDI2NjMsIDI2NjIsIDI2NjAsIDI2NTgsIDE4MjUsIDI2NjcsIDI3NjksIDE4NTIsIDI3NjAsIDI3NTgsIDE0MiwgMTQxLCAxMTM5LCAxMTM4LFxuICAgICAgICAxMzQsIDEzMiwgMTI5LCAxMjYsIDE5ODIsIDExMjksIDExMjgsIDExMjYsIDExMzEsIDExMywgMTExLCAxMDgsIDEwNSwgMTk3MiwgMTAxLCAxOTcwLCAxMjAsIDExOCwgMTE1LCAxMTA5LCAxMTA4LFxuICAgICAgICAxMTA2LCAxMTA0LCAxMjMsIDExMTMsIDExMTEsIDgyLCA3OSwgMTk1MSwgNzUsIDE5NDksIDcyLCAxOTQ2LCA5MiwgODksIDg2LCAxOTU2LCAxMDc3LCAxMDc2LCAxMDc0LCAxMDcyLCA5OCxcbiAgICAgICAgMTA2OSwgOTYsIDEwODQsIDEwODIsIDEwNzksIDEwODgsIDE5NjgsIDE5NjcsIDQ4LCA0NSwgMTkxNiwgNDIsIDE5MTQsIDM5LCAxOTExLCAxOTA4LCA2MCwgNTcsIDU0LCAxOTIzLCA1MCwgMTkyMCxcbiAgICAgICAgMTAzMSwgMTAzMCwgMTAyOCwgMTAyNiwgNjcsIDEwMjMsIDY1LCAxMDIwLCA2MiwgMTA0MSwgMTAzOSwgMTAzNiwgMTAzMywgNjksIDEwNDYsIDEwNDQsIDE5NDQsIDE5NDMsIDE5NDEsIDExLCA5LFxuICAgICAgICAxODY4LCA3LCAxODY1LCAxODYyLCAxODU5LCAyMCwgMTg3OCwgMTYsIDE4NzUsIDEzLCAxODcyLCA5NzAsIDk2OCwgOTY2LCA5NjMsIDI5LCA5NjAsIDI2LCAyMywgOTgzLCA5ODEsIDk3OCwgOTc1LFxuICAgICAgICAzMywgOTcxLCAzMSwgOTkwLCA5ODgsIDk4NSwgMTkwNiwgMTkwNCwgMTkwMiwgOTkzLCAzNTEsIDIxNDUsIDEzODMsIDMzMSwgMzMwLCAzMjgsIDMyNiwgMjEzNywgMzIzLCAyMTM1LCAzMzksXG4gICAgICAgIDEzNzIsIDEzNzAsIDI5NCwgMjkzLCAyOTEsIDI4OSwgMjEyMiwgMjg2LCAyMTIwLCAyODMsIDIxMTcsIDMwOSwgMzAzLCAzMTcsIDEzNDgsIDEzNDYsIDEzNDQsIDI0NSwgMjQ0LCAyNDIsIDIwOTAsXG4gICAgICAgIDIzOSwgMjA4OCwgMjM2LCAyMDg1LCAyMDgyLCAyNjAsIDIwOTksIDI0OSwgMjcwLCAxMzA3LCAxMzA1LCAxMzAzLCAxMzAwLCAxMzE0LCAxODksIDIwMzgsIDE4NiwgMjAzNiwgMTgzLCAyMDMzLFxuICAgICAgICAyMDMwLCAyMDI2LCAyMDYsIDE5OCwgMjA0NywgMTk0LCAyMTYsIDEyNDcsIDEyNDUsIDEyNDMsIDEyNDAsIDIyNywgMTIzNywgMTI1NSwgMjMxMCwgMjMwMiwgMjMwMCwgMjI4NiwgMjI4NCxcbiAgICAgICAgMjI4MSwgNTY1LCA1NjMsIDU2MSwgNTU4LCA1NzUsIDE1ODksIDIyNjEsIDIyNTksIDIyNTYsIDIyNTMsIDE1NDIsIDUyMSwgNTE5LCA1MTcsIDUxNCwgMjI3MCwgNTExLCA1MzMsIDE1NjksXG4gICAgICAgIDE1NjcsIDIyMjMsIDIyMjEsIDIyMTgsIDIyMTUsIDE0ODMsIDIyMTEsIDE0ODAsIDQ1OSwgNDU2LCA0NTMsIDIyMzIsIDQ0OSwgNDc0LCA0OTEsIDE1MjcsIDE1MjUsIDE1MjIsIDI0NzUsIDI0NjcsXG4gICAgICAgIDI0NjUsIDI0NTEsIDI0NDksIDI0NDYsIDgwMSwgODAwLCAyNDI2LCAyNDI0LCAyNDIxLCAyNDE4LCAxNzIzLCAyNDM1LCA3ODAsIDc3OCwgNzc1LCAyMzg3LCAyMzg1LCAyMzgyLCAyMzc5LFxuICAgICAgICAxNjk1LCAyMzc1LCAxNjkzLCAyMzk2LCA3MzUsIDczMywgNzMwLCA3MjcsIDc0OSwgMTcxOCwgMjYxNiwgMjYxNSwgMjYwNCwgMjYwMywgMjYwMSwgMjU4NCwgMjU4MywgMjU4MSwgMjU3OSxcbiAgICAgICAgMTgwMCwgMjU5MSwgMjU1MCwgMjU0OSwgMjU0NywgMjU0NSwgMTc5MiwgMjU0MiwgMTc5MCwgMjU1OCwgOTI5LCAyNzE5LCAxODQxLCAyNzEwLCAyNzA4LCAxODMzLCAxODMxLCAyNjkwLCAyNjg4LFxuICAgICAgICAyNjg2LCAxODE1LCAxODA5LCAxODA4LCAxNzc0LCAxNzU2LCAxNzU0LCAxNzM3LCAxNzM2LCAxNzM0LCAxNzM5LCAxODE2LCAxNzExLCAxNjc2LCAxNjc0LCA2MzMsIDYyOSwgMTYzOCwgMTYzNixcbiAgICAgICAgMTYzMywgMTY0MSwgNTk4LCAxNjA1LCAxNjA0LCAxNjAyLCAxNjAwLCA2MDUsIDE2MDksIDE2MDcsIDIzMjcsIDg4NywgODUzLCAxNzc1LCA4MjIsIDgyMCwgMTc1NywgMTc1NSwgMTU4NCwgNTI0LFxuICAgICAgICAxNTYwLCAxNTU4LCA0NjgsIDQ2NCwgMTUxNCwgMTUxMSwgMTUwOCwgMTUxOSwgNDA4LCA0MDQsIDQwMCwgMTQ1MiwgMTQ0NywgMTQ0NCwgNDE3LCAxNDU4LCAxNDU1LCAyMjA4LCAzNjQsIDM2MSxcbiAgICAgICAgMzU4LCAyMTU0LCAxNDAxLCAxNDAwLCAxMzk4LCAxMzk2LCAzNzQsIDEzOTMsIDM3MSwgMTQwOCwgMTQwNiwgMTQwMywgMTQxMywgMjE3MywgMjE3MiwgNzcyLCA3MjYsIDcyMywgMTcxMiwgNjcyLFxuICAgICAgICA2NjksIDY2NiwgNjgyLCAxNjc4LCAxNjc1LCA2MjUsIDYyMywgNjIxLCA2MTgsIDIzMzEsIDYzNiwgNjMyLCAxNjM5LCAxNjM3LCAxNjM1LCA5MjAsIDkxOCwgODg0LCA4ODAsIDg4OSwgODQ5LFxuICAgICAgICA4NDgsIDg0NywgODQ2LCAyNDk3LCA4NTUsIDg1MiwgMTc3NiwgMjY0MSwgMjc0MiwgMjc4NywgMTM4MCwgMzM0LCAxMzY3LCAxMzY1LCAzMDEsIDI5NywgMTM0MCwgMTMzOCwgMTMzNSwgMTM0MyxcbiAgICAgICAgMjU1LCAyNTEsIDI0NywgMTI5NiwgMTI5MSwgMTI4OCwgMjY1LCAxMzAyLCAxMjk5LCAyMTEzLCAyMDQsIDE5NiwgMTkyLCAyMDQyLCAxMjMyLCAxMjMwLCAxMjI0LCAyMTQsIDEyMjAsIDIxMCxcbiAgICAgICAgMTI0MiwgMTIzOSwgMTIzNSwgMTI1MCwgMjA3NywgMjA3NSwgMTUxLCAxNDgsIDE5OTMsIDE0NCwgMTk5MCwgMTE2MywgMTE2MiwgMTE2MCwgMTE1OCwgMTE1NSwgMTYxLCAxMTUyLCAxNTcsXG4gICAgICAgIDExNzMsIDExNzEsIDExNjgsIDExNjUsIDE2OCwgMTE4MSwgMTE3OCwgMjAyMSwgMjAyMCwgMjAxOCwgMjAyMywgNTg1LCA1NjAsIDU1NywgMTU4NSwgNTE2LCA1MDksIDE1NjIsIDE1NTksIDQ1OCxcbiAgICAgICAgNDQ3LCAyMjI3LCA0NzIsIDE1MTYsIDE1MTMsIDE1MTAsIDM5OCwgMzk2LCAzOTMsIDM5MCwgMjE4MSwgMzg2LCAyMTc4LCA0MDcsIDE0NTMsIDE0NTEsIDE0NDksIDE0NDYsIDQyMCwgMTQ2MCxcbiAgICAgICAgMjIwOSwgNzY5LCA3NjQsIDcyMCwgNzEyLCAyMzkxLCA3MjksIDE3MTMsIDY2NCwgNjYzLCA2NjEsIDY1OSwgMjM1MiwgNjU2LCAyMzQ5LCA2NzEsIDE2NzksIDE2NzcsIDI1NTMsIDkyMiwgOTE5LFxuICAgICAgICAyNTE5LCAyNTE2LCA4ODUsIDg4MywgODgxLCAyNjg1LCAyNjYxLCAyNjU5LCAyNzY3LCAyNzU2LCAyNzU1LCAxNDAsIDExMzcsIDExMzYsIDEzMCwgMTI3LCAxMTI1LCAxMTI0LCAxMTIyLCAxMTI3LFxuICAgICAgICAxMDksIDEwNiwgMTAyLCAxMTAzLCAxMTAyLCAxMTAwLCAxMDk4LCAxMTYsIDExMDcsIDExMDUsIDE5ODAsIDgwLCA3NiwgNzMsIDE5NDcsIDEwNjgsIDEwNjcsIDEwNjUsIDEwNjMsIDkwLCAxMDYwLFxuICAgICAgICA4NywgMTA3NSwgMTA3MywgMTA3MCwgMTA4MCwgMTk2NiwgMTk2NSwgNDYsIDQzLCA0MCwgMTkxMiwgMzYsIDE5MDksIDEwMTksIDEwMTgsIDEwMTYsIDEwMTQsIDU4LCAxMDExLCA1NSwgMTAwOCxcbiAgICAgICAgNTEsIDEwMjksIDEwMjcsIDEwMjQsIDEwMjEsIDYzLCAxMDM3LCAxMDM0LCAxOTQwLCAxOTM5LCAxOTM3LCAxOTQyLCA4LCAxODY2LCA0LCAxODYzLCAxLCAxODYwLCA5NTYsIDk1NCwgOTUyLFxuICAgICAgICA5NDksIDk0NiwgMTcsIDE0LCA5NjksIDk2NywgOTY0LCA5NjEsIDI3LCA5NTcsIDI0LCA5NzksIDk3NiwgOTcyLCAxOTAxLCAxOTAwLCAxODk4LCAxODk2LCA5ODYsIDE5MDUsIDE5MDMsIDM1MCxcbiAgICAgICAgMzQ5LCAxMzgxLCAzMjksIDMyNywgMzI0LCAxMzY4LCAxMzY2LCAyOTIsIDI5MCwgMjg3LCAyODQsIDIxMTgsIDMwNCwgMTM0MSwgMTMzOSwgMTMzNywgMTM0NSwgMjQzLCAyNDAsIDIzNywgMjA4NixcbiAgICAgICAgMjMzLCAyMDgzLCAyNTQsIDEyOTcsIDEyOTUsIDEyOTMsIDEyOTAsIDEzMDQsIDIxMTQsIDE5MCwgMTg3LCAxODQsIDIwMzQsIDE4MCwgMjAzMSwgMTc3LCAyMDI3LCAxOTksIDEyMzMsIDEyMzEsXG4gICAgICAgIDEyMjksIDEyMjYsIDIxNywgMTIyMywgMTI0MSwgMjA3OCwgMjA3NiwgNTg0LCA1NTUsIDU1NCwgNTUyLCA1NTAsIDIyODIsIDU2MiwgMTU4NiwgNTA3LCA1MDYsIDUwNCwgNTAyLCAyMjU3LCA0OTksXG4gICAgICAgIDIyNTQsIDUxNSwgMTU2MywgMTU2MSwgNDQ1LCA0NDMsIDQ0MSwgMjIxOSwgNDM4LCAyMjE2LCA0MzUsIDIyMTIsIDQ2MCwgNDU0LCA0NzUsIDE1MTcsIDE1MTUsIDE1MTIsIDI0NDcsIDc5OCxcbiAgICAgICAgNzk3LCAyNDIyLCAyNDE5LCA3NzAsIDc2OCwgNzY2LCAyMzgzLCAyMzgwLCAyMzc2LCA3MjEsIDcxOSwgNzE3LCA3MTQsIDczMSwgMTcxNCwgMjYwMiwgMjU4MiwgMjU4MCwgMjU0OCwgMjU0NixcbiAgICAgICAgMjU0MywgOTIzLCA5MjEsIDI3MTcsIDI3MDYsIDI3MDUsIDI2ODMsIDI2ODIsIDI2ODAsIDE3NzEsIDE3NTIsIDE3NTAsIDE3MzMsIDE3MzIsIDE3MzEsIDE3MzUsIDE4MTQsIDE3MDcsIDE2NzAsXG4gICAgICAgIDE2NjgsIDE2MzEsIDE2MjksIDE2MjYsIDE2MzQsIDE1OTksIDE1OTgsIDE1OTYsIDE1OTQsIDE2MDMsIDE2MDEsIDIzMjYsIDE3NzIsIDE3NTMsIDE3NTEsIDE1ODEsIDE1NTQsIDE1NTIsIDE1MDQsXG4gICAgICAgIDE1MDEsIDE0OTgsIDE1MDksIDE0NDIsIDE0MzcsIDE0MzQsIDQwMSwgMTQ0OCwgMTQ0NSwgMjIwNiwgMTM5MiwgMTM5MSwgMTM4OSwgMTM4NywgMTM4NCwgMzU5LCAxMzk5LCAxMzk3LCAxMzk0LFxuICAgICAgICAxNDA0LCAyMTcxLCAyMTcwLCAxNzA4LCAxNjcyLCAxNjY5LCA2MTksIDE2MzIsIDE2MzAsIDE2MjgsIDE3NzMsIDEzNzgsIDEzNjMsIDEzNjEsIDEzMzMsIDEzMjgsIDEzMzYsIDEyODYsIDEyODEsXG4gICAgICAgIDEyNzgsIDI0OCwgMTI5MiwgMTI4OSwgMjExMSwgMTIxOCwgMTIxNiwgMTIxMCwgMTk3LCAxMjA2LCAxOTMsIDEyMjgsIDEyMjUsIDEyMjEsIDEyMzYsIDIwNzMsIDIwNzEsIDExNTEsIDExNTAsXG4gICAgICAgIDExNDgsIDExNDYsIDE1MiwgMTE0MywgMTQ5LCAxMTQwLCAxNDUsIDExNjEsIDExNTksIDExNTYsIDExNTMsIDE1OCwgMTE2OSwgMTE2NiwgMjAxNywgMjAxNiwgMjAxNCwgMjAxOSwgMTU4MixcbiAgICAgICAgNTEwLCAxNTU2LCAxNTUzLCA0NTIsIDQ0OCwgMTUwNiwgMTUwMCwgMzk0LCAzOTEsIDM4NywgMTQ0MywgMTQ0MSwgMTQzOSwgMTQzNiwgMTQ1MCwgMjIwNywgNzY1LCA3MTYsIDcxMywgMTcwOSxcbiAgICAgICAgNjYyLCA2NjAsIDY1NywgMTY3MywgMTY3MSwgOTE2LCA5MTQsIDg3OSwgODc4LCA4NzcsIDg4MiwgMTEzNSwgMTEzNCwgMTEyMSwgMTEyMCwgMTExOCwgMTEyMywgMTA5NywgMTA5NiwgMTA5NCxcbiAgICAgICAgMTA5MiwgMTAzLCAxMTAxLCAxMDk5LCAxOTc5LCAxMDU5LCAxMDU4LCAxMDU2LCAxMDU0LCA3NywgMTA1MSwgNzQsIDEwNjYsIDEwNjQsIDEwNjEsIDEwNzEsIDE5NjQsIDE5NjMsIDEwMDcsXG4gICAgICAgIDEwMDYsIDEwMDQsIDEwMDIsIDk5OSwgNDEsIDk5NiwgMzcsIDEwMTcsIDEwMTUsIDEwMTIsIDEwMDksIDUyLCAxMDI1LCAxMDIyLCAxOTM2LCAxOTM1LCAxOTMzLCAxOTM4LCA5NDIsIDk0MCxcbiAgICAgICAgOTM4LCA5MzUsIDkzMiwgNSwgMiwgOTU1LCA5NTMsIDk1MCwgOTQ3LCAxOCwgOTQzLCAxNSwgOTY1LCA5NjIsIDk1OCwgMTg5NSwgMTg5NCwgMTg5MiwgMTg5MCwgOTczLCAxODk5LCAxODk3LFxuICAgICAgICAxMzc5LCAzMjUsIDEzNjQsIDEzNjIsIDI4OCwgMjg1LCAxMzM0LCAxMzMyLCAxMzMwLCAyNDEsIDIzOCwgMjM0LCAxMjg3LCAxMjg1LCAxMjgzLCAxMjgwLCAxMjk0LCAyMTEyLCAxODgsIDE4NSxcbiAgICAgICAgMTgxLCAxNzgsIDIwMjgsIDEyMTksIDEyMTcsIDEyMTUsIDEyMTIsIDIwMCwgMTIwOSwgMTIyNywgMjA3NCwgMjA3MiwgNTgzLCA1NTMsIDU1MSwgMTU4MywgNTA1LCA1MDMsIDUwMCwgNTEzLFxuICAgICAgICAxNTU3LCAxNTU1LCA0NDQsIDQ0MiwgNDM5LCA0MzYsIDIyMTMsIDQ1NSwgNDUxLCAxNTA3LCAxNTA1LCAxNTAyLCA3OTYsIDc2MywgNzYyLCA3NjAsIDc2NywgNzExLCA3MTAsIDcwOCwgNzA2LFxuICAgICAgICAyMzc3LCA3MTgsIDcxNSwgMTcxMCwgMjU0NCwgOTE3LCA5MTUsIDI2ODEsIDE2MjcsIDE1OTcsIDE1OTUsIDIzMjUsIDE3NjksIDE3NDksIDE3NDcsIDE0OTksIDE0MzgsIDE0MzUsIDIyMDQsXG4gICAgICAgIDEzOTAsIDEzODgsIDEzODUsIDEzOTUsIDIxNjksIDIxNjcsIDE3MDQsIDE2NjUsIDE2NjIsIDE2MjUsIDE2MjMsIDE2MjAsIDE3NzAsIDEzMjksIDEyODIsIDEyNzksIDIxMDksIDEyMTQsIDEyMDcsXG4gICAgICAgIDEyMjIsIDIwNjgsIDIwNjUsIDExNDksIDExNDcsIDExNDQsIDExNDEsIDE0NiwgMTE1NywgMTE1NCwgMjAxMywgMjAxMSwgMjAwOCwgMjAxNSwgMTU3OSwgMTU0OSwgMTU0NiwgMTQ5NSwgMTQ4NyxcbiAgICAgICAgMTQzMywgMTQzMSwgMTQyOCwgMTQyNSwgMzg4LCAxNDQwLCAyMjA1LCAxNzA1LCA2NTgsIDE2NjcsIDE2NjQsIDExMTksIDEwOTUsIDEwOTMsIDE5NzgsIDEwNTcsIDEwNTUsIDEwNTIsIDEwNjIsXG4gICAgICAgIDE5NjIsIDE5NjAsIDEwMDUsIDEwMDMsIDEwMDAsIDk5NywgMzgsIDEwMTMsIDEwMTAsIDE5MzIsIDE5MzAsIDE5MjcsIDE5MzQsIDk0MSwgOTM5LCA5MzYsIDkzMywgNiwgOTMwLCAzLCA5NTEsXG4gICAgICAgIDk0OCwgOTQ0LCAxODg5LCAxODg3LCAxODg0LCAxODgxLCA5NTksIDE4OTMsIDE4OTEsIDM1LCAxMzc3LCAxMzYwLCAxMzU4LCAxMzI3LCAxMzI1LCAxMzIyLCAxMzMxLCAxMjc3LCAxMjc1LFxuICAgICAgICAxMjcyLCAxMjY5LCAyMzUsIDEyODQsIDIxMTAsIDEyMDUsIDEyMDQsIDEyMDEsIDExOTgsIDE4MiwgMTE5NSwgMTc5LCAxMjEzLCAyMDcwLCAyMDY3LCAxNTgwLCA1MDEsIDE1NTEsIDE1NDgsXG4gICAgICAgIDQ0MCwgNDM3LCAxNDk3LCAxNDk0LCAxNDkwLCAxNTAzLCA3NjEsIDcwOSwgNzA3LCAxNzA2LCA5MTMsIDkxMiwgMjE5OCwgMTM4NiwgMjE2NCwgMjE2MSwgMTYyMSwgMTc2NiwgMjEwMywgMTIwOCxcbiAgICAgICAgMjA1OCwgMjA1NCwgMTE0NSwgMTE0MiwgMjAwNSwgMjAwMiwgMTk5OSwgMjAwOSwgMTQ4OCwgMTQyOSwgMTQyNiwgMjIwMCwgMTY5OCwgMTY1OSwgMTY1NiwgMTk3NSwgMTA1MywgMTk1NywgMTk1NCxcbiAgICAgICAgMTAwMSwgOTk4LCAxOTI0LCAxOTIxLCAxOTE4LCAxOTI4LCA5MzcsIDkzNCwgOTMxLCAxODc5LCAxODc2LCAxODczLCAxODcwLCA5NDUsIDE4ODUsIDE4ODIsIDEzMjMsIDEyNzMsIDEyNzAsXG4gICAgICAgIDIxMDUsIDEyMDIsIDExOTksIDExOTYsIDEyMTEsIDIwNjEsIDIwNTcsIDE1NzYsIDE1NDMsIDE1NDAsIDE0ODQsIDE0ODEsIDE0NzgsIDE0OTEsIDE3MDBcbiAgICBdKTtcblxuICAgIC8qXG4gICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgKlxuICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICpcbiAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgKlxuICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTGlzdDtcbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKnB1YmxpYyBmaW5hbCovIGNsYXNzIFBERjQxN0RldGVjdG9yUmVzdWx0IHtcbiAgICAgICAgY29uc3RydWN0b3IoYml0cywgcG9pbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICAgICAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Qml0cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UG9pbnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheXM7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTWFwO1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBsb2dpYyB0aGF0IGNhbiBkZXRlY3QgYSBQREY0MTcgQ29kZSBpbiBhbiBpbWFnZSwgZXZlbiBpZiB0aGVcbiAgICAgKiBQREY0MTcgQ29kZSBpcyByb3RhdGVkIG9yIHNrZXdlZCwgb3IgcGFydGlhbGx5IG9ic2N1cmVkLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU0lUQSBMYWIgKGtldmluLm9zdWxsaXZhbkBzaXRhLmFlcm8pXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKnB1YmxpYyovIC8qZmluYWwqLyBjbGFzcyBEZXRlY3RvciQzIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRldGVjdHMgYSBQREY0MTcgQ29kZSBpbiBhbiBpbWFnZS4gT25seSBjaGVja3MgMCBhbmQgMTgwIGRlZ3JlZSByb3RhdGlvbnMuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2UgYmFyY29kZSBpbWFnZSB0byBkZWNvZGVcbiAgICAgICAgICogQHBhcmFtIGhpbnRzIG9wdGlvbmFsIGhpbnRzIHRvIGRldGVjdG9yXG4gICAgICAgICAqIEBwYXJhbSBtdWx0aXBsZSBpZiB0cnVlLCB0aGVuIHRoZSBpbWFnZSBpcyBzZWFyY2hlZCBmb3IgbXVsdGlwbGUgY29kZXMuIElmIGZhbHNlLCB0aGVuIGF0IG1vc3Qgb25lIGNvZGUgd2lsbFxuICAgICAgICAgKiBiZSBmb3VuZCBhbmQgcmV0dXJuZWRcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgUERGNDE3RGV0ZWN0b3JSZXN1bHR9IGVuY2Fwc3VsYXRpbmcgcmVzdWx0cyBvZiBkZXRlY3RpbmcgYSBQREY0MTcgY29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIG5vIFBERjQxNyBDb2RlIGNhbiBiZSBmb3VuZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRldGVjdE11bHRpcGxlKGltYWdlLCBoaW50cywgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gZGV0ZWN0aW9uIGltcHJvdmVtZW50LCB0cnlIYXJkZXIgY291bGQgdHJ5IHNldmVyYWwgZGlmZmVyZW50IGx1bWluYW5jZSB0aHJlc2hvbGRzL2JsYWNrcG9pbnRzIG9yIGV2ZW5cbiAgICAgICAgICAgIC8vIGRpZmZlcmVudCBiaW5hcml6ZXJzXG4gICAgICAgICAgICAvLyBib29sZWFuIHRyeUhhcmRlciA9IGhpbnRzICE9IG51bGwgJiYgaGludHMuY29udGFpbnNLZXkoRGVjb2RlSGludFR5cGUuVFJZX0hBUkRFUik7XG4gICAgICAgICAgICBsZXQgYml0TWF0cml4ID0gaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKTtcbiAgICAgICAgICAgIGxldCBiYXJjb2RlQ29vcmRpbmF0ZXMgPSBEZXRlY3RvciQzLmRldGVjdChtdWx0aXBsZSwgYml0TWF0cml4KTtcbiAgICAgICAgICAgIGlmICghYmFyY29kZUNvb3JkaW5hdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJpdE1hdHJpeCA9IGJpdE1hdHJpeC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5yb3RhdGUxODAoKTtcbiAgICAgICAgICAgICAgICBiYXJjb2RlQ29vcmRpbmF0ZXMgPSBEZXRlY3RvciQzLmRldGVjdChtdWx0aXBsZSwgYml0TWF0cml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUERGNDE3RGV0ZWN0b3JSZXN1bHQoYml0TWF0cml4LCBiYXJjb2RlQ29vcmRpbmF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlY3RzIFBERjQxNyBjb2RlcyBpbiBhbiBpbWFnZS4gT25seSBjaGVja3MgMCBkZWdyZWUgcm90YXRpb25cbiAgICAgICAgICogQHBhcmFtIG11bHRpcGxlIGlmIHRydWUsIHRoZW4gdGhlIGltYWdlIGlzIHNlYXJjaGVkIGZvciBtdWx0aXBsZSBjb2Rlcy4gSWYgZmFsc2UsIHRoZW4gYXQgbW9zdCBvbmUgY29kZSB3aWxsXG4gICAgICAgICAqIGJlIGZvdW5kIGFuZCByZXR1cm5lZFxuICAgICAgICAgKiBAcGFyYW0gYml0TWF0cml4IGJpdCBtYXRyaXggdG8gZGV0ZWN0IGJhcmNvZGVzIGluXG4gICAgICAgICAqIEByZXR1cm4gTGlzdCBvZiBSZXN1bHRQb2ludCBhcnJheXMgY29udGFpbmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgZm91bmQgYmFyY29kZXNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZXRlY3QobXVsdGlwbGUsIGJpdE1hdHJpeCkge1xuICAgICAgICAgICAgY29uc3QgYmFyY29kZUNvb3JkaW5hdGVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICBsZXQgcm93ID0gMDtcbiAgICAgICAgICAgIGxldCBjb2x1bW4gPSAwO1xuICAgICAgICAgICAgbGV0IGZvdW5kQmFyY29kZUluUm93ID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAocm93IDwgYml0TWF0cml4LmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVydGljZXMgPSBEZXRlY3RvciQzLmZpbmRWZXJ0aWNlcyhiaXRNYXRyaXgsIHJvdywgY29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAodmVydGljZXNbMF0gPT0gbnVsbCAmJiB2ZXJ0aWNlc1szXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRCYXJjb2RlSW5Sb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRpZG4ndCBmaW5kIGFueSBiYXJjb2RlIHNvIHRoYXQncyB0aGUgZW5kIG9mIHNlYXJjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZGlkbid0IGZpbmQgYSBiYXJjb2RlIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBjb2x1bW4gYW5kIHJvdy4gVHJ5IGFnYWluIGZyb20gdGhlIGZpcnN0IGNvbHVtbiBhbmQgc2xpZ2h0bHlcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVsb3cgdGhlIGxvd2VzdCBiYXJjb2RlIHdlIGZvdW5kIHNvIGZhci5cbiAgICAgICAgICAgICAgICAgICAgZm91bmRCYXJjb2RlSW5Sb3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXJjb2RlQ29vcmRpbmF0ZSBvZiBiYXJjb2RlQ29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXJjb2RlQ29vcmRpbmF0ZVsxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gTWF0aC50cnVuYyhNYXRoLm1heChyb3csIGJhcmNvZGVDb29yZGluYXRlWzFdLmdldFkoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhcmNvZGVDb29yZGluYXRlWzNdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSBNYXRoLm1heChyb3csIE1hdGgudHJ1bmMoYmFyY29kZUNvb3JkaW5hdGVbM10uZ2V0WSgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm93ICs9IERldGVjdG9yJDMuUk9XX1NURVA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3VuZEJhcmNvZGVJblJvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYmFyY29kZUNvb3JkaW5hdGVzLnB1c2godmVydGljZXMpO1xuICAgICAgICAgICAgICAgIGlmICghbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgcmlnaHQgcm93IGluZGljYXRvciBjb2x1bW4sIHRoZW4gY29udGludWUgdGhlIHNlYXJjaCBmb3IgdGhlIG5leHQgYmFyY29kZSBhZnRlciB0aGVcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBwYXR0ZXJuIG9mIHRoZSBiYXJjb2RlIGp1c3QgZm91bmQuXG4gICAgICAgICAgICAgICAgaWYgKHZlcnRpY2VzWzJdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gTWF0aC50cnVuYyh2ZXJ0aWNlc1syXS5nZXRYKCkpO1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBNYXRoLnRydW5jKHZlcnRpY2VzWzJdLmdldFkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBNYXRoLnRydW5jKHZlcnRpY2VzWzRdLmdldFgoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IE1hdGgudHJ1bmModmVydGljZXNbNF0uZ2V0WSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFyY29kZUNvb3JkaW5hdGVzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2NhdGUgdGhlIHZlcnRpY2VzIGFuZCB0aGUgY29kZXdvcmRzIGFyZWEgb2YgYSBibGFjayBibG9iIHVzaW5nIHRoZSBTdGFydFxuICAgICAgICAgKiBhbmQgU3RvcCBwYXR0ZXJucyBhcyBsb2NhdG9ycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1hdHJpeCB0aGUgc2Nhbm5lZCBiYXJjb2RlIGltYWdlLlxuICAgICAgICAgKiBAcmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZlcnRpY2VzOlxuICAgICAgICAgKiAgICAgICAgICAgdmVydGljZXNbMF0geCwgeSB0b3AgbGVmdCBiYXJjb2RlXG4gICAgICAgICAqICAgICAgICAgICB2ZXJ0aWNlc1sxXSB4LCB5IGJvdHRvbSBsZWZ0IGJhcmNvZGVcbiAgICAgICAgICogICAgICAgICAgIHZlcnRpY2VzWzJdIHgsIHkgdG9wIHJpZ2h0IGJhcmNvZGVcbiAgICAgICAgICogICAgICAgICAgIHZlcnRpY2VzWzNdIHgsIHkgYm90dG9tIHJpZ2h0IGJhcmNvZGVcbiAgICAgICAgICogICAgICAgICAgIHZlcnRpY2VzWzRdIHgsIHkgdG9wIGxlZnQgY29kZXdvcmQgYXJlYVxuICAgICAgICAgKiAgICAgICAgICAgdmVydGljZXNbNV0geCwgeSBib3R0b20gbGVmdCBjb2Rld29yZCBhcmVhXG4gICAgICAgICAqICAgICAgICAgICB2ZXJ0aWNlc1s2XSB4LCB5IHRvcCByaWdodCBjb2Rld29yZCBhcmVhXG4gICAgICAgICAqICAgICAgICAgICB2ZXJ0aWNlc1s3XSB4LCB5IGJvdHRvbSByaWdodCBjb2Rld29yZCBhcmVhXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZmluZFZlcnRpY2VzKG1hdHJpeCwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBtYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IG1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgLy8gY29uc3QgcmVzdWx0ID0gbmV3IFJlc3VsdFBvaW50WzhdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KDgpO1xuICAgICAgICAgICAgRGV0ZWN0b3IkMy5jb3B5VG9SZXN1bHQocmVzdWx0LCBEZXRlY3RvciQzLmZpbmRSb3dzV2l0aFBhdHRlcm4obWF0cml4LCBoZWlnaHQsIHdpZHRoLCBzdGFydFJvdywgc3RhcnRDb2x1bW4sIERldGVjdG9yJDMuU1RBUlRfUEFUVEVSTiksIERldGVjdG9yJDMuSU5ERVhFU19TVEFSVF9QQVRURVJOKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRbNF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gTWF0aC50cnVuYyhyZXN1bHRbNF0uZ2V0WCgpKTtcbiAgICAgICAgICAgICAgICBzdGFydFJvdyA9IE1hdGgudHJ1bmMocmVzdWx0WzRdLmdldFkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBEZXRlY3RvciQzLmNvcHlUb1Jlc3VsdChyZXN1bHQsIERldGVjdG9yJDMuZmluZFJvd3NXaXRoUGF0dGVybihtYXRyaXgsIGhlaWdodCwgd2lkdGgsIHN0YXJ0Um93LCBzdGFydENvbHVtbiwgRGV0ZWN0b3IkMy5TVE9QX1BBVFRFUk4pLCBEZXRlY3RvciQzLklOREVYRVNfU1RPUF9QQVRURVJOKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNvcHlUb1Jlc3VsdChyZXN1bHQsIHRtcFJlc3VsdCwgZGVzdGluYXRpb25JbmRleGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc3RpbmF0aW9uSW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtkZXN0aW5hdGlvbkluZGV4ZXNbaV1dID0gdG1wUmVzdWx0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmaW5kUm93c1dpdGhQYXR0ZXJuKG1hdHJpeCwgaGVpZ2h0LCB3aWR0aCwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uLCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAvLyBjb25zdCByZXN1bHQgPSBuZXcgUmVzdWx0UG9pbnRbNF07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ZXJzID0gbmV3IEludDMyQXJyYXkocGF0dGVybi5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICg7IHN0YXJ0Um93IDwgaGVpZ2h0OyBzdGFydFJvdyArPSBEZXRlY3RvciQzLlJPV19TVEVQKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxvYyA9IERldGVjdG9yJDMuZmluZEd1YXJkUGF0dGVybihtYXRyaXgsIHN0YXJ0Q29sdW1uLCBzdGFydFJvdywgd2lkdGgsIGZhbHNlLCBwYXR0ZXJuLCBjb3VudGVycyk7XG4gICAgICAgICAgICAgICAgaWYgKGxvYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFydFJvdyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUm93TG9jID0gRGV0ZWN0b3IkMy5maW5kR3VhcmRQYXR0ZXJuKG1hdHJpeCwgc3RhcnRDb2x1bW4sIC0tc3RhcnRSb3csIHdpZHRoLCBmYWxzZSwgcGF0dGVybiwgY291bnRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzUm93TG9jICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2MgPSBwcmV2aW91c1Jvd0xvYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Um93Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0WzBdID0gbmV3IFJlc3VsdFBvaW50KGxvY1swXSwgc3RhcnRSb3cpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbMV0gPSBuZXcgUmVzdWx0UG9pbnQobG9jWzFdLCBzdGFydFJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0b3BSb3cgPSBzdGFydFJvdyArIDE7XG4gICAgICAgICAgICAvLyBMYXN0IHJvdyBvZiB0aGUgY3VycmVudCBzeW1ib2wgdGhhdCBjb250YWlucyBwYXR0ZXJuXG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2tpcHBlZFJvd0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXNSb3dMb2MgPSBJbnQzMkFycmF5LmZyb20oW01hdGgudHJ1bmMocmVzdWx0WzBdLmdldFgoKSksIE1hdGgudHJ1bmMocmVzdWx0WzFdLmdldFgoKSldKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgc3RvcFJvdyA8IGhlaWdodDsgc3RvcFJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYyA9IERldGVjdG9yJDMuZmluZEd1YXJkUGF0dGVybihtYXRyaXgsIHByZXZpb3VzUm93TG9jWzBdLCBzdG9wUm93LCB3aWR0aCwgZmFsc2UsIHBhdHRlcm4sIGNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBmb3VuZCBwYXR0ZXJuIGlzIG9ubHkgY29uc2lkZXJlZCB0byBiZWxvbmcgdG8gdGhlIHNhbWUgYmFyY29kZSBpZiB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgZGlmZmVyIHRvbyBtdWNoLiBQYXR0ZXJuIGRyaWZ0IHNob3VsZCBiZSBub3QgYmlnZ2VyIHRoYW4gdHdvIGZvciBjb25zZWN1dGl2ZSByb3dzLiBXaXRoXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgaGlnaGVyIG51bWJlciBvZiBza2lwcGVkIHJvd3MgZHJpZnQgY291bGQgYmUgbGFyZ2VyLiBUbyBrZWVwIGl0IHNpbXBsZSBmb3Igbm93LCB3ZSBhbGxvdyBhIHNsaWdodGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGxhcmdlciBkcmlmdCBhbmQgZG9uJ3QgY2hlY2sgZm9yIHNraXBwZWQgcm93cy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYyAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhwcmV2aW91c1Jvd0xvY1swXSAtIGxvY1swXSkgPCBEZXRlY3RvciQzLk1BWF9QQVRURVJOX0RSSUZUICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhwcmV2aW91c1Jvd0xvY1sxXSAtIGxvY1sxXSkgPCBEZXRlY3RvciQzLk1BWF9QQVRURVJOX0RSSUZUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1Jvd0xvYyA9IGxvYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWRSb3dDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZFJvd0NvdW50ID4gRGV0ZWN0b3IkMy5TS0lQUEVEX1JPV19DT1VOVF9NQVgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWRSb3dDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0b3BSb3cgLT0gc2tpcHBlZFJvd0NvdW50ICsgMTtcbiAgICAgICAgICAgICAgICByZXN1bHRbMl0gPSBuZXcgUmVzdWx0UG9pbnQocHJldmlvdXNSb3dMb2NbMF0sIHN0b3BSb3cpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFszXSA9IG5ldyBSZXN1bHRQb2ludChwcmV2aW91c1Jvd0xvY1sxXSwgc3RvcFJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RvcFJvdyAtIHN0YXJ0Um93IDwgRGV0ZWN0b3IkMy5CQVJDT0RFX01JTl9IRUlHSFQpIHtcbiAgICAgICAgICAgICAgICBBcnJheXMuZmlsbChyZXN1bHQsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG1hdHJpeCByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gY29sdW1uIHggcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSByb3cgeSBwb3NpdGlvbiB0byBzdGFydCBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIHdpZHRoIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRvIHNlYXJjaCBvbiB0aGlzIHJvd1xuICAgICAgICAgKiBAcGFyYW0gcGF0dGVybiBwYXR0ZXJuIG9mIGNvdW50cyBvZiBudW1iZXIgb2YgYmxhY2sgYW5kIHdoaXRlIHBpeGVscyB0aGF0IGFyZVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgYmVpbmcgc2VhcmNoZWQgZm9yIGFzIGEgcGF0dGVyblxuICAgICAgICAgKiBAcGFyYW0gY291bnRlcnMgYXJyYXkgb2YgY291bnRlcnMsIGFzIGxvbmcgYXMgcGF0dGVybiwgdG8gcmUtdXNlXG4gICAgICAgICAqIEByZXR1cm4gc3RhcnQvZW5kIGhvcml6b250YWwgb2Zmc2V0IG9mIGd1YXJkIHBhdHRlcm4sIGFzIGFuIGFycmF5IG9mIHR3byBpbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZpbmRHdWFyZFBhdHRlcm4obWF0cml4LCBjb2x1bW4sIHJvdywgd2lkdGgsIHdoaXRlRmlyc3QsIHBhdHRlcm4sIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICBBcnJheXMuZmlsbFdpdGhpbihjb3VudGVycywgMCwgY291bnRlcnMubGVuZ3RoLCAwKTtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSBjb2x1bW47XG4gICAgICAgICAgICBsZXQgcGl4ZWxEcmlmdCA9IDA7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgYmxhY2sgcGl4ZWxzIGxlZnQgb2YgdGhlIGN1cnJlbnQgcGl4ZWwgc2hpZnQgdG8gdGhlIGxlZnQsIGJ1dCBvbmx5IGZvciBNQVhfUElYRUxfRFJJRlQgcGl4ZWxzXG4gICAgICAgICAgICB3aGlsZSAobWF0cml4LmdldChwYXR0ZXJuU3RhcnQsIHJvdykgJiYgcGF0dGVyblN0YXJ0ID4gMCAmJiBwaXhlbERyaWZ0KysgPCBEZXRlY3RvciQzLk1BWF9QSVhFTF9EUklGVCkge1xuICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHggPSBwYXR0ZXJuU3RhcnQ7XG4gICAgICAgICAgICBsZXQgY291bnRlclBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuTGVuZ3RoID0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpc1doaXRlID0gd2hpdGVGaXJzdDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGl4ZWwgPSBtYXRyaXguZ2V0KHgsIHJvdyk7XG4gICAgICAgICAgICAgICAgaWYgKHBpeGVsICE9PSBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IHBhdHRlcm5MZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRGV0ZWN0b3IkMy5wYXR0ZXJuTWF0Y2hWYXJpYW5jZShjb3VudGVycywgcGF0dGVybiwgRGV0ZWN0b3IkMy5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSkgPCBEZXRlY3RvciQzLk1BWF9BVkdfVkFSSUFOQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoW3BhdHRlcm5TdGFydCwgeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJzWzBdICsgY291bnRlcnNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGNvdW50ZXJzLCAyLCBjb3VudGVycywgMCwgY291bnRlclBvc2l0aW9uIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb24gLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSBwYXR0ZXJuTGVuZ3RoIC0gMSAmJlxuICAgICAgICAgICAgICAgIERldGVjdG9yJDMucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIERldGVjdG9yJDMuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpIDwgRGV0ZWN0b3IkMy5NQVhfQVZHX1ZBUklBTkNFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KFtwYXR0ZXJuU3RhcnQsIHggLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBob3cgY2xvc2VseSBhIHNldCBvZiBvYnNlcnZlZCBjb3VudHMgb2YgcnVucyBvZiBibGFjay93aGl0ZVxuICAgICAgICAgKiB2YWx1ZXMgbWF0Y2hlcyBhIGdpdmVuIHRhcmdldCBwYXR0ZXJuLiBUaGlzIGlzIHJlcG9ydGVkIGFzIHRoZSByYXRpbyBvZlxuICAgICAgICAgKiB0aGUgdG90YWwgdmFyaWFuY2UgZnJvbSB0aGUgZXhwZWN0ZWQgcGF0dGVybiBwcm9wb3J0aW9ucyBhY3Jvc3MgYWxsXG4gICAgICAgICAqIHBhdHRlcm4gZWxlbWVudHMsIHRvIHRoZSBsZW5ndGggb2YgdGhlIHBhdHRlcm4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb3VudGVycyBvYnNlcnZlZCBjb3VudGVyc1xuICAgICAgICAgKiBAcGFyYW0gcGF0dGVybiBleHBlY3RlZCBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBtYXhJbmRpdmlkdWFsVmFyaWFuY2UgVGhlIG1vc3QgYW55IGNvdW50ZXIgY2FuIGRpZmZlciBiZWZvcmUgd2UgZ2l2ZSB1cFxuICAgICAgICAgKiBAcmV0dXJuIHJhdGlvIG9mIHRvdGFsIHZhcmlhbmNlIGJldHdlZW4gY291bnRlcnMgYW5kIHBhdHRlcm4gY29tcGFyZWQgdG8gdG90YWwgcGF0dGVybiBzaXplXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIG1heEluZGl2aWR1YWxWYXJpYW5jZSkge1xuICAgICAgICAgICAgbGV0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgIHBhdHRlcm5MZW5ndGggKz0gcGF0dGVybltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3RhbCA8IHBhdHRlcm5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBldmVuIGhhdmUgb25lIHBpeGVsIHBlciB1bml0IG9mIGJhciB3aWR0aCwgYXNzdW1lIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBpcyB0b28gc21hbGwgdG8gcmVsaWFibHkgbWF0Y2gsIHNvIGZhaWw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIC8qRmxvYXQuUE9TSVRJVkVfSU5GSU5JVFkqLyBJbmZpbml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGZha2UgZmxvYXRpbmctcG9pbnQgbWF0aCBpbiBpbnRlZ2Vycy4gV2UganVzdCBuZWVkIHRvIHVzZSBtb3JlIGJpdHMuXG4gICAgICAgICAgICAvLyBTY2FsZSB1cCBwYXR0ZXJuTGVuZ3RoIHNvIHRoYXQgaW50ZXJtZWRpYXRlIHZhbHVlcyBiZWxvdyBsaWtlIHNjYWxlZENvdW50ZXIgd2lsbCBoYXZlXG4gICAgICAgICAgICAvLyBtb3JlIFwic2lnbmlmaWNhbnQgZGlnaXRzXCIuXG4gICAgICAgICAgICBsZXQgdW5pdEJhcldpZHRoID0gdG90YWwgLyBwYXR0ZXJuTGVuZ3RoO1xuICAgICAgICAgICAgbWF4SW5kaXZpZHVhbFZhcmlhbmNlICo9IHVuaXRCYXJXaWR0aDtcbiAgICAgICAgICAgIGxldCB0b3RhbFZhcmlhbmNlID0gMC4wO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBudW1Db3VudGVyczsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvdW50ZXIgPSBjb3VudGVyc1t4XTtcbiAgICAgICAgICAgICAgICBsZXQgc2NhbGVkUGF0dGVybiA9IHBhdHRlcm5beF0gKiB1bml0QmFyV2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IHZhcmlhbmNlID0gY291bnRlciA+IHNjYWxlZFBhdHRlcm4gPyBjb3VudGVyIC0gc2NhbGVkUGF0dGVybiA6IHNjYWxlZFBhdHRlcm4gLSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYW5jZSA+IG1heEluZGl2aWR1YWxWYXJpYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLypGbG9hdC5QT1NJVElWRV9JTkZJTklUWSovIEluZmluaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3RhbFZhcmlhbmNlICs9IHZhcmlhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsVmFyaWFuY2UgLyB0b3RhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEZXRlY3RvciQzLklOREVYRVNfU1RBUlRfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbMCwgNCwgMSwgNV0pO1xuICAgIERldGVjdG9yJDMuSU5ERVhFU19TVE9QX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzYsIDIsIDcsIDNdKTtcbiAgICBEZXRlY3RvciQzLk1BWF9BVkdfVkFSSUFOQ0UgPSAwLjQyO1xuICAgIERldGVjdG9yJDMuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UgPSAwLjg7XG4gICAgLy8gQiBTIEIgUyBCIFMgQiBTIEJhci9TcGFjZSBwYXR0ZXJuXG4gICAgLy8gMTExMTExMTEgMCAxIDAgMSAwIDEgMDAwXG4gICAgRGV0ZWN0b3IkMy5TVEFSVF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFs4LCAxLCAxLCAxLCAxLCAxLCAxLCAzXSk7XG4gICAgLy8gMTExMTExMSAwIDEgMDAwIDEgMCAxIDAwIDFcbiAgICBEZXRlY3RvciQzLlNUT1BfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbNywgMSwgMSwgMywgMSwgMSwgMSwgMiwgMV0pO1xuICAgIERldGVjdG9yJDMuTUFYX1BJWEVMX0RSSUZUID0gMztcbiAgICBEZXRlY3RvciQzLk1BWF9QQVRURVJOX0RSSUZUID0gNTtcbiAgICAvLyBpZiB3ZSBzZXQgdGhlIHZhbHVlIHRvbyBsb3csIHRoZW4gd2UgZG9uJ3QgZGV0ZWN0IHRoZSBjb3JyZWN0IGhlaWdodCBvZiB0aGUgYmFyIGlmIHRoZSBzdGFydCBwYXR0ZXJucyBhcmUgZGFtYWdlZC5cbiAgICAvLyBpZiB3ZSBzZXQgdGhlIHZhbHVlIHRvbyBoaWdoLCB0aGVuIHdlIG1pZ2h0IGRldGVjdCB0aGUgc3RhcnQgcGF0dGVybiBmcm9tIGEgbmVpZ2hib3IgYmFyY29kZS5cbiAgICBEZXRlY3RvciQzLlNLSVBQRURfUk9XX0NPVU5UX01BWCA9IDI1O1xuICAgIC8vIEEgUERGNDcxIGJhcmNvZGUgc2hvdWxkIGhhdmUgYXQgbGVhc3QgMyByb3dzLCB3aXRoIGVhY2ggcm93IGJlaW5nID49IDMgdGltZXMgdGhlIG1vZHVsZSB3aWR0aC4gVGhlcmVmb3JlIGl0IHNob3VsZCBiZSBhdCBsZWFzdFxuICAgIC8vIDkgcGl4ZWxzIHRhbGwuIFRvIGJlIGNvbnNlcnZhdGl2ZSwgd2UgdXNlIGFib3V0IGhhbGYgdGhlIHNpemUgdG8gZW5zdXJlIHdlIGRvbid0IG1pc3MgaXQuXG4gICAgRGV0ZWN0b3IkMy5ST1dfU1RFUCA9IDU7XG4gICAgRGV0ZWN0b3IkMy5CQVJDT0RFX01JTl9IRUlHSFQgPSAxMDtcblxuICAgIC8qXG4gICAgKiBDb3B5cmlnaHQgMjAxMiBaWGluZyBhdXRob3JzXG4gICAgKlxuICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICpcbiAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgKlxuICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICogQHNlZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5yZWVkc29sb21vbi5HZW5lcmljR0ZQb2x5XG4gICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIE1vZHVsdXNQb2x5IHtcbiAgICAgICAgY29uc3RydWN0b3IoZmllbGQsIGNvZWZmaWNpZW50cykge1xuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgICAgICBsZXQgY29lZmZpY2llbnRzTGVuZ3RoID0gLyppbnQqLyBjb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50c0xlbmd0aCA+IDEgJiYgY29lZmZpY2llbnRzWzBdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyB0ZXJtIG11c3QgYmUgbm9uLXplcm8gZm9yIGFueXRoaW5nIGV4Y2VwdCB0aGUgY29uc3RhbnQgcG9seW5vbWlhbCBcIjBcIlxuICAgICAgICAgICAgICAgIGxldCBmaXJzdE5vblplcm8gPSAvKmludCovIDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGZpcnN0Tm9uWmVybyA8IGNvZWZmaWNpZW50c0xlbmd0aCAmJiBjb2VmZmljaWVudHNbZmlyc3ROb25aZXJvXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Tm9uWmVybyA9PT0gY29lZmZpY2llbnRzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoY29lZmZpY2llbnRzTGVuZ3RoIC0gZmlyc3ROb25aZXJvKTtcbiAgICAgICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShjb2VmZmljaWVudHMsIGZpcnN0Tm9uWmVybywgdGhpcy5jb2VmZmljaWVudHMsIDAsIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmZmljaWVudHMgPSBjb2VmZmljaWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q29lZmZpY2llbnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGRlZ3JlZSBvZiB0aGlzIHBvbHlub21pYWxcbiAgICAgICAgICovXG4gICAgICAgIGdldERlZ3JlZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWZmIHRoaXMgcG9seW5vbWlhbCBpcyB0aGUgbW9ub21pYWwgXCIwXCJcbiAgICAgICAgICovXG4gICAgICAgIGlzWmVybygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50c1swXSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBjb2VmZmljaWVudCBvZiB4XmRlZ3JlZSB0ZXJtIGluIHRoaXMgcG9seW5vbWlhbFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29lZmZpY2llbnQoZGVncmVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHNbdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoIC0gMSAtIGRlZ3JlZV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gZXZhbHVhdGlvbiBvZiB0aGlzIHBvbHlub21pYWwgYXQgYSBnaXZlbiBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgZXZhbHVhdGVBdChhKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIHRoZSB4XjAgY29lZmZpY2llbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2VmZmljaWVudCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSnVzdCB0aGUgc3VtIG9mIHRoZSBjb2VmZmljaWVudHNcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gLyppbnQqLyAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZWZmaWNpZW50IC8qaW50Ki8gb2YgdGhpcy5jb2VmZmljaWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gdGhpcy5maWVsZC5hZGQoc3VtLCBjb2VmZmljaWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gLyppbnQqLyB0aGlzLmNvZWZmaWNpZW50c1swXTtcbiAgICAgICAgICAgIGxldCBzaXplID0gLyppbnQqLyB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAxOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWVsZC5hZGQodGhpcy5maWVsZC5tdWx0aXBseShhLCByZXN1bHQpLCB0aGlzLmNvZWZmaWNpZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdNb2R1bHVzUG9seXMgZG8gbm90IGhhdmUgc2FtZSBNb2R1bHVzR0YgZmllbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc21hbGxlckNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgbGV0IGxhcmdlckNvZWZmaWNpZW50cyA9IG90aGVyLmNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIGlmIChzbWFsbGVyQ29lZmZpY2llbnRzLmxlbmd0aCA+IGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IHNtYWxsZXJDb2VmZmljaWVudHM7XG4gICAgICAgICAgICAgICAgc21hbGxlckNvZWZmaWNpZW50cyA9IGxhcmdlckNvZWZmaWNpZW50cztcbiAgICAgICAgICAgICAgICBsYXJnZXJDb2VmZmljaWVudHMgPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN1bURpZmYgPSBuZXcgSW50MzJBcnJheShsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBsZW5ndGhEaWZmID0gLyppbnQqLyBsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoIC0gc21hbGxlckNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBDb3B5IGhpZ2gtb3JkZXIgdGVybXMgb25seSBmb3VuZCBpbiBoaWdoZXItZGVncmVlIHBvbHlub21pYWwncyBjb2VmZmljaWVudHNcbiAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkobGFyZ2VyQ29lZmZpY2llbnRzLCAwLCBzdW1EaWZmLCAwLCBsZW5ndGhEaWZmKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IGxlbmd0aERpZmY7IGkgPCBsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdW1EaWZmW2ldID0gdGhpcy5maWVsZC5hZGQoc21hbGxlckNvZWZmaWNpZW50c1tpIC0gbGVuZ3RoRGlmZl0sIGxhcmdlckNvZWZmaWNpZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIHN1bURpZmYpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmllbGQuZXF1YWxzKG90aGVyLmZpZWxkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ01vZHVsdXNQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIE1vZHVsdXNHRiBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRpdmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkob3RoZXIpIHtcbiAgICAgICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIE1vZHVsdXNQb2x5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlPdGhlcihvdGhlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcihvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHlPdGhlcihvdGhlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdNb2R1bHVzUG9seXMgZG8gbm90IGhhdmUgc2FtZSBNb2R1bHVzR0YgZmllbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzWmVybygpIHx8IG90aGVyLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMuZmllbGQuZ2V0WmVybygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgbmV3IEludDMyQXJyYXkoWzBdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYUNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgbGV0IGFMZW5ndGggPSAvKmludCovIGFDb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGJDb2VmZmljaWVudHMgPSBvdGhlci5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBsZXQgYkxlbmd0aCA9IC8qaW50Ki8gYkNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KGFMZW5ndGggKyBiTGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgYUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFDb2VmZiA9IC8qaW50Ki8gYUNvZWZmaWNpZW50c1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqIC8qaW50Ki8gPSAwOyBqIDwgYkxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3RbaSArIGpdID0gdGhpcy5maWVsZC5hZGQocHJvZHVjdFtpICsgal0sIHRoaXMuZmllbGQubXVsdGlwbHkoYUNvZWZmLCBiQ29lZmZpY2llbnRzW2pdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBwcm9kdWN0KTtcbiAgICAgICAgfVxuICAgICAgICBuZWdhdGl2ZSgpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gLyppbnQqLyB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbmVnYXRpdmVDb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuZWdhdGl2ZUNvZWZmaWNpZW50c1tpXSA9IHRoaXMuZmllbGQuc3VidHJhY3QoMCwgdGhpcy5jb2VmZmljaWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBuZWdhdGl2ZUNvZWZmaWNpZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHlTY2FsYXIoc2NhbGFyKSB7XG4gICAgICAgICAgICBpZiAoc2NhbGFyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBuZXcgSW50MzJBcnJheShbMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2FsYXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaXplID0gLyppbnQqLyB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb2R1Y3RbaV0gPSB0aGlzLmZpZWxkLm11bHRpcGx5KHRoaXMuY29lZmZpY2llbnRzW2ldLCBzY2FsYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBwcm9kdWN0KTtcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseUJ5TW9ub21pYWwoZGVncmVlLCBjb2VmZmljaWVudCkge1xuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIG5ldyBJbnQzMkFycmF5KFswXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNpemUgPSAvKmludCovIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBwcm9kdWN0ID0gbmV3IEludDMyQXJyYXkoc2l6ZSArIGRlZ3JlZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvZHVjdFtpXSA9IHRoaXMuZmllbGQubXVsdGlwbHkodGhpcy5jb2VmZmljaWVudHNbaV0sIGNvZWZmaWNpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgcHJvZHVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgTW9kdWx1c1BvbHlbXSBkaXZpZGUob3RoZXI6IE1vZHVsdXNQb2x5KSB7XG4gICAgICAgICAgaWYgKCFmaWVsZC5lcXVhbHMob3RoZXIuZmllbGQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiTW9kdWx1c1BvbHlzIGRvIG5vdCBoYXZlIHNhbWUgTW9kdWx1c0dGIGZpZWxkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3RoZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJEaXZpZGUgYnkgMFwiKTtcbiAgICAgICAgICB9XG4gICAgICBcbiAgICAgICAgICBsZXQgcXVvdGllbnQ6IE1vZHVsdXNQb2x5ID0gZmllbGQuZ2V0WmVybygpO1xuICAgICAgICAgIGxldCByZW1haW5kZXI6IE1vZHVsdXNQb2x5ID0gdGhpcztcbiAgICAgIFxuICAgICAgICAgIGxldCBkZW5vbWluYXRvckxlYWRpbmdUZXJtOiAvKmludC8gbnVtYmVyID0gb3RoZXIuZ2V0Q29lZmZpY2llbnQob3RoZXIuZ2V0RGVncmVlKCkpO1xuICAgICAgICAgIGxldCBpbnZlcnNlRGVub21pbmF0b3JMZWFkaW5nVGVybTogLyppbnQvIG51bWJlciA9IGZpZWxkLmludmVyc2UoZGVub21pbmF0b3JMZWFkaW5nVGVybSk7XG4gICAgICBcbiAgICAgICAgICB3aGlsZSAocmVtYWluZGVyLmdldERlZ3JlZSgpID49IG90aGVyLmdldERlZ3JlZSgpICYmICFyZW1haW5kZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIGxldCBkZWdyZWVEaWZmZXJlbmNlOiAvKmludC8gbnVtYmVyID0gcmVtYWluZGVyLmdldERlZ3JlZSgpIC0gb3RoZXIuZ2V0RGVncmVlKCk7XG4gICAgICAgICAgICBsZXQgc2NhbGU6IC8qaW50LyBudW1iZXIgPSBmaWVsZC5tdWx0aXBseShyZW1haW5kZXIuZ2V0Q29lZmZpY2llbnQocmVtYWluZGVyLmdldERlZ3JlZSgpKSwgaW52ZXJzZURlbm9taW5hdG9yTGVhZGluZ1Rlcm0pO1xuICAgICAgICAgICAgbGV0IHRlcm06IE1vZHVsdXNQb2x5ID0gb3RoZXIubXVsdGlwbHlCeU1vbm9taWFsKGRlZ3JlZURpZmZlcmVuY2UsIHNjYWxlKTtcbiAgICAgICAgICAgIGxldCBpdGVyYXRpb25RdW90aWVudDogTW9kdWx1c1BvbHkgPSBmaWVsZC5idWlsZE1vbm9taWFsKGRlZ3JlZURpZmZlcmVuY2UsIHNjYWxlKTtcbiAgICAgICAgICAgIHF1b3RpZW50ID0gcXVvdGllbnQuYWRkKGl0ZXJhdGlvblF1b3RpZW50KTtcbiAgICAgICAgICAgIHJlbWFpbmRlciA9IHJlbWFpbmRlci5zdWJ0cmFjdCh0ZXJtKTtcbiAgICAgICAgICB9XG4gICAgICBcbiAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5W10geyBxdW90aWVudCwgcmVtYWluZGVyIH07XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCAvKjggKiB0aGlzLmdldERlZ3JlZSgpKi8pOyAvLyBkeW5hbWljIHN0cmluZyBzaXplIGluIEpTXG4gICAgICAgICAgICBmb3IgKGxldCBkZWdyZWUgLyppbnQqLyA9IHRoaXMuZ2V0RGVncmVlKCk7IGRlZ3JlZSA+PSAwOyBkZWdyZWUtLSkge1xuICAgICAgICAgICAgICAgIGxldCBjb2VmZmljaWVudCA9IC8qaW50Ki8gdGhpcy5nZXRDb2VmZmljaWVudChkZWdyZWUpO1xuICAgICAgICAgICAgICAgIGlmIChjb2VmZmljaWVudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcgLSAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmaWNpZW50ID0gLWNvZWZmaWNpZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcgKyAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVncmVlID09PSAwIHx8IGNvZWZmaWNpZW50ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGNvZWZmaWNpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVncmVlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVncmVlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgneCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgneF4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGRlZ3JlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBNb2R1bHVzQmFzZSB7XG4gICAgICAgIGFkZChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGEgKyBiKSAlIHRoaXMubW9kdWx1cztcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubW9kdWx1cyArIGEgLSBiKSAlIHRoaXMubW9kdWx1cztcbiAgICAgICAgfVxuICAgICAgICBleHAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbYV07XG4gICAgICAgIH1cbiAgICAgICAgbG9nKGEpIHtcbiAgICAgICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9nVGFibGVbYV07XG4gICAgICAgIH1cbiAgICAgICAgaW52ZXJzZShhKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcml0aG1ldGljRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVt0aGlzLm1vZHVsdXMgLSB0aGlzLmxvZ1RhYmxlW2FdIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPT09IDAgfHwgYiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbKHRoaXMubG9nVGFibGVbYV0gKyB0aGlzLmxvZ1RhYmxlW2JdKSAlICh0aGlzLm1vZHVsdXMgLSAxKV07XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZHVsdXM7XG4gICAgICAgIH1cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIHJldHVybiBvID09PSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMiBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5BIGZpZWxkIGJhc2VkIG9uIHBvd2VycyBvZiBhIGdlbmVyYXRvciBpbnRlZ2VyLCBtb2R1bG8gc29tZSBtb2R1bHVzLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICogQHNlZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5yZWVkc29sb21vbi5HZW5lcmljR0ZcbiAgICAgKi9cbiAgICAvKnB1YmxpYyBmaW5hbCovIGNsYXNzIE1vZHVsdXNHRiBleHRlbmRzIE1vZHVsdXNCYXNlIHtcbiAgICAgICAgLy8gcHJpdmF0ZSAvKmZpbmFsKi8gbW9kdWx1czogLyppbnQqLyBudW1iZXI7XG4gICAgICAgIGNvbnN0cnVjdG9yKG1vZHVsdXMsIGdlbmVyYXRvcikge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMubW9kdWx1cyA9IG1vZHVsdXM7XG4gICAgICAgICAgICB0aGlzLmV4cFRhYmxlID0gbmV3IEludDMyQXJyYXkobW9kdWx1cyk7XG4gICAgICAgICAgICB0aGlzLmxvZ1RhYmxlID0gbmV3IEludDMyQXJyYXkobW9kdWx1cyk7XG4gICAgICAgICAgICBsZXQgeCA9IC8qaW50Ki8gMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBtb2R1bHVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cFRhYmxlW2ldID0geDtcbiAgICAgICAgICAgICAgICB4ID0gKHggKiBnZW5lcmF0b3IpICUgbW9kdWx1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBtb2R1bHVzIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dUYWJsZVt0aGlzLmV4cFRhYmxlW2ldXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsb2dUYWJsZVswXSA9PSAwIGJ1dCB0aGlzIHNob3VsZCBuZXZlciBiZSB1c2VkXG4gICAgICAgICAgICB0aGlzLnplcm8gPSBuZXcgTW9kdWx1c1BvbHkodGhpcywgbmV3IEludDMyQXJyYXkoWzBdKSk7XG4gICAgICAgICAgICB0aGlzLm9uZSA9IG5ldyBNb2R1bHVzUG9seSh0aGlzLCBuZXcgSW50MzJBcnJheShbMV0pKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRaZXJvKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgICAgICBnZXRPbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRNb25vbWlhbChkZWdyZWUsIGNvZWZmaWNpZW50KSB7XG4gICAgICAgICAgICBpZiAoZGVncmVlIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2VmZmljaWVudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoZGVncmVlICsgMSk7XG4gICAgICAgICAgICBjb2VmZmljaWVudHNbMF0gPSBjb2VmZmljaWVudDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcywgY29lZmZpY2llbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBNb2R1bHVzR0YuUERGNDE3X0dGID0gbmV3IE1vZHVsdXNHRihQREY0MTdDb21tb24uTlVNQkVSX09GX0NPREVXT1JEUywgMyk7XG5cbiAgICAvKlxuICAgICogQ29weXJpZ2h0IDIwMTIgWlhpbmcgYXV0aG9yc1xuICAgICpcbiAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAqXG4gICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICpcbiAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5QREY0MTcgZXJyb3IgY29ycmVjdGlvbiBpbXBsZW1lbnRhdGlvbi48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaGlzIDxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JlZWQlRTIlODAlOTNTb2xvbW9uX2Vycm9yX2NvcnJlY3Rpb24jRXhhbXBsZVwiPmV4YW1wbGU8L2E+XG4gICAgICogaXMgcXVpdGUgdXNlZnVsIGluIHVuZGVyc3RhbmRpbmcgdGhlIGFsZ29yaXRobS48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBzZWUgY29tLmdvb2dsZS56eGluZy5jb21tb24ucmVlZHNvbG9tb24uUmVlZFNvbG9tb25EZWNvZGVyXG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBFcnJvckNvcnJlY3Rpb24ge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuZmllbGQgPSBNb2R1bHVzR0YuUERGNDE3X0dGO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gcmVjZWl2ZWQgcmVjZWl2ZWQgY29kZXdvcmRzXG4gICAgICAgICAqIEBwYXJhbSBudW1FQ0NvZGV3b3JkcyBudW1iZXIgb2YgdGhvc2UgY29kZXdvcmRzIHVzZWQgZm9yIEVDXG4gICAgICAgICAqIEBwYXJhbSBlcmFzdXJlcyBsb2NhdGlvbiBvZiBlcmFzdXJlc1xuICAgICAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBlcnJvcnNcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvcnMgY2Fubm90IGJlIGNvcnJlY3RlZCwgbWF5YmUgYmVjYXVzZSBvZiB0b28gbWFueSBlcnJvcnNcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZShyZWNlaXZlZCwgbnVtRUNDb2Rld29yZHMsIGVyYXN1cmVzKSB7XG4gICAgICAgICAgICBsZXQgcG9seSA9IG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCByZWNlaXZlZCk7XG4gICAgICAgICAgICBsZXQgUyA9IG5ldyBJbnQzMkFycmF5KG51bUVDQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gbnVtRUNDb2Rld29yZHM7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZXZhbHVhdGlvbiA9IHBvbHkuZXZhbHVhdGVBdCh0aGlzLmZpZWxkLmV4cChpKSk7XG4gICAgICAgICAgICAgICAgU1tudW1FQ0NvZGV3b3JkcyAtIGldID0gZXZhbHVhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGtub3duRXJyb3JzID0gdGhpcy5maWVsZC5nZXRPbmUoKTtcbiAgICAgICAgICAgIGlmIChlcmFzdXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlcmFzdXJlIG9mIGVyYXN1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiID0gdGhpcy5maWVsZC5leHAocmVjZWl2ZWQubGVuZ3RoIC0gMSAtIGVyYXN1cmUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgKDEgLSBieCkgdGVybTpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgbmV3IEludDMyQXJyYXkoW3RoaXMuZmllbGQuc3VidHJhY3QoMCwgYiksIDFdKSk7XG4gICAgICAgICAgICAgICAgICAgIGtub3duRXJyb3JzID0ga25vd25FcnJvcnMubXVsdGlwbHkodGVybSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN5bmRyb21lID0gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIFMpO1xuICAgICAgICAgICAgLy8gc3luZHJvbWUgPSBzeW5kcm9tZS5tdWx0aXBseShrbm93bkVycm9ycyk7XG4gICAgICAgICAgICBsZXQgc2lnbWFPbWVnYSA9IHRoaXMucnVuRXVjbGlkZWFuQWxnb3JpdGhtKHRoaXMuZmllbGQuYnVpbGRNb25vbWlhbChudW1FQ0NvZGV3b3JkcywgMSksIHN5bmRyb21lLCBudW1FQ0NvZGV3b3Jkcyk7XG4gICAgICAgICAgICBsZXQgc2lnbWEgPSBzaWdtYU9tZWdhWzBdO1xuICAgICAgICAgICAgbGV0IG9tZWdhID0gc2lnbWFPbWVnYVsxXTtcbiAgICAgICAgICAgIC8vIHNpZ21hID0gc2lnbWEubXVsdGlwbHkoa25vd25FcnJvcnMpO1xuICAgICAgICAgICAgbGV0IGVycm9yTG9jYXRpb25zID0gdGhpcy5maW5kRXJyb3JMb2NhdGlvbnMoc2lnbWEpO1xuICAgICAgICAgICAgbGV0IGVycm9yTWFnbml0dWRlcyA9IHRoaXMuZmluZEVycm9yTWFnbml0dWRlcyhvbWVnYSwgc2lnbWEsIGVycm9yTG9jYXRpb25zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBlcnJvckxvY2F0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHJlY2VpdmVkLmxlbmd0aCAtIDEgLSB0aGlzLmZpZWxkLmxvZyhlcnJvckxvY2F0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBDaGVja3N1bUV4Y2VwdGlvbi5nZXRDaGVja3N1bUluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkW3Bvc2l0aW9uXSA9IHRoaXMuZmllbGQuc3VidHJhY3QocmVjZWl2ZWRbcG9zaXRpb25dLCBlcnJvck1hZ25pdHVkZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9yTG9jYXRpb25zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIE1vZHVsdXNQb2x5XG4gICAgICAgICAqIEBwYXJhbSBhXG4gICAgICAgICAqIEBwYXJhbSBNb2R1bHVzUG9seVxuICAgICAgICAgKiBAcGFyYW0gYlxuICAgICAgICAgKiBAcGFyYW0gaW50XG4gICAgICAgICAqIEBwYXJhbSBSXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHJ1bkV1Y2xpZGVhbkFsZ29yaXRobShhLCBiLCBSKSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgYSdzIGRlZ3JlZSBpcyA+PSBiJ3NcbiAgICAgICAgICAgIGlmIChhLmdldERlZ3JlZSgpIDwgYi5nZXREZWdyZWUoKSkge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gYTtcbiAgICAgICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICAgICAgICBiID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByTGFzdCA9IGE7XG4gICAgICAgICAgICBsZXQgciA9IGI7XG4gICAgICAgICAgICBsZXQgdExhc3QgPSB0aGlzLmZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgICAgIGxldCB0ID0gdGhpcy5maWVsZC5nZXRPbmUoKTtcbiAgICAgICAgICAgIC8vIFJ1biBFdWNsaWRlYW4gYWxnb3JpdGhtIHVudGlsIHIncyBkZWdyZWUgaXMgbGVzcyB0aGFuIFIvMlxuICAgICAgICAgICAgd2hpbGUgKHIuZ2V0RGVncmVlKCkgPj0gTWF0aC5yb3VuZChSIC8gMikpIHtcbiAgICAgICAgICAgICAgICBsZXQgckxhc3RMYXN0ID0gckxhc3Q7XG4gICAgICAgICAgICAgICAgbGV0IHRMYXN0TGFzdCA9IHRMYXN0O1xuICAgICAgICAgICAgICAgIHJMYXN0ID0gcjtcbiAgICAgICAgICAgICAgICB0TGFzdCA9IHQ7XG4gICAgICAgICAgICAgICAgLy8gRGl2aWRlIHJMYXN0TGFzdCBieSByTGFzdCwgd2l0aCBxdW90aWVudCBpbiBxIGFuZCByZW1haW5kZXIgaW4gclxuICAgICAgICAgICAgICAgIGlmIChyTGFzdC5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPb3BzLCBFdWNsaWRlYW4gYWxnb3JpdGhtIGFscmVhZHkgdGVybWluYXRlZD9cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb24uZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByID0gckxhc3RMYXN0O1xuICAgICAgICAgICAgICAgIGxldCBxID0gdGhpcy5maWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgbGV0IGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0gPSByTGFzdC5nZXRDb2VmZmljaWVudChyTGFzdC5nZXREZWdyZWUoKSk7XG4gICAgICAgICAgICAgICAgbGV0IGRsdEludmVyc2UgPSB0aGlzLmZpZWxkLmludmVyc2UoZGVub21pbmF0b3JMZWFkaW5nVGVybSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHIuZ2V0RGVncmVlKCkgPj0gckxhc3QuZ2V0RGVncmVlKCkgJiYgIXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlZ3JlZURpZmYgPSByLmdldERlZ3JlZSgpIC0gckxhc3QuZ2V0RGVncmVlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzY2FsZSA9IHRoaXMuZmllbGQubXVsdGlwbHkoci5nZXRDb2VmZmljaWVudChyLmdldERlZ3JlZSgpKSwgZGx0SW52ZXJzZSk7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLmFkZCh0aGlzLmZpZWxkLmJ1aWxkTW9ub21pYWwoZGVncmVlRGlmZiwgc2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgciA9IHIuc3VidHJhY3Qockxhc3QubXVsdGlwbHlCeU1vbm9taWFsKGRlZ3JlZURpZmYsIHNjYWxlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgPSBxLm11bHRpcGx5KHRMYXN0KS5zdWJ0cmFjdCh0TGFzdExhc3QpLm5lZ2F0aXZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2lnbWFUaWxkZUF0WmVybyA9IHQuZ2V0Q29lZmZpY2llbnQoMCk7XG4gICAgICAgICAgICBpZiAoc2lnbWFUaWxkZUF0WmVybyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uLmdldENoZWNrc3VtSW5zdGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbnZlcnNlID0gdGhpcy5maWVsZC5pbnZlcnNlKHNpZ21hVGlsZGVBdFplcm8pO1xuICAgICAgICAgICAgbGV0IHNpZ21hID0gdC5tdWx0aXBseShpbnZlcnNlKTtcbiAgICAgICAgICAgIGxldCBvbWVnYSA9IHIubXVsdGlwbHkoaW52ZXJzZSk7XG4gICAgICAgICAgICByZXR1cm4gW3NpZ21hLCBvbWVnYV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlcnJvckxvY2F0b3JcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZmluZEVycm9yTG9jYXRpb25zKGVycm9yTG9jYXRvcikge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGRpcmVjdCBhcHBsaWNhdGlvbiBvZiBDaGllbidzIHNlYXJjaFxuICAgICAgICAgICAgbGV0IG51bUVycm9ycyA9IGVycm9yTG9jYXRvci5nZXREZWdyZWUoKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgSW50MzJBcnJheShudW1FcnJvcnMpO1xuICAgICAgICAgICAgbGV0IGUgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMTsgaSA8IHRoaXMuZmllbGQuZ2V0U2l6ZSgpICYmIGUgPCBudW1FcnJvcnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvckxvY2F0b3IuZXZhbHVhdGVBdChpKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZV0gPSB0aGlzLmZpZWxkLmludmVyc2UoaSk7XG4gICAgICAgICAgICAgICAgICAgIGUrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSAhPT0gbnVtRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb24uZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmaW5kRXJyb3JNYWduaXR1ZGVzKGVycm9yRXZhbHVhdG9yLCBlcnJvckxvY2F0b3IsIGVycm9yTG9jYXRpb25zKSB7XG4gICAgICAgICAgICBsZXQgZXJyb3JMb2NhdG9yRGVncmVlID0gZXJyb3JMb2NhdG9yLmdldERlZ3JlZSgpO1xuICAgICAgICAgICAgbGV0IGZvcm1hbERlcml2YXRpdmVDb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShlcnJvckxvY2F0b3JEZWdyZWUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMTsgaSA8PSBlcnJvckxvY2F0b3JEZWdyZWU7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvcm1hbERlcml2YXRpdmVDb2VmZmljaWVudHNbZXJyb3JMb2NhdG9yRGVncmVlIC0gaV0gPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpZWxkLm11bHRpcGx5KGksIGVycm9yTG9jYXRvci5nZXRDb2VmZmljaWVudChpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9ybWFsRGVyaXZhdGl2ZSA9IG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBmb3JtYWxEZXJpdmF0aXZlQ29lZmZpY2llbnRzKTtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgZGlyZWN0bHkgYXBwbHlpbmcgRm9ybmV5J3MgRm9ybXVsYVxuICAgICAgICAgICAgbGV0IHMgPSBlcnJvckxvY2F0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkocyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHhpSW52ZXJzZSA9IHRoaXMuZmllbGQuaW52ZXJzZShlcnJvckxvY2F0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgbGV0IG51bWVyYXRvciA9IHRoaXMuZmllbGQuc3VidHJhY3QoMCwgZXJyb3JFdmFsdWF0b3IuZXZhbHVhdGVBdCh4aUludmVyc2UpKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVub21pbmF0b3IgPSB0aGlzLmZpZWxkLmludmVyc2UoZm9ybWFsRGVyaXZhdGl2ZS5ldmFsdWF0ZUF0KHhpSW52ZXJzZSkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuZmllbGQubXVsdGlwbHkobnVtZXJhdG9yLCBkZW5vbWluYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIEJvdW5kaW5nQm94IHtcbiAgICAgICAgY29uc3RydWN0b3IoaW1hZ2UsIHRvcExlZnQsIGJvdHRvbUxlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCkge1xuICAgICAgICAgICAgaWYgKGltYWdlIGluc3RhbmNlb2YgQm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yXzIoaW1hZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvcl8xKGltYWdlLCB0b3BMZWZ0LCBib3R0b21MZWZ0LCB0b3BSaWdodCwgYm90dG9tUmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VcbiAgICAgICAgICogQHBhcmFtIHRvcExlZnRcbiAgICAgICAgICogQHBhcmFtIGJvdHRvbUxlZnRcbiAgICAgICAgICogQHBhcmFtIHRvcFJpZ2h0XG4gICAgICAgICAqIEBwYXJhbSBib3R0b21SaWdodFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcl8xKGltYWdlLCB0b3BMZWZ0LCBib3R0b21MZWZ0LCB0b3BSaWdodCwgYm90dG9tUmlnaHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRVbnNwZWNpZmllZCA9IHRvcExlZnQgPT0gbnVsbCB8fCBib3R0b21MZWZ0ID09IG51bGw7XG4gICAgICAgICAgICBjb25zdCByaWdodFVuc3BlY2lmaWVkID0gdG9wUmlnaHQgPT0gbnVsbCB8fCBib3R0b21SaWdodCA9PSBudWxsO1xuICAgICAgICAgICAgaWYgKGxlZnRVbnNwZWNpZmllZCAmJiByaWdodFVuc3BlY2lmaWVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdFVuc3BlY2lmaWVkKSB7XG4gICAgICAgICAgICAgICAgdG9wTGVmdCA9IG5ldyBSZXN1bHRQb2ludCgwLCB0b3BSaWdodC5nZXRZKCkpO1xuICAgICAgICAgICAgICAgIGJvdHRvbUxlZnQgPSBuZXcgUmVzdWx0UG9pbnQoMCwgYm90dG9tUmlnaHQuZ2V0WSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0VW5zcGVjaWZpZWQpIHtcbiAgICAgICAgICAgICAgICB0b3BSaWdodCA9IG5ldyBSZXN1bHRQb2ludChpbWFnZS5nZXRXaWR0aCgpIC0gMSwgdG9wTGVmdC5nZXRZKCkpO1xuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0ID0gbmV3IFJlc3VsdFBvaW50KGltYWdlLmdldFdpZHRoKCkgLSAxLCBib3R0b21MZWZ0LmdldFkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLnRvcExlZnQgPSB0b3BMZWZ0O1xuICAgICAgICAgICAgdGhpcy5ib3R0b21MZWZ0ID0gYm90dG9tTGVmdDtcbiAgICAgICAgICAgIHRoaXMudG9wUmlnaHQgPSB0b3BSaWdodDtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tUmlnaHQgPSBib3R0b21SaWdodDtcbiAgICAgICAgICAgIHRoaXMubWluWCA9IE1hdGgudHJ1bmMoTWF0aC5taW4odG9wTGVmdC5nZXRYKCksIGJvdHRvbUxlZnQuZ2V0WCgpKSk7XG4gICAgICAgICAgICB0aGlzLm1heFggPSBNYXRoLnRydW5jKE1hdGgubWF4KHRvcFJpZ2h0LmdldFgoKSwgYm90dG9tUmlnaHQuZ2V0WCgpKSk7XG4gICAgICAgICAgICB0aGlzLm1pblkgPSBNYXRoLnRydW5jKE1hdGgubWluKHRvcExlZnQuZ2V0WSgpLCB0b3BSaWdodC5nZXRZKCkpKTtcbiAgICAgICAgICAgIHRoaXMubWF4WSA9IE1hdGgudHJ1bmMoTWF0aC5tYXgoYm90dG9tTGVmdC5nZXRZKCksIGJvdHRvbVJpZ2h0LmdldFkoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0cnVjdG9yXzIoYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBib3VuZGluZ0JveC5pbWFnZTtcbiAgICAgICAgICAgIHRoaXMudG9wTGVmdCA9IGJvdW5kaW5nQm94LmdldFRvcExlZnQoKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tTGVmdCA9IGJvdW5kaW5nQm94LmdldEJvdHRvbUxlZnQoKTtcbiAgICAgICAgICAgIHRoaXMudG9wUmlnaHQgPSBib3VuZGluZ0JveC5nZXRUb3BSaWdodCgpO1xuICAgICAgICAgICAgdGhpcy5ib3R0b21SaWdodCA9IGJvdW5kaW5nQm94LmdldEJvdHRvbVJpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLm1pblggPSBib3VuZGluZ0JveC5nZXRNaW5YKCk7XG4gICAgICAgICAgICB0aGlzLm1heFggPSBib3VuZGluZ0JveC5nZXRNYXhYKCk7XG4gICAgICAgICAgICB0aGlzLm1pblkgPSBib3VuZGluZ0JveC5nZXRNaW5ZKCk7XG4gICAgICAgICAgICB0aGlzLm1heFkgPSBib3VuZGluZ0JveC5nZXRNYXhZKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBtZXJnZShsZWZ0Qm94LCByaWdodEJveCkge1xuICAgICAgICAgICAgaWYgKGxlZnRCb3ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByaWdodEJveDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyaWdodEJveCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRCb3g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KGxlZnRCb3guaW1hZ2UsIGxlZnRCb3gudG9wTGVmdCwgbGVmdEJveC5ib3R0b21MZWZ0LCByaWdodEJveC50b3BSaWdodCwgcmlnaHRCb3guYm90dG9tUmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBhZGRNaXNzaW5nUm93cyhtaXNzaW5nU3RhcnRSb3dzLCBtaXNzaW5nRW5kUm93cywgaXNMZWZ0KSB7XG4gICAgICAgICAgICBsZXQgbmV3VG9wTGVmdCA9IHRoaXMudG9wTGVmdDtcbiAgICAgICAgICAgIGxldCBuZXdCb3R0b21MZWZ0ID0gdGhpcy5ib3R0b21MZWZ0O1xuICAgICAgICAgICAgbGV0IG5ld1RvcFJpZ2h0ID0gdGhpcy50b3BSaWdodDtcbiAgICAgICAgICAgIGxldCBuZXdCb3R0b21SaWdodCA9IHRoaXMuYm90dG9tUmlnaHQ7XG4gICAgICAgICAgICBpZiAobWlzc2luZ1N0YXJ0Um93cyA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9wID0gaXNMZWZ0ID8gdGhpcy50b3BMZWZ0IDogdGhpcy50b3BSaWdodDtcbiAgICAgICAgICAgICAgICBsZXQgbmV3TWluWSA9IE1hdGgudHJ1bmModG9wLmdldFkoKSAtIG1pc3NpbmdTdGFydFJvd3MpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdNaW5ZIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdNaW5ZID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG5ld1RvcCA9IG5ldyBSZXN1bHRQb2ludCh0b3AuZ2V0WCgpLCBuZXdNaW5ZKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1RvcExlZnQgPSBuZXdUb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdUb3BSaWdodCA9IG5ld1RvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWlzc2luZ0VuZFJvd3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJvdHRvbSA9IGlzTGVmdCA/IHRoaXMuYm90dG9tTGVmdCA6IHRoaXMuYm90dG9tUmlnaHQ7XG4gICAgICAgICAgICAgICAgbGV0IG5ld01heFkgPSBNYXRoLnRydW5jKGJvdHRvbS5nZXRZKCkgKyBtaXNzaW5nRW5kUm93cyk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld01heFkgPj0gdGhpcy5pbWFnZS5nZXRIZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXhZID0gdGhpcy5pbWFnZS5nZXRIZWlnaHQoKSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBuZXdCb3R0b20gPSBuZXcgUmVzdWx0UG9pbnQoYm90dG9tLmdldFgoKSwgbmV3TWF4WSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdCb3R0b21MZWZ0ID0gbmV3Qm90dG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Qm90dG9tUmlnaHQgPSBuZXdCb3R0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh0aGlzLmltYWdlLCBuZXdUb3BMZWZ0LCBuZXdCb3R0b21MZWZ0LCBuZXdUb3BSaWdodCwgbmV3Qm90dG9tUmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGdldE1pblgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW5YO1xuICAgICAgICB9XG4gICAgICAgIGdldE1heFgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhYO1xuICAgICAgICB9XG4gICAgICAgIGdldE1pblkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW5ZO1xuICAgICAgICB9XG4gICAgICAgIGdldE1heFkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhZO1xuICAgICAgICB9XG4gICAgICAgIGdldFRvcExlZnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3BMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGdldFRvcFJpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9wUmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Qm90dG9tTGVmdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdHRvbUxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Qm90dG9tUmlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3R0b21SaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5kZWNvZGVyO1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qZmluYWwqLyBjbGFzcyBCYXJjb2RlTWV0YWRhdGEge1xuICAgICAgICBjb25zdHJ1Y3Rvcihjb2x1bW5Db3VudCwgcm93Q291bnRVcHBlclBhcnQsIHJvd0NvdW50TG93ZXJQYXJ0LCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5Db3VudCA9IGNvbHVtbkNvdW50O1xuICAgICAgICAgICAgdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbCA9IGVycm9yQ29ycmVjdGlvbkxldmVsO1xuICAgICAgICAgICAgdGhpcy5yb3dDb3VudFVwcGVyUGFydCA9IHJvd0NvdW50VXBwZXJQYXJ0O1xuICAgICAgICAgICAgdGhpcy5yb3dDb3VudExvd2VyUGFydCA9IHJvd0NvdW50TG93ZXJQYXJ0O1xuICAgICAgICAgICAgdGhpcy5yb3dDb3VudCA9IHJvd0NvdW50VXBwZXJQYXJ0ICsgcm93Q291bnRMb3dlclBhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q29sdW1uQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5Db3VudDtcbiAgICAgICAgfVxuICAgICAgICBnZXRFcnJvckNvcnJlY3Rpb25MZXZlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsO1xuICAgICAgICB9XG4gICAgICAgIGdldFJvd0NvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93Q291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Um93Q291bnRVcHBlclBhcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dDb3VudFVwcGVyUGFydDtcbiAgICAgICAgfVxuICAgICAgICBnZXRSb3dDb3VudExvd2VyUGFydCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0NvdW50TG93ZXJQYXJ0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSmF2YSBGb3JtYXR0ZXIgY2xhc3MgcG9seWZpbGwgdGhhdCB3b3JrcyBpbiB0aGUgSlMgd2F5LlxuICAgICAqL1xuICAgIGNsYXNzIEZvcm1hdHRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSAnJztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTM0Mzk3MTEvNDM2NzY4M1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3RyXG4gICAgICAgICAqIEBwYXJhbSBhcnJcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmb3JtKHN0ciwgYXJyKSB7XG4gICAgICAgICAgICBsZXQgaSA9IC0xO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soZXhwLCBwMCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwID09PSAnJSUnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyUnO1xuICAgICAgICAgICAgICAgIGlmIChhcnJbKytpXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGV4cCA9IHAyID8gcGFyc2VJbnQocDIuc3Vic3RyKDEpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZSA9IHAzID8gcGFyc2VJbnQocDMuc3Vic3RyKDEpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgdmFsO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocDQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcnJbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcnJbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFycltpXSkudG9GaXhlZChleHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChhcnJbaV0pLnRvUHJlY2lzaW9uKGV4cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFycltpXSkudG9FeHBvbmVudGlhbChleHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VJbnQoYXJyW2ldKS50b1N0cmluZyhiYXNlID8gYmFzZSA6IDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQocGFyc2VJbnQoYXJyW2ldLCBiYXNlID8gYmFzZSA6IDEwKS50b1ByZWNpc2lvbihleHApKS50b0ZpeGVkKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnID8gSlNPTi5zdHJpbmdpZnkodmFsKSA6ICgrdmFsKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KHAxKTsgLyogcGFkZGluZyBzaXplICovXG4gICAgICAgICAgICAgICAgbGV0IGNoID0gcDEgJiYgKHAxWzBdICsgJycpID09PSAnMCcgPyAnMCcgOiAnICc7IC8qIGlzbnVsbD8gKi9cbiAgICAgICAgICAgICAgICB3aGlsZSAodmFsLmxlbmd0aCA8IHNpemUpXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHAwICE9PSB1bmRlZmluZWQgPyB2YWwgKyBjaCA6IGNoICsgdmFsOyAvKiBpc21pbnVzPyAqL1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvJSgtKT8oMD9bMC05XSspPyhbLl1bMC05XSspPyhbI11bMC05XSspPyhbc2NmcGV4ZCVdKS9nO1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlZ2V4LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBhcHBlbmQgVGhlIG5ldyBzdHJpbmcgdG8gYXBwZW5kLlxuICAgICAgICAgKiBAcGFyYW0gYXJncyBBcmd1bWV0cyB2YWx1ZXMgdG8gYmUgZm9ybWF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmb3JtYXQoYXBwZW5kLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciArPSBGb3JtYXR0ZXIuZm9ybShhcHBlbmQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBGb3JtYXR0ZXIgc3RyaW5nIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIGNsYXNzIERldGVjdGlvblJlc3VsdENvbHVtbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIC8vIHRoaXMuY29kZXdvcmRzID0gbmV3IENvZGV3b3JkW2JvdW5kaW5nQm94LmdldE1heFkoKSAtIGJvdW5kaW5nQm94LmdldE1pblkoKSArIDFdO1xuICAgICAgICAgICAgdGhpcy5jb2Rld29yZHMgPSBuZXcgQXJyYXkoYm91bmRpbmdCb3guZ2V0TWF4WSgpIC0gYm91bmRpbmdCb3guZ2V0TWluWSgpICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLypmaW5hbCovIGdldENvZGV3b3JkTmVhcmJ5KGltYWdlUm93KSB7XG4gICAgICAgICAgICBsZXQgY29kZXdvcmQgPSB0aGlzLmdldENvZGV3b3JkKGltYWdlUm93KTtcbiAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGV3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBEZXRlY3Rpb25SZXN1bHRDb2x1bW4uTUFYX05FQVJCWV9ESVNUQU5DRTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5lYXJJbWFnZVJvdyA9IHRoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoaW1hZ2VSb3cpIC0gaTtcbiAgICAgICAgICAgICAgICBpZiAobmVhckltYWdlUm93ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmQgPSB0aGlzLmNvZGV3b3Jkc1tuZWFySW1hZ2VSb3ddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGV3b3JkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5lYXJJbWFnZVJvdyA9IHRoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoaW1hZ2VSb3cpICsgaTtcbiAgICAgICAgICAgICAgICBpZiAobmVhckltYWdlUm93IDwgdGhpcy5jb2Rld29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3JkID0gdGhpcy5jb2Rld29yZHNbbmVhckltYWdlUm93XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2Rld29yZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qZmluYWwgaW50Ki8gaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoaW1hZ2VSb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWFnZVJvdyAtIHRoaXMuYm91bmRpbmdCb3guZ2V0TWluWSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qZmluYWwgdm9pZCovIHNldENvZGV3b3JkKGltYWdlUm93LCBjb2Rld29yZCkge1xuICAgICAgICAgICAgdGhpcy5jb2Rld29yZHNbdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChpbWFnZVJvdyldID0gY29kZXdvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgLypmaW5hbCovIGdldENvZGV3b3JkKGltYWdlUm93KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2Rld29yZHNbdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChpbWFnZVJvdyldO1xuICAgICAgICB9XG4gICAgICAgIC8qZmluYWwqLyBnZXRCb3VuZGluZ0JveCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nQm94O1xuICAgICAgICB9XG4gICAgICAgIC8qZmluYWwqLyBnZXRDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcigpO1xuICAgICAgICAgICAgbGV0IHJvdyA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvZGV3b3JkIG9mIHRoaXMuY29kZXdvcmRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnJTNkOiAgICB8ICAgJW4nLCByb3crKyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCclM2Q6ICUzZHwlM2QlbicsIHJvdysrLCBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSwgY29kZXdvcmQuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uLk1BWF9ORUFSQllfRElTVEFOQ0UgPSA1O1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkNvbGxlY3Rpb247XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5IYXNoTWFwO1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTWFwO1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTWFwLkVudHJ5O1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qZmluYWwqLyBjbGFzcyBCYXJjb2RlVmFsdWUge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYW4gb2NjdXJyZW5jZSBvZiBhIHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnRydW5jKHZhbHVlKTtcbiAgICAgICAgICAgIGxldCBjb25maWRlbmNlID0gdGhpcy52YWx1ZXMuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjb25maWRlbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWRlbmNlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZGVuY2UrKztcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnNldCh2YWx1ZSwgY29uZmlkZW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgdGhlIG1heGltdW0gb2NjdXJyZW5jZSBvZiBhIHNldCB2YWx1ZSBhbmQgcmV0dXJucyBhbGwgdmFsdWVzIHdoaWNoIHdlcmUgc2V0IHdpdGggdGhpcyBvY2N1cnJlbmNlLlxuICAgICAgICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGludCwgY29udGFpbmluZyB0aGUgdmFsdWVzIHdpdGggdGhlIGhpZ2hlc3Qgb2NjdXJyZW5jZSwgb3IgbnVsbCwgaWYgbm8gdmFsdWUgd2FzIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICBsZXQgbWF4Q29uZmlkZW5jZSA9IC0xO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy52YWx1ZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgIGdldEtleTogKCkgPT4ga2V5LFxuICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZTogKCkgPT4gdmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuZ2V0VmFsdWUoKSA+IG1heENvbmZpZGVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4Q29uZmlkZW5jZSA9IGVudHJ5LmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbnRyeS5nZXRLZXkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVudHJ5LmdldFZhbHVlKCkgPT09IG1heENvbmZpZGVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW50cnkuZ2V0S2V5KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQREY0MTdDb21tb24udG9JbnRBcnJheShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGdldENvbmZpZGVuY2UodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5nZXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKmZpbmFsKi8gY2xhc3MgRGV0ZWN0aW9uUmVzdWx0Um93SW5kaWNhdG9yQ29sdW1uIGV4dGVuZHMgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uIHtcbiAgICAgICAgY29uc3RydWN0b3IoYm91bmRpbmdCb3gsIGlzTGVmdCkge1xuICAgICAgICAgICAgc3VwZXIoYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgdGhpcy5faXNMZWZ0ID0gaXNMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHNldFJvd051bWJlcnMoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2Rld29yZCAvKkNvZGV3b3JkKi8gb2YgdGhpcy5nZXRDb2Rld29yZHMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlckFzUm93SW5kaWNhdG9yQ29sdW1uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IHByb3Blcmx5XG4gICAgICAgIC8vIFRPRE8gbWF5YmUgd2Ugc2hvdWxkIGFkZCBtaXNzaW5nIGNvZGV3b3JkcyB0byBzdG9yZSB0aGUgY29ycmVjdCByb3cgbnVtYmVyIHRvIG1ha2VcbiAgICAgICAgLy8gZmluZGluZyByb3cgbnVtYmVycyBmb3Igb3RoZXIgY29sdW1ucyBlYXNpZXJcbiAgICAgICAgLy8gdXNlIHJvdyBoZWlnaHQgY291bnQgdG8gbWFrZSBkZXRlY3Rpb24gb2YgaW52YWxpZCByb3cgbnVtYmVycyBtb3JlIHJlbGlhYmxlXG4gICAgICAgIGFkanVzdENvbXBsZXRlSW5kaWNhdG9yQ29sdW1uUm93TnVtYmVycyhiYXJjb2RlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZHMgPSB0aGlzLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgdGhpcy5zZXRSb3dOdW1iZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUluY29ycmVjdENvZGV3b3Jkcyhjb2Rld29yZHMsIGJhcmNvZGVNZXRhZGF0YSk7XG4gICAgICAgICAgICBsZXQgYm91bmRpbmdCb3ggPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5faXNMZWZ0ID8gYm91bmRpbmdCb3guZ2V0VG9wTGVmdCgpIDogYm91bmRpbmdCb3guZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgICAgIGxldCBib3R0b20gPSB0aGlzLl9pc0xlZnQgPyBib3VuZGluZ0JveC5nZXRCb3R0b21MZWZ0KCkgOiBib3VuZGluZ0JveC5nZXRCb3R0b21SaWdodCgpO1xuICAgICAgICAgICAgbGV0IGZpcnN0Um93ID0gdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChNYXRoLnRydW5jKHRvcC5nZXRZKCkpKTtcbiAgICAgICAgICAgIGxldCBsYXN0Um93ID0gdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChNYXRoLnRydW5jKGJvdHRvbS5nZXRZKCkpKTtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYmUgY2FyZWZ1bCB1c2luZyB0aGUgYXZlcmFnZSByb3cgaGVpZ2h0LiBCYXJjb2RlIGNvdWxkIGJlIHNrZXdlZCBzbyB0aGF0IHdlIGhhdmUgc21hbGxlciBhbmRcbiAgICAgICAgICAgIC8vIHRhbGxlciByb3dzXG4gICAgICAgICAgICAvLyBmbG9hdCBhdmVyYWdlUm93SGVpZ2h0ID0gKGxhc3RSb3cgLSBmaXJzdFJvdykgLyAvKihmbG9hdCkqLyBiYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgICAgIGxldCBiYXJjb2RlUm93ID0gLTE7XG4gICAgICAgICAgICBsZXQgbWF4Um93SGVpZ2h0ID0gMTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Um93SGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3Jkc1JvdyAvKmludCovID0gZmlyc3RSb3c7IGNvZGV3b3Jkc1JvdyA8IGxhc3RSb3c7IGNvZGV3b3Jkc1JvdysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddO1xuICAgICAgICAgICAgICAgIC8vICAgICAgZmxvYXQgZXhwZWN0ZWRSb3dOdW1iZXIgPSAoY29kZXdvcmRzUm93IC0gZmlyc3RSb3cpIC8gYXZlcmFnZVJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICAvLyAgICAgIGlmIChNYXRoLmFicyhjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSAtIGV4cGVjdGVkUm93TnVtYmVyKSA+IDIpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgU2ltcGxlTG9nLmxvZyhMRVZFTC5XQVJOSU5HLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgXCJSZW1vdmluZyBjb2Rld29yZCwgcm93TnVtYmVyU2tldyB0b28gaGlnaCwgY29kZXdvcmRbXCIgKyBjb2Rld29yZHNSb3cgKyBcIl06IEV4cGVjdGVkIFJvdzogXCIgK1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIGV4cGVjdGVkUm93TnVtYmVyICsgXCIsIFJlYWxSb3c6IFwiICsgY29kZXdvcmQuZ2V0Um93TnVtYmVyKCkgKyBcIiwgdmFsdWU6IFwiICsgY29kZXdvcmQuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcm93RGlmZmVyZW5jZSA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpIC0gYmFyY29kZVJvdztcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGltcHJvdmUgaGFuZGxpbmcgd2l0aCBjYXNlIHdoZXJlIGZpcnN0IHJvdyBpbmRpY2F0b3IgZG9lc24ndCBzdGFydCB3aXRoIDBcbiAgICAgICAgICAgICAgICBpZiAocm93RGlmZmVyZW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um93SGVpZ2h0Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJvd0RpZmZlcmVuY2UgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4Um93SGVpZ2h0ID0gTWF0aC5tYXgobWF4Um93SGVpZ2h0LCBjdXJyZW50Um93SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvd0hlaWdodCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJhcmNvZGVSb3cgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocm93RGlmZmVyZW5jZSA8IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmQuZ2V0Um93TnVtYmVyKCkgPj0gYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCkgfHxcbiAgICAgICAgICAgICAgICAgICAgcm93RGlmZmVyZW5jZSA+IGNvZGV3b3Jkc1Jvdykge1xuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hlY2tlZFJvd3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhSb3dIZWlnaHQgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkUm93cyA9IChtYXhSb3dIZWlnaHQgLSAyKSAqIHJvd0RpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkUm93cyA9IHJvd0RpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNsb3NlUHJldmlvdXNDb2Rld29yZEZvdW5kID0gY2hlY2tlZFJvd3MgPj0gY29kZXdvcmRzUm93O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAxOyBpIDw9IGNoZWNrZWRSb3dzICYmICFjbG9zZVByZXZpb3VzQ29kZXdvcmRGb3VuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBtdXN0IGJlIChoZWlnaHQgKiByb3dEaWZmZXJlbmNlKSBudW1iZXIgb2YgY29kZXdvcmRzIG1pc3NpbmcuIEZvciBub3cgd2UgYXNzdW1lIGhlaWdodCA9IDEuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBob3BlZnVsbHkgZ2V0IHJpZCBvZiBtb3N0IHByb2JsZW1zIGFscmVhZHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZVByZXZpb3VzQ29kZXdvcmRGb3VuZCA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgLSBpXSAhPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZVByZXZpb3VzQ29kZXdvcmRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZVJvdyA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvd0hlaWdodCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gKGludCkgKGF2ZXJhZ2VSb3dIZWlnaHQgKyAwLjUpO1xuICAgICAgICB9XG4gICAgICAgIGdldFJvd0hlaWdodHMoKSB7XG4gICAgICAgICAgICBsZXQgYmFyY29kZU1ldGFkYXRhID0gdGhpcy5nZXRCYXJjb2RlTWV0YWRhdGEoKTtcbiAgICAgICAgICAgIGlmIChiYXJjb2RlTWV0YWRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGp1c3RJbmNvbXBsZXRlSW5kaWNhdG9yQ29sdW1uUm93TnVtYmVycyhiYXJjb2RlTWV0YWRhdGEpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3JkIC8qQ29kZXdvcmQqLyBvZiB0aGlzLmdldENvZGV3b3JkcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvd051bWJlciA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocm93TnVtYmVyID49IHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgbW9yZSByb3dzIHRoYW4gdGhlIGJhcmNvZGUgbWV0YWRhdGEgYWxsb3dzIGZvciwgaWdub3JlIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcm93TnVtYmVyXSsrO1xuICAgICAgICAgICAgICAgIH0gLy8gZWxzZSB0aHJvdyBleGNlcHRpb24/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gbWF5YmUgd2Ugc2hvdWxkIGFkZCBtaXNzaW5nIGNvZGV3b3JkcyB0byBzdG9yZSB0aGUgY29ycmVjdCByb3cgbnVtYmVyIHRvIG1ha2VcbiAgICAgICAgLy8gZmluZGluZyByb3cgbnVtYmVycyBmb3Igb3RoZXIgY29sdW1ucyBlYXNpZXJcbiAgICAgICAgLy8gdXNlIHJvdyBoZWlnaHQgY291bnQgdG8gbWFrZSBkZXRlY3Rpb24gb2YgaW52YWxpZCByb3cgbnVtYmVycyBtb3JlIHJlbGlhYmxlXG4gICAgICAgIGFkanVzdEluY29tcGxldGVJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzKGJhcmNvZGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgbGV0IGJvdW5kaW5nQm94ID0gdGhpcy5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMuX2lzTGVmdCA/IGJvdW5kaW5nQm94LmdldFRvcExlZnQoKSA6IGJvdW5kaW5nQm94LmdldFRvcFJpZ2h0KCk7XG4gICAgICAgICAgICBsZXQgYm90dG9tID0gdGhpcy5faXNMZWZ0ID8gYm91bmRpbmdCb3guZ2V0Qm90dG9tTGVmdCgpIDogYm91bmRpbmdCb3guZ2V0Qm90dG9tUmlnaHQoKTtcbiAgICAgICAgICAgIGxldCBmaXJzdFJvdyA9IHRoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoTWF0aC50cnVuYyh0b3AuZ2V0WSgpKSk7XG4gICAgICAgICAgICBsZXQgbGFzdFJvdyA9IHRoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoTWF0aC50cnVuYyhib3R0b20uZ2V0WSgpKSk7XG4gICAgICAgICAgICAvLyBmbG9hdCBhdmVyYWdlUm93SGVpZ2h0ID0gKGxhc3RSb3cgLSBmaXJzdFJvdykgLyAvKihmbG9hdCkqLyBiYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZHMgPSB0aGlzLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgbGV0IGJhcmNvZGVSb3cgPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3Jkc1JvdyAvKmludCovID0gZmlyc3RSb3c7IGNvZGV3b3Jkc1JvdyA8IGxhc3RSb3c7IGNvZGV3b3Jkc1JvdysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddO1xuICAgICAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlckFzUm93SW5kaWNhdG9yQ29sdW1uKCk7XG4gICAgICAgICAgICAgICAgbGV0IHJvd0RpZmZlcmVuY2UgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSAtIGJhcmNvZGVSb3c7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBpbXByb3ZlIGhhbmRsaW5nIHdpdGggY2FzZSB3aGVyZSBmaXJzdCByb3cgaW5kaWNhdG9yIGRvZXNuJ3Qgc3RhcnQgd2l0aCAwXG4gICAgICAgICAgICAgICAgaWYgKHJvd0RpZmZlcmVuY2UgPT09IDApIDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyb3dEaWZmZXJlbmNlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhcmNvZGVSb3cgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29kZXdvcmQuZ2V0Um93TnVtYmVyKCkgPj0gYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmFyY29kZVJvdyA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiAoaW50KSAoYXZlcmFnZVJvd0hlaWdodCArIDAuNSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QmFyY29kZU1ldGFkYXRhKCkge1xuICAgICAgICAgICAgbGV0IGNvZGV3b3JkcyA9IHRoaXMuZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICBsZXQgYmFyY29kZUNvbHVtbkNvdW50ID0gbmV3IEJhcmNvZGVWYWx1ZSgpO1xuICAgICAgICAgICAgbGV0IGJhcmNvZGVSb3dDb3VudFVwcGVyUGFydCA9IG5ldyBCYXJjb2RlVmFsdWUoKTtcbiAgICAgICAgICAgIGxldCBiYXJjb2RlUm93Q291bnRMb3dlclBhcnQgPSBuZXcgQmFyY29kZVZhbHVlKCk7XG4gICAgICAgICAgICBsZXQgYmFyY29kZUVDTGV2ZWwgPSBuZXcgQmFyY29kZVZhbHVlKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2Rld29yZCAvKkNvZGV3b3JkKi8gb2YgY29kZXdvcmRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlckFzUm93SW5kaWNhdG9yQ29sdW1uKCk7XG4gICAgICAgICAgICAgICAgbGV0IHJvd0luZGljYXRvclZhbHVlID0gY29kZXdvcmQuZ2V0VmFsdWUoKSAlIDMwO1xuICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZFJvd051bWJlciA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3JkUm93TnVtYmVyICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZXdvcmRSb3dOdW1iZXIgJSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVSb3dDb3VudFVwcGVyUGFydC5zZXRWYWx1ZShyb3dJbmRpY2F0b3JWYWx1ZSAqIDMgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2RlRUNMZXZlbC5zZXRWYWx1ZShyb3dJbmRpY2F0b3JWYWx1ZSAvIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZVJvd0NvdW50TG93ZXJQYXJ0LnNldFZhbHVlKHJvd0luZGljYXRvclZhbHVlICUgMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZUNvbHVtbkNvdW50LnNldFZhbHVlKHJvd0luZGljYXRvclZhbHVlICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYXliZSB3ZSBzaG91bGQgY2hlY2sgaWYgd2UgaGF2ZSBhbWJpZ3VvdXMgdmFsdWVzP1xuICAgICAgICAgICAgaWYgKChiYXJjb2RlQ29sdW1uQ291bnQuZ2V0VmFsdWUoKS5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICAgICAgICAgKGJhcmNvZGVSb3dDb3VudFVwcGVyUGFydC5nZXRWYWx1ZSgpLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgICAgICAgICAoYmFyY29kZVJvd0NvdW50TG93ZXJQYXJ0LmdldFZhbHVlKCkubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAgICAgICAgIChiYXJjb2RlRUNMZXZlbC5nZXRWYWx1ZSgpLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgICAgICAgICBiYXJjb2RlQ29sdW1uQ291bnQuZ2V0VmFsdWUoKVswXSA8IDEgfHxcbiAgICAgICAgICAgICAgICBiYXJjb2RlUm93Q291bnRVcHBlclBhcnQuZ2V0VmFsdWUoKVswXSArIGJhcmNvZGVSb3dDb3VudExvd2VyUGFydC5nZXRWYWx1ZSgpWzBdIDwgUERGNDE3Q29tbW9uLk1JTl9ST1dTX0lOX0JBUkNPREUgfHxcbiAgICAgICAgICAgICAgICBiYXJjb2RlUm93Q291bnRVcHBlclBhcnQuZ2V0VmFsdWUoKVswXSArIGJhcmNvZGVSb3dDb3VudExvd2VyUGFydC5nZXRWYWx1ZSgpWzBdID4gUERGNDE3Q29tbW9uLk1BWF9ST1dTX0lOX0JBUkNPREUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBiYXJjb2RlTWV0YWRhdGEgPSBuZXcgQmFyY29kZU1ldGFkYXRhKGJhcmNvZGVDb2x1bW5Db3VudC5nZXRWYWx1ZSgpWzBdLCBiYXJjb2RlUm93Q291bnRVcHBlclBhcnQuZ2V0VmFsdWUoKVswXSwgYmFyY29kZVJvd0NvdW50TG93ZXJQYXJ0LmdldFZhbHVlKClbMF0sIGJhcmNvZGVFQ0xldmVsLmdldFZhbHVlKClbMF0pO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVJbmNvcnJlY3RDb2Rld29yZHMoY29kZXdvcmRzLCBiYXJjb2RlTWV0YWRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGJhcmNvZGVNZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVJbmNvcnJlY3RDb2Rld29yZHMoY29kZXdvcmRzLCBiYXJjb2RlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjb2Rld29yZHMgd2hpY2ggZG8gbm90IG1hdGNoIHRoZSBtZXRhZGF0YVxuICAgICAgICAgICAgLy8gVE9ETyBNYXliZSB3ZSBzaG91bGQga2VlcCB0aGUgaW5jb3JyZWN0IGNvZGV3b3JkcyBmb3IgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zP1xuICAgICAgICAgICAgZm9yIChsZXQgY29kZXdvcmRSb3cgLyppbnQqLyA9IDA7IGNvZGV3b3JkUm93IDwgY29kZXdvcmRzLmxlbmd0aDsgY29kZXdvcmRSb3crKykge1xuICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IGNvZGV3b3Jkc1tjb2Rld29yZFJvd107XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2Rld29yZFJvd10gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJvd0luZGljYXRvclZhbHVlID0gY29kZXdvcmQuZ2V0VmFsdWUoKSAlIDMwO1xuICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZFJvd051bWJlciA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZFJvd051bWJlciA+IGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZFJvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0xlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRSb3dOdW1iZXIgKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2Rld29yZFJvd051bWJlciAlIDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0luZGljYXRvclZhbHVlICogMyArIDEgIT09IGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudFVwcGVyUGFydCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzW2NvZGV3b3JkUm93XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGgudHJ1bmMocm93SW5kaWNhdG9yVmFsdWUgLyAzKSAhPT0gYmFyY29kZU1ldGFkYXRhLmdldEVycm9yQ29ycmVjdGlvbkxldmVsKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRpY2F0b3JWYWx1ZSAlIDMgIT09IGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudExvd2VyUGFydCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzW2NvZGV3b3JkUm93XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0luZGljYXRvclZhbHVlICsgMSAhPT0gYmFyY29kZU1ldGFkYXRhLmdldENvbHVtbkNvdW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRSb3ddID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc0xlZnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnSXNMZWZ0OiAnICsgdGhpcy5faXNMZWZ0ICsgJ1xcbicgKyBzdXBlci50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKmZpbmFsKi8gY2xhc3MgRGV0ZWN0aW9uUmVzdWx0IHtcbiAgICAgICAgY29uc3RydWN0b3IoYmFyY29kZU1ldGFkYXRhLCBib3VuZGluZ0JveCkge1xuICAgICAgICAgICAgLypmaW5hbCovIHRoaXMuQURKVVNUX1JPV19OVU1CRVJfU0tJUCA9IDI7XG4gICAgICAgICAgICB0aGlzLmJhcmNvZGVNZXRhZGF0YSA9IGJhcmNvZGVNZXRhZGF0YTtcbiAgICAgICAgICAgIHRoaXMuYmFyY29kZUNvbHVtbkNvdW50ID0gYmFyY29kZU1ldGFkYXRhLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XG4gICAgICAgICAgICAvLyB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnMgPSBuZXcgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMl07XG4gICAgICAgICAgICB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnMgPSBuZXcgQXJyYXkodGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBnZXREZXRlY3Rpb25SZXN1bHRDb2x1bW5zKCkge1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzKHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1swXSk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdEluZGljYXRvckNvbHVtblJvd051bWJlcnModGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMV0pO1xuICAgICAgICAgICAgbGV0IHVuYWRqdXN0ZWRDb2Rld29yZENvdW50ID0gUERGNDE3Q29tbW9uLk1BWF9DT0RFV09SRFNfSU5fQkFSQ09ERTtcbiAgICAgICAgICAgIGxldCBwcmV2aW91c1VuYWRqdXN0ZWRDb3VudDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1VuYWRqdXN0ZWRDb3VudCA9IHVuYWRqdXN0ZWRDb2Rld29yZENvdW50O1xuICAgICAgICAgICAgICAgIHVuYWRqdXN0ZWRDb2Rld29yZENvdW50ID0gdGhpcy5hZGp1c3RSb3dOdW1iZXJzQW5kR2V0Q291bnQoKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHVuYWRqdXN0ZWRDb2Rld29yZENvdW50ID4gMCAmJiB1bmFkanVzdGVkQ29kZXdvcmRDb3VudCA8IHByZXZpb3VzVW5hZGp1c3RlZENvdW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnM7XG4gICAgICAgIH1cbiAgICAgICAgYWRqdXN0SW5kaWNhdG9yQ29sdW1uUm93TnVtYmVycyhkZXRlY3Rpb25SZXN1bHRDb2x1bW4pIHtcbiAgICAgICAgICAgIGlmIChkZXRlY3Rpb25SZXN1bHRDb2x1bW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdENvbHVtblxuICAgICAgICAgICAgICAgICAgICAuYWRqdXN0Q29tcGxldGVJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzKHRoaXMuYmFyY29kZU1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIGVuc3VyZSB0aGF0IG5vIGRldGVjdGVkIGNvZGV3b3JkcyB3aXRoIHVua25vd24gcm93IG51bWJlciBhcmUgbGVmdFxuICAgICAgICAvLyB3ZSBzaG91bGQgYmUgYWJsZSB0byBlc3RpbWF0ZSB0aGUgcm93IGhlaWdodCBhbmQgdXNlIGl0IGFzIGEgaGludCBmb3IgdGhlIHJvdyBudW1iZXJcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGFsc28gZmlsbCB0aGUgcm93cyB0b3AgdG8gYm90dG9tIGFuZCBib3R0b20gdG8gdG9wXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBjb2Rld29yZHMgd2hpY2ggZG9uJ3QgaGF2ZSBhIHZhbGlkIHJvdyBudW1iZXIuIE5vdGUgdGhhdCB0aGUgY291bnQgaXMgbm90IGFjY3VyYXRlIGFzIGNvZGV3b3Jkc1xuICAgICAgICAgKiB3aWxsIGJlIGNvdW50ZWQgc2V2ZXJhbCB0aW1lcy4gSXQganVzdCBzZXJ2ZXMgYXMgYW4gaW5kaWNhdG9yIHRvIHNlZSB3aGVuIHdlIGNhbiBzdG9wIGFkanVzdGluZyByb3cgbnVtYmVyc1xuICAgICAgICAgKi9cbiAgICAgICAgYWRqdXN0Um93TnVtYmVyc0FuZEdldENvdW50KCkge1xuICAgICAgICAgICAgbGV0IHVuYWRqdXN0ZWRDb3VudCA9IHRoaXMuYWRqdXN0Um93TnVtYmVyc0J5Um93KCk7XG4gICAgICAgICAgICBpZiAodW5hZGp1c3RlZENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBiYXJjb2RlQ29sdW1uIC8qaW50Ki8gPSAxOyBiYXJjb2RlQ29sdW1uIDwgdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxOyBiYXJjb2RlQ29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmRzID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3Jkc1JvdyAvKmludCovID0gMDsgY29kZXdvcmRzUm93IDwgY29kZXdvcmRzLmxlbmd0aDsgY29kZXdvcmRzUm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10uaGFzVmFsaWRSb3dOdW1iZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RSb3dOdW1iZXJzKGJhcmNvZGVDb2x1bW4sIGNvZGV3b3Jkc1JvdywgY29kZXdvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmFkanVzdGVkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgYWRqdXN0Um93TnVtYmVyc0J5Um93KCkge1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RSb3dOdW1iZXJzRnJvbUJvdGhSSSgpO1xuICAgICAgICAgICAgLy8gVE9ETyB3ZSBzaG91bGQgb25seSBkbyBmdWxsIHJvdyBhZGp1c3RtZW50cyBpZiByb3cgbnVtYmVycyBvZiBsZWZ0IGFuZCByaWdodCByb3cgaW5kaWNhdG9yIGNvbHVtbiBtYXRjaC5cbiAgICAgICAgICAgIC8vIE1heWJlIGl0J3MgZXZlbiBiZXR0ZXIgdG8gY2FsY3VsYXRlZCB0aGUgaGVpZ2h0IChyb3dzOiBkKSBhbmQgZGl2aWRlIGl0IGJ5IHRoZSBudW1iZXIgb2YgYmFyY29kZVxuICAgICAgICAgICAgLy8gcm93cy4gVGhpcywgdG9nZXRoZXIgd2l0aCB0aGUgTFJJIGFuZCBSUkkgcm93IG51bWJlcnMgc2hvdWxkIGFsbG93IHVzIHRvIGdldCBhIGdvb2QgZXN0aW1hdGUgd2hlcmUgYSByb3dcbiAgICAgICAgICAgIC8vIG51bWJlciBzdGFydHMgYW5kIGVuZHMuXG4gICAgICAgICAgICBsZXQgdW5hZGp1c3RlZENvdW50ID0gdGhpcy5hZGp1c3RSb3dOdW1iZXJzRnJvbUxSSSgpO1xuICAgICAgICAgICAgcmV0dXJuIHVuYWRqdXN0ZWRDb3VudCArIHRoaXMuYWRqdXN0Um93TnVtYmVyc0Zyb21SUkkoKTtcbiAgICAgICAgfVxuICAgICAgICBhZGp1c3RSb3dOdW1iZXJzRnJvbUJvdGhSSSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbMF0gPT0gbnVsbCB8fCB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IExSSWNvZGV3b3JkcyA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1swXS5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIGxldCBSUkljb2Rld29yZHMgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxXS5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3Jkc1JvdyAvKmludCovID0gMDsgY29kZXdvcmRzUm93IDwgTFJJY29kZXdvcmRzLmxlbmd0aDsgY29kZXdvcmRzUm93KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoTFJJY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBSUkljb2Rld29yZHNbY29kZXdvcmRzUm93XSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIExSSWNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddLmdldFJvd051bWJlcigpID09PSBSUkljb2Rld29yZHNbY29kZXdvcmRzUm93XS5nZXRSb3dOdW1iZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBiYXJjb2RlQ29sdW1uIC8qaW50Ki8gPSAxOyBiYXJjb2RlQ29sdW1uIDw9IHRoaXMuYmFyY29kZUNvbHVtbkNvdW50OyBiYXJjb2RlQ29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uXS5nZXRDb2Rld29yZHMoKVtjb2Rld29yZHNSb3ddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlcihMUkljb2Rld29yZHNbY29kZXdvcmRzUm93XS5nZXRSb3dOdW1iZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvZGV3b3JkLmhhc1ZhbGlkUm93TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0uZ2V0Q29kZXdvcmRzKClbY29kZXdvcmRzUm93XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRqdXN0Um93TnVtYmVyc0Zyb21SUkkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHVuYWRqdXN0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgY29kZXdvcmRzID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMV0uZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2Rld29yZHNSb3cgLyppbnQqLyA9IDA7IGNvZGV3b3Jkc1JvdyA8IGNvZGV3b3Jkcy5sZW5ndGg7IGNvZGV3b3Jkc1JvdysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByb3dJbmRpY2F0b3JSb3dOdW1iZXIgPSBjb2Rld29yZHNbY29kZXdvcmRzUm93XS5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBsZXQgaW52YWxpZFJvd0NvdW50cyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYmFyY29kZUNvbHVtbiAvKmludCovID0gdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxOyBiYXJjb2RlQ29sdW1uID4gMCAmJiBpbnZhbGlkUm93Q291bnRzIDwgdGhpcy5BREpVU1RfUk9XX05VTUJFUl9TS0lQOyBiYXJjb2RlQ29sdW1uLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dLmdldENvZGV3b3JkcygpW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkUm93Q291bnRzID0gRGV0ZWN0aW9uUmVzdWx0LmFkanVzdFJvd051bWJlcklmVmFsaWQocm93SW5kaWNhdG9yUm93TnVtYmVyLCBpbnZhbGlkUm93Q291bnRzLCBjb2Rld29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvZGV3b3JkLmhhc1ZhbGlkUm93TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmFkanVzdGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmFkanVzdGVkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgYWRqdXN0Um93TnVtYmVyc0Zyb21MUkkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zWzBdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB1bmFkanVzdGVkQ291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IGNvZGV3b3JkcyA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1swXS5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3Jkc1JvdyAvKmludCovID0gMDsgY29kZXdvcmRzUm93IDwgY29kZXdvcmRzLmxlbmd0aDsgY29kZXdvcmRzUm93KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJvd0luZGljYXRvclJvd051bWJlciA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgIGxldCBpbnZhbGlkUm93Q291bnRzID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiYXJjb2RlQ29sdW1uIC8qaW50Ki8gPSAxOyBiYXJjb2RlQ29sdW1uIDwgdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxICYmIGludmFsaWRSb3dDb3VudHMgPCB0aGlzLkFESlVTVF9ST1dfTlVNQkVSX1NLSVA7IGJhcmNvZGVDb2x1bW4rKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmQgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0uZ2V0Q29kZXdvcmRzKClbY29kZXdvcmRzUm93XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRSb3dDb3VudHMgPSBEZXRlY3Rpb25SZXN1bHQuYWRqdXN0Um93TnVtYmVySWZWYWxpZChyb3dJbmRpY2F0b3JSb3dOdW1iZXIsIGludmFsaWRSb3dDb3VudHMsIGNvZGV3b3JkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29kZXdvcmQuaGFzVmFsaWRSb3dOdW1iZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuYWRqdXN0ZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuYWRqdXN0ZWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYWRqdXN0Um93TnVtYmVySWZWYWxpZChyb3dJbmRpY2F0b3JSb3dOdW1iZXIsIGludmFsaWRSb3dDb3VudHMsIGNvZGV3b3JkKSB7XG4gICAgICAgICAgICBpZiAoY29kZXdvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnZhbGlkUm93Q291bnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb2Rld29yZC5oYXNWYWxpZFJvd051bWJlcigpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkLmlzVmFsaWRSb3dOdW1iZXIocm93SW5kaWNhdG9yUm93TnVtYmVyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZC5zZXRSb3dOdW1iZXIocm93SW5kaWNhdG9yUm93TnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFJvd0NvdW50cyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICArK2ludmFsaWRSb3dDb3VudHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGludmFsaWRSb3dDb3VudHM7XG4gICAgICAgIH1cbiAgICAgICAgYWRqdXN0Um93TnVtYmVycyhiYXJjb2RlQ29sdW1uLCBjb2Rld29yZHNSb3csIGNvZGV3b3Jkcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbiAtIDFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNDb2x1bW5Db2Rld29yZHMgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbiAtIDFdLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgbGV0IG5leHRDb2x1bW5Db2Rld29yZHMgPSBwcmV2aW91c0NvbHVtbkNvZGV3b3JkcztcbiAgICAgICAgICAgIGlmICh0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbiArIDFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29sdW1uQ29kZXdvcmRzID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW4gKyAxXS5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxldCBvdGhlckNvZGV3b3JkczogQ29kZXdvcmRbXSA9IG5ldyBDb2Rld29yZFsxNF07XG4gICAgICAgICAgICBsZXQgb3RoZXJDb2Rld29yZHMgPSBuZXcgQXJyYXkoMTQpO1xuICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbMl0gPSBwcmV2aW91c0NvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddO1xuICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbM10gPSBuZXh0Q29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgICAgICBpZiAoY29kZXdvcmRzUm93ID4gMCkge1xuICAgICAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzBdID0gY29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIDFdO1xuICAgICAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzRdID0gcHJldmlvdXNDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93IC0gMV07XG4gICAgICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbNV0gPSBuZXh0Q29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1JvdyA+IDEpIHtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s4XSA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgLSAyXTtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1sxMF0gPSBwcmV2aW91c0NvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgLSAyXTtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1sxMV0gPSBuZXh0Q29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1JvdyA8IGNvZGV3b3Jkcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbMV0gPSBjb2Rld29yZHNbY29kZXdvcmRzUm93ICsgMV07XG4gICAgICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbNl0gPSBwcmV2aW91c0NvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgKyAxXTtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s3XSA9IG5leHRDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93ICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZXdvcmRzUm93IDwgY29kZXdvcmRzLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s5XSA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgKyAyXTtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1sxMl0gPSBwcmV2aW91c0NvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgKyAyXTtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1sxM10gPSBuZXh0Q29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyArIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgb3RoZXJDb2Rld29yZCBvZiBvdGhlckNvZGV3b3Jkcykge1xuICAgICAgICAgICAgICAgIGlmIChEZXRlY3Rpb25SZXN1bHQuYWRqdXN0Um93TnVtYmVyKGNvZGV3b3JkLCBvdGhlckNvZGV3b3JkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRydWUsIGlmIHJvdyBudW1iZXIgd2FzIGFkanVzdGVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhZGp1c3RSb3dOdW1iZXIoY29kZXdvcmQsIG90aGVyQ29kZXdvcmQpIHtcbiAgICAgICAgICAgIGlmIChvdGhlckNvZGV3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXJDb2Rld29yZC5oYXNWYWxpZFJvd051bWJlcigpICYmIG90aGVyQ29kZXdvcmQuZ2V0QnVja2V0KCkgPT09IGNvZGV3b3JkLmdldEJ1Y2tldCgpKSB7XG4gICAgICAgICAgICAgICAgY29kZXdvcmQuc2V0Um93TnVtYmVyKG90aGVyQ29kZXdvcmQuZ2V0Um93TnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGdldEJhcmNvZGVDb2x1bW5Db3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhcmNvZGVDb2x1bW5Db3VudDtcbiAgICAgICAgfVxuICAgICAgICBnZXRCYXJjb2RlUm93Q291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRCYXJjb2RlRUNMZXZlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhcmNvZGVNZXRhZGF0YS5nZXRFcnJvckNvcnJlY3Rpb25MZXZlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHNldEJvdW5kaW5nQm94KGJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Qm91bmRpbmdCb3goKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3VuZGluZ0JveDtcbiAgICAgICAgfVxuICAgICAgICBzZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oYmFyY29kZUNvbHVtbiwgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uKSB7XG4gICAgICAgICAgICB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0gPSBkZXRlY3Rpb25SZXN1bHRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJhcmNvZGVDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgbGV0IHJvd0luZGljYXRvckNvbHVtbiA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1swXTtcbiAgICAgICAgICAgIGlmIChyb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJvd0luZGljYXRvckNvbHVtbiA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1t0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJ5IChcbiAgICAgICAgICAgIGxldCBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKCk7XG4gICAgICAgICAgICAvLyApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3Jkc1JvdyAvKmludCovID0gMDsgY29kZXdvcmRzUm93IDwgcm93SW5kaWNhdG9yQ29sdW1uLmdldENvZGV3b3JkcygpLmxlbmd0aDsgY29kZXdvcmRzUm93KyspIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCdDVyAlM2Q6JywgY29kZXdvcmRzUm93KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiYXJjb2RlQ29sdW1uIC8qaW50Ki8gPSAwOyBiYXJjb2RlQ29sdW1uIDwgdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAyOyBiYXJjb2RlQ29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCcgICAgfCAgICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dLmdldENvZGV3b3JkcygpW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCcgICAgfCAgICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnICUzZHwlM2QnLCBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSwgY29kZXdvcmQuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZGVjb2RlcjtcbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKmZpbmFsKi8gY2xhc3MgQ29kZXdvcmQge1xuICAgICAgICBjb25zdHJ1Y3RvcihzdGFydFgsIGVuZFgsIGJ1Y2tldCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucm93TnVtYmVyID0gQ29kZXdvcmQuQkFSQ09ERV9ST1dfVU5LTk9XTjtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRYID0gTWF0aC50cnVuYyhzdGFydFgpO1xuICAgICAgICAgICAgdGhpcy5lbmRYID0gTWF0aC50cnVuYyhlbmRYKTtcbiAgICAgICAgICAgIHRoaXMuYnVja2V0ID0gTWF0aC50cnVuYyhidWNrZXQpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IE1hdGgudHJ1bmModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGhhc1ZhbGlkUm93TnVtYmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZFJvd051bWJlcih0aGlzLnJvd051bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgaXNWYWxpZFJvd051bWJlcihyb3dOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiByb3dOdW1iZXIgIT09IENvZGV3b3JkLkJBUkNPREVfUk9XX1VOS05PV04gJiYgdGhpcy5idWNrZXQgPT09IChyb3dOdW1iZXIgJSAzKSAqIDM7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Um93TnVtYmVyQXNSb3dJbmRpY2F0b3JDb2x1bW4oKSB7XG4gICAgICAgICAgICB0aGlzLnJvd051bWJlciA9IE1hdGgudHJ1bmMoKE1hdGgudHJ1bmModGhpcy52YWx1ZSAvIDMwKSkgKiAzICsgTWF0aC50cnVuYyh0aGlzLmJ1Y2tldCAvIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZFggLSB0aGlzLnN0YXJ0WDtcbiAgICAgICAgfVxuICAgICAgICBnZXRTdGFydFgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydFg7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RW5kWCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZFg7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QnVja2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0O1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Um93TnVtYmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93TnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIHNldFJvd051bWJlcihyb3dOdW1iZXIpIHtcbiAgICAgICAgICAgIHRoaXMucm93TnVtYmVyID0gcm93TnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIC8vICAgQE92ZXJyaWRlXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93TnVtYmVyICsgJ3wnICsgdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb2Rld29yZC5CQVJDT0RFX1JPV19VTktOT1dOID0gLTE7XG5cbiAgICAvKlxuICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICpcbiAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAqXG4gICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICpcbiAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKiBAYXV0aG9yIGNyZWF0YWxlIEdtYkggKGNocmlzdG9waC5zY2h1bHpAY3JlYXRhbGUuZGUpXG4gICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIFBERjQxN0NvZGV3b3JkRGVjb2RlciB7XG4gICAgICAgIC8qIEBub3RlXG4gICAgICAgICAqIHRoaXMgYWN0aW9uIGhhdmUgdG8gYmUgcGVyZm9ybWVkIGJlZm9yZSBmaXJzdCB1c2Ugb2YgY2xhc3NcbiAgICAgICAgICogLSBzdGF0aWMgY29uc3RydWN0b3JcbiAgICAgICAgICogd29ya2luZyB3aXRoIDMyYml0IGZsb2F0IChiYXNlZCBmcm9tIEphdmEgbG9naWMpXG4gICAgICAgICovXG4gICAgICAgIHN0YXRpYyBpbml0aWFsaXplKCkge1xuICAgICAgICAgICAgLy8gUHJlLWNvbXB1dGVzIHRoZSBzeW1ib2wgcmF0aW8gdGFibGUuXG4gICAgICAgICAgICBmb3IgKCAvKmludCovbGV0IGkgPSAwOyBpIDwgUERGNDE3Q29tbW9uLlNZTUJPTF9UQUJMRS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U3ltYm9sID0gUERGNDE3Q29tbW9uLlNZTUJPTF9UQUJMRVtpXTtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEJpdCA9IGN1cnJlbnRTeW1ib2wgJiAweDE7XG4gICAgICAgICAgICAgICAgZm9yICggLyppbnQqL2xldCBqID0gMDsgaiA8IFBERjQxN0NvbW1vbi5CQVJTX0lOX01PRFVMRTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnRTeW1ib2wgJiAweDEpID09PSBjdXJyZW50Qml0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplICs9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTeW1ib2wgPj49IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEJpdCA9IGN1cnJlbnRTeW1ib2wgJiAweDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghUERGNDE3Q29kZXdvcmREZWNvZGVyLlJBVElPU19UQUJMRVtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUERGNDE3Q29kZXdvcmREZWNvZGVyLlJBVElPU19UQUJMRVtpXSA9IG5ldyBBcnJheShQREY0MTdDb21tb24uQkFSU19JTl9NT0RVTEUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5SQVRJT1NfVEFCTEVbaV1bUERGNDE3Q29tbW9uLkJBUlNfSU5fTU9EVUxFIC0gaiAtIDFdID0gTWF0aC5mcm91bmQoc2l6ZSAvIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX0NPREVXT1JEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJTeW1ib2xUYWJsZVJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0RGVjb2RlZFZhbHVlKG1vZHVsZUJpdENvdW50KSB7XG4gICAgICAgICAgICBsZXQgZGVjb2RlZFZhbHVlID0gUERGNDE3Q29kZXdvcmREZWNvZGVyLmdldERlY29kZWRDb2Rld29yZFZhbHVlKFBERjQxN0NvZGV3b3JkRGVjb2Rlci5zYW1wbGVCaXRDb3VudHMobW9kdWxlQml0Q291bnQpKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGVkVmFsdWUgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQREY0MTdDb2Rld29yZERlY29kZXIuZ2V0Q2xvc2VzdERlY29kZWRWYWx1ZShtb2R1bGVCaXRDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHNhbXBsZUJpdENvdW50cyhtb2R1bGVCaXRDb3VudCkge1xuICAgICAgICAgICAgbGV0IGJpdENvdW50U3VtID0gTWF0aFV0aWxzLnN1bShtb2R1bGVCaXRDb3VudCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkoUERGNDE3Q29tbW9uLkJBUlNfSU5fTU9EVUxFKTtcbiAgICAgICAgICAgIGxldCBiaXRDb3VudEluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBzdW1QcmV2aW91c0JpdHMgPSAwO1xuICAgICAgICAgICAgZm9yICggLyppbnQqL2xldCBpID0gMDsgaSA8IFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX0NPREVXT1JEOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc2FtcGxlSW5kZXggPSBiaXRDb3VudFN1bSAvICgyICogUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fQ09ERVdPUkQpICtcbiAgICAgICAgICAgICAgICAgICAgKGkgKiBiaXRDb3VudFN1bSkgLyBQREY0MTdDb21tb24uTU9EVUxFU19JTl9DT0RFV09SRDtcbiAgICAgICAgICAgICAgICBpZiAoc3VtUHJldmlvdXNCaXRzICsgbW9kdWxlQml0Q291bnRbYml0Q291bnRJbmRleF0gPD0gc2FtcGxlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtUHJldmlvdXNCaXRzICs9IG1vZHVsZUJpdENvdW50W2JpdENvdW50SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBiaXRDb3VudEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtiaXRDb3VudEluZGV4XSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0RGVjb2RlZENvZGV3b3JkVmFsdWUobW9kdWxlQml0Q291bnQpIHtcbiAgICAgICAgICAgIGxldCBkZWNvZGVkVmFsdWUgPSBQREY0MTdDb2Rld29yZERlY29kZXIuZ2V0Qml0VmFsdWUobW9kdWxlQml0Q291bnQpO1xuICAgICAgICAgICAgcmV0dXJuIFBERjQxN0NvbW1vbi5nZXRDb2Rld29yZChkZWNvZGVkVmFsdWUpID09PSAtMSA/IC0xIDogZGVjb2RlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRCaXRWYWx1ZShtb2R1bGVCaXRDb3VudCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IC8qbG9uZyovIDA7XG4gICAgICAgICAgICBmb3IgKGxldCAvKmludCovIGkgPSAwOyBpIDwgbW9kdWxlQml0Q291bnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKCAvKmludCovbGV0IGJpdCA9IDA7IGJpdCA8IG1vZHVsZUJpdENvdW50W2ldOyBiaXQrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDEpIHwgKGkgJSAyID09PSAwID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnRydW5jKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd29ya2luZyB3aXRoIDMyYml0IGZsb2F0IChhcyBpbiBKYXZhKVxuICAgICAgICBzdGF0aWMgZ2V0Q2xvc2VzdERlY29kZWRWYWx1ZShtb2R1bGVCaXRDb3VudCkge1xuICAgICAgICAgICAgbGV0IGJpdENvdW50U3VtID0gTWF0aFV0aWxzLnN1bShtb2R1bGVCaXRDb3VudCk7XG4gICAgICAgICAgICBsZXQgYml0Q291bnRSYXRpb3MgPSBuZXcgQXJyYXkoUERGNDE3Q29tbW9uLkJBUlNfSU5fTU9EVUxFKTtcbiAgICAgICAgICAgIGlmIChiaXRDb3VudFN1bSA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCAvKmludCovIGkgPSAwOyBpIDwgYml0Q291bnRSYXRpb3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYml0Q291bnRSYXRpb3NbaV0gPSBNYXRoLmZyb3VuZChtb2R1bGVCaXRDb3VudFtpXSAvIGJpdENvdW50U3VtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYmVzdE1hdGNoRXJyb3IgPSBGbG9hdC5NQVhfVkFMVUU7XG4gICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gLTE7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYlN5bWJvbFRhYmxlUmVhZHkpIHtcbiAgICAgICAgICAgICAgICBQREY0MTdDb2Rld29yZERlY29kZXIuaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICggLyppbnQqL2xldCBqID0gMDsgaiA8IFBERjQxN0NvZGV3b3JkRGVjb2Rlci5SQVRJT1NfVEFCTEUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3IgPSAwLjA7XG4gICAgICAgICAgICAgICAgbGV0IHJhdGlvVGFibGVSb3cgPSBQREY0MTdDb2Rld29yZERlY29kZXIuUkFUSU9TX1RBQkxFW2pdO1xuICAgICAgICAgICAgICAgIGZvciAoIC8qaW50Ki9sZXQgayA9IDA7IGsgPCBQREY0MTdDb21tb24uQkFSU19JTl9NT0RVTEU7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGlmZiA9IE1hdGguZnJvdW5kKHJhdGlvVGFibGVSb3dba10gLSBiaXRDb3VudFJhdGlvc1trXSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yICs9IE1hdGguZnJvdW5kKGRpZmYgKiBkaWZmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yID49IGJlc3RNYXRjaEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2hFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2hFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSBQREY0MTdDb21tb24uU1lNQk9MX1RBQkxFW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZmxhZyB0aGF0IHRoZSB0YWJsZSBpcyByZWFkeSBmb3IgdXNlXG4gICAgUERGNDE3Q29kZXdvcmREZWNvZGVyLmJTeW1ib2xUYWJsZVJlYWR5ID0gZmFsc2U7XG4gICAgUERGNDE3Q29kZXdvcmREZWNvZGVyLlJBVElPU19UQUJMRSA9IG5ldyBBcnJheShQREY0MTdDb21tb24uU1lNQk9MX1RBQkxFLmxlbmd0aCkubWFwKHggPT4geCA9IG5ldyBBcnJheShQREY0MTdDb21tb24uQkFSU19JTl9NT0RVTEUpKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNztcbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKnB1YmxpYyBmaW5hbCovIGNsYXNzIFBERjQxN1Jlc3VsdE1ldGFkYXRhIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLnNlZ21lbnRDb3VudCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5maWxlU2l6ZSA9IC0xO1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tzdW0gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFNlZ21lbnQgSUQgcmVwcmVzZW50cyB0aGUgc2VnbWVudCBvZiB0aGUgd2hvbGUgZmlsZSBkaXN0cmlidXRlZCBvdmVyIGRpZmZlcmVudCBzeW1ib2xzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIEZpbGUgc2VnbWVudCBpbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VnbWVudEluZGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHNldFNlZ21lbnRJbmRleChzZWdtZW50SW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudEluZGV4ID0gc2VnbWVudEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgc2FtZSBmb3IgZWFjaCByZWxhdGVkIFBERjQxNyBzeW1ib2xcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBGaWxlIElEXG4gICAgICAgICAqL1xuICAgICAgICBnZXRGaWxlSWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RmlsZUlkKGZpbGVJZCkge1xuICAgICAgICAgICAgdGhpcy5maWxlSWQgPSBmaWxlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gYWx3YXlzIG51bGxcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgdXNlIGRlZGljYXRlZCBhbHJlYWR5IHBhcnNlZCBmaWVsZHNcbiAgICAgICAgICovXG4gICAgICAgIC8vICAgQERlcHJlY2F0ZWRcbiAgICAgICAgZ2V0T3B0aW9uYWxEYXRhKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uYWxEYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gb3B0aW9uYWxEYXRhIG9sZCBvcHRpb25hbCBkYXRhIGZvcm1hdCBhcyBpbnQgYXJyYXlcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgcGFyc2UgYW5kIHVzZSBuZXcgZmllbGRzXG4gICAgICAgICAqL1xuICAgICAgICAvLyAgIEBEZXByZWNhdGVkXG4gICAgICAgIHNldE9wdGlvbmFsRGF0YShvcHRpb25hbERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uYWxEYXRhID0gb3B0aW9uYWxEYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgaXQgaXMgdGhlIGxhc3Qgc2VnbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgaXNMYXN0U2VnbWVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3RTZWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIHNldExhc3RTZWdtZW50KGxhc3RTZWdtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RTZWdtZW50ID0gbGFzdFNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gY291bnQgb2Ygc2VnbWVudHMsIC0xIGlmIG5vdCBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGdldFNlZ21lbnRDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBzZXRTZWdtZW50Q291bnQoc2VnbWVudENvdW50IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudENvdW50ID0gc2VnbWVudENvdW50O1xuICAgICAgICB9XG4gICAgICAgIGdldFNlbmRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRlciB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHNldFNlbmRlcihzZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xuICAgICAgICB9XG4gICAgICAgIGdldEFkZHJlc3NlZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZHJlc3NlZSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHNldEFkZHJlc3NlZShhZGRyZXNzZWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzc2VlID0gYWRkcmVzc2VlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWxlbmFtZSBvZiB0aGUgZW5jb2RlZCBmaWxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gZmlsZW5hbWVcbiAgICAgICAgICovXG4gICAgICAgIGdldEZpbGVOYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RmlsZU5hbWUoZmlsZU5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZU5hbWUgPSBmaWxlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogZmlsZXNpemUgaW4gYnl0ZXMgb2YgdGhlIGVuY29kZWQgZmlsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIGZpbGVzaXplIGluIGJ5dGVzLCAtMSBpZiBub3Qgc2V0XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGaWxlU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIHNldEZpbGVTaXplKGZpbGVTaXplIC8qbG9uZyovKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVTaXplID0gZmlsZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDE2LWJpdCBDUkMgY2hlY2tzdW0gdXNpbmcgQ0NJVFQtMTZcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBjcmMgY2hlY2tzdW0sIC0xIGlmIG5vdCBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGdldENoZWNrc3VtKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tzdW07XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q2hlY2tzdW0oY2hlY2tzdW0gLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy5jaGVja3N1bSA9IGNoZWNrc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1bml4IGVwb2NrIHRpbWVzdGFtcCwgZWxhcHNlZCBzZWNvbmRzIHNpbmNlIDE5NzAtMDEtMDFcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBlbGFwc2VkIHNlY29uZHMsIC0xIGlmIG5vdCBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGdldFRpbWVzdGFtcCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lc3RhbXAodGltZXN0YW1wIC8qbG9uZyovKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbnlmaWxsIGZvciBKYXZhJ3MgTG9uZyBjbGFzcy5cbiAgICAgKi9cbiAgICBjbGFzcyBMb25nIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhIHN0cmluZyB0byBhIG51bWJlciwgc2luY2UgSlMgaGFzIG5vIHJlYWxseSBJbnQ2NC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG51bSBOdW1lcmljIHN0cmluZy5cbiAgICAgICAgICogQHBhcmFtIHJhZGl4IERlc3RpbmF0aW9uIHJhZGl4LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHBhcnNlTG9uZyhudW0sIHJhZGl4ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLCByYWRpeCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgTnVsbFBvaW50ZXJFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIH1cbiAgICBOdWxsUG9pbnRlckV4Y2VwdGlvbi5raW5kID0gJ051bGxQb2ludGVyRXhjZXB0aW9uJztcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IChjKSAxOTk0LCAyMDA0LCBPcmFjbGUgYW5kL29yIGl0cyBhZmZpbGlhdGVzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICAgICAqIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi5cbiAgICAgKlxuICAgICAqIFRoaXMgY29kZSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXNcbiAgICAgKiBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbi4gIE9yYWNsZSBkZXNpZ25hdGVzIHRoaXNcbiAgICAgKiBwYXJ0aWN1bGFyIGZpbGUgYXMgc3ViamVjdCB0byB0aGUgXCJDbGFzc3BhdGhcIiBleGNlcHRpb24gYXMgcHJvdmlkZWRcbiAgICAgKiBieSBPcmFjbGUgaW4gdGhlIExJQ0VOU0UgZmlsZSB0aGF0IGFjY29tcGFuaWVkIHRoaXMgY29kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgY29kZSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgICAqIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWSBvclxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgICAqIHZlcnNpb24gMiBmb3IgbW9yZSBkZXRhaWxzIChhIGNvcHkgaXMgaW5jbHVkZWQgaW4gdGhlIExJQ0VOU0UgZmlsZSB0aGF0XG4gICAgICogYWNjb21wYW5pZWQgdGhpcyBjb2RlKS5cbiAgICAgKlxuICAgICAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb25cbiAgICAgKiAyIGFsb25nIHdpdGggdGhpcyB3b3JrOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sXG4gICAgICogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLlxuICAgICAqXG4gICAgICogUGxlYXNlIGNvbnRhY3QgT3JhY2xlLCA1MDAgT3JhY2xlIFBhcmt3YXksIFJlZHdvb2QgU2hvcmVzLCBDQSA5NDA2NSBVU0FcbiAgICAgKiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55XG4gICAgICogcXVlc3Rpb25zLlxuICAgICAqL1xuICAgIC8vIHBhY2thZ2UgamF2YS5pbztcbiAgICAvKipcbiAgICAgKiBUaGlzIGFic3RyYWN0IGNsYXNzIGlzIHRoZSBzdXBlcmNsYXNzIG9mIGFsbCBjbGFzc2VzIHJlcHJlc2VudGluZ1xuICAgICAqIGFuIG91dHB1dCBzdHJlYW0gb2YgYnl0ZXMuIEFuIG91dHB1dCBzdHJlYW0gYWNjZXB0cyBvdXRwdXQgYnl0ZXNcbiAgICAgKiBhbmQgc2VuZHMgdGhlbSB0byBzb21lIHNpbmsuXG4gICAgICogPHA+XG4gICAgICogQXBwbGljYXRpb25zIHRoYXQgbmVlZCB0byBkZWZpbmUgYSBzdWJjbGFzcyBvZlxuICAgICAqIDxjb2RlPk91dHB1dFN0cmVhbTwvY29kZT4gbXVzdCBhbHdheXMgcHJvdmlkZSBhdCBsZWFzdCBhIG1ldGhvZFxuICAgICAqIHRoYXQgd3JpdGVzIG9uZSBieXRlIG9mIG91dHB1dC5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgIEFydGh1ciB2YW4gSG9mZlxuICAgICAqIEBzZWUgICAgIGphdmEuaW8uQnVmZmVyZWRPdXRwdXRTdHJlYW1cbiAgICAgKiBAc2VlICAgICBqYXZhLmlvLkJ5dGVBcnJheU91dHB1dFN0cmVhbVxuICAgICAqIEBzZWUgICAgIGphdmEuaW8uRGF0YU91dHB1dFN0cmVhbVxuICAgICAqIEBzZWUgICAgIGphdmEuaW8uRmlsdGVyT3V0cHV0U3RyZWFtXG4gICAgICogQHNlZSAgICAgamF2YS5pby5JbnB1dFN0cmVhbVxuICAgICAqIEBzZWUgICAgIGphdmEuaW8uT3V0cHV0U3RyZWFtI3dyaXRlKGludClcbiAgICAgKiBAc2luY2UgICBKREsxLjBcbiAgICAgKi9cbiAgICAvKnB1YmxpYyovIGNsYXNzIE91dHB1dFN0cmVhbSAvKmltcGxlbWVudHMgQ2xvc2VhYmxlLCBGbHVzaGFibGUqLyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgPGNvZGU+Yi5sZW5ndGg8L2NvZGU+IGJ5dGVzIGZyb20gdGhlIHNwZWNpZmllZCBieXRlIGFycmF5XG4gICAgICAgICAqIHRvIHRoaXMgb3V0cHV0IHN0cmVhbS4gVGhlIGdlbmVyYWwgY29udHJhY3QgZm9yIDxjb2RlPndyaXRlKGIpPC9jb2RlPlxuICAgICAgICAgKiBpcyB0aGF0IGl0IHNob3VsZCBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWZmZWN0IGFzIHRoZSBjYWxsXG4gICAgICAgICAqIDxjb2RlPndyaXRlKGIsIDAsIGIubGVuZ3RoKTwvY29kZT4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgICAgIGIgICB0aGUgZGF0YS5cbiAgICAgICAgICogQGV4Y2VwdGlvbiAgSU9FeGNlcHRpb24gIGlmIGFuIEkvTyBlcnJvciBvY2N1cnMuXG4gICAgICAgICAqIEBzZWUgICAgICAgIGphdmEuaW8uT3V0cHV0U3RyZWFtI3dyaXRlKGJ5dGVbXSwgaW50LCBpbnQpXG4gICAgICAgICAqL1xuICAgICAgICB3cml0ZUJ5dGVzKGIpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlc09mZnNldChiLCAwLCBiLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyA8Y29kZT5sZW48L2NvZGU+IGJ5dGVzIGZyb20gdGhlIHNwZWNpZmllZCBieXRlIGFycmF5XG4gICAgICAgICAqIHN0YXJ0aW5nIGF0IG9mZnNldCA8Y29kZT5vZmY8L2NvZGU+IHRvIHRoaXMgb3V0cHV0IHN0cmVhbS5cbiAgICAgICAgICogVGhlIGdlbmVyYWwgY29udHJhY3QgZm9yIDxjb2RlPndyaXRlKGIsIG9mZiwgbGVuKTwvY29kZT4gaXMgdGhhdFxuICAgICAgICAgKiBzb21lIG9mIHRoZSBieXRlcyBpbiB0aGUgYXJyYXkgPGNvZGU+YjwvY29kZT4gYXJlIHdyaXR0ZW4gdG8gdGhlXG4gICAgICAgICAqIG91dHB1dCBzdHJlYW0gaW4gb3JkZXI7IGVsZW1lbnQgPGNvZGU+YltvZmZdPC9jb2RlPiBpcyB0aGUgZmlyc3RcbiAgICAgICAgICogYnl0ZSB3cml0dGVuIGFuZCA8Y29kZT5iW29mZitsZW4tMV08L2NvZGU+IGlzIHRoZSBsYXN0IGJ5dGUgd3JpdHRlblxuICAgICAgICAgKiBieSB0aGlzIG9wZXJhdGlvbi5cbiAgICAgICAgICogPHA+XG4gICAgICAgICAqIFRoZSA8Y29kZT53cml0ZTwvY29kZT4gbWV0aG9kIG9mIDxjb2RlPk91dHB1dFN0cmVhbTwvY29kZT4gY2FsbHNcbiAgICAgICAgICogdGhlIHdyaXRlIG1ldGhvZCBvZiBvbmUgYXJndW1lbnQgb24gZWFjaCBvZiB0aGUgYnl0ZXMgdG8gYmVcbiAgICAgICAgICogd3JpdHRlbiBvdXQuIFN1YmNsYXNzZXMgYXJlIGVuY291cmFnZWQgdG8gb3ZlcnJpZGUgdGhpcyBtZXRob2QgYW5kXG4gICAgICAgICAqIHByb3ZpZGUgYSBtb3JlIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICogPHA+XG4gICAgICAgICAqIElmIDxjb2RlPmI8L2NvZGU+IGlzIDxjb2RlPm51bGw8L2NvZGU+LCBhXG4gICAgICAgICAqIDxjb2RlPk51bGxQb2ludGVyRXhjZXB0aW9uPC9jb2RlPiBpcyB0aHJvd24uXG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKiBJZiA8Y29kZT5vZmY8L2NvZGU+IGlzIG5lZ2F0aXZlLCBvciA8Y29kZT5sZW48L2NvZGU+IGlzIG5lZ2F0aXZlLCBvclxuICAgICAgICAgKiA8Y29kZT5vZmYrbGVuPC9jb2RlPiBpcyBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXlcbiAgICAgICAgICogPGNvZGU+YjwvY29kZT4sIHRoZW4gYW4gPHR0PkluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb248L3R0PiBpcyB0aHJvd24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgICAgIGIgICAgIHRoZSBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gICAgICBvZmYgICB0aGUgc3RhcnQgb2Zmc2V0IGluIHRoZSBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gICAgICBsZW4gICB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLlxuICAgICAgICAgKiBAZXhjZXB0aW9uICBJT0V4Y2VwdGlvbiAgaWYgYW4gSS9PIGVycm9yIG9jY3Vycy4gSW4gcGFydGljdWxhcixcbiAgICAgICAgICogICAgICAgICAgICAgYW4gPGNvZGU+SU9FeGNlcHRpb248L2NvZGU+IGlzIHRocm93biBpZiB0aGUgb3V0cHV0XG4gICAgICAgICAqICAgICAgICAgICAgIHN0cmVhbSBpcyBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB3cml0ZUJ5dGVzT2Zmc2V0KGIsIG9mZiwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE51bGxQb2ludGVyRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgob2ZmIDwgMCkgfHwgKG9mZiA+IGIubGVuZ3RoKSB8fCAobGVuIDwgMCkgfHxcbiAgICAgICAgICAgICAgICAoKG9mZiArIGxlbikgPiBiLmxlbmd0aCkgfHwgKChvZmYgKyBsZW4pIDwgMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGUoYltvZmYgKyBpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsdXNoZXMgdGhpcyBvdXRwdXQgc3RyZWFtIGFuZCBmb3JjZXMgYW55IGJ1ZmZlcmVkIG91dHB1dCBieXRlc1xuICAgICAgICAgKiB0byBiZSB3cml0dGVuIG91dC4gVGhlIGdlbmVyYWwgY29udHJhY3Qgb2YgPGNvZGU+Zmx1c2g8L2NvZGU+IGlzXG4gICAgICAgICAqIHRoYXQgY2FsbGluZyBpdCBpcyBhbiBpbmRpY2F0aW9uIHRoYXQsIGlmIGFueSBieXRlcyBwcmV2aW91c2x5XG4gICAgICAgICAqIHdyaXR0ZW4gaGF2ZSBiZWVuIGJ1ZmZlcmVkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgb3V0cHV0XG4gICAgICAgICAqIHN0cmVhbSwgc3VjaCBieXRlcyBzaG91bGQgaW1tZWRpYXRlbHkgYmUgd3JpdHRlbiB0byB0aGVpclxuICAgICAgICAgKiBpbnRlbmRlZCBkZXN0aW5hdGlvbi5cbiAgICAgICAgICogPHA+XG4gICAgICAgICAqIElmIHRoZSBpbnRlbmRlZCBkZXN0aW5hdGlvbiBvZiB0aGlzIHN0cmVhbSBpcyBhbiBhYnN0cmFjdGlvbiBwcm92aWRlZCBieVxuICAgICAgICAgKiB0aGUgdW5kZXJseWluZyBvcGVyYXRpbmcgc3lzdGVtLCBmb3IgZXhhbXBsZSBhIGZpbGUsIHRoZW4gZmx1c2hpbmcgdGhlXG4gICAgICAgICAqIHN0cmVhbSBndWFyYW50ZWVzIG9ubHkgdGhhdCBieXRlcyBwcmV2aW91c2x5IHdyaXR0ZW4gdG8gdGhlIHN0cmVhbSBhcmVcbiAgICAgICAgICogcGFzc2VkIHRvIHRoZSBvcGVyYXRpbmcgc3lzdGVtIGZvciB3cml0aW5nOyBpdCBkb2VzIG5vdCBndWFyYW50ZWUgdGhhdFxuICAgICAgICAgKiB0aGV5IGFyZSBhY3R1YWxseSB3cml0dGVuIHRvIGEgcGh5c2ljYWwgZGV2aWNlIHN1Y2ggYXMgYSBkaXNrIGRyaXZlLlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICogVGhlIDxjb2RlPmZsdXNoPC9jb2RlPiBtZXRob2Qgb2YgPGNvZGU+T3V0cHV0U3RyZWFtPC9jb2RlPiBkb2VzIG5vdGhpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGNlcHRpb24gIElPRXhjZXB0aW9uICBpZiBhbiBJL08gZXJyb3Igb2NjdXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgZmx1c2goKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb3NlcyB0aGlzIG91dHB1dCBzdHJlYW0gYW5kIHJlbGVhc2VzIGFueSBzeXN0ZW0gcmVzb3VyY2VzXG4gICAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHN0cmVhbS4gVGhlIGdlbmVyYWwgY29udHJhY3Qgb2YgPGNvZGU+Y2xvc2U8L2NvZGU+XG4gICAgICAgICAqIGlzIHRoYXQgaXQgY2xvc2VzIHRoZSBvdXRwdXQgc3RyZWFtLiBBIGNsb3NlZCBzdHJlYW0gY2Fubm90IHBlcmZvcm1cbiAgICAgICAgICogb3V0cHV0IG9wZXJhdGlvbnMgYW5kIGNhbm5vdCBiZSByZW9wZW5lZC5cbiAgICAgICAgICogPHA+XG4gICAgICAgICAqIFRoZSA8Y29kZT5jbG9zZTwvY29kZT4gbWV0aG9kIG9mIDxjb2RlPk91dHB1dFN0cmVhbTwvY29kZT4gZG9lcyBub3RoaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhjZXB0aW9uICBJT0V4Y2VwdGlvbiAgaWYgYW4gSS9PIGVycm9yIG9jY3Vycy5cbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIE91dE9mTWVtb3J5RXJyb3IgZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IChjKSAxOTk0LCAyMDEwLCBPcmFjbGUgYW5kL29yIGl0cyBhZmZpbGlhdGVzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICAgICAqIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi5cbiAgICAgKlxuICAgICAqIFRoaXMgY29kZSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXNcbiAgICAgKiBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbi4gIE9yYWNsZSBkZXNpZ25hdGVzIHRoaXNcbiAgICAgKiBwYXJ0aWN1bGFyIGZpbGUgYXMgc3ViamVjdCB0byB0aGUgXCJDbGFzc3BhdGhcIiBleGNlcHRpb24gYXMgcHJvdmlkZWRcbiAgICAgKiBieSBPcmFjbGUgaW4gdGhlIExJQ0VOU0UgZmlsZSB0aGF0IGFjY29tcGFuaWVkIHRoaXMgY29kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgY29kZSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgICAqIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWSBvclxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgICAqIHZlcnNpb24gMiBmb3IgbW9yZSBkZXRhaWxzIChhIGNvcHkgaXMgaW5jbHVkZWQgaW4gdGhlIExJQ0VOU0UgZmlsZSB0aGF0XG4gICAgICogYWNjb21wYW5pZWQgdGhpcyBjb2RlKS5cbiAgICAgKlxuICAgICAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb25cbiAgICAgKiAyIGFsb25nIHdpdGggdGhpcyB3b3JrOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sXG4gICAgICogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLlxuICAgICAqXG4gICAgICogUGxlYXNlIGNvbnRhY3QgT3JhY2xlLCA1MDAgT3JhY2xlIFBhcmt3YXksIFJlZHdvb2QgU2hvcmVzLCBDQSA5NDA2NSBVU0FcbiAgICAgKiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55XG4gICAgICogcXVlc3Rpb25zLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBhbiBvdXRwdXQgc3RyZWFtIGluIHdoaWNoIHRoZSBkYXRhIGlzXG4gICAgICogd3JpdHRlbiBpbnRvIGEgYnl0ZSBhcnJheS4gVGhlIGJ1ZmZlciBhdXRvbWF0aWNhbGx5IGdyb3dzIGFzIGRhdGFcbiAgICAgKiBpcyB3cml0dGVuIHRvIGl0LlxuICAgICAqIFRoZSBkYXRhIGNhbiBiZSByZXRyaWV2ZWQgdXNpbmcgPGNvZGU+dG9CeXRlQXJyYXkoKTwvY29kZT4gYW5kXG4gICAgICogPGNvZGU+dG9TdHJpbmcoKTwvY29kZT4uXG4gICAgICogPHA+XG4gICAgICogQ2xvc2luZyBhIDx0dD5CeXRlQXJyYXlPdXRwdXRTdHJlYW08L3R0PiBoYXMgbm8gZWZmZWN0LiBUaGUgbWV0aG9kcyBpblxuICAgICAqIHRoaXMgY2xhc3MgY2FuIGJlIGNhbGxlZCBhZnRlciB0aGUgc3RyZWFtIGhhcyBiZWVuIGNsb3NlZCB3aXRob3V0XG4gICAgICogZ2VuZXJhdGluZyBhbiA8dHQ+SU9FeGNlcHRpb248L3R0Pi5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgIEFydGh1ciB2YW4gSG9mZlxuICAgICAqIEBzaW5jZSAgIEpESzEuMFxuICAgICAqL1xuICAgIC8qcHVibGljKi8gY2xhc3MgQnl0ZUFycmF5T3V0cHV0U3RyZWFtIGV4dGVuZHMgT3V0cHV0U3RyZWFtIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgYnl0ZSBhcnJheSBvdXRwdXQgc3RyZWFtLiBUaGUgYnVmZmVyIGNhcGFjaXR5IGlzXG4gICAgICAgICAqIGluaXRpYWxseSAzMiBieXRlcywgdGhvdWdoIGl0cyBzaXplIGluY3JlYXNlcyBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vICAgICB0aGlzKDMyKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBieXRlIGFycmF5IG91dHB1dCBzdHJlYW0sIHdpdGggYSBidWZmZXIgY2FwYWNpdHkgb2ZcbiAgICAgICAgICogdGhlIHNwZWNpZmllZCBzaXplLCBpbiBieXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAgc2l6ZSAgIHRoZSBpbml0aWFsIHNpemUuXG4gICAgICAgICAqIEBleGNlcHRpb24gIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiBzaXplIGlzIG5lZ2F0aXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3Ioc2l6ZSA9IDMyKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGluIHRoZSBidWZmZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICAgICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignTmVnYXRpdmUgaW5pdGlhbCBzaXplOiAnXG4gICAgICAgICAgICAgICAgICAgICsgc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmNyZWFzZXMgdGhlIGNhcGFjaXR5IGlmIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhhdCBpdCBjYW4gaG9sZFxuICAgICAgICAgKiBhdCBsZWFzdCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHNwZWNpZmllZCBieSB0aGUgbWluaW11bVxuICAgICAgICAgKiBjYXBhY2l0eSBhcmd1bWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1pbkNhcGFjaXR5IHRoZSBkZXNpcmVkIG1pbmltdW0gY2FwYWNpdHlcbiAgICAgICAgICogQHRocm93cyBPdXRPZk1lbW9yeUVycm9yIGlmIHtAY29kZSBtaW5DYXBhY2l0eSA8IDB9LiAgVGhpcyBpc1xuICAgICAgICAgKiBpbnRlcnByZXRlZCBhcyBhIHJlcXVlc3QgZm9yIHRoZSB1bnNhdGlzZmlhYmx5IGxhcmdlIGNhcGFjaXR5XG4gICAgICAgICAqIHtAY29kZSAobG9uZykgSW50ZWdlci5NQVhfVkFMVUUgKyAobWluQ2FwYWNpdHkgLSBJbnRlZ2VyLk1BWF9WQUxVRSl9LlxuICAgICAgICAgKi9cbiAgICAgICAgZW5zdXJlQ2FwYWNpdHkobWluQ2FwYWNpdHkpIHtcbiAgICAgICAgICAgIC8vIG92ZXJmbG93LWNvbnNjaW91cyBjb2RlXG4gICAgICAgICAgICBpZiAobWluQ2FwYWNpdHkgLSB0aGlzLmJ1Zi5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdyhtaW5DYXBhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluY3JlYXNlcyB0aGUgY2FwYWNpdHkgdG8gZW5zdXJlIHRoYXQgaXQgY2FuIGhvbGQgYXQgbGVhc3QgdGhlXG4gICAgICAgICAqIG51bWJlciBvZiBlbGVtZW50cyBzcGVjaWZpZWQgYnkgdGhlIG1pbmltdW0gY2FwYWNpdHkgYXJndW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBtaW5DYXBhY2l0eSB0aGUgZGVzaXJlZCBtaW5pbXVtIGNhcGFjaXR5XG4gICAgICAgICAqL1xuICAgICAgICBncm93KG1pbkNhcGFjaXR5KSB7XG4gICAgICAgICAgICAvLyBvdmVyZmxvdy1jb25zY2lvdXMgY29kZVxuICAgICAgICAgICAgbGV0IG9sZENhcGFjaXR5ID0gdGhpcy5idWYubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG5ld0NhcGFjaXR5ID0gb2xkQ2FwYWNpdHkgPDwgMTtcbiAgICAgICAgICAgIGlmIChuZXdDYXBhY2l0eSAtIG1pbkNhcGFjaXR5IDwgMClcbiAgICAgICAgICAgICAgICBuZXdDYXBhY2l0eSA9IG1pbkNhcGFjaXR5O1xuICAgICAgICAgICAgaWYgKG5ld0NhcGFjaXR5IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChtaW5DYXBhY2l0eSA8IDApIC8vIG92ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPdXRPZk1lbW9yeUVycm9yKCk7XG4gICAgICAgICAgICAgICAgbmV3Q2FwYWNpdHkgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmID0gQXJyYXlzLmNvcHlPZlVpbnQ4QXJyYXkodGhpcy5idWYsIG5ld0NhcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIHRoZSBzcGVjaWZpZWQgYnl0ZSB0byB0aGlzIGJ5dGUgYXJyYXkgb3V0cHV0IHN0cmVhbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAgYiAgIHRoZSBieXRlIHRvIGJlIHdyaXR0ZW4uXG4gICAgICAgICAqL1xuICAgICAgICB3cml0ZShiKSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuY291bnQgKyAxKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMuY291bnRdID0gLyooYnl0ZSkqLyBiO1xuICAgICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgPGNvZGU+bGVuPC9jb2RlPiBieXRlcyBmcm9tIHRoZSBzcGVjaWZpZWQgYnl0ZSBhcnJheVxuICAgICAgICAgKiBzdGFydGluZyBhdCBvZmZzZXQgPGNvZGU+b2ZmPC9jb2RlPiB0byB0aGlzIGJ5dGUgYXJyYXkgb3V0cHV0IHN0cmVhbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAgYiAgICAgdGhlIGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSAgIG9mZiAgIHRoZSBzdGFydCBvZmZzZXQgaW4gdGhlIGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSAgIGxlbiAgIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuXG4gICAgICAgICAqL1xuICAgICAgICB3cml0ZUJ5dGVzT2Zmc2V0KGIsIG9mZiwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoKG9mZiA8IDApIHx8IChvZmYgPiBiLmxlbmd0aCkgfHwgKGxlbiA8IDApIHx8XG4gICAgICAgICAgICAgICAgKChvZmYgKyBsZW4pIC0gYi5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuY291bnQgKyBsZW4pO1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShiLCBvZmYsIHRoaXMuYnVmLCB0aGlzLmNvdW50LCBsZW4pO1xuICAgICAgICAgICAgdGhpcy5jb3VudCArPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyB0aGUgY29tcGxldGUgY29udGVudHMgb2YgdGhpcyBieXRlIGFycmF5IG91dHB1dCBzdHJlYW0gdG9cbiAgICAgICAgICogdGhlIHNwZWNpZmllZCBvdXRwdXQgc3RyZWFtIGFyZ3VtZW50LCBhcyBpZiBieSBjYWxsaW5nIHRoZSBvdXRwdXRcbiAgICAgICAgICogc3RyZWFtJ3Mgd3JpdGUgbWV0aG9kIHVzaW5nIDxjb2RlPm91dC53cml0ZShidWYsIDAsIGNvdW50KTwvY29kZT4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgICAgIG91dCAgIHRoZSBvdXRwdXQgc3RyZWFtIHRvIHdoaWNoIHRvIHdyaXRlIHRoZSBkYXRhLlxuICAgICAgICAgKiBAZXhjZXB0aW9uICBJT0V4Y2VwdGlvbiAgaWYgYW4gSS9PIGVycm9yIG9jY3Vycy5cbiAgICAgICAgICovXG4gICAgICAgIHdyaXRlVG8ob3V0KSB7XG4gICAgICAgICAgICBvdXQud3JpdGVCeXRlc09mZnNldCh0aGlzLmJ1ZiwgMCwgdGhpcy5jb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUgPGNvZGU+Y291bnQ8L2NvZGU+IGZpZWxkIG9mIHRoaXMgYnl0ZSBhcnJheSBvdXRwdXRcbiAgICAgICAgICogc3RyZWFtIHRvIHplcm8sIHNvIHRoYXQgYWxsIGN1cnJlbnRseSBhY2N1bXVsYXRlZCBvdXRwdXQgaW4gdGhlXG4gICAgICAgICAqIG91dHB1dCBzdHJlYW0gaXMgZGlzY2FyZGVkLiBUaGUgb3V0cHV0IHN0cmVhbSBjYW4gYmUgdXNlZCBhZ2FpbixcbiAgICAgICAgICogcmV1c2luZyB0aGUgYWxyZWFkeSBhbGxvY2F0ZWQgYnVmZmVyIHNwYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc2VlICAgICBqYXZhLmlvLkJ5dGVBcnJheUlucHV0U3RyZWFtI2NvdW50XG4gICAgICAgICAqL1xuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3bHkgYWxsb2NhdGVkIGJ5dGUgYXJyYXkuIEl0cyBzaXplIGlzIHRoZSBjdXJyZW50XG4gICAgICAgICAqIHNpemUgb2YgdGhpcyBvdXRwdXQgc3RyZWFtIGFuZCB0aGUgdmFsaWQgY29udGVudHMgb2YgdGhlIGJ1ZmZlclxuICAgICAgICAgKiBoYXZlIGJlZW4gY29waWVkIGludG8gaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gIHRoZSBjdXJyZW50IGNvbnRlbnRzIG9mIHRoaXMgb3V0cHV0IHN0cmVhbSwgYXMgYSBieXRlIGFycmF5LlxuICAgICAgICAgKiBAc2VlICAgICBqYXZhLmlvLkJ5dGVBcnJheU91dHB1dFN0cmVhbSNzaXplKClcbiAgICAgICAgICovXG4gICAgICAgIHRvQnl0ZUFycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5cy5jb3B5T2ZVaW50OEFycmF5KHRoaXMuYnVmLCB0aGlzLmNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBidWZmZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gIHRoZSB2YWx1ZSBvZiB0aGUgPGNvZGU+Y291bnQ8L2NvZGU+IGZpZWxkLCB3aGljaCBpcyB0aGUgbnVtYmVyXG4gICAgICAgICAqICAgICAgICAgIG9mIHZhbGlkIGJ5dGVzIGluIHRoaXMgb3V0cHV0IHN0cmVhbS5cbiAgICAgICAgICogQHNlZSAgICAgamF2YS5pby5CeXRlQXJyYXlPdXRwdXRTdHJlYW0jY291bnRcbiAgICAgICAgICovXG4gICAgICAgIHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZyhwYXJhbSkge1xuICAgICAgICAgICAgaWYgKCFwYXJhbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nX3ZvaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmdfc3RyaW5nKHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nX251bWJlcihwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoZSBidWZmZXIncyBjb250ZW50cyBpbnRvIGEgc3RyaW5nIGRlY29kaW5nIGJ5dGVzIHVzaW5nIHRoZVxuICAgICAgICAgKiBwbGF0Zm9ybSdzIGRlZmF1bHQgY2hhcmFjdGVyIHNldC4gVGhlIGxlbmd0aCBvZiB0aGUgbmV3IDx0dD5TdHJpbmc8L3R0PlxuICAgICAgICAgKiBpcyBhIGZ1bmN0aW9uIG9mIHRoZSBjaGFyYWN0ZXIgc2V0LCBhbmQgaGVuY2UgbWF5IG5vdCBiZSBlcXVhbCB0byB0aGVcbiAgICAgICAgICogc2l6ZSBvZiB0aGUgYnVmZmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD4gVGhpcyBtZXRob2QgYWx3YXlzIHJlcGxhY2VzIG1hbGZvcm1lZC1pbnB1dCBhbmQgdW5tYXBwYWJsZS1jaGFyYWN0ZXJcbiAgICAgICAgICogc2VxdWVuY2VzIHdpdGggdGhlIGRlZmF1bHQgcmVwbGFjZW1lbnQgc3RyaW5nIGZvciB0aGUgcGxhdGZvcm0nc1xuICAgICAgICAgKiBkZWZhdWx0IGNoYXJhY3RlciBzZXQuIFRoZSB7QGxpbmtwbGFpbiBqYXZhLm5pby5jaGFyc2V0LkNoYXJzZXREZWNvZGVyfVxuICAgICAgICAgKiBjbGFzcyBzaG91bGQgYmUgdXNlZCB3aGVuIG1vcmUgY29udHJvbCBvdmVyIHRoZSBkZWNvZGluZyBwcm9jZXNzIGlzXG4gICAgICAgICAqIHJlcXVpcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIFN0cmluZyBkZWNvZGVkIGZyb20gdGhlIGJ1ZmZlcidzIGNvbnRlbnRzLlxuICAgICAgICAgKiBAc2luY2UgIEpESzEuMVxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmdfdm9pZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nKHRoaXMuYnVmIC8qLCAwLCB0aGlzLmNvdW50Ki8pLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoZSBidWZmZXIncyBjb250ZW50cyBpbnRvIGEgc3RyaW5nIGJ5IGRlY29kaW5nIHRoZSBieXRlcyB1c2luZ1xuICAgICAgICAgKiB0aGUgc3BlY2lmaWVkIHtAbGluayBqYXZhLm5pby5jaGFyc2V0LkNoYXJzZXQgY2hhcnNldE5hbWV9LiBUaGUgbGVuZ3RoIG9mXG4gICAgICAgICAqIHRoZSBuZXcgPHR0PlN0cmluZzwvdHQ+IGlzIGEgZnVuY3Rpb24gb2YgdGhlIGNoYXJzZXQsIGFuZCBoZW5jZSBtYXkgbm90IGJlXG4gICAgICAgICAqIGVxdWFsIHRvIHRoZSBsZW5ndGggb2YgdGhlIGJ5dGUgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPiBUaGlzIG1ldGhvZCBhbHdheXMgcmVwbGFjZXMgbWFsZm9ybWVkLWlucHV0IGFuZCB1bm1hcHBhYmxlLWNoYXJhY3RlclxuICAgICAgICAgKiBzZXF1ZW5jZXMgd2l0aCB0aGlzIGNoYXJzZXQncyBkZWZhdWx0IHJlcGxhY2VtZW50IHN0cmluZy4gVGhlIHtAbGlua1xuICAgICAgICAgKiBqYXZhLm5pby5jaGFyc2V0LkNoYXJzZXREZWNvZGVyfSBjbGFzcyBzaG91bGQgYmUgdXNlZCB3aGVuIG1vcmUgY29udHJvbFxuICAgICAgICAgKiBvdmVyIHRoZSBkZWNvZGluZyBwcm9jZXNzIGlzIHJlcXVpcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIGNoYXJzZXROYW1lICB0aGUgbmFtZSBvZiBhIHN1cHBvcnRlZFxuICAgICAgICAgKiAgICAgICAgICAgICAge0BsaW5rcGxhaW4gamF2YS5uaW8uY2hhcnNldC5DaGFyc2V0IDwvY29kZT5jaGFyc2V0PGNvZGU+fVxuICAgICAgICAgKiBAcmV0dXJuIFN0cmluZyBkZWNvZGVkIGZyb20gdGhlIGJ1ZmZlcidzIGNvbnRlbnRzLlxuICAgICAgICAgKiBAZXhjZXB0aW9uICBVbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uXG4gICAgICAgICAqICAgICAgICAgICAgIElmIHRoZSBuYW1lZCBjaGFyc2V0IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICogQHNpbmNlICAgSkRLMS4xXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZ19zdHJpbmcoY2hhcnNldE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nKHRoaXMuYnVmIC8qLCAwLCB0aGlzLmNvdW50LCBjaGFyc2V0TmFtZSovKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3bHkgYWxsb2NhdGVkIHN0cmluZy4gSXRzIHNpemUgaXMgdGhlIGN1cnJlbnQgc2l6ZSBvZlxuICAgICAgICAgKiB0aGUgb3V0cHV0IHN0cmVhbSBhbmQgdGhlIHZhbGlkIGNvbnRlbnRzIG9mIHRoZSBidWZmZXIgaGF2ZSBiZWVuXG4gICAgICAgICAqIGNvcGllZCBpbnRvIGl0LiBFYWNoIGNoYXJhY3RlciA8aT5jPC9pPiBpbiB0aGUgcmVzdWx0aW5nIHN0cmluZyBpc1xuICAgICAgICAgKiBjb25zdHJ1Y3RlZCBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgPGk+YjwvaT4gaW4gdGhlIGJ5dGVcbiAgICAgICAgICogYXJyYXkgc3VjaCB0aGF0OlxuICAgICAgICAgKiA8YmxvY2txdW90ZT48cHJlPlxuICAgICAgICAgKiAgICAgYyA9PSAoY2hhcikoKChoaWJ5dGUgJmFtcDsgMHhmZikgJmx0OyZsdDsgOCkgfCAoYiAmYW1wOyAweGZmKSlcbiAgICAgICAgICogPC9wcmU+PC9ibG9ja3F1b3RlPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCBkb2VzIG5vdCBwcm9wZXJseSBjb252ZXJ0IGJ5dGVzIGludG8gY2hhcmFjdGVycy5cbiAgICAgICAgICogQXMgb2YgSkRLJm5ic3A7MS4xLCB0aGUgcHJlZmVycmVkIHdheSB0byBkbyB0aGlzIGlzIHZpYSB0aGVcbiAgICAgICAgICogPGNvZGU+dG9TdHJpbmcoU3RyaW5nIGVuYyk8L2NvZGU+IG1ldGhvZCwgd2hpY2ggdGFrZXMgYW4gZW5jb2RpbmctbmFtZVxuICAgICAgICAgKiBhcmd1bWVudCwgb3IgdGhlIDxjb2RlPnRvU3RyaW5nKCk8L2NvZGU+IG1ldGhvZCwgd2hpY2ggdXNlcyB0aGVcbiAgICAgICAgICogcGxhdGZvcm0ncyBkZWZhdWx0IGNoYXJhY3RlciBlbmNvZGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAgICAgaGlieXRlICAgIHRoZSBoaWdoIGJ5dGUgb2YgZWFjaCByZXN1bHRpbmcgVW5pY29kZSBjaGFyYWN0ZXIuXG4gICAgICAgICAqIEByZXR1cm4gICAgIHRoZSBjdXJyZW50IGNvbnRlbnRzIG9mIHRoZSBvdXRwdXQgc3RyZWFtLCBhcyBhIHN0cmluZy5cbiAgICAgICAgICogQHNlZSAgICAgICAgamF2YS5pby5CeXRlQXJyYXlPdXRwdXRTdHJlYW0jc2l6ZSgpXG4gICAgICAgICAqIEBzZWUgICAgICAgIGphdmEuaW8uQnl0ZUFycmF5T3V0cHV0U3RyZWFtI3RvU3RyaW5nKFN0cmluZylcbiAgICAgICAgICogQHNlZSAgICAgICAgamF2YS5pby5CeXRlQXJyYXlPdXRwdXRTdHJlYW0jdG9TdHJpbmcoKVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQERlcHJlY2F0ZWRcbiAgICAgICAgdG9TdHJpbmdfbnVtYmVyKGhpYnl0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmcodGhpcy5idWYgLyosIGhpYnl0ZSwgMCwgdGhpcy5jb3VudCovKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9zaW5nIGEgPHR0PkJ5dGVBcnJheU91dHB1dFN0cmVhbTwvdHQ+IGhhcyBubyBlZmZlY3QuIFRoZSBtZXRob2RzIGluXG4gICAgICAgICAqIHRoaXMgY2xhc3MgY2FuIGJlIGNhbGxlZCBhZnRlciB0aGUgc3RyZWFtIGhhcyBiZWVuIGNsb3NlZCB3aXRob3V0XG4gICAgICAgICAqIGdlbmVyYXRpbmcgYW4gPHR0PklPRXhjZXB0aW9uPC90dD4uXG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIElPRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypwcml2YXRlKi8gdmFyIE1vZGUkMjtcbiAgICAoZnVuY3Rpb24gKE1vZGUpIHtcbiAgICAgICAgTW9kZVtNb2RlW1wiQUxQSEFcIl0gPSAwXSA9IFwiQUxQSEFcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiTE9XRVJcIl0gPSAxXSA9IFwiTE9XRVJcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiTUlYRURcIl0gPSAyXSA9IFwiTUlYRURcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiUFVOQ1RcIl0gPSAzXSA9IFwiUFVOQ1RcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiQUxQSEFfU0hJRlRcIl0gPSA0XSA9IFwiQUxQSEFfU0hJRlRcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiUFVOQ1RfU0hJRlRcIl0gPSA1XSA9IFwiUFVOQ1RfU0hJRlRcIjtcbiAgICB9KShNb2RlJDIgfHwgKE1vZGUkMiA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogSW5kaXJlY3RseSBhY2Nlc3MgdGhlIGdsb2JhbCBCaWdJbnQgY29uc3RydWN0b3IsIGl0XG4gICAgICogYWxsb3dzIGJyb3dzZXJzIHRoYXQgZG9lc24ndCBzdXBwb3J0IEJpZ0ludCB0byBydW5cbiAgICAgKiB0aGUgbGlicmFyeSB3aXRob3V0IGJyZWFraW5nIGR1ZSB0byBcInVuZGVmaW5lZCBCaWdJbnRcIlxuICAgICAqIGVycm9ycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRCaWdJbnRDb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93WydCaWdJbnQnXSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFsnQmlnSW50J10gfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZlsnQmlnSW50J10gfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3Qgc2VhcmNoIGdsb2JhbHMgZm9yIEJpZ0ludCEnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBzdG9yZSB0aGUgQmlnSW50IGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGxldCBCaWdJbnRlZ2VyO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIGJpZ2ludCB2YWx1ZS4gSXQgYWxsb3dzIGJyb3dzZXJzXG4gICAgICogdGhhdCBkb2Vzbid0IHN1cHBvcnQgQmlnSW50IHRvIHJ1biB0aGUgcmVzdCBvZiB0aGUgbGlicmFyeVxuICAgICAqIGJ5IG5vdCBkaXJlY3RseSBhY2Nlc3NpbmcgdGhlIEJpZ0ludCBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCaWdJbnQobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgQmlnSW50ZWdlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIEJpZ0ludGVnZXIgPSBnZXRCaWdJbnRDb25zdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCaWdJbnRlZ2VyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBpcyBub3Qgc3VwcG9ydGVkIScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnRlZ2VyKG51bSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEVYUDkwMCgpIHtcbiAgICAgICAgLy8gaW4gSmF2YSAtIGFycmF5IHdpdGggbGVuZ3RoID0gMTZcbiAgICAgICAgbGV0IEVYUDkwMCA9IFtdO1xuICAgICAgICBFWFA5MDBbMF0gPSBjcmVhdGVCaWdJbnQoMSk7XG4gICAgICAgIGxldCBuaW5lSHVuZHJlZCA9IGNyZWF0ZUJpZ0ludCg5MDApO1xuICAgICAgICBFWFA5MDBbMV0gPSBuaW5lSHVuZHJlZDtcbiAgICAgICAgLy8gaW4gSmF2YSAtIGFycmF5IHdpdGggbGVuZ3RoID0gMTZcbiAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMjsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgIEVYUDkwMFtpXSA9IEVYUDkwMFtpIC0gMV0gKiBuaW5lSHVuZHJlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRVhQOTAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiA8cD5UaGlzIGNsYXNzIGNvbnRhaW5zIHRoZSBtZXRob2RzIGZvciBkZWNvZGluZyB0aGUgUERGNDE3IGNvZGV3b3Jkcy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNJVEEgTGFiIChrZXZpbi5vc3VsbGl2YW5Ac2l0YS5hZXJvKVxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qZmluYWwqLyBjbGFzcyBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIge1xuICAgICAgICAvLyAgIHByaXZhdGUgRGVjb2RlZEJpdFN0cmVhbVBhcnNlcigpIHtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvZGV3b3Jkc1xuICAgICAgICAgKiBAcGFyYW0gZWNMZXZlbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZShjb2Rld29yZHMsIGVjTGV2ZWwpIHtcbiAgICAgICAgICAgIC8vIHBhc3MgZW5jb2RpbmcgdG8gcmVzdWx0ICh3aWxsIGJlIHVzZWQgZm9yIGRlY29kZSBzeW1ib2xzIGluIGJ5dGUgbW9kZSlcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcignJyk7XG4gICAgICAgICAgICAvLyBsZXQgZW5jb2Rpbmc6IENoYXJzZXQgPSBTdGFuZGFyZENoYXJzZXRzLklTT184ODU5XzE7XG4gICAgICAgICAgICBsZXQgZW5jb2RpbmcgPSBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbm90ZSB0aGUgbmV4dCBjb21tYW5kIGlzIHNwZWNpZmljIGZyb20gdGhpcyBUeXBlU2NyaXB0IGxpYnJhcnlcbiAgICAgICAgICAgICAqIGJlY2F1c2UgVFMgY2FuJ3QgcHJvcGVybHkgY2FzdCBzb21lIHZhbHVlcyB0byBjaGFyIGFuZFxuICAgICAgICAgICAgICogY29udmVydCBpdCB0byBzdHJpbmcgbGF0ZXIgY29ycmVjdGx5IGR1ZSB0byBlbmNvZGluZ1xuICAgICAgICAgICAgICogZGlmZmVyZW5jZXMgZnJvbSBKYXZhIHZlcnNpb24uIEFzIHJlcG9ydGVkIGhlcmU6XG4gICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20venhpbmctanMvbGlicmFyeS9wdWxsLzI2NC9maWxlcyNyMzgyODMxNTkzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlc3VsdC5lbmFibGVEZWNvZGluZyhlbmNvZGluZyk7XG4gICAgICAgICAgICAvLyBHZXQgY29tcGFjdGlvbiBtb2RlXG4gICAgICAgICAgICBsZXQgY29kZUluZGV4ID0gMTtcbiAgICAgICAgICAgIGxldCBjb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcbiAgICAgICAgICAgIGxldCByZXN1bHRNZXRhZGF0YSA9IG5ldyBQREY0MTdSZXN1bHRNZXRhZGF0YSgpO1xuICAgICAgICAgICAgd2hpbGUgKGNvZGVJbmRleCA8IGNvZGV3b3Jkc1swXSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi50ZXh0Q29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0hfNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5ieXRlQ29tcGFjdGlvbihjb2RlLCBjb2Rld29yZHMsIGVuY29kaW5nLCBjb2RlSW5kZXgsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoLyooY2hhcikqLyBjb2Rld29yZHNbY29kZUluZGV4KytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1FUklDX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5udW1lcmljQ29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5FQ0lfQ0hBUlNFVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGFyc2V0RUNJID0gQ2hhcmFjdGVyU2V0RUNJLmdldENoYXJhY3RlclNldEVDSUJ5VmFsdWUoY29kZXdvcmRzW2NvZGVJbmRleCsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmNvZGluZyA9IENoYXJzZXQuZm9yTmFtZShjaGFyc2V0RUNJLmdldE5hbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuRUNJX0dFTkVSQUxfUFVSUE9TRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbid0IGRvIGFueXRoaW5nIHdpdGggZ2VuZXJpYyBFQ0k7IHNraXAgaXRzIDIgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuRUNJX1VTRVJfREVGSU5FRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbid0IGRvIGFueXRoaW5nIHdpdGggdXNlciBFQ0k7IHNraXAgaXRzIDEgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfQ09OVFJPTF9CTE9DSzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5kZWNvZGVNYWNyb0Jsb2NrKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHRNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfVEVSTUlOQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBub3Qgc2VlIHRoZXNlIG91dHNpZGUgYSBtYWNybyBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB0byB0ZXh0IGNvbXBhY3Rpb24uIER1cmluZyB0ZXN0aW5nIG51bWVyb3VzIGJhcmNvZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcHBlYXJlZCB0byBiZSBtaXNzaW5nIHRoZSBzdGFydGluZyBtb2RlLiBJbiB0aGVzZSBjYXNlcyBkZWZhdWx0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byB0ZXh0IGNvbXBhY3Rpb24gc2VlbXMgdG8gd29yay5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLnRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2RlSW5kZXggPCBjb2Rld29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRlY29kZXJSZXN1bHQgPSBuZXcgRGVjb2RlclJlc3VsdChudWxsLCByZXN1bHQudG9TdHJpbmcoKSwgbnVsbCwgZWNMZXZlbCk7XG4gICAgICAgICAgICBkZWNvZGVyUmVzdWx0LnNldE90aGVyKHJlc3VsdE1ldGFkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVyUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW50XG4gICAgICAgICAqIEBwYXJhbSBwYXJhbTFcbiAgICAgICAgICogQHBhcmFtIGNvZGV3b3Jkc1xuICAgICAgICAgKiBAcGFyYW0gaW50XG4gICAgICAgICAqIEBwYXJhbSBjb2RlSW5kZXhcbiAgICAgICAgICogQHBhcmFtIFBERjQxN1Jlc3VsdE1ldGFkYXRhXG4gICAgICAgICAqIEBwYXJhbSByZXN1bHRNZXRhZGF0YVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQFN1cHByZXNzV2FybmluZ3MoXCJkZXByZWNhdGlvblwiKVxuICAgICAgICBzdGF0aWMgZGVjb2RlTWFjcm9CbG9jayhjb2Rld29yZHMsIGNvZGVJbmRleCwgcmVzdWx0TWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGlmIChjb2RlSW5kZXggKyBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNQkVSX09GX1NFUVVFTkNFX0NPREVXT1JEUyA+IGNvZGV3b3Jkc1swXSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIG11c3QgaGF2ZSBhdCBsZWFzdCB0d28gYnl0ZXMgbGVmdCBmb3IgdGhlIHNlZ21lbnQgaW5kZXhcbiAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzZWdtZW50SW5kZXhBcnJheSA9IG5ldyBJbnQzMkFycmF5KERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1CRVJfT0ZfU0VRVUVOQ0VfQ09ERVdPUkRTKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNQkVSX09GX1NFUVVFTkNFX0NPREVXT1JEUzsgaSsrLCBjb2RlSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRJbmRleEFycmF5W2ldID0gY29kZXdvcmRzW2NvZGVJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRTZWdtZW50SW5kZXgoSW50ZWdlci5wYXJzZUludChEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuZGVjb2RlQmFzZTkwMHRvQmFzZTEwKHNlZ21lbnRJbmRleEFycmF5LCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNQkVSX09GX1NFUVVFTkNFX0NPREVXT1JEUykpKTtcbiAgICAgICAgICAgIGxldCBmaWxlSWQgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLnRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4LCBmaWxlSWQpO1xuICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0RmlsZUlkKGZpbGVJZC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGxldCBvcHRpb25hbEZpZWxkc1N0YXJ0ID0gLTE7XG4gICAgICAgICAgICBpZiAoY29kZXdvcmRzW2NvZGVJbmRleF0gPT09IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25hbEZpZWxkc1N0YXJ0ID0gY29kZUluZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjb2RlSW5kZXggPCBjb2Rld29yZHNbMF0pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGV3b3Jkc1tjb2RlSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2Rld29yZHNbY29kZUluZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9GSUxFX05BTUU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlTmFtZSA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi50ZXh0Q29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCArIDEsIGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0RmlsZU5hbWUoZmlsZU5hbWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9TRU5ERVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzZW5kZXIgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIudGV4dENvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCBzZW5kZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRTZW5kZXIoc2VuZGVyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfQUREUkVTU0VFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWRkcmVzc2VlID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLnRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4ICsgMSwgYWRkcmVzc2VlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0QWRkcmVzc2VlKGFkZHJlc3NlZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX1NFR01FTlRfQ09VTlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzZWdtZW50Q291bnQgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIubnVtZXJpY0NvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCBzZWdtZW50Q291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRTZWdtZW50Q291bnQoSW50ZWdlci5wYXJzZUludChzZWdtZW50Q291bnQudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfVElNRV9TVEFNUDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRpbWVzdGFtcCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5udW1lcmljQ29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCArIDEsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldFRpbWVzdGFtcChMb25nLnBhcnNlTG9uZyh0aW1lc3RhbXAudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfQ0hFQ0tTVU06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGVja3N1bSA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5udW1lcmljQ29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCArIDEsIGNoZWNrc3VtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0Q2hlY2tzdW0oSW50ZWdlci5wYXJzZUludChjaGVja3N1bS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9GSUxFX1NJWkU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlU2l6ZSA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5udW1lcmljQ29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCArIDEsIGZpbGVTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0RmlsZVNpemUoTG9uZy5wYXJzZUxvbmcoZmlsZVNpemUudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfVEVSTUlOQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0TGFzdFNlZ21lbnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvcHkgb3B0aW9uYWwgZmllbGRzIHRvIGFkZGl0aW9uYWwgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKG9wdGlvbmFsRmllbGRzU3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9wdGlvbmFsRmllbGRzTGVuZ3RoID0gY29kZUluZGV4IC0gb3B0aW9uYWxGaWVsZHNTdGFydDtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0TWV0YWRhdGEuaXNMYXN0U2VnbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBpbmNsdWRlIHRlcm1pbmF0b3JcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxGaWVsZHNMZW5ndGgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0T3B0aW9uYWxEYXRhKEFycmF5cy5jb3B5T2ZSYW5nZShjb2Rld29yZHMsIG9wdGlvbmFsRmllbGRzU3RhcnQsIG9wdGlvbmFsRmllbGRzU3RhcnQgKyBvcHRpb25hbEZpZWxkc0xlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGV4dCBDb21wYWN0aW9uIG1vZGUgKHNlZSA1LjQuMS41KSBwZXJtaXRzIGFsbCBwcmludGFibGUgQVNDSUkgY2hhcmFjdGVycyB0byBiZVxuICAgICAgICAgKiBlbmNvZGVkLCBpLmUuIHZhbHVlcyAzMiAtIDEyNiBpbmNsdXNpdmUgaW4gYWNjb3JkYW5jZSB3aXRoIElTTy9JRUMgNjQ2IChJUlYpLCBhc1xuICAgICAgICAgKiB3ZWxsIGFzIHNlbGVjdGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvZGV3b3JkcyBUaGUgYXJyYXkgb2YgY29kZXdvcmRzIChkYXRhICsgZXJyb3IpXG4gICAgICAgICAqIEBwYXJhbSBjb2RlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggaW50byB0aGUgY29kZXdvcmQgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSByZXN1bHQgICAgVGhlIGRlY29kZWQgZGF0YSBpcyBhcHBlbmRlZCB0byB0aGUgcmVzdWx0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBuZXh0IGluZGV4IGludG8gdGhlIGNvZGV3b3JkIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIDIgY2hhcmFjdGVyIHBlciBjb2Rld29yZFxuICAgICAgICAgICAgbGV0IHRleHRDb21wYWN0aW9uRGF0YSA9IG5ldyBJbnQzMkFycmF5KChjb2Rld29yZHNbMF0gLSBjb2RlSW5kZXgpICogMik7XG4gICAgICAgICAgICAvLyBVc2VkIHRvIGhvbGQgdGhlIGJ5dGUgY29tcGFjdGlvbiB2YWx1ZSBpZiB0aGVyZSBpcyBhIG1vZGUgc2hpZnRcbiAgICAgICAgICAgIGxldCBieXRlQ29tcGFjdGlvbkRhdGEgPSBuZXcgSW50MzJBcnJheSgoY29kZXdvcmRzWzBdIC0gY29kZUluZGV4KSAqIDIpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBlbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICgoY29kZUluZGV4IDwgY29kZXdvcmRzWzBdKSAmJiAhZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRDb21wYWN0aW9uRGF0YVtpbmRleF0gPSBjb2RlIC8gMzA7XG4gICAgICAgICAgICAgICAgICAgIHRleHRDb21wYWN0aW9uRGF0YVtpbmRleCArIDFdID0gY29kZSAlIDMwO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWluaXRpYWxpemUgdGV4dCBjb21wYWN0aW9uIG1vZGUgdG8gYWxwaGEgc3ViIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q29tcGFjdGlvbkRhdGFbaW5kZXgrK10gPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzY6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1FUklDX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19DT05UUk9MX0JMT0NLOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X1RFUk1JTkFUT1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1PREVfU0hJRlRfVE9fQllURV9DT01QQUNUSU9OX01PREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIE1vZGUgU2hpZnQgY29kZXdvcmQgOTEzIHNoYWxsIGNhdXNlIGEgdGVtcG9yYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIGZyb20gVGV4dCBDb21wYWN0aW9uIG1vZGUgdG8gQnl0ZSBDb21wYWN0aW9uIG1vZGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzd2l0Y2ggc2hhbGwgYmUgaW4gZWZmZWN0IGZvciBvbmx5IHRoZSBuZXh0IGNvZGV3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIHdoaWNoIHRoZSBtb2RlIHNoYWxsIHJldmVydCB0byB0aGUgcHJldmFpbGluZyBzdWItbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBUZXh0IENvbXBhY3Rpb24gbW9kZS4gQ29kZXdvcmQgOTEzIGlzIG9ubHkgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gVGV4dCBDb21wYWN0aW9uIG1vZGU7IGl0cyB1c2UgaXMgZGVzY3JpYmVkIGluIDUuNC4yLjQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbXBhY3Rpb25EYXRhW2luZGV4XSA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVDb21wYWN0aW9uRGF0YVtpbmRleF0gPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuZGVjb2RlVGV4dENvbXBhY3Rpb24odGV4dENvbXBhY3Rpb25EYXRhLCBieXRlQ29tcGFjdGlvbkRhdGEsIGluZGV4LCByZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFRleHQgQ29tcGFjdGlvbiBtb2RlIGluY2x1ZGVzIGFsbCB0aGUgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3RlcnNcbiAgICAgICAgICogKGkuZS4gdmFsdWVzIGZyb20gMzIgdG8gMTI2KSBhbmQgdGhyZWUgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzOiBIVCBvciB0YWJcbiAgICAgICAgICogKDk6IGUpLCBMRiBvciBsaW5lIGZlZWQgKDEwOiBlKSwgYW5kIENSIG9yIGNhcnJpYWdlXG4gICAgICAgICAqIHJldHVybiAoMTM6IGUpLiBUaGUgVGV4dCBDb21wYWN0aW9uIG1vZGUgYWxzbyBpbmNsdWRlcyB2YXJpb3VzIGxhdGNoXG4gICAgICAgICAqIGFuZCBzaGlmdCBjaGFyYWN0ZXJzIHdoaWNoIGFyZSB1c2VkIGV4Y2x1c2l2ZWx5IHdpdGhpbiB0aGUgbW9kZS4gVGhlIFRleHRcbiAgICAgICAgICogQ29tcGFjdGlvbiBtb2RlIGVuY29kZXMgdXAgdG8gMiBjaGFyYWN0ZXJzIHBlciBjb2Rld29yZC4gVGhlIGNvbXBhY3Rpb24gcnVsZXNcbiAgICAgICAgICogZm9yIGNvbnZlcnRpbmcgZGF0YSBpbnRvIFBERjQxNyBjb2Rld29yZHMgYXJlIGRlZmluZWQgaW4gNS40LjIuMi4gVGhlIHN1Yi1tb2RlXG4gICAgICAgICAqIHN3aXRjaGVzIGFyZSBkZWZpbmVkIGluIDUuNC4yLjMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0ZXh0Q29tcGFjdGlvbkRhdGEgVGhlIHRleHQgY29tcGFjdGlvbiBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUNvbXBhY3Rpb25EYXRhIFRoZSBieXRlIGNvbXBhY3Rpb24gZGF0YSBpZiB0aGVyZVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcyBhIG1vZGUgc2hpZnQuXG4gICAgICAgICAqIEBwYXJhbSBsZW5ndGggICAgICAgICAgICAgVGhlIHNpemUgb2YgdGhlIHRleHQgY29tcGFjdGlvbiBhbmQgYnl0ZSBjb21wYWN0aW9uIGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSByZXN1bHQgICAgICAgICAgICAgVGhlIGRlY29kZWQgZGF0YSBpcyBhcHBlbmRlZCB0byB0aGUgcmVzdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZVRleHRDb21wYWN0aW9uKHRleHRDb21wYWN0aW9uRGF0YSwgYnl0ZUNvbXBhY3Rpb25EYXRhLCBsZW5ndGgsIHJlc3VsdCkge1xuICAgICAgICAgICAgLy8gQmVnaW5uaW5nIGZyb20gYW4gaW5pdGlhbCBzdGF0ZSBvZiB0aGUgQWxwaGEgc3ViLW1vZGVcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGNvbXBhY3Rpb24gbW9kZSBmb3IgUERGNDE3IGluIGVmZmVjdCBhdCB0aGUgc3RhcnQgb2YgZWFjaCBzeW1ib2wgc2hhbGwgYWx3YXlzIGJlIFRleHRcbiAgICAgICAgICAgIC8vIENvbXBhY3Rpb24gbW9kZSBBbHBoYSBzdWItbW9kZSAoYWxwaGFiZXRpYzogdXBwZXJjYXNlKS4gQSBsYXRjaCBjb2Rld29yZCBmcm9tIGFub3RoZXIgbW9kZSB0byB0aGUgVGV4dFxuICAgICAgICAgICAgLy8gQ29tcGFjdGlvbiBtb2RlIHNoYWxsIGFsd2F5cyBzd2l0Y2ggdG8gdGhlIFRleHQgQ29tcGFjdGlvbiBBbHBoYSBzdWItbW9kZS5cbiAgICAgICAgICAgIGxldCBzdWJNb2RlID0gTW9kZSQyLkFMUEhBO1xuICAgICAgICAgICAgbGV0IHByaW9yVG9TaGlmdE1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBzdWJNb2RlQ2ggPSB0ZXh0Q29tcGFjdGlvbkRhdGFbaV07XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gLypjaGFyKi8gJyc7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzdWJNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQyLkFMUEhBOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxwaGEgKGFscGhhYmV0aWM6IHVwcGVyY2FzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJNb2RlQ2ggPCAyNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwcGVyIGNhc2UgQWxwaGEgQ2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogNjUgPSAnQScgQVNDSUkgLT4gdGhlcmUgaXMgYnl0ZSBjb2RlIG9mIHN5bWJvbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gLyooY2hhcikoJ0EnICsgc3ViTW9kZUNoKSAqLyBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgc3ViTW9kZUNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZUNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5MTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuTE9XRVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLk1JWEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hpZnQgdG8gcHVuY3R1YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yVG9TaGlmdE1vZGUgPSBzdWJNb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5QVU5DVF9TSElGVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgvKihjaGFyKSovIGJ5dGVDb21wYWN0aW9uRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQyLkxPV0VSOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG93ZXIgKGFscGhhYmV0aWM6IGxvd2VyY2FzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJNb2RlQ2ggPCAyNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gLyooY2hhcikoJ2EnICsgc3ViTW9kZUNoKSovIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyBzdWJNb2RlQ2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdWJNb2RlQ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkFTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hpZnQgdG8gYWxwaGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yVG9TaGlmdE1vZGUgPSBzdWJNb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5BTFBIQV9TSElGVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuTUlYRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUFM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGlmdCB0byBwdW5jdHVhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JUb1NoaWZ0TW9kZSA9IHN1Yk1vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLlBVTkNUX1NISUZUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1PREVfU0hJRlRfVE9fQllURV9DT01QQUNUSU9OX01PREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIERvZXMgdGhpcyBuZWVkIHRvIHVzZSB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZW5jb2Rpbmc/IFNlZSBvdGhlciBvY2N1cnJlbmNlcyBiZWxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgvKihjaGFyKSovIGJ5dGVDb21wYWN0aW9uRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQyLk1JWEVEOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWl4ZWQgKHB1bmN0dWF0aW9uOiBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk1vZGVDaCA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1JWEVEX0NIQVJTW3N1Yk1vZGVDaF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1Yk1vZGVDaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuUFVOQ1Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkxMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5MT1dFUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5BTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUFM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGlmdCB0byBwdW5jdHVhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JUb1NoaWZ0TW9kZSA9IHN1Yk1vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLlBVTkNUX1NISUZUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1PREVfU0hJRlRfVE9fQllURV9DT01QQUNUSU9OX01PREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKC8qKGNoYXIpKi8gYnl0ZUNvbXBhY3Rpb25EYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDIuUFVOQ1Q6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdW5jdHVhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk1vZGVDaCA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QVU5DVF9DSEFSU1tzdWJNb2RlQ2hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdWJNb2RlQ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUEFMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5BTFBIQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgvKihjaGFyKSovIGJ5dGVDb21wYWN0aW9uRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQyLkFMUEhBX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBzdWItbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IHByaW9yVG9TaGlmdE1vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViTW9kZUNoIDwgMjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9IC8qKGNoYXIpKCdBJyArIHN1Yk1vZGVDaCkqLyBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgc3ViTW9kZUNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZUNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDIuUFVOQ1RfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHN1Yi1tb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gcHJpb3JUb1NoaWZ0TW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJNb2RlQ2ggPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUEFMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUFVOQ1RfQ0hBUlNbc3ViTW9kZUNoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZUNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBBTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBTIGJlZm9yZSBTaGlmdC10by1CeXRlIGlzIHVzZWQgYXMgYSBwYWRkaW5nIGNoYXJhY3RlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSA1LjQuMi40IG9mIHRoZSBzcGVjaWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKC8qKGNoYXIpKi8gYnl0ZUNvbXBhY3Rpb25EYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgKGNoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgZGVjb2RlZCBjaGFyYWN0ZXIgdG8gcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoY2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ5dGUgQ29tcGFjdGlvbiBtb2RlIChzZWUgNS40LjMpIHBlcm1pdHMgYWxsIDI1NiBwb3NzaWJsZSA4LWJpdCBieXRlIHZhbHVlcyB0byBiZSBlbmNvZGVkLlxuICAgICAgICAgKiBUaGlzIGluY2x1ZGVzIGFsbCBBU0NJSSBjaGFyYWN0ZXJzIHZhbHVlIDAgdG8gMTI3IGluY2x1c2l2ZSBhbmQgcHJvdmlkZXMgZm9yIGludGVybmF0aW9uYWxcbiAgICAgICAgICogY2hhcmFjdGVyIHNldCBzdXBwb3J0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbW9kZSAgICAgIFRoZSBieXRlIGNvbXBhY3Rpb24gbW9kZSBpLmUuIDkwMSBvciA5MjRcbiAgICAgICAgICogQHBhcmFtIGNvZGV3b3JkcyBUaGUgYXJyYXkgb2YgY29kZXdvcmRzIChkYXRhICsgZXJyb3IpXG4gICAgICAgICAqIEBwYXJhbSBlbmNvZGluZyAgQ3VycmVudGx5IGFjdGl2ZSBjaGFyYWN0ZXIgZW5jb2RpbmdcbiAgICAgICAgICogQHBhcmFtIGNvZGVJbmRleCBUaGUgY3VycmVudCBpbmRleCBpbnRvIHRoZSBjb2Rld29yZCBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIHJlc3VsdCAgICBUaGUgZGVjb2RlZCBkYXRhIGlzIGFwcGVuZGVkIHRvIHRoZSByZXN1bHQuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIG5leHQgaW5kZXggaW50byB0aGUgY29kZXdvcmQgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgLyppbnQqLyBieXRlQ29tcGFjdGlvbihtb2RlLCBjb2Rld29yZHMsIGVuY29kaW5nLCBjb2RlSW5kZXgsIHJlc3VsdCkge1xuICAgICAgICAgICAgbGV0IGRlY29kZWRCeXRlcyA9IG5ldyBCeXRlQXJyYXlPdXRwdXRTdHJlYW0oKTtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAvKmxvbmcqLyAwO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBCeXRlIENvbXBhY3Rpb24gY2hhcmFjdGVycyB0byBiZSBlbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCBhIG11bHRpcGxlIG9mIDZcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJ5dGVDb21wYWN0ZWRDb2Rld29yZHMgPSBuZXcgSW50MzJBcnJheSg2KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRDb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjb2RlSW5kZXggPCBjb2Rld29yZHNbMF0pICYmICFlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVDb21wYWN0ZWRDb2Rld29yZHNbY291bnQrK10gPSBuZXh0Q29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhc2UgOTAwXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDkwMCAqIHZhbHVlICsgbmV4dENvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29kZSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwZXJoYXBzIGl0IHNob3VsZCBiZSBvayB0byBjaGVjayBvbmx5IG5leHRDb2RlID49IFRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5leHRDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0hfNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfQ09OVFJPTF9CTE9DSzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X1RFUk1JTkFUT1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvdW50ICUgNSA9PT0gMCkgJiYgKGNvdW50ID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlY29kZSBldmVyeSA1IGNvZGV3b3Jkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBCYXNlIDI1NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiAvKmludCovID0gMDsgaiA8IDY7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEBub3RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogSmF2YVNjcmlwdCBzdG9yZXMgbnVtYmVycyBhcyA2NCBiaXRzIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIGJ1dCBhbGwgYml0d2lzZSBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgb24gMzIgYml0cyBiaW5hcnkgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTbyB0aGUgbmV4dCBiaXR3aXNlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgZG9uZSB3aXRoIHNpbXBsZSBudW1iZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZEJ5dGVzLndyaXRlKC8qKGJ5dGUpKi8gTnVtYmVyKGNyZWF0ZUJpZ0ludCh2YWx1ZSkgPj4gY3JlYXRlQmlnSW50KDggKiAoNSAtIGopKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBlbmQgb2YgYWxsIGNvZGV3b3JkcyBpcyByZWFjaGVkIHRoZSBsYXN0IGNvZGV3b3JkIG5lZWRzIHRvIGJlIGFkZGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlSW5kZXggPT09IGNvZGV3b3Jkc1swXSAmJiBuZXh0Q29kZSA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUNvbXBhY3RlZENvZGV3b3Jkc1tjb3VudCsrXSA9IG5leHRDb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIEJ5dGUgQ29tcGFjdGlvbiBtb2RlIGlzIGludm9rZWQgd2l0aCBjb2Rld29yZCA5MDEsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBsYXN0IGdyb3VwIG9mIGNvZGV3b3JkcyBpcyBpbnRlcnByZXRlZCBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICAvLyBhcyBvbmUgYnl0ZSBwZXIgY29kZXdvcmQsIHdpdGhvdXQgY29tcGFjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRCeXRlcy53cml0ZSgvKihieXRlKSovIGJ5dGVDb21wYWN0ZWRDb2Rld29yZHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzY6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBCeXRlIENvbXBhY3Rpb24gY2hhcmFjdGVycyB0byBiZSBlbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGFuIGludGVnZXIgbXVsdGlwbGUgb2YgNlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29kZUluZGV4IDwgY29kZXdvcmRzWzBdICYmICFlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXNlIDkwMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gOTAwICogdmFsdWUgKyBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19DT05UUk9MX0JMT0NLOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19URVJNSU5BVE9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb3VudCAlIDUgPT09IDApICYmIChjb3VudCA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVjb2RlIGV2ZXJ5IDUgY29kZXdvcmRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBCYXNlIDI1NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEBub3RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogSmF2YVNjcmlwdCBzdG9yZXMgbnVtYmVycyBhcyA2NCBiaXRzIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIGJ1dCBhbGwgYml0d2lzZSBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgb24gMzIgYml0cyBiaW5hcnkgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTbyB0aGUgbmV4dCBiaXR3aXNlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgZG9uZSB3aXRoIHNpbXBsZSBudW1iZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqIC8qaW50Ki8gPSAwOyBqIDwgNjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRCeXRlcy53cml0ZSgvKihieXRlKSovIE51bWJlcihjcmVhdGVCaWdJbnQodmFsdWUpID4+IGNyZWF0ZUJpZ0ludCg4ICogKDUgLSBqKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nRW5jb2RpbmcuZGVjb2RlKGRlY29kZWRCeXRlcy50b0J5dGVBcnJheSgpLCBlbmNvZGluZykpO1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTnVtZXJpYyBDb21wYWN0aW9uIG1vZGUgKHNlZSA1LjQuNCkgcGVybWl0cyBlZmZpY2llbnQgZW5jb2Rpbmcgb2YgbnVtZXJpYyBkYXRhIHN0cmluZ3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb2Rld29yZHMgVGhlIGFycmF5IG9mIGNvZGV3b3JkcyAoZGF0YSArIGVycm9yKVxuICAgICAgICAgKiBAcGFyYW0gY29kZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IGludG8gdGhlIGNvZGV3b3JkIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gcmVzdWx0ICAgIFRoZSBkZWNvZGVkIGRhdGEgaXMgYXBwZW5kZWQgdG8gdGhlIHJlc3VsdC5cbiAgICAgICAgICogQHJldHVybiBUaGUgbmV4dCBpbmRleCBpbnRvIHRoZSBjb2Rld29yZCBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBudW1lcmljQ29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCAvKmludCovLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgZW5kID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbnVtZXJpY0NvZGV3b3JkcyA9IG5ldyBJbnQzMkFycmF5KERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQVhfTlVNRVJJQ19DT0RFV09SRFMpO1xuICAgICAgICAgICAgd2hpbGUgKGNvZGVJbmRleCA8IGNvZGV3b3Jkc1swXSAmJiAhZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlSW5kZXggPT09IGNvZGV3b3Jkc1swXSkge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29kZSA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCkge1xuICAgICAgICAgICAgICAgICAgICBudW1lcmljQ29kZXdvcmRzW2NvdW50XSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSF82OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X0NPTlRST0xfQkxPQ0s6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfVEVSTUlOQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoY291bnQgJSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFYX05VTUVSSUNfQ09ERVdPUkRTID09PSAwIHx8IGNvZGUgPT09IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1FUklDX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCB8fCBlbmQpICYmIGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZS1pbnZva2luZyBOdW1lcmljIENvbXBhY3Rpb24gbW9kZSAoYnkgdXNpbmcgY29kZXdvcmQgOTAyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWxlIGluIE51bWVyaWMgQ29tcGFjdGlvbiBtb2RlKSBzZXJ2ZXMgIHRvIHRlcm1pbmF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBOdW1lcmljIENvbXBhY3Rpb24gbW9kZSBncm91cGluZyBhcyBkZXNjcmliZWQgaW4gNS40LjQuMixcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoZW4gdG8gc3RhcnQgYSBuZXcgb25lIGdyb3VwaW5nLlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5kZWNvZGVCYXNlOTAwdG9CYXNlMTAobnVtZXJpY0NvZGV3b3JkcywgY291bnQpKTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2RlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgYSBsaXN0IG9mIE51bWVyaWMgQ29tcGFjdGVkIGNvZGV3b3JkcyBmcm9tIEJhc2UgOTAwIHRvIEJhc2UgMTAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb2Rld29yZHMgVGhlIGFycmF5IG9mIGNvZGV3b3Jkc1xuICAgICAgICAgKiBAcGFyYW0gY291bnQgICAgIFRoZSBudW1iZXIgb2YgY29kZXdvcmRzXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGRlY29kZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgTnVtZXJpYyBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFWEFNUExFXG4gICAgICAgICAqIEVuY29kZSB0aGUgZmlmdGVlbiBkaWdpdCBudW1lcmljIHN0cmluZyAwMDAyMTMyOTgxNzQwMDBcbiAgICAgICAgICogUHJlZml4IHRoZSBudW1lcmljIHN0cmluZyB3aXRoIGEgMSBhbmQgc2V0IHRoZSBpbml0aWFsIHZhbHVlIG9mXG4gICAgICAgICAqIHQgPSAxIDAwMCAyMTMgMjk4IDE3NCAwMDBcbiAgICAgICAgICogQ2FsY3VsYXRlIGNvZGV3b3JkIDBcbiAgICAgICAgICogZDAgPSAxIDAwMCAyMTMgMjk4IDE3NCAwMDAgbW9kIDkwMCA9IDIwMFxuICAgICAgICAgKlxuICAgICAgICAgKiB0ID0gMSAwMDAgMjEzIDI5OCAxNzQgMDAwIGRpdiA5MDAgPSAxIDExMSAzNDggMTA5IDA4MlxuICAgICAgICAgKiBDYWxjdWxhdGUgY29kZXdvcmQgMVxuICAgICAgICAgKiBkMSA9IDEgMTExIDM0OCAxMDkgMDgyIG1vZCA5MDAgPSAyODJcbiAgICAgICAgICpcbiAgICAgICAgICogdCA9IDEgMTExIDM0OCAxMDkgMDgyIGRpdiA5MDAgPSAxIDIzNCA4MzEgMjMyXG4gICAgICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCAyXG4gICAgICAgICAqIGQyID0gMSAyMzQgODMxIDIzMiBtb2QgOTAwID0gNjMyXG4gICAgICAgICAqXG4gICAgICAgICAqIHQgPSAxIDIzNCA4MzEgMjMyIGRpdiA5MDAgPSAxIDM3MiAwMzRcbiAgICAgICAgICogQ2FsY3VsYXRlIGNvZGV3b3JkIDNcbiAgICAgICAgICogZDMgPSAxIDM3MiAwMzQgbW9kIDkwMCA9IDQzNFxuICAgICAgICAgKlxuICAgICAgICAgKiB0ID0gMSAzNzIgMDM0IGRpdiA5MDAgPSAxIDUyNFxuICAgICAgICAgKiBDYWxjdWxhdGUgY29kZXdvcmQgNFxuICAgICAgICAgKiBkNCA9IDEgNTI0IG1vZCA5MDAgPSA2MjRcbiAgICAgICAgICpcbiAgICAgICAgICogdCA9IDEgNTI0IGRpdiA5MDAgPSAxXG4gICAgICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCA1XG4gICAgICAgICAqIGQ1ID0gMSBtb2QgOTAwID0gMVxuICAgICAgICAgKiB0ID0gMSBkaXYgOTAwID0gMFxuICAgICAgICAgKiBDb2Rld29yZCBzZXF1ZW5jZSBpczogMSwgNjI0LCA0MzQsIDYzMiwgMjgyLCAyMDBcbiAgICAgICAgICpcbiAgICAgICAgICogRGVjb2RlIHRoZSBhYm92ZSBjb2Rld29yZHMgaW52b2x2ZXNcbiAgICAgICAgICogICAxIHggOTAwIHBvd2VyIG9mIDUgKyA2MjQgeCA5MDAgcG93ZXIgb2YgNCArIDQzNCB4IDkwMCBwb3dlciBvZiAzICtcbiAgICAgICAgICogNjMyIHggOTAwIHBvd2VyIG9mIDIgKyAyODIgeCA5MDAgcG93ZXIgb2YgMSArIDIwMCB4IDkwMCBwb3dlciBvZiAwID0gMTAwMDIxMzI5ODE3NDAwMFxuICAgICAgICAgKlxuICAgICAgICAgKiBSZW1vdmUgbGVhZGluZyAxID0+ICBSZXN1bHQgaXMgMDAwMjEzMjk4MTc0MDAwXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlQmFzZTkwMHRvQmFzZTEwKGNvZGV3b3JkcywgY291bnQpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBjcmVhdGVCaWdJbnQoMCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuRVhQOTAwW2NvdW50IC0gaSAtIDFdICogY3JlYXRlQmlnSW50KGNvZGV3b3Jkc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0U3RyaW5nID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0U3RyaW5nLmNoYXJBdCgwKSAhPT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFN0cmluZy5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIID0gOTAwO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCA9IDkwMTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0ggPSA5MDI7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzYgPSA5MjQ7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkVDSV9VU0VSX0RFRklORUQgPSA5MjU7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkVDSV9HRU5FUkFMX1BVUlBPU0UgPSA5MjY7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkVDSV9DSEFSU0VUID0gOTI3O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfQ09OVFJPTF9CTE9DSyA9IDkyODtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEID0gOTIzO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfVEVSTUlOQVRPUiA9IDkyMjtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERSA9IDkxMztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFYX05VTUVSSUNfQ09ERVdPUkRTID0gMTU7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9GSUxFX05BTUUgPSAwO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfU0VHTUVOVF9DT1VOVCA9IDE7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9USU1FX1NUQU1QID0gMjtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX1NFTkRFUiA9IDM7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9BRERSRVNTRUUgPSA0O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfRklMRV9TSVpFID0gNTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0NIRUNLU1VNID0gNjtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUEwgPSAyNTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTEwgPSAyNztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQVMgPSAyNztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUwgPSAyODtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQUwgPSAyODtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUFMgPSAyOTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUEFMID0gMjk7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBVTkNUX0NIQVJTID0gJzs8PkBbXFxcXF1fYH4hXFxyXFx0LDpcXG4tLiQvXCJ8KigpP3t9XFwnJztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUlYRURfQ0hBUlMgPSAnMDEyMzQ1Njc4OSZcXHJcXHQsOiMtLiQvKyUqPV4nO1xuICAgIC8qKlxuICAgICAqIFRhYmxlIGNvbnRhaW5pbmcgdmFsdWVzIGZvciB0aGUgZXhwb25lbnQgb2YgOTAwLlxuICAgICAqIFRoaXMgaXMgdXNlZCBpbiB0aGUgbnVtZXJpYyBjb21wYWN0aW9uIGRlY29kZSBhbGdvcml0aG0uXG4gICAgICovXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkVYUDkwMCA9IGdldEJpZ0ludENvbnN0cnVjdG9yKCkgPyBnZXRFWFA5MDAoKSA6IFtdO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1CRVJfT0ZfU0VRVUVOQ0VfQ09ERVdPUkRTID0gMjtcblxuICAgIC8qXG4gICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgKlxuICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICpcbiAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgKlxuICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0O1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbjtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkZvcm1hdHRlcjtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkxpc3Q7XG4gICAgLyoqXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBQREY0MTdTY2FubmluZ0RlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQFRPRE8gZG9uJ3QgcGFzcyBpbiBtaW5Db2Rld29yZFdpZHRoIGFuZCBtYXhDb2Rld29yZFdpZHRoLCBwYXNzIGluIGJhcmNvZGUgY29sdW1ucyBmb3Igc3RhcnQgYW5kIHN0b3AgcGF0dGVyblxuICAgICAgICAgKlxuICAgICAgICAgKiBjb2x1bW5zLiBUaGF0IHdheSB3aWR0aCBjYW4gYmUgZGVkdWN0ZWQgZnJvbSB0aGUgcGF0dGVybiBjb2x1bW4uXG4gICAgICAgICAqIFRoaXMgYXBwcm9hY2ggYWxzbyBhbGxvd3MgdG8gZGV0ZWN0IG1vcmUgZGV0YWlscyBhYm91dCB0aGUgYmFyY29kZSwgZS5nLiBpZiBhIGJhciB0eXBlICh3aGl0ZSBvciBibGFjaykgaXMgd2lkZXJcbiAgICAgICAgICogdGhhbiBpdCBzaG91bGQgYmUuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgc2Nhbm5lciB1c2VkIGEgYmFkIGJsYWNrcG9pbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBCaXRNYXRyaXhcbiAgICAgICAgICogQHBhcmFtIGltYWdlXG4gICAgICAgICAqIEBwYXJhbSBSZXN1bHRQb2ludFxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VUb3BMZWZ0XG4gICAgICAgICAqIEBwYXJhbSBSZXN1bHRQb2ludFxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VCb3R0b21MZWZ0XG4gICAgICAgICAqIEBwYXJhbSBSZXN1bHRQb2ludFxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VUb3BSaWdodFxuICAgICAgICAgKiBAcGFyYW0gUmVzdWx0UG9pbnRcbiAgICAgICAgICogQHBhcmFtIGltYWdlQm90dG9tUmlnaHRcbiAgICAgICAgICogQHBhcmFtIGludFxuICAgICAgICAgKiBAcGFyYW0gbWluQ29kZXdvcmRXaWR0aFxuICAgICAgICAgKiBAcGFyYW0gaW50XG4gICAgICAgICAqIEBwYXJhbSBtYXhDb2Rld29yZFdpZHRoXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZShpbWFnZSwgaW1hZ2VUb3BMZWZ0LCBpbWFnZUJvdHRvbUxlZnQsIGltYWdlVG9wUmlnaHQsIGltYWdlQm90dG9tUmlnaHQsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpIHtcbiAgICAgICAgICAgIGxldCBib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveChpbWFnZSwgaW1hZ2VUb3BMZWZ0LCBpbWFnZUJvdHRvbUxlZnQsIGltYWdlVG9wUmlnaHQsIGltYWdlQm90dG9tUmlnaHQpO1xuICAgICAgICAgICAgbGV0IGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4gPSBudWxsO1xuICAgICAgICAgICAgbGV0IHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBkZXRlY3Rpb25SZXN1bHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBmaXJzdFBhc3MgLypib29sZWFuKi8gPSB0cnVlOzsgZmlyc3RQYXNzID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VUb3BMZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdFJvd0luZGljYXRvckNvbHVtbiA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRSb3dJbmRpY2F0b3JDb2x1bW4oaW1hZ2UsIGJvdW5kaW5nQm94LCBpbWFnZVRvcExlZnQsIHRydWUsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VUb3BSaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldFJvd0luZGljYXRvckNvbHVtbihpbWFnZSwgYm91bmRpbmdCb3gsIGltYWdlVG9wUmlnaHQsIGZhbHNlLCBtaW5Db2Rld29yZFdpZHRoLCBtYXhDb2Rld29yZFdpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0ID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLm1lcmdlKGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4sIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0aW9uUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgTm90Rm91bmRFeGNlcHRpb24uZ2V0Tm90Rm91bmRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0Qm94ID0gZGV0ZWN0aW9uUmVzdWx0LmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0UGFzcyAmJiByZXN1bHRCb3ggIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Qm94LmdldE1pblkoKSA8IGJvdW5kaW5nQm94LmdldE1pblkoKSB8fCByZXN1bHRCb3guZ2V0TWF4WSgpID4gYm91bmRpbmdCb3guZ2V0TWF4WSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBib3VuZGluZ0JveCA9IHJlc3VsdEJveDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdC5zZXRCb3VuZGluZ0JveChib3VuZGluZ0JveCk7XG4gICAgICAgICAgICBsZXQgbWF4QmFyY29kZUNvbHVtbiA9IGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKSArIDE7XG4gICAgICAgICAgICBkZXRlY3Rpb25SZXN1bHQuc2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKDAsIGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4pO1xuICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0LnNldERldGVjdGlvblJlc3VsdENvbHVtbihtYXhCYXJjb2RlQ29sdW1uLCByaWdodFJvd0luZGljYXRvckNvbHVtbik7XG4gICAgICAgICAgICBsZXQgbGVmdFRvUmlnaHQgPSBsZWZ0Um93SW5kaWNhdG9yQ29sdW1uICE9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBiYXJjb2RlQ29sdW1uQ291bnQgLyppbnQqLyA9IDE7IGJhcmNvZGVDb2x1bW5Db3VudCA8PSBtYXhCYXJjb2RlQ29sdW1uOyBiYXJjb2RlQ29sdW1uQ291bnQrKykge1xuICAgICAgICAgICAgICAgIGxldCBiYXJjb2RlQ29sdW1uID0gbGVmdFRvUmlnaHQgPyBiYXJjb2RlQ29sdW1uQ291bnQgOiBtYXhCYXJjb2RlQ29sdW1uIC0gYmFyY29kZUNvbHVtbkNvdW50O1xuICAgICAgICAgICAgICAgIGlmIChkZXRlY3Rpb25SZXN1bHQuZ2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJhcmNvZGVDb2x1bW4pICE9PSAvKiBudWxsICovIHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgYmUgdGhlIGNhc2UgZm9yIHRoZSBvcHBvc2l0ZSByb3cgaW5kaWNhdG9yIGNvbHVtbiwgd2hpY2ggZG9lc24ndCBuZWVkIHRvIGJlIGRlY29kZWQgYWdhaW4uXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uO1xuICAgICAgICAgICAgICAgIGlmIChiYXJjb2RlQ29sdW1uID09PSAwIHx8IGJhcmNvZGVDb2x1bW4gPT09IG1heEJhcmNvZGVDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uID0gbmV3IERldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbihib3VuZGluZ0JveCwgYmFyY29kZUNvbHVtbiA9PT0gMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXRlY3Rpb25SZXN1bHRDb2x1bW4gPSBuZXcgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0LnNldERldGVjdGlvblJlc3VsdENvbHVtbihiYXJjb2RlQ29sdW1uLCBkZXRlY3Rpb25SZXN1bHRDb2x1bW4pO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydENvbHVtbiA9IC0xO1xuICAgICAgICAgICAgICAgIGxldCBwcmV2aW91c1N0YXJ0Q29sdW1uID0gc3RhcnRDb2x1bW47XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBzdGFydCBhdCBhIHJvdyBmb3Igd2hpY2ggd2Uga25vdyB0aGUgc3RhcnQgcG9zaXRpb24sIHRoZW4gZGV0ZWN0IHVwd2FyZHMgYW5kIGRvd253YXJkcyBmcm9tIHRoZXJlLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGltYWdlUm93IC8qaW50Ki8gPSBib3VuZGluZ0JveC5nZXRNaW5ZKCk7IGltYWdlUm93IDw9IGJvdW5kaW5nQm94LmdldE1heFkoKTsgaW1hZ2VSb3crKykge1xuICAgICAgICAgICAgICAgICAgICBzdGFydENvbHVtbiA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRTdGFydENvbHVtbihkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVDb2x1bW4sIGltYWdlUm93LCBsZWZ0VG9SaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydENvbHVtbiA8IDAgfHwgc3RhcnRDb2x1bW4gPiBib3VuZGluZ0JveC5nZXRNYXhYKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1N0YXJ0Q29sdW1uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBwcmV2aW91c1N0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5kZXRlY3RDb2Rld29yZChpbWFnZSwgYm91bmRpbmdCb3guZ2V0TWluWCgpLCBib3VuZGluZ0JveC5nZXRNYXhYKCksIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3csIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uLnNldENvZGV3b3JkKGltYWdlUm93LCBjb2Rld29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1N0YXJ0Q29sdW1uID0gc3RhcnRDb2x1bW47XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5Db2Rld29yZFdpZHRoID0gTWF0aC5taW4obWluQ29kZXdvcmRXaWR0aCwgY29kZXdvcmQuZ2V0V2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhDb2Rld29yZFdpZHRoID0gTWF0aC5tYXgobWF4Q29kZXdvcmRXaWR0aCwgY29kZXdvcmQuZ2V0V2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNyZWF0ZURlY29kZXJSZXN1bHQoZGV0ZWN0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxlZnRSb3dJbmRpY2F0b3JDb2x1bW5cbiAgICAgICAgICogQHBhcmFtIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBtZXJnZShsZWZ0Um93SW5kaWNhdG9yQ29sdW1uLCByaWdodFJvd0luZGljYXRvckNvbHVtbikge1xuICAgICAgICAgICAgaWYgKGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCAmJiByaWdodFJvd0luZGljYXRvckNvbHVtbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYmFyY29kZU1ldGFkYXRhID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldEJhcmNvZGVNZXRhZGF0YShsZWZ0Um93SW5kaWNhdG9yQ29sdW1uLCByaWdodFJvd0luZGljYXRvckNvbHVtbik7XG4gICAgICAgICAgICBpZiAoYmFyY29kZU1ldGFkYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBib3VuZGluZ0JveCA9IEJvdW5kaW5nQm94Lm1lcmdlKFBERjQxN1NjYW5uaW5nRGVjb2Rlci5hZGp1c3RCb3VuZGluZ0JveChsZWZ0Um93SW5kaWNhdG9yQ29sdW1uKSwgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmFkanVzdEJvdW5kaW5nQm94KHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERldGVjdGlvblJlc3VsdChiYXJjb2RlTWV0YWRhdGEsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvd0luZGljYXRvckNvbHVtblxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYWRqdXN0Qm91bmRpbmdCb3gocm93SW5kaWNhdG9yQ29sdW1uKSB7XG4gICAgICAgICAgICBpZiAocm93SW5kaWNhdG9yQ29sdW1uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByb3dIZWlnaHRzID0gcm93SW5kaWNhdG9yQ29sdW1uLmdldFJvd0hlaWdodHMoKTtcbiAgICAgICAgICAgIGlmIChyb3dIZWlnaHRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtYXhSb3dIZWlnaHQgPSBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0TWF4KHJvd0hlaWdodHMpO1xuICAgICAgICAgICAgbGV0IG1pc3NpbmdTdGFydFJvd3MgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93SGVpZ2h0IC8qaW50Ki8gb2Ygcm93SGVpZ2h0cykge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdTdGFydFJvd3MgKz0gbWF4Um93SGVpZ2h0IC0gcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChyb3dIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb2Rld29yZHMgPSByb3dJbmRpY2F0b3JDb2x1bW4uZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgLyppbnQqLyA9IDA7IG1pc3NpbmdTdGFydFJvd3MgPiAwICYmIGNvZGV3b3Jkc1tyb3ddID09IG51bGw7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ1N0YXJ0Um93cy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1pc3NpbmdFbmRSb3dzID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyAvKmludCovID0gcm93SGVpZ2h0cy5sZW5ndGggLSAxOyByb3cgPj0gMDsgcm93LS0pIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nRW5kUm93cyArPSBtYXhSb3dIZWlnaHQgLSByb3dIZWlnaHRzW3Jvd107XG4gICAgICAgICAgICAgICAgaWYgKHJvd0hlaWdodHNbcm93XSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgcm93IC8qaW50Ki8gPSBjb2Rld29yZHMubGVuZ3RoIC0gMTsgbWlzc2luZ0VuZFJvd3MgPiAwICYmIGNvZGV3b3Jkc1tyb3ddID09IG51bGw7IHJvdy0tKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ0VuZFJvd3MtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3dJbmRpY2F0b3JDb2x1bW4uZ2V0Qm91bmRpbmdCb3goKS5hZGRNaXNzaW5nUm93cyhtaXNzaW5nU3RhcnRSb3dzLCBtaXNzaW5nRW5kUm93cywgcm93SW5kaWNhdG9yQ29sdW1uLmlzTGVmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0TWF4KHZhbHVlcykge1xuICAgICAgICAgICAgbGV0IG1heFZhbHVlID0gLTE7XG4gICAgICAgICAgICBmb3IgKGxldCB2YWx1ZSAvKmludCovIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gTWF0aC5tYXgobWF4VmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXhWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0QmFyY29kZU1ldGFkYXRhKGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4sIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uKSB7XG4gICAgICAgICAgICBsZXQgbGVmdEJhcmNvZGVNZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChsZWZ0Um93SW5kaWNhdG9yQ29sdW1uID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAobGVmdEJhcmNvZGVNZXRhZGF0YSA9IGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4uZ2V0QmFyY29kZU1ldGFkYXRhKCkpID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiByaWdodFJvd0luZGljYXRvckNvbHVtbi5nZXRCYXJjb2RlTWV0YWRhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByaWdodEJhcmNvZGVNZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChyaWdodFJvd0luZGljYXRvckNvbHVtbiA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKHJpZ2h0QmFyY29kZU1ldGFkYXRhID0gcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4uZ2V0QmFyY29kZU1ldGFkYXRhKCkpID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdEJhcmNvZGVNZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0QmFyY29kZU1ldGFkYXRhLmdldENvbHVtbkNvdW50KCkgIT09IHJpZ2h0QmFyY29kZU1ldGFkYXRhLmdldENvbHVtbkNvdW50KCkgJiZcbiAgICAgICAgICAgICAgICBsZWZ0QmFyY29kZU1ldGFkYXRhLmdldEVycm9yQ29ycmVjdGlvbkxldmVsKCkgIT09IHJpZ2h0QmFyY29kZU1ldGFkYXRhLmdldEVycm9yQ29ycmVjdGlvbkxldmVsKCkgJiZcbiAgICAgICAgICAgICAgICBsZWZ0QmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCkgIT09IHJpZ2h0QmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZWZ0QmFyY29kZU1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRSb3dJbmRpY2F0b3JDb2x1bW4oaW1hZ2UsIGJvdW5kaW5nQm94LCBzdGFydFBvaW50LCBsZWZ0VG9SaWdodCwgbWluQ29kZXdvcmRXaWR0aCwgbWF4Q29kZXdvcmRXaWR0aCkge1xuICAgICAgICAgICAgbGV0IHJvd0luZGljYXRvckNvbHVtbiA9IG5ldyBEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW4oYm91bmRpbmdCb3gsIGxlZnRUb1JpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5jcmVtZW50ID0gaSA9PT0gMCA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRDb2x1bW4gPSBNYXRoLnRydW5jKE1hdGgudHJ1bmMoc3RhcnRQb2ludC5nZXRYKCkpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbWFnZVJvdyAvKmludCovID0gTWF0aC50cnVuYyhNYXRoLnRydW5jKHN0YXJ0UG9pbnQuZ2V0WSgpKSk7IGltYWdlUm93IDw9IGJvdW5kaW5nQm94LmdldE1heFkoKSAmJlxuICAgICAgICAgICAgICAgICAgICBpbWFnZVJvdyA+PSBib3VuZGluZ0JveC5nZXRNaW5ZKCk7IGltYWdlUm93ICs9IGluY3JlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmQgPSBQREY0MTdTY2FubmluZ0RlY29kZXIuZGV0ZWN0Q29kZXdvcmQoaW1hZ2UsIDAsIGltYWdlLmdldFdpZHRoKCksIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3csIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93SW5kaWNhdG9yQ29sdW1uLnNldENvZGV3b3JkKGltYWdlUm93LCBjb2Rld29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFRvUmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydENvbHVtbiA9IGNvZGV3b3JkLmdldFN0YXJ0WCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBjb2Rld29yZC5nZXRFbmRYKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93SW5kaWNhdG9yQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGV0ZWN0aW9uUmVzdWx0XG4gICAgICAgICAqIEBwYXJhbSBCYXJjb2RlVmFsdWVcbiAgICAgICAgICogQHBhcmFtIHBhcmFtMlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW0zXG4gICAgICAgICAqIEBwYXJhbSBiYXJjb2RlTWF0cml4XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhZGp1c3RDb2Rld29yZENvdW50KGRldGVjdGlvblJlc3VsdCwgYmFyY29kZU1hdHJpeCkge1xuICAgICAgICAgICAgbGV0IGJhcmNvZGVNYXRyaXgwMSA9IGJhcmNvZGVNYXRyaXhbMF1bMV07XG4gICAgICAgICAgICBsZXQgbnVtYmVyT2ZDb2Rld29yZHMgPSBiYXJjb2RlTWF0cml4MDEuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGxldCBjYWxjdWxhdGVkTnVtYmVyT2ZDb2Rld29yZHMgPSBkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUNvbHVtbkNvdW50KCkgKlxuICAgICAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlUm93Q291bnQoKSAtXG4gICAgICAgICAgICAgICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldE51bWJlck9mRUNDb2RlV29yZHMoZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVFQ0xldmVsKCkpO1xuICAgICAgICAgICAgaWYgKG51bWJlck9mQ29kZXdvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChjYWxjdWxhdGVkTnVtYmVyT2ZDb2Rld29yZHMgPCAxIHx8IGNhbGN1bGF0ZWROdW1iZXJPZkNvZGV3b3JkcyA+IFBERjQxN0NvbW1vbi5NQVhfQ09ERVdPUkRTX0lOX0JBUkNPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgTm90Rm91bmRFeGNlcHRpb24uZ2V0Tm90Rm91bmRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYXJjb2RlTWF0cml4MDEuc2V0VmFsdWUoY2FsY3VsYXRlZE51bWJlck9mQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG51bWJlck9mQ29kZXdvcmRzWzBdICE9PSBjYWxjdWxhdGVkTnVtYmVyT2ZDb2Rld29yZHMpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FsY3VsYXRlZCBvbmUgaXMgbW9yZSByZWxpYWJsZSBhcyBpdCBpcyBkZXJpdmVkIGZyb20gdGhlIHJvdyBpbmRpY2F0b3IgY29sdW1uc1xuICAgICAgICAgICAgICAgIGJhcmNvZGVNYXRyaXgwMS5zZXRWYWx1ZShjYWxjdWxhdGVkTnVtYmVyT2ZDb2Rld29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGV0ZWN0aW9uUmVzdWx0XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNyZWF0ZURlY29kZXJSZXN1bHQoZGV0ZWN0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICBsZXQgYmFyY29kZU1hdHJpeCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5jcmVhdGVCYXJjb2RlTWF0cml4KGRldGVjdGlvblJlc3VsdCk7XG4gICAgICAgICAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuYWRqdXN0Q29kZXdvcmRDb3VudChkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVNYXRyaXgpO1xuICAgICAgICAgICAgbGV0IGVyYXN1cmVzIC8qQ29sbGVjdGlvbjxJbnRlZ2VyPiovID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICBsZXQgY29kZXdvcmRzID0gbmV3IEludDMyQXJyYXkoZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVSb3dDb3VudCgpICogZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpKTtcbiAgICAgICAgICAgIGxldCBhbWJpZ3VvdXNJbmRleFZhbHVlc0xpc3QgPSAvKkxpc3Q8aW50W10+Ki8gW107XG4gICAgICAgICAgICBsZXQgYW1iaWd1b3VzSW5kZXhlc0xpc3QgPSAvKkNvbGxlY3Rpb248SW50ZWdlcj4qLyBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyAvKmludCovID0gMDsgcm93IDwgZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVSb3dDb3VudCgpOyByb3crKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbHVtbiAvKmludCovID0gMDsgY29sdW1uIDwgZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gYmFyY29kZU1hdHJpeFtyb3ddW2NvbHVtbiArIDFdLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZEluZGV4ID0gcm93ICogZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpICsgY29sdW1uO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJhc3VyZXMucHVzaChjb2Rld29yZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRJbmRleF0gPSB2YWx1ZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbWJpZ3VvdXNJbmRleGVzTGlzdC5wdXNoKGNvZGV3b3JkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW1iaWd1b3VzSW5kZXhWYWx1ZXNMaXN0LnB1c2godmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhbWJpZ3VvdXNJbmRleFZhbHVlcyA9IG5ldyBBcnJheShhbWJpZ3VvdXNJbmRleFZhbHVlc0xpc3QubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBhbWJpZ3VvdXNJbmRleFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFtYmlndW91c0luZGV4VmFsdWVzW2ldID0gYW1iaWd1b3VzSW5kZXhWYWx1ZXNMaXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5jcmVhdGVEZWNvZGVyUmVzdWx0RnJvbUFtYmlndW91c1ZhbHVlcyhkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUVDTGV2ZWwoKSwgY29kZXdvcmRzLCBQREY0MTdDb21tb24udG9JbnRBcnJheShlcmFzdXJlcyksIFBERjQxN0NvbW1vbi50b0ludEFycmF5KGFtYmlndW91c0luZGV4ZXNMaXN0KSwgYW1iaWd1b3VzSW5kZXhWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBkZWFscyB3aXRoIHRoZSBmYWN0LCB0aGF0IHRoZSBkZWNvZGluZyBwcm9jZXNzIGRvZXNuJ3QgYWx3YXlzIHlpZWxkIGEgc2luZ2xlIG1vc3QgbGlrZWx5IHZhbHVlLiBUaGVcbiAgICAgICAgICogY3VycmVudCBlcnJvciBjb3JyZWN0aW9uIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgZGVhbCB3aXRoIGVyYXN1cmVzIHZlcnkgd2VsbCwgc28gaXQncyBiZXR0ZXIgdG8gcHJvdmlkZSBhIHZhbHVlXG4gICAgICAgICAqIGZvciB0aGVzZSBhbWJpZ3VvdXMgY29kZXdvcmRzIGluc3RlYWQgb2YgdHJlYXRpbmcgaXQgYXMgYW4gZXJhc3VyZS4gVGhlIHByb2JsZW0gaXMgdGhhdCB3ZSBkb24ndCBrbm93IHdoaWNoIG9mXG4gICAgICAgICAqIHRoZSBhbWJpZ3VvdXMgdmFsdWVzIHRvIGNob29zZS4gV2UgdHJ5IGRlY29kZSB1c2luZyB0aGUgZmlyc3QgdmFsdWUsIGFuZCBpZiB0aGF0IGZhaWxzLCB3ZSB1c2UgYW5vdGhlciBvZiB0aGVcbiAgICAgICAgICogYW1iaWd1b3VzIHZhbHVlcyBhbmQgdHJ5IHRvIGRlY29kZSBhZ2Fpbi4gVGhpcyB1c3VhbGx5IG9ubHkgaGFwcGVucyBvbiB2ZXJ5IGhhcmQgdG8gcmVhZCBhbmQgZGVjb2RlIGJhcmNvZGVzLFxuICAgICAgICAgKiBzbyBkZWNvZGluZyB0aGUgbm9ybWFsIGJhcmNvZGVzIGlzIG5vdCBhZmZlY3RlZCBieSB0aGlzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZXJhc3VyZUFycmF5IGNvbnRhaW5zIHRoZSBpbmRleGVzIG9mIGVyYXN1cmVzXG4gICAgICAgICAqIEBwYXJhbSBhbWJpZ3VvdXNJbmRleGVzIGFycmF5IHdpdGggdGhlIGluZGV4ZXMgdGhhdCBoYXZlIG1vcmUgdGhhbiBvbmUgbW9zdCBsaWtlbHkgdmFsdWVcbiAgICAgICAgICogQHBhcmFtIGFtYmlndW91c0luZGV4VmFsdWVzIHR3byBkaW1lbnNpb25hbCBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBhbWJpZ3VvdXMgdmFsdWVzLiBUaGUgZmlyc3QgZGltZW5zaW9uIG11c3RcbiAgICAgICAgICogYmUgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBhbWJpZ3VvdXNJbmRleGVzIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjcmVhdGVEZWNvZGVyUmVzdWx0RnJvbUFtYmlndW91c1ZhbHVlcyhlY0xldmVsLCBjb2Rld29yZHMsIGVyYXN1cmVBcnJheSwgYW1iaWd1b3VzSW5kZXhlcywgYW1iaWd1b3VzSW5kZXhWYWx1ZXMpIHtcbiAgICAgICAgICAgIGxldCBhbWJpZ3VvdXNJbmRleENvdW50ID0gbmV3IEludDMyQXJyYXkoYW1iaWd1b3VzSW5kZXhlcy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IHRyaWVzID0gMTAwO1xuICAgICAgICAgICAgd2hpbGUgKHRyaWVzLS0gPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IGFtYmlndW91c0luZGV4Q291bnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzW2FtYmlndW91c0luZGV4ZXNbaV1dID0gYW1iaWd1b3VzSW5kZXhWYWx1ZXNbaV1bYW1iaWd1b3VzSW5kZXhDb3VudFtpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQREY0MTdTY2FubmluZ0RlY29kZXIuZGVjb2RlQ29kZXdvcmRzKGNvZGV3b3JkcywgZWNMZXZlbCwgZXJhc3VyZUFycmF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaWdub3JlZCA9IGVyciBpbnN0YW5jZW9mIENoZWNrc3VtRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYW1iaWd1b3VzSW5kZXhDb3VudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb24uZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgYW1iaWd1b3VzSW5kZXhDb3VudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW1iaWd1b3VzSW5kZXhDb3VudFtpXSA8IGFtYmlndW91c0luZGV4VmFsdWVzW2ldLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtYmlndW91c0luZGV4Q291bnRbaV0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW1iaWd1b3VzSW5kZXhDb3VudFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gYW1iaWd1b3VzSW5kZXhDb3VudC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb24uZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb24uZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjcmVhdGVCYXJjb2RlTWF0cml4KGRldGVjdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgLy8gbGV0IGJhcmNvZGVNYXRyaXg6IEJhcmNvZGVWYWx1ZVtdW10gPVxuICAgICAgICAgICAgLy8gbmV3IEJhcmNvZGVWYWx1ZVtkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZVJvd0NvdW50KCldW2RldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKSArIDJdO1xuICAgICAgICAgICAgbGV0IGJhcmNvZGVNYXRyaXggPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZVJvd0NvdW50KCkgfSwgKCkgPT4gbmV3IEFycmF5KGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKSArIDIpKTtcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyAvKmludCovID0gMDsgcm93IDwgYmFyY29kZU1hdHJpeC5sZW5ndGg7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29sdW1uIC8qaW50Ki8gPSAwOyBjb2x1bW4gPCBiYXJjb2RlTWF0cml4W3Jvd10ubGVuZ3RoOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgICAgICAgICBiYXJjb2RlTWF0cml4W3Jvd11bY29sdW1uXSA9IG5ldyBCYXJjb2RlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY29sdW1uID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGRldGVjdGlvblJlc3VsdENvbHVtbiAvKkRldGVjdGlvblJlc3VsdENvbHVtbiovIG9mIGRldGVjdGlvblJlc3VsdC5nZXREZXRlY3Rpb25SZXN1bHRDb2x1bW5zKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0aW9uUmVzdWx0Q29sdW1uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZXdvcmQgLypDb2Rld29yZCovIG9mIGRldGVjdGlvblJlc3VsdENvbHVtbi5nZXRDb2Rld29yZHMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcm93TnVtYmVyID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd051bWJlciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3dOdW1iZXIgPj0gYmFyY29kZU1hdHJpeC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgbW9yZSByb3dzIHRoYW4gdGhlIGJhcmNvZGUgbWV0YWRhdGEgYWxsb3dzIGZvciwgaWdub3JlIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2RlTWF0cml4W3Jvd051bWJlcl1bY29sdW1uXS5zZXRWYWx1ZShjb2Rld29yZC5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sdW1uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFyY29kZU1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXNWYWxpZEJhcmNvZGVDb2x1bW4oZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFyY29kZUNvbHVtbiA+PSAwICYmIGJhcmNvZGVDb2x1bW4gPD0gZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0U3RhcnRDb2x1bW4oZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlQ29sdW1uLCBpbWFnZVJvdywgbGVmdFRvUmlnaHQpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSBsZWZ0VG9SaWdodCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmlzVmFsaWRCYXJjb2RlQ29sdW1uKGRldGVjdGlvblJlc3VsdCwgYmFyY29kZUNvbHVtbiAtIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZCA9IGRldGVjdGlvblJlc3VsdC5nZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oYmFyY29kZUNvbHVtbiAtIG9mZnNldCkuZ2V0Q29kZXdvcmQoaW1hZ2VSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFRvUmlnaHQgPyBjb2Rld29yZC5nZXRFbmRYKCkgOiBjb2Rld29yZC5nZXRTdGFydFgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGV3b3JkID0gZGV0ZWN0aW9uUmVzdWx0LmdldERldGVjdGlvblJlc3VsdENvbHVtbihiYXJjb2RlQ29sdW1uKS5nZXRDb2Rld29yZE5lYXJieShpbWFnZVJvdyk7XG4gICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0VG9SaWdodCA/IGNvZGV3b3JkLmdldFN0YXJ0WCgpIDogY29kZXdvcmQuZ2V0RW5kWCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFBERjQxN1NjYW5uaW5nRGVjb2Rlci5pc1ZhbGlkQmFyY29kZUNvbHVtbihkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVDb2x1bW4gLSBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgY29kZXdvcmQgPSBkZXRlY3Rpb25SZXN1bHQuZ2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJhcmNvZGVDb2x1bW4gLSBvZmZzZXQpLmdldENvZGV3b3JkTmVhcmJ5KGltYWdlUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRUb1JpZ2h0ID8gY29kZXdvcmQuZ2V0RW5kWCgpIDogY29kZXdvcmQuZ2V0U3RhcnRYKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2tpcHBlZENvbHVtbnMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKFBERjQxN1NjYW5uaW5nRGVjb2Rlci5pc1ZhbGlkQmFyY29kZUNvbHVtbihkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVDb2x1bW4gLSBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgYmFyY29kZUNvbHVtbiAtPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcHJldmlvdXNSb3dDb2Rld29yZCAvKkNvZGV3b3JkKi8gb2YgZGV0ZWN0aW9uUmVzdWx0LmdldERldGVjdGlvblJlc3VsdENvbHVtbihiYXJjb2RlQ29sdW1uKS5nZXRDb2Rld29yZHMoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNSb3dDb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGxlZnRUb1JpZ2h0ID8gcHJldmlvdXNSb3dDb2Rld29yZC5nZXRFbmRYKCkgOiBwcmV2aW91c1Jvd0NvZGV3b3JkLmdldFN0YXJ0WCgpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZENvbHVtbnMgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJldmlvdXNSb3dDb2Rld29yZC5nZXRFbmRYKCkgLSBwcmV2aW91c1Jvd0NvZGV3b3JkLmdldFN0YXJ0WCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwcGVkQ29sdW1ucysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxlZnRUb1JpZ2h0ID8gZGV0ZWN0aW9uUmVzdWx0LmdldEJvdW5kaW5nQm94KCkuZ2V0TWluWCgpIDogZGV0ZWN0aW9uUmVzdWx0LmdldEJvdW5kaW5nQm94KCkuZ2V0TWF4WCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZXRlY3RDb2Rld29yZChpbWFnZSwgbWluQ29sdW1uLCBtYXhDb2x1bW4sIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3csIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpIHtcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmFkanVzdENvZGV3b3JkU3RhcnRDb2x1bW4oaW1hZ2UsIG1pbkNvbHVtbiwgbWF4Q29sdW1uLCBsZWZ0VG9SaWdodCwgc3RhcnRDb2x1bW4sIGltYWdlUm93KTtcbiAgICAgICAgICAgIC8vIHdlIHVzdWFsbHkga25vdyBmYWlybHkgZXhhY3Qgbm93IGhvdyBsb25nIGEgY29kZXdvcmQgaXMuIFdlIHNob3VsZCBwcm92aWRlIG1pbmltdW0gYW5kIG1heGltdW0gZXhwZWN0ZWQgbGVuZ3RoXG4gICAgICAgICAgICAvLyBhbmQgdHJ5IHRvIGFkanVzdCB0aGUgcmVhZCBwaXhlbHMsIGUuZy4gcmVtb3ZlIHNpbmdsZSBwaXhlbCBlcnJvcnMgb3IgdHJ5IHRvIGN1dCBvZmYgZXhjZWVkaW5nIHBpeGVscy5cbiAgICAgICAgICAgIC8vIG1pbiBhbmQgbWF4Q29kZXdvcmRXaWR0aCBzaG91bGQgbm90IGJlIHVzZWQgYXMgdGhleSBhcmUgY2FsY3VsYXRlZCBmb3IgdGhlIHdob2xlIGJhcmNvZGUgYW4gY2FuIGJlIGluYWNjdXJhdGVcbiAgICAgICAgICAgIC8vIGZvciB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgICAgbGV0IG1vZHVsZUJpdENvdW50ID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldE1vZHVsZUJpdENvdW50KGltYWdlLCBtaW5Db2x1bW4sIG1heENvbHVtbiwgbGVmdFRvUmlnaHQsIHN0YXJ0Q29sdW1uLCBpbWFnZVJvdyk7XG4gICAgICAgICAgICBpZiAobW9kdWxlQml0Q291bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVuZENvbHVtbjtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZEJpdENvdW50ID0gTWF0aFV0aWxzLnN1bShtb2R1bGVCaXRDb3VudCk7XG4gICAgICAgICAgICBpZiAobGVmdFRvUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW4gPSBzdGFydENvbHVtbiArIGNvZGV3b3JkQml0Q291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgbW9kdWxlQml0Q291bnQubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0bXBDb3VudCA9IG1vZHVsZUJpdENvdW50W2ldO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVCaXRDb3VudFtpXSA9IG1vZHVsZUJpdENvdW50W21vZHVsZUJpdENvdW50Lmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlQml0Q291bnRbbW9kdWxlQml0Q291bnQubGVuZ3RoIC0gMSAtIGldID0gdG1wQ291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuZENvbHVtbiA9IHN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gZW5kQ29sdW1uIC0gY29kZXdvcmRCaXRDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IGNoZWNrIGZvciB3aWR0aCBhbmQgY29ycmVjdGlvbiBvZiBibGFjayBhbmQgd2hpdGUgYmFyc1xuICAgICAgICAgICAgLy8gdXNlIHN0YXJ0IChhbmQgbWF5YmUgc3RvcCBwYXR0ZXJuKSB0byBkZXRlcm1pbmUgaWYgYmxhY2sgYmFycyBhcmUgd2lkZXIgdGhhbiB3aGl0ZSBiYXJzLiBJZiBzbywgYWRqdXN0LlxuICAgICAgICAgICAgLy8gc2hvdWxkIHByb2JhYmx5IGRvbmUgb25seSBmb3IgY29kZXdvcmRzIHdpdGggYSBsb3QgbW9yZSB0aGFuIDE3IGJpdHMuXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGZpeGVzIDEwLTEucG5nLCB3aGljaCBoYXMgd2lkZSBibGFjayBiYXJzIGFuZCBzbWFsbCB3aGl0ZSBiYXJzXG4gICAgICAgICAgICAvLyAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgbW9kdWxlQml0Q291bnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgbW9kdWxlQml0Q291bnRbaV0tLTtcbiAgICAgICAgICAgIC8vICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICAgICAgICBtb2R1bGVCaXRDb3VudFtpXSsrO1xuICAgICAgICAgICAgLy8gICAgICB9XG4gICAgICAgICAgICAvLyAgICB9XG4gICAgICAgICAgICAvLyBXZSBjb3VsZCBhbHNvIHVzZSB0aGUgd2lkdGggb2Ygc3Vycm91bmRpbmcgY29kZXdvcmRzIGZvciBtb3JlIGFjY3VyYXRlIHJlc3VsdHMsIGJ1dCB0aGlzIHNlZW1zXG4gICAgICAgICAgICAvLyBzdWZmaWNpZW50IGZvciBub3dcbiAgICAgICAgICAgIGlmICghUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNoZWNrQ29kZXdvcmRTa2V3KGNvZGV3b3JkQml0Q291bnQsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY291bGQgdHJ5IHRvIHVzZSB0aGUgc3RhcnRYIGFuZCBlbmRYIHBvc2l0aW9uIG9mIHRoZSBjb2Rld29yZCBpbiB0aGUgc2FtZSBjb2x1bW4gaW4gdGhlIHByZXZpb3VzIHJvdyxcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGJpdCBjb3VudCBmcm9tIGl0IGFuZCBub3JtYWxpemUgaXQgdG8gOC4gVGhpcyB3b3VsZCBoZWxwIHdpdGggc2luZ2xlIHBpeGVsIGVycm9ycy5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkZWNvZGVkVmFsdWUgPSBQREY0MTdDb2Rld29yZERlY29kZXIuZ2V0RGVjb2RlZFZhbHVlKG1vZHVsZUJpdENvdW50KTtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IFBERjQxN0NvbW1vbi5nZXRDb2Rld29yZChkZWNvZGVkVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNvZGV3b3JkID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2Rld29yZChzdGFydENvbHVtbiwgZW5kQ29sdW1uLCBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXIoZGVjb2RlZFZhbHVlKSwgY29kZXdvcmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRNb2R1bGVCaXRDb3VudChpbWFnZSwgbWluQ29sdW1uLCBtYXhDb2x1bW4sIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3cpIHtcbiAgICAgICAgICAgIGxldCBpbWFnZUNvbHVtbiA9IHN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgbGV0IG1vZHVsZUJpdENvdW50ID0gbmV3IEludDMyQXJyYXkoOCk7XG4gICAgICAgICAgICBsZXQgbW9kdWxlTnVtYmVyID0gMDtcbiAgICAgICAgICAgIGxldCBpbmNyZW1lbnQgPSBsZWZ0VG9SaWdodCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGxldCBwcmV2aW91c1BpeGVsVmFsdWUgPSBsZWZ0VG9SaWdodDtcbiAgICAgICAgICAgIHdoaWxlICgobGVmdFRvUmlnaHQgPyBpbWFnZUNvbHVtbiA8IG1heENvbHVtbiA6IGltYWdlQ29sdW1uID49IG1pbkNvbHVtbikgJiZcbiAgICAgICAgICAgICAgICBtb2R1bGVOdW1iZXIgPCBtb2R1bGVCaXRDb3VudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGltYWdlQ29sdW1uLCBpbWFnZVJvdykgPT09IHByZXZpb3VzUGl4ZWxWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVCaXRDb3VudFttb2R1bGVOdW1iZXJdKys7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlQ29sdW1uICs9IGluY3JlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU51bWJlcisrO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1BpeGVsVmFsdWUgPSAhcHJldmlvdXNQaXhlbFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2R1bGVOdW1iZXIgPT09IG1vZHVsZUJpdENvdW50Lmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICgoaW1hZ2VDb2x1bW4gPT09IChsZWZ0VG9SaWdodCA/IG1heENvbHVtbiA6IG1pbkNvbHVtbikpICYmXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU51bWJlciA9PT0gbW9kdWxlQml0Q291bnQubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlQml0Q291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0TnVtYmVyT2ZFQ0NvZGVXb3JkcyhiYXJjb2RlRUNMZXZlbCkge1xuICAgICAgICAgICAgcmV0dXJuIDIgPDwgYmFyY29kZUVDTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFkanVzdENvZGV3b3JkU3RhcnRDb2x1bW4oaW1hZ2UsIG1pbkNvbHVtbiwgbWF4Q29sdW1uLCBsZWZ0VG9SaWdodCwgY29kZXdvcmRTdGFydENvbHVtbiwgaW1hZ2VSb3cpIHtcbiAgICAgICAgICAgIGxldCBjb3JyZWN0ZWRTdGFydENvbHVtbiA9IGNvZGV3b3JkU3RhcnRDb2x1bW47XG4gICAgICAgICAgICBsZXQgaW5jcmVtZW50ID0gbGVmdFRvUmlnaHQgPyAtMSA6IDE7XG4gICAgICAgICAgICAvLyB0aGVyZSBzaG91bGQgYmUgbm8gYmxhY2sgcGl4ZWxzIGJlZm9yZSB0aGUgc3RhcnQgY29sdW1uLiBJZiB0aGVyZSBhcmUsIHRoZW4gd2UgbmVlZCB0byBzdGFydCBlYXJsaWVyLlxuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgICAgIHdoaWxlICgobGVmdFRvUmlnaHQgPyBjb3JyZWN0ZWRTdGFydENvbHVtbiA+PSBtaW5Db2x1bW4gOiBjb3JyZWN0ZWRTdGFydENvbHVtbiA8IG1heENvbHVtbikgJiZcbiAgICAgICAgICAgICAgICAgICAgbGVmdFRvUmlnaHQgPT09IGltYWdlLmdldChjb3JyZWN0ZWRTdGFydENvbHVtbiwgaW1hZ2VSb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjb2Rld29yZFN0YXJ0Q29sdW1uIC0gY29ycmVjdGVkU3RhcnRDb2x1bW4pID4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLkNPREVXT1JEX1NLRVdfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGV3b3JkU3RhcnRDb2x1bW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29ycmVjdGVkU3RhcnRDb2x1bW4gKz0gaW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmNyZW1lbnQgPSAtaW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIGxlZnRUb1JpZ2h0ID0gIWxlZnRUb1JpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvcnJlY3RlZFN0YXJ0Q29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjaGVja0NvZGV3b3JkU2tldyhjb2Rld29yZFNpemUsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW5Db2Rld29yZFdpZHRoIC0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLkNPREVXT1JEX1NLRVdfU0laRSA8PSBjb2Rld29yZFNpemUgJiZcbiAgICAgICAgICAgICAgICBjb2Rld29yZFNpemUgPD0gbWF4Q29kZXdvcmRXaWR0aCArIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5DT0RFV09SRF9TS0VXX1NJWkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uLFxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlQ29kZXdvcmRzKGNvZGV3b3JkcywgZWNMZXZlbCwgZXJhc3VyZXMpIHtcbiAgICAgICAgICAgIGlmIChjb2Rld29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbnVtRUNDb2Rld29yZHMgPSAxIDw8IChlY0xldmVsICsgMSk7XG4gICAgICAgICAgICBsZXQgY29ycmVjdGVkRXJyb3JzQ291bnQgPSBQREY0MTdTY2FubmluZ0RlY29kZXIuY29ycmVjdEVycm9ycyhjb2Rld29yZHMsIGVyYXN1cmVzLCBudW1FQ0NvZGV3b3Jkcyk7XG4gICAgICAgICAgICBQREY0MTdTY2FubmluZ0RlY29kZXIudmVyaWZ5Q29kZXdvcmRDb3VudChjb2Rld29yZHMsIG51bUVDQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIC8vIERlY29kZSB0aGUgY29kZXdvcmRzXG4gICAgICAgICAgICBsZXQgZGVjb2RlclJlc3VsdCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5kZWNvZGUoY29kZXdvcmRzLCAnJyArIGVjTGV2ZWwpO1xuICAgICAgICAgICAgZGVjb2RlclJlc3VsdC5zZXRFcnJvcnNDb3JyZWN0ZWQoY29ycmVjdGVkRXJyb3JzQ291bnQpO1xuICAgICAgICAgICAgZGVjb2RlclJlc3VsdC5zZXRFcmFzdXJlcyhlcmFzdXJlcy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkdpdmVuIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzIHJlY2VpdmVkLCBwb3NzaWJseSBjb3JydXB0ZWQgYnkgZXJyb3JzLCBhdHRlbXB0cyB0b1xuICAgICAgICAgKiBjb3JyZWN0IHRoZSBlcnJvcnMgaW4tcGxhY2UuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY29kZXdvcmRzICAgZGF0YSBhbmQgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHNcbiAgICAgICAgICogQHBhcmFtIGVyYXN1cmVzIHBvc2l0aW9ucyBvZiBhbnkga25vd24gZXJhc3VyZXNcbiAgICAgICAgICogQHBhcmFtIG51bUVDQ29kZXdvcmRzIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3JkcyB0aGF0IGFyZSBhdmFpbGFibGUgaW4gY29kZXdvcmRzXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNvcnJlY3RFcnJvcnMoY29kZXdvcmRzLCBlcmFzdXJlcywgbnVtRUNDb2Rld29yZHMpIHtcbiAgICAgICAgICAgIGlmIChlcmFzdXJlcyAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgZXJhc3VyZXMubGVuZ3RoID4gbnVtRUNDb2Rld29yZHMgLyAyICsgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLk1BWF9FUlJPUlMgfHxcbiAgICAgICAgICAgICAgICBudW1FQ0NvZGV3b3JkcyA8IDAgfHxcbiAgICAgICAgICAgICAgICBudW1FQ0NvZGV3b3JkcyA+IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5NQVhfRUNfQ09ERVdPUkRTKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9vIG1hbnkgZXJyb3JzIG9yIEVDIENvZGV3b3JkcyBpcyBjb3JydXB0ZWRcbiAgICAgICAgICAgICAgICB0aHJvdyBDaGVja3N1bUV4Y2VwdGlvbi5nZXRDaGVja3N1bUluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmVycm9yQ29ycmVjdGlvbi5kZWNvZGUoY29kZXdvcmRzLCBudW1FQ0NvZGV3b3JkcywgZXJhc3VyZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZnkgdGhhdCBhbGwgaXMgT0sgd2l0aCB0aGUgY29kZXdvcmQgYXJyYXkuXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgdmVyaWZ5Q29kZXdvcmRDb3VudChjb2Rld29yZHMsIG51bUVDQ29kZXdvcmRzKSB7XG4gICAgICAgICAgICBpZiAoY29kZXdvcmRzLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBDb2Rld29yZCBhcnJheSBzaXplIHNob3VsZCBiZSBhdCBsZWFzdCA0IGFsbG93aW5nIGZvclxuICAgICAgICAgICAgICAgIC8vIENvdW50IENXLCBBdCBsZWFzdCBvbmUgRGF0YSBDVywgRXJyb3IgQ29ycmVjdGlvbiBDVywgRXJyb3IgQ29ycmVjdGlvbiBDV1xuICAgICAgICAgICAgICAgIHRocm93IEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGNvZGV3b3JkLCB0aGUgU3ltYm9sIExlbmd0aCBEZXNjcmlwdG9yLCBzaGFsbCBhbHdheXMgZW5jb2RlIHRoZSB0b3RhbCBudW1iZXIgb2YgZGF0YVxuICAgICAgICAgICAgLy8gY29kZXdvcmRzIGluIHRoZSBzeW1ib2wsIGluY2x1ZGluZyB0aGUgU3ltYm9sIExlbmd0aCBEZXNjcmlwdG9yIGl0c2VsZiwgZGF0YSBjb2Rld29yZHMgYW5kIHBhZFxuICAgICAgICAgICAgLy8gY29kZXdvcmRzLCBidXQgZXhjbHVkaW5nIHRoZSBudW1iZXIgb2YgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHMuXG4gICAgICAgICAgICBsZXQgbnVtYmVyT2ZDb2Rld29yZHMgPSBjb2Rld29yZHNbMF07XG4gICAgICAgICAgICBpZiAobnVtYmVyT2ZDb2Rld29yZHMgPiBjb2Rld29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVtYmVyT2ZDb2Rld29yZHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSAtIDggKEFsbG93IGZvciBhdCBsZWFzdCBsZXZlbCAzIEVycm9yIENvcnJlY3Rpb24gKDggRXJyb3IgQ29kZXdvcmRzKVxuICAgICAgICAgICAgICAgIGlmIChudW1FQ0NvZGV3b3JkcyA8IGNvZGV3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzWzBdID0gY29kZXdvcmRzLmxlbmd0aCAtIG51bUVDQ29kZXdvcmRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRCaXRDb3VudEZvckNvZGV3b3JkKGNvZGV3b3JkKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkoOCk7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNWYWx1ZSA9IDA7XG4gICAgICAgICAgICBsZXQgaSA9IHJlc3VsdC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGNvZGV3b3JkICYgMHgxKSAhPT0gcHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gY29kZXdvcmQgJiAweDE7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbaV0rKztcbiAgICAgICAgICAgICAgICBjb2Rld29yZCA+Pj0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldENvZGV3b3JkQnVja2V0TnVtYmVyKGNvZGV3b3JkKSB7XG4gICAgICAgICAgICBpZiAoY29kZXdvcmQgaW5zdGFuY2VvZiBJbnQzMkFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXJfSW50MzJBcnJheShjb2Rld29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2Rld29yZEJ1Y2tldE51bWJlcl9udW1iZXIoY29kZXdvcmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRDb2Rld29yZEJ1Y2tldE51bWJlcl9udW1iZXIoY29kZXdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXIoUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldEJpdENvdW50Rm9yQ29kZXdvcmQoY29kZXdvcmQpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXJfSW50MzJBcnJheShtb2R1bGVCaXRDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIChtb2R1bGVCaXRDb3VudFswXSAtIG1vZHVsZUJpdENvdW50WzJdICsgbW9kdWxlQml0Q291bnRbNF0gLSBtb2R1bGVCaXRDb3VudFs2XSArIDkpICUgOTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgdG9TdHJpbmcoYmFyY29kZU1hdHJpeCkge1xuICAgICAgICAgICAgbGV0IGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIoKTtcbiAgICAgICAgICAgIC8vIHRyeSAobGV0IGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIoKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcm93IC8qaW50Ki8gPSAwOyByb3cgPCBiYXJjb2RlTWF0cml4Lmxlbmd0aDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCdSb3cgJTJkOiAnLCByb3cpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbHVtbiAvKmludCovID0gMDsgY29sdW1uIDwgYmFyY29kZU1hdHJpeFtyb3ddLmxlbmd0aDsgY29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJhcmNvZGVWYWx1ZSA9IGJhcmNvZGVNYXRyaXhbcm93XVtjb2x1bW5dO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFyY29kZVZhbHVlLmdldFZhbHVlKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCcgICAgICAgICcsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnJTRkKCUyZCknLCBiYXJjb2RlVmFsdWUuZ2V0VmFsdWUoKVswXSwgYmFyY29kZVZhbHVlLmdldENvbmZpZGVuY2UoYmFyY29kZVZhbHVlLmdldFZhbHVlKClbMF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCclbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci50b1N0cmluZygpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qZmluYWwqLyBQREY0MTdTY2FubmluZ0RlY29kZXIuQ09ERVdPUkRfU0tFV19TSVpFID0gMjtcbiAgICAvKmZpbmFsKi8gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLk1BWF9FUlJPUlMgPSAzO1xuICAgIC8qZmluYWwqLyBQREY0MTdTY2FubmluZ0RlY29kZXIuTUFYX0VDX0NPREVXT1JEUyA9IDUxMjtcbiAgICAvKmZpbmFsKi8gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmVycm9yQ29ycmVjdGlvbiA9IG5ldyBFcnJvckNvcnJlY3Rpb24oKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTWFwO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaW1wbGVtZW50YXRpb24gY2FuIGRldGVjdCBhbmQgZGVjb2RlIFBERjQxNyBjb2RlcyBpbiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qcHVibGljIGZpbmFsKi8gY2xhc3MgUERGNDE3UmVhZGVyIHtcbiAgICAgICAgLy8gcHJpdmF0ZSBzdGF0aWMgLypmaW5hbCBSZXN1bHRbXSovIEVNUFRZX1JFU1VMVF9BUlJBWTogUmVzdWx0W10gPSBuZXcgUmVzdWx0KFswXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2NhdGVzIGFuZCBkZWNvZGVzIGEgUERGNDE3IGNvZGUgaW4gYW4gaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gYSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb250ZW50IGVuY29kZWQgYnkgdGhlIFBERjQxNyBjb2RlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgYSBQREY0MTcgY29kZSBjYW5ub3QgYmUgZm91bmQsXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgUERGNDE3IGNhbm5vdCBiZSBkZWNvZGVkXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBkZWNvZGUoaW1hZ2UsIGhpbnRzID0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFBERjQxN1JlYWRlci5kZWNvZGUoaW1hZ2UsIGhpbnRzLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0Lmxlbmd0aCA9PT0gMCB8fCByZXN1bHRbMF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IE5vdEZvdW5kRXhjZXB0aW9uLmdldE5vdEZvdW5kSW5zdGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBCaW5hcnlCaXRtYXBcbiAgICAgICAgICogQHBhcmFtIGltYWdlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIC8vICAgQE92ZXJyaWRlXG4gICAgICAgIGRlY29kZU11bHRpcGxlKGltYWdlLCBoaW50cyA9IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBERjQxN1JlYWRlci5kZWNvZGUoaW1hZ2UsIGhpbnRzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBGb3JtYXRFeGNlcHRpb24gfHwgaWdub3JlZCBpbnN0YW5jZW9mIENoZWNrc3VtRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IE5vdEZvdW5kRXhjZXB0aW9uLmdldE5vdEZvdW5kSW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgaWdub3JlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltYWdlXG4gICAgICAgICAqIEBwYXJhbSBoaW50c1xuICAgICAgICAgKiBAcGFyYW0gbXVsdGlwbGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbsOfXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGUoaW1hZ2UsIGhpbnRzLCBtdWx0aXBsZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgY29uc3QgZGV0ZWN0b3JSZXN1bHQgPSBEZXRlY3RvciQzLmRldGVjdE11bHRpcGxlKGltYWdlLCBoaW50cywgbXVsdGlwbGUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludHMgb2YgZGV0ZWN0b3JSZXN1bHQuZ2V0UG9pbnRzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVyUmVzdWx0ID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmRlY29kZShkZXRlY3RvclJlc3VsdC5nZXRCaXRzKCksIHBvaW50c1s0XSwgcG9pbnRzWzVdLCBwb2ludHNbNl0sIHBvaW50c1s3XSwgUERGNDE3UmVhZGVyLmdldE1pbkNvZGV3b3JkV2lkdGgocG9pbnRzKSwgUERGNDE3UmVhZGVyLmdldE1heENvZGV3b3JkV2lkdGgocG9pbnRzKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFJlc3VsdChkZWNvZGVyUmVzdWx0LmdldFRleHQoKSwgZGVjb2RlclJlc3VsdC5nZXRSYXdCeXRlcygpLCB1bmRlZmluZWQsIHBvaW50cywgQmFyY29kZUZvcm1hdCQxLlBERl80MTcpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OX0xFVkVMLCBkZWNvZGVyUmVzdWx0LmdldEVDTGV2ZWwoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGRmNDE3UmVzdWx0TWV0YWRhdGEgPSBkZWNvZGVyUmVzdWx0LmdldE90aGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBkZjQxN1Jlc3VsdE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLlBERjQxN19FWFRSQV9NRVRBREFUQSwgcGRmNDE3UmVzdWx0TWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzLm1hcCh4ID0+IHgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRNYXhXaWR0aChwMSwgcDIpIHtcbiAgICAgICAgICAgIGlmIChwMSA9PSBudWxsIHx8IHAyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnRydW5jKE1hdGguYWJzKHAxLmdldFgoKSAtIHAyLmdldFgoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRNaW5XaWR0aChwMSwgcDIpIHtcbiAgICAgICAgICAgIGlmIChwMSA9PSBudWxsIHx8IHAyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC50cnVuYyhNYXRoLmFicyhwMS5nZXRYKCkgLSBwMi5nZXRYKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0TWF4Q29kZXdvcmRXaWR0aChwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1heChNYXRoLm1heChQREY0MTdSZWFkZXIuZ2V0TWF4V2lkdGgocFswXSwgcFs0XSksIFBERjQxN1JlYWRlci5nZXRNYXhXaWR0aChwWzZdLCBwWzJdKSAqIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX0NPREVXT1JEIC9cbiAgICAgICAgICAgICAgICBQREY0MTdDb21tb24uTU9EVUxFU19JTl9TVE9QX1BBVFRFUk4pLCBNYXRoLm1heChQREY0MTdSZWFkZXIuZ2V0TWF4V2lkdGgocFsxXSwgcFs1XSksIFBERjQxN1JlYWRlci5nZXRNYXhXaWR0aChwWzddLCBwWzNdKSAqIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX0NPREVXT1JEIC9cbiAgICAgICAgICAgICAgICBQREY0MTdDb21tb24uTU9EVUxFU19JTl9TVE9QX1BBVFRFUk4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldE1pbkNvZGV3b3JkV2lkdGgocCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5taW4oTWF0aC5taW4oUERGNDE3UmVhZGVyLmdldE1pbldpZHRoKHBbMF0sIHBbNF0pLCBQREY0MTdSZWFkZXIuZ2V0TWluV2lkdGgocFs2XSwgcFsyXSkgKiBQREY0MTdDb21tb24uTU9EVUxFU19JTl9DT0RFV09SRCAvXG4gICAgICAgICAgICAgICAgUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fU1RPUF9QQVRURVJOKSwgTWF0aC5taW4oUERGNDE3UmVhZGVyLmdldE1pbldpZHRoKHBbMV0sIHBbNV0pLCBQREY0MTdSZWFkZXIuZ2V0TWluV2lkdGgocFs3XSwgcFszXSkgKiBQREY0MTdDb21tb24uTU9EVUxFU19JTl9DT0RFV09SRCAvXG4gICAgICAgICAgICAgICAgUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fU1RPUF9QQVRURVJOKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgbmVlZHMgdG8gYmUgcmVzZXRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBSZWFkZXJFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIH1cbiAgICBSZWFkZXJFeGNlcHRpb24ua2luZCA9ICdSZWFkZXJFeGNlcHRpb24nO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xuICAgIC8qKlxuICAgICAqIE11bHRpRm9ybWF0UmVhZGVyIGlzIGEgY29udmVuaWVuY2UgY2xhc3MgYW5kIHRoZSBtYWluIGVudHJ5IHBvaW50IGludG8gdGhlIGxpYnJhcnkgZm9yIG1vc3QgdXNlcy5cbiAgICAgKiBCeSBkZWZhdWx0IGl0IGF0dGVtcHRzIHRvIGRlY29kZSBhbGwgYmFyY29kZSBmb3JtYXRzIHRoYXQgdGhlIGxpYnJhcnkgc3VwcG9ydHMuIE9wdGlvbmFsbHksIHlvdVxuICAgICAqIGNhbiBwcm92aWRlIGEgaGludHMgb2JqZWN0IHRvIHJlcXVlc3QgZGlmZmVyZW50IGJlaGF2aW9yLCBmb3IgZXhhbXBsZSBvbmx5IGRlY29kaW5nIFFSIGNvZGVzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIE11bHRpRm9ybWF0UmVhZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSB2ZXJib3NlIGlmICd0cnVlJyBsb2dzIHdpbGwgYmUgZHVtcGVkIHRvIGNvbnNvbGUsIG90aGVyd2lzZSBoaWRkZW4uXG4gICAgICAgICAqIEBwYXJhbSBoaW50cyBUaGUgaGludHMgdG8gdXNlLCBjbGVhcmluZyB0aGUgcHJldmlvdXMgc3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcih2ZXJib3NlLCBoaW50cykge1xuICAgICAgICAgICAgdGhpcy52ZXJib3NlID0gKHZlcmJvc2UgPT09IHRydWUpO1xuICAgICAgICAgICAgaWYgKGhpbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIaW50cyhoaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgdmVyc2lvbiBvZiBkZWNvZGUgaG9ub3JzIHRoZSBpbnRlbnQgb2YgUmVhZGVyLmRlY29kZShCaW5hcnlCaXRtYXApIGluIHRoYXQgaXRcbiAgICAgICAgICogcGFzc2VzIG51bGwgYXMgYSBoaW50IHRvIHRoZSBkZWNvZGVycy4gSG93ZXZlciwgdGhhdCBtYWtlcyBpdCBpbmVmZmljaWVudCB0byBjYWxsIHJlcGVhdGVkbHkuXG4gICAgICAgICAqIFVzZSBzZXRIaW50cygpIGZvbGxvd2VkIGJ5IGRlY29kZVdpdGhTdGF0ZSgpIGZvciBjb250aW51b3VzIHNjYW4gYXBwbGljYXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2UgVGhlIHBpeGVsIGRhdGEgdG8gZGVjb2RlXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGNvbnRlbnRzIG9mIHRoZSBpbWFnZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIEFueSBlcnJvcnMgd2hpY2ggb2NjdXJyZWRcbiAgICAgICAgICovXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgLy8gcHVibGljIGRlY29kZShpbWFnZTogQmluYXJ5Qml0bWFwKTogUmVzdWx0IHtcbiAgICAgICAgLy8gICBzZXRIaW50cyhudWxsKVxuICAgICAgICAvLyAgIHJldHVybiBkZWNvZGVJbnRlcm5hbChpbWFnZSlcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlIGFuIGltYWdlIHVzaW5nIHRoZSBoaW50cyBwcm92aWRlZC4gRG9lcyBub3QgaG9ub3IgZXhpc3Rpbmcgc3RhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBUaGUgcGl4ZWwgZGF0YSB0byBkZWNvZGVcbiAgICAgICAgICogQHBhcmFtIGhpbnRzIFRoZSBoaW50cyB0byB1c2UsIGNsZWFyaW5nIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgICAgICAgICogQHJldHVybiBUaGUgY29udGVudHMgb2YgdGhlIGltYWdlXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gQW55IGVycm9ycyB3aGljaCBvY2N1cnJlZFxuICAgICAgICAgKi9cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBkZWNvZGUoaW1hZ2UsIGhpbnRzKSB7XG4gICAgICAgICAgICBpZiAoaGludHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhpbnRzKGhpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUludGVybmFsKGltYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlIGFuIGltYWdlIHVzaW5nIHRoZSBzdGF0ZSBzZXQgdXAgYnkgY2FsbGluZyBzZXRIaW50cygpIHByZXZpb3VzbHkuIENvbnRpbnVvdXMgc2NhblxuICAgICAgICAgKiBjbGllbnRzIHdpbGwgZ2V0IGEgPGI+bGFyZ2U8L2I+IHNwZWVkIGluY3JlYXNlIGJ5IHVzaW5nIHRoaXMgaW5zdGVhZCBvZiBkZWNvZGUoKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltYWdlIFRoZSBwaXhlbCBkYXRhIHRvIGRlY29kZVxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBjb250ZW50cyBvZiB0aGUgaW1hZ2VcbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBBbnkgZXJyb3JzIHdoaWNoIG9jY3VycmVkXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVXaXRoU3RhdGUoaW1hZ2UpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byBzZXQgdXAgdGhlIGRlZmF1bHQgc3RhdGUgc28gd2UgZG9uJ3QgY3Jhc2hcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRlcnMgPT09IG51bGwgfHwgdGhpcy5yZWFkZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhpbnRzKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlSW50ZXJuYWwoaW1hZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBhZGRzIHN0YXRlIHRvIHRoZSBNdWx0aUZvcm1hdFJlYWRlci4gQnkgc2V0dGluZyB0aGUgaGludHMgb25jZSwgc3Vic2VxdWVudCBjYWxsc1xuICAgICAgICAgKiB0byBkZWNvZGVXaXRoU3RhdGUoaW1hZ2UpIGNhbiByZXVzZSB0aGUgc2FtZSBzZXQgb2YgcmVhZGVycyB3aXRob3V0IHJlYWxsb2NhdGluZyBtZW1vcnkuIFRoaXNcbiAgICAgICAgICogaXMgaW1wb3J0YW50IGZvciBwZXJmb3JtYW5jZSBpbiBjb250aW51b3VzIHNjYW4gY2xpZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGhpbnRzIFRoZSBzZXQgb2YgaGludHMgdG8gdXNlIGZvciBzdWJzZXF1ZW50IGNhbGxzIHRvIGRlY29kZShpbWFnZSlcbiAgICAgICAgICovXG4gICAgICAgIHNldEhpbnRzKGhpbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmhpbnRzID0gaGludHM7XG4gICAgICAgICAgICBjb25zdCB0cnlIYXJkZXIgPSAhaXNOdWxsT3JVbmRlZmluZWQoaGludHMpXG4gICAgICAgICAgICAgICAgJiYgaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuVFJZX0hBUkRFUikgPT09IHRydWU7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXRzID0gaXNOdWxsT3JVbmRlZmluZWQoaGludHMpID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlBPU1NJQkxFX0ZPUk1BVFMpO1xuICAgICAgICAgICAgY29uc3QgcmVhZGVycyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChmb3JtYXRzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZE9uZURSZWFkZXIgPSBmb3JtYXRzLnNvbWUoZiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0JDEuVVBDX0EgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5VUENfRSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdCQxLkVBTl8xMyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdCQxLkVBTl84IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0JDEuQ09EQUJBUiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdCQxLkNPREVfMzkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5DT0RFXzkzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0JDEuQ09ERV8xMjggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5JVEYgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5SU1NfMTQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5SU1NfRVhQQU5ERUQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFB1dCAxRCByZWFkZXJzIHVwZnJvbnQgaW4gXCJub3JtYWxcIiBtb2RlXG4gICAgICAgICAgICAgICAgaWYgKGFkZE9uZURSZWFkZXIgJiYgIXRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IE11bHRpRm9ybWF0T25lRFJlYWRlcihoaW50cywgdGhpcy52ZXJib3NlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5RUl9DT0RFKSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IFFSQ29kZVJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLkRBVEFfTUFUUklYKSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IERhdGFNYXRyaXhSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5BWlRFQykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBBenRlY1JlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLlBERl80MTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgUERGNDE3UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiAoZm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0Lk1BWElDT0RFKSkge1xuICAgICAgICAgICAgICAgIC8vICAgIHJlYWRlcnMucHVzaChuZXcgTWF4aUNvZGVSZWFkZXIoKSlcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gQXQgZW5kIGluIFwidHJ5IGhhcmRlclwiIG1vZGVcbiAgICAgICAgICAgICAgICBpZiAoYWRkT25lRFJlYWRlciAmJiB0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdE9uZURSZWFkZXIoaGludHMsIHRoaXMudmVyYm9zZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICghdHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgTXVsdGlGb3JtYXRPbmVEUmVhZGVyKGhpbnRzLCB0aGlzLnZlcmJvc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBRUkNvZGVSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBEYXRhTWF0cml4UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgQXp0ZWNSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBQREY0MTdSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgLy8gcmVhZGVycy5wdXNoKG5ldyBNYXhpQ29kZVJlYWRlcigpKVxuICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdE9uZURSZWFkZXIoaGludHMsIHRoaXMudmVyYm9zZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVycyA9IHJlYWRlcnM7IC8vIC50b0FycmF5KG5ldyBSZWFkZXJbcmVhZGVycy5zaXplKCldKVxuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5yZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlSW50ZXJuYWwoaW1hZ2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRlcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVhZGVyRXhjZXB0aW9uKCdObyByZWFkZXJzIHdoZXJlIHNlbGVjdGVkLCBub3RoaW5nIGNhbiBiZSByZWFkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5yZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5aW5nIHRvIGRlY29kZSB3aXRoICR7cmVhZGVyfSByZWFkZXIuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5kZWNvZGUoaW1hZ2UsIHRoaXMuaGludHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgUmVhZGVyRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBCYWQgRXhjZXB0aW9uLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbignTm8gTXVsdGlGb3JtYXQgUmVhZGVycyB3ZXJlIGFibGUgdG8gZGV0ZWN0IHRoZSBjb2RlLicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgQnJvd3Nlck11bHRpRm9ybWF0UmVhZGVyIGV4dGVuZHMgQnJvd3NlckNvZGVSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihoaW50cyA9IG51bGwsIHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPSA1MDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBNdWx0aUZvcm1hdFJlYWRlcigpO1xuICAgICAgICAgICAgcmVhZGVyLnNldEhpbnRzKGhpbnRzKTtcbiAgICAgICAgICAgIHN1cGVyKHJlYWRlciwgdGltZUJldHdlZW5TY2Fuc01pbGxpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0ZSBkZWNvZGVCaXRtYXAgdG8gY2FsbCBkZWNvZGVXaXRoU3RhdGUsIHdoaWNoIHdpbGwgcGF5XG4gICAgICAgICAqIGF0dGVudGlvbiB0byB0aGUgaGludHMgc2V0IGluIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlQml0bWFwKGJpbmFyeUJpdG1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLmRlY29kZVdpdGhTdGF0ZShiaW5hcnlCaXRtYXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICpcbiAgICAgKiBRUiBDb2RlIHJlYWRlciB0byB1c2UgZnJvbSBicm93c2VyLlxuICAgICAqL1xuICAgIGNsYXNzIEJyb3dzZXJQREY0MTdSZWFkZXIgZXh0ZW5kcyBCcm93c2VyQ29kZVJlYWRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJyb3dzZXJQREY0MTdSZWFkZXIuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZUJldHdlZW5TY2Fuc01pbGxpcz01MDBdIHRoZSB0aW1lIGRlbGF5IGJldHdlZW4gc3Vic2VxdWVudCBkZWNvZGUgdHJpZXNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPSA1MDApIHtcbiAgICAgICAgICAgIHN1cGVyKG5ldyBQREY0MTdSZWFkZXIoKSwgdGltZUJldHdlZW5TY2Fuc01pbGxpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBNb3ZpbmcgdG8gQHp4aW5nL2Jyb3dzZXJcbiAgICAgKlxuICAgICAqIFFSIENvZGUgcmVhZGVyIHRvIHVzZSBmcm9tIGJyb3dzZXIuXG4gICAgICovXG4gICAgY2xhc3MgQnJvd3NlclFSQ29kZVJlYWRlciBleHRlbmRzIEJyb3dzZXJDb2RlUmVhZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQnJvd3NlclFSQ29kZVJlYWRlci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lQmV0d2VlblNjYW5zTWlsbGlzPTUwMF0gdGhlIHRpbWUgZGVsYXkgYmV0d2VlbiBzdWJzZXF1ZW50IGRlY29kZSB0cmllc1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IodGltZUJldHdlZW5TY2Fuc01pbGxpcyA9IDUwMCkge1xuICAgICAgICAgICAgc3VwZXIobmV3IFFSQ29kZVJlYWRlcigpLCB0aW1lQmV0d2VlblNjYW5zTWlsbGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cbiAgICAvKipcbiAgICAgKiBUaGVzZSBhcmUgYSBzZXQgb2YgaGludHMgdGhhdCB5b3UgbWF5IHBhc3MgdG8gV3JpdGVycyB0byBzcGVjaWZ5IHRoZWlyIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKi9cbiAgICB2YXIgRW5jb2RlSGludFR5cGU7XG4gICAgKGZ1bmN0aW9uIChFbmNvZGVIaW50VHlwZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoYXQgZGVncmVlIG9mIGVycm9yIGNvcnJlY3Rpb24gdG8gdXNlLCBmb3IgZXhhbXBsZSBpbiBRUiBDb2Rlcy5cbiAgICAgICAgICogVHlwZSBkZXBlbmRzIG9uIHRoZSBlbmNvZGVyLiBGb3IgZXhhbXBsZSBmb3IgUVIgY29kZXMgaXQncyB0eXBlXG4gICAgICAgICAqIHtAbGluayBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5kZWNvZGVyLkVycm9yQ29ycmVjdGlvbkxldmVsIEVycm9yQ29ycmVjdGlvbkxldmVsfS5cbiAgICAgICAgICogRm9yIEF6dGVjIGl0IGlzIG9mIHR5cGUge0BsaW5rIEludGVnZXJ9LCByZXByZXNlbnRpbmcgdGhlIG1pbmltYWwgcGVyY2VudGFnZSBvZiBlcnJvciBjb3JyZWN0aW9uIHdvcmRzLlxuICAgICAgICAgKiBGb3IgUERGNDE3IGl0IGlzIG9mIHR5cGUge0BsaW5rIEludGVnZXJ9LCB2YWxpZCB2YWx1ZXMgYmVpbmcgMCB0byA4LlxuICAgICAgICAgKiBJbiBhbGwgY2FzZXMsIGl0IGNhbiBhbHNvIGJlIGEge0BsaW5rIFN0cmluZ30gcmVwcmVzZW50YXRpb24gb2YgdGhlIGRlc2lyZWQgdmFsdWUgYXMgd2VsbC5cbiAgICAgICAgICogTm90ZTogYW4gQXp0ZWMgc3ltYm9sIHNob3VsZCBoYXZlIGEgbWluaW11bSBvZiAyNSUgRUMgd29yZHMuXG4gICAgICAgICAqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIkVSUk9SX0NPUlJFQ1RJT05cIl0gPSAwXSA9IFwiRVJST1JfQ09SUkVDVElPTlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoYXQgY2hhcmFjdGVyIGVuY29kaW5nIHRvIHVzZSB3aGVyZSBhcHBsaWNhYmxlICh0eXBlIHtAbGluayBTdHJpbmd9KVxuICAgICAgICAgKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJDSEFSQUNURVJfU0VUXCJdID0gMV0gPSBcIkNIQVJBQ1RFUl9TRVRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbWF0cml4IHNoYXBlIGZvciBEYXRhIE1hdHJpeCAodHlwZSB7QGxpbmsgY29tLmdvb2dsZS56eGluZy5kYXRhbWF0cml4LmVuY29kZXIuU3ltYm9sU2hhcGVIaW50fSlcbiAgICAgICAgICovXG4gICAgICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiREFUQV9NQVRSSVhfU0hBUEVcIl0gPSAyXSA9IFwiREFUQV9NQVRSSVhfU0hBUEVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBhIG1pbmltdW0gYmFyY29kZSBzaXplICh0eXBlIHtAbGluayBEaW1lbnNpb259KS4gT25seSBhcHBsaWNhYmxlIHRvIERhdGEgTWF0cml4IG5vdy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgdXNlIHdpZHRoL2hlaWdodCBwYXJhbXMgaW5cbiAgICAgICAgICoge0BsaW5rIGNvbS5nb29nbGUuenhpbmcuZGF0YW1hdHJpeC5EYXRhTWF0cml4V3JpdGVyI2VuY29kZShTdHJpbmcsIEJhcmNvZGVGb3JtYXQsIGludCwgaW50KX1cbiAgICAgICAgICovXG4gICAgICAgIC8qQERlcHJlY2F0ZWQqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIk1JTl9TSVpFXCJdID0gM10gPSBcIk1JTl9TSVpFXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgYSBtYXhpbXVtIGJhcmNvZGUgc2l6ZSAodHlwZSB7QGxpbmsgRGltZW5zaW9ufSkuIE9ubHkgYXBwbGljYWJsZSB0byBEYXRhIE1hdHJpeCBub3cuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHdpdGhvdXQgcmVwbGFjZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIC8qQERlcHJlY2F0ZWQqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIk1BWF9TSVpFXCJdID0gNF0gPSBcIk1BWF9TSVpFXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgbWFyZ2luLCBpbiBwaXhlbHMsIHRvIHVzZSB3aGVuIGdlbmVyYXRpbmcgdGhlIGJhcmNvZGUuIFRoZSBtZWFuaW5nIGNhbiB2YXJ5XG4gICAgICAgICAqIGJ5IGZvcm1hdDsgZm9yIGV4YW1wbGUgaXQgY29udHJvbHMgbWFyZ2luIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGJhcmNvZGUgaG9yaXpvbnRhbGx5IGZvclxuICAgICAgICAgKiBtb3N0IDFEIGZvcm1hdHMuIChUeXBlIHtAbGluayBJbnRlZ2VyfSwgb3Ige0BsaW5rIFN0cmluZ30gcmVwcmVzZW50YXRpb24gb2YgdGhlIGludGVnZXIgdmFsdWUpLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJNQVJHSU5cIl0gPSA1XSA9IFwiTUFSR0lOXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0byB1c2UgY29tcGFjdCBtb2RlIGZvciBQREY0MTcgKHR5cGUge0BsaW5rIEJvb2xlYW59LCBvciBcInRydWVcIiBvciBcImZhbHNlXCJcbiAgICAgICAgICoge0BsaW5rIFN0cmluZ30gdmFsdWUpLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJQREY0MTdfQ09NUEFDVFwiXSA9IDZdID0gXCJQREY0MTdfQ09NUEFDVFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoYXQgY29tcGFjdGlvbiBtb2RlIHRvIHVzZSBmb3IgUERGNDE3ICh0eXBlXG4gICAgICAgICAqIHtAbGluayBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5lbmNvZGVyLkNvbXBhY3Rpb24gQ29tcGFjdGlvbn0gb3Ige0BsaW5rIFN0cmluZ30gdmFsdWUgb2Ygb25lIG9mIGl0c1xuICAgICAgICAgKiBlbnVtIHZhbHVlcykuXG4gICAgICAgICAqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIlBERjQxN19DT01QQUNUSU9OXCJdID0gN10gPSBcIlBERjQxN19DT01QQUNUSU9OXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgZm9yIFBERjQxNyAodHlwZVxuICAgICAgICAgKiB7QGxpbmsgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZW5jb2Rlci5EaW1lbnNpb25zIERpbWVuc2lvbnN9KS5cbiAgICAgICAgICovXG4gICAgICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiUERGNDE3X0RJTUVOU0lPTlNcIl0gPSA4XSA9IFwiUERGNDE3X0RJTUVOU0lPTlNcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGxheWVycyBmb3IgYW4gQXp0ZWMgY29kZS5cbiAgICAgICAgICogQSBuZWdhdGl2ZSBudW1iZXIgKC0xLCAtMiwgLTMsIC00KSBzcGVjaWZpZXMgYSBjb21wYWN0IEF6dGVjIGNvZGUuXG4gICAgICAgICAqIDAgaW5kaWNhdGVzIHRvIHVzZSB0aGUgbWluaW11bSBudW1iZXIgb2YgbGF5ZXJzICh0aGUgZGVmYXVsdCkuXG4gICAgICAgICAqIEEgcG9zaXRpdmUgbnVtYmVyICgxLCAyLCAuLiAzMikgc3BlY2lmaWVzIGEgbm9ybWFsIChub24tY29tcGFjdCkgQXp0ZWMgY29kZS5cbiAgICAgICAgICogKFR5cGUge0BsaW5rIEludGVnZXJ9LCBvciB7QGxpbmsgU3RyaW5nfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW50ZWdlciB2YWx1ZSkuXG4gICAgICAgICAqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIkFaVEVDX0xBWUVSU1wiXSA9IDldID0gXCJBWlRFQ19MQVlFUlNcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgZXhhY3QgdmVyc2lvbiBvZiBRUiBjb2RlIHRvIGJlIGVuY29kZWQuXG4gICAgICAgICAqIChUeXBlIHtAbGluayBJbnRlZ2VyfSwgb3Ige0BsaW5rIFN0cmluZ30gcmVwcmVzZW50YXRpb24gb2YgdGhlIGludGVnZXIgdmFsdWUpLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJRUl9WRVJTSU9OXCJdID0gMTBdID0gXCJRUl9WRVJTSU9OXCI7XG4gICAgfSkoRW5jb2RlSGludFR5cGUgfHwgKEVuY29kZUhpbnRUeXBlID0ge30pKTtcbiAgICB2YXIgRW5jb2RlSGludFR5cGUkMSA9IEVuY29kZUhpbnRUeXBlO1xuXG4gICAgLyoqXG4gICAgICogPHA+SW1wbGVtZW50cyBSZWVkLVNvbG9tb24gZW5jb2RpbmcsIGFzIHRoZSBuYW1lIGltcGxpZXMuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIFdpbGxpYW0gUnVja2xpZGdlXG4gICAgICovXG4gICAgY2xhc3MgUmVlZFNvbG9tb25FbmNvZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVlZCBzb2xvbW9uIGVycm9yLWNvcnJlY3RpbmcgZW5jb2RpbmcgY29uc3RydWN0b3IgaXMgY3JlYXRlZCBieVxuICAgICAgICAgKiBwYXNzaW5nIGFzIEdhbG9pcyBGaWVsZCB3aXRoIG9mIHNpemUgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBjb2RlXG4gICAgICAgICAqIHdvcmRzIChzeW1ib2xzKSBpbiB0aGUgYWxwaGFiZXQgKHRoZSBudW1iZXIgb2YgdmFsdWVzIGluIGVhY2hcbiAgICAgICAgICogZWxlbWVudCBvZiBhcnJheXMgdGhhdCBhcmUgZW5jb2RlZC9kZWNvZGVkKS5cbiAgICAgICAgICogQHBhcmFtIGZpZWxkIEEgZ2Fsb2lzIGZpZWxkIHdpdGggYSBudW1iZXIgb2YgZWxlbWVudHMgZXF1YWwgdG8gdGhlIHNpemVcbiAgICAgICAgICogb2YgdGhlIGFscGhhYmV0IG9mIHN5bWJvbHMgdG8gZW5jb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoZmllbGQpIHtcbiAgICAgICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkR2VuZXJhdG9ycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRHZW5lcmF0b3JzLnB1c2gobmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIEludDMyQXJyYXkuZnJvbShbMV0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRHZW5lcmF0b3IoZGVncmVlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZEdlbmVyYXRvcnMgPSB0aGlzLmNhY2hlZEdlbmVyYXRvcnM7XG4gICAgICAgICAgICBpZiAoZGVncmVlID49IGNhY2hlZEdlbmVyYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RHZW5lcmF0b3IgPSBjYWNoZWRHZW5lcmF0b3JzW2NhY2hlZEdlbmVyYXRvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSBjYWNoZWRHZW5lcmF0b3JzLmxlbmd0aDsgZCA8PSBkZWdyZWU7IGQrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0R2VuZXJhdG9yID0gbGFzdEdlbmVyYXRvci5tdWx0aXBseShuZXcgR2VuZXJpY0dGUG9seShmaWVsZCwgSW50MzJBcnJheS5mcm9tKFsxLCBmaWVsZC5leHAoZCAtIDEgKyBmaWVsZC5nZXRHZW5lcmF0b3JCYXNlKCkpXSkpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkR2VuZXJhdG9ycy5wdXNoKG5leHRHZW5lcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdG9yID0gbmV4dEdlbmVyYXRvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkR2VuZXJhdG9yc1tkZWdyZWVdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5FbmNvZGUgYSBzZXF1ZW5jZSBvZiBjb2RlIHdvcmRzIChzeW1ib2xzKSB1c2luZyBSZWVkLVNvbG9tb24gdG8gYWxsb3cgZGVjb2RlcnNcbiAgICAgICAgICogdG8gZGV0ZWN0IGFuZCBjb3JyZWN0IGVycm9ycyB0aGF0IG1heSBoYXZlIGJlZW4gaW50cm9kdWNlZCB3aGVuIHRoZSByZXN1bHRpbmdcbiAgICAgICAgICogZGF0YSBpcyBzdG9yZWQgb3IgdHJhbnNtaXR0ZWQuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdG9FbmNvZGUgYXJyYXkgdXNlZCBmb3IgYm90aCBhbmQgb3V0cHV0LiBDYWxsZXIgaW5pdGlhbGl6ZXMgdGhlIGFycmF5IHdpdGhcbiAgICAgICAgICogdGhlIGNvZGUgd29yZHMgKHN5bWJvbHMpIHRvIGJlIGVuY29kZWQgZm9sbG93ZWQgYnkgZW1wdHkgZWxlbWVudHMgYWxsb2NhdGVkIHRvIG1ha2VcbiAgICAgICAgICogc3BhY2UgZm9yIGVycm9yLWNvcnJlY3Rpb24gY29kZSB3b3JkcyBpbiB0aGUgZW5jb2RlZCBvdXRwdXQuIFRoZSBhcnJheSBjb250YWluc1xuICAgICAgICAgKiB0aGUgZW5jZG9kZWQgb3V0cHV0IHdoZW4gZW5jb2RlIHJldHVybnMuIENvZGUgd29yZHMgYXJlIGVuY29kZWQgYXMgbnVtYmVycyBmcm9tXG4gICAgICAgICAqIDAgdG8gbi0xLCB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2YgcG9zc2libGUgY29kZSB3b3JkcyAoc3ltYm9scyksIGFzIGRldGVybWluZWRcbiAgICAgICAgICogYnkgdGhlIHNpemUgb2YgdGhlIEdhbG9pcyBGaWVsZCBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0gZWNCeXRlcyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHJlc2VydmVkIGluIHRoZSBhcnJheSAoZmlyc3QgcGFyYW1ldGVyKVxuICAgICAgICAgKiB0byBzdG9yZSBlcnJvci1jb3JyZWN0aW9uIGNvZGUgd29yZHMuIFRodXMsIHRoZSBudW1iZXIgb2YgY29kZSB3b3JkcyAoc3ltYm9scylcbiAgICAgICAgICogdG8gZW5jb2RlIGluIHRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdGh1cyB0b0VuY29kZS5sZW5ndGggLSBlY0J5dGVzLlxuICAgICAgICAgKiBOb3RlLCB0aGUgdXNlIG9mIFwiYnl0ZXNcIiBpbiB0aGUgbmFtZSBvZiB0aGlzIHBhcmFtZXRlciBpcyBtaXNsZWFkaW5nLCBhcyB0aGVyZSBtYXlcbiAgICAgICAgICogYmUgbW9yZSBvciBmZXdlciB0aGFuIDI1NiBzeW1ib2xzIGJlaW5nIGVuY29kZWQsIGFzIGRldGVybWluZWQgYnkgdGhlIG51bWJlciBvZlxuICAgICAgICAgKiBlbGVtZW50cyBpbiB0aGUgR2Fsb2lzIEZpZWxkIHBhc3NlZCBhcyBhIGNvbnN0cnVjdG9yIHRvIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiB0aHJvd24gaW4gcmVzcG9uc2UgdG8gdmFsaWRhdGlvbiBlcnJyb3MuXG4gICAgICAgICAqL1xuICAgICAgICBlbmNvZGUodG9FbmNvZGUsIGVjQnl0ZXMgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKGVjQnl0ZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdObyBlcnJvciBjb3JyZWN0aW9uIGJ5dGVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhQnl0ZXMgPSB0b0VuY29kZS5sZW5ndGggLSBlY0J5dGVzO1xuICAgICAgICAgICAgaWYgKGRhdGFCeXRlcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignTm8gZGF0YSBieXRlcyBwcm92aWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2VuZXJhdG9yID0gdGhpcy5idWlsZEdlbmVyYXRvcihlY0J5dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm9Db2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShkYXRhQnl0ZXMpO1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0b0VuY29kZSwgMCwgaW5mb0NvZWZmaWNpZW50cywgMCwgZGF0YUJ5dGVzKTtcbiAgICAgICAgICAgIGxldCBpbmZvID0gbmV3IEdlbmVyaWNHRlBvbHkodGhpcy5maWVsZCwgaW5mb0NvZWZmaWNpZW50cyk7XG4gICAgICAgICAgICBpbmZvID0gaW5mby5tdWx0aXBseUJ5TW9ub21pYWwoZWNCeXRlcywgMSk7XG4gICAgICAgICAgICBjb25zdCByZW1haW5kZXIgPSBpbmZvLmRpdmlkZShnZW5lcmF0b3IpWzFdO1xuICAgICAgICAgICAgY29uc3QgY29lZmZpY2llbnRzID0gcmVtYWluZGVyLmdldENvZWZmaWNpZW50cygpO1xuICAgICAgICAgICAgY29uc3QgbnVtWmVyb0NvZWZmaWNpZW50cyA9IGVjQnl0ZXMgLSBjb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1aZXJvQ29lZmZpY2llbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b0VuY29kZVtkYXRhQnl0ZXMgKyBpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGNvZWZmaWNpZW50cywgMCwgdG9FbmNvZGUsIGRhdGFCeXRlcyArIG51bVplcm9Db2VmZmljaWVudHMsIGNvZWZmaWNpZW50cy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBTYXRvcnUgVGFrYWJheWFzaGlcbiAgICAgKiBAYXV0aG9yIERhbmllbCBTd2l0a2luXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBNYXNrVXRpbCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSBtYXNrIHBlbmFsdHkgcnVsZSAxIGFuZCByZXR1cm4gdGhlIHBlbmFsdHkuIEZpbmQgcmVwZXRpdGl2ZSBjZWxscyB3aXRoIHRoZSBzYW1lIGNvbG9yIGFuZFxuICAgICAgICAgKiBnaXZlIHBlbmFsdHkgdG8gdGhlbS4gRXhhbXBsZTogMDAwMDAgb3IgMTExMTEuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYXBwbHlNYXNrUGVuYWx0eVJ1bGUxKG1hdHJpeCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlMUludGVybmFsKG1hdHJpeCwgdHJ1ZSkgKyBNYXNrVXRpbC5hcHBseU1hc2tQZW5hbHR5UnVsZTFJbnRlcm5hbChtYXRyaXgsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgbWFzayBwZW5hbHR5IHJ1bGUgMiBhbmQgcmV0dXJuIHRoZSBwZW5hbHR5LiBGaW5kIDJ4MiBibG9ja3Mgd2l0aCB0aGUgc2FtZSBjb2xvciBhbmQgZ2l2ZVxuICAgICAgICAgKiBwZW5hbHR5IHRvIHRoZW0uIFRoaXMgaXMgYWN0dWFsbHkgZXF1aXZhbGVudCB0byB0aGUgc3BlYydzIHJ1bGUsIHdoaWNoIGlzIHRvIGZpbmQgTXhOIGJsb2NrcyBhbmQgZ2l2ZSBhXG4gICAgICAgICAqIHBlbmFsdHkgcHJvcG9ydGlvbmFsIHRvIChNLTEpeChOLTEpLCBiZWNhdXNlIHRoaXMgaXMgdGhlIG51bWJlciBvZiAyeDIgYmxvY2tzIGluc2lkZSBzdWNoIGEgYmxvY2suXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYXBwbHlNYXNrUGVuYWx0eVJ1bGUyKG1hdHJpeCkge1xuICAgICAgICAgICAgbGV0IHBlbmFsdHkgPSAwO1xuICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBtYXRyaXguZ2V0QXJyYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gbWF0cml4LmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBtYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodCAtIDE7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5WSA9IGFycmF5W3ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGggLSAxOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcnJheVlbeF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gYXJyYXlZW3ggKyAxXSAmJiB2YWx1ZSA9PT0gYXJyYXlbeSArIDFdW3hdICYmIHZhbHVlID09PSBhcnJheVt5ICsgMV1beCArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5hbHR5Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWFza1V0aWwuTjIgKiBwZW5hbHR5O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSBtYXNrIHBlbmFsdHkgcnVsZSAzIGFuZCByZXR1cm4gdGhlIHBlbmFsdHkuIEZpbmQgY29uc2VjdXRpdmUgcnVucyBvZiAxOjE6MzoxOjE6NFxuICAgICAgICAgKiBzdGFydGluZyB3aXRoIGJsYWNrLCBvciA0OjE6MTozOjE6MSBzdGFydGluZyB3aXRoIHdoaXRlLCBhbmQgZ2l2ZSBwZW5hbHR5IHRvIHRoZW0uICBJZiB3ZVxuICAgICAgICAgKiBmaW5kIHBhdHRlcm5zIGxpa2UgMDAwMDEwMTExMDEwMDAwLCB3ZSBnaXZlIHBlbmFsdHkgb25jZS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBseU1hc2tQZW5hbHR5UnVsZTMobWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgbnVtUGVuYWx0aWVzID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IG1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheVkgPSBhcnJheVt5XTsgLy8gV2UgY2FuIGF0IGxlYXN0IG9wdGltaXplIHRoaXMgYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIGlmICh4ICsgNiA8IHdpZHRoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVlbeF0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgMV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgMl0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgM10gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgNF0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgNV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgNl0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChNYXNrVXRpbC5pc1doaXRlSG9yaXpvbnRhbChhcnJheVksIHggLSA0LCB4KSB8fCBNYXNrVXRpbC5pc1doaXRlSG9yaXpvbnRhbChhcnJheVksIHggKyA3LCB4ICsgMTEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtUGVuYWx0aWVzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgKyA2IDwgaGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVt5XVt4XSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbeSArIDFdW3hdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVt5ICsgMl1beF0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyAzXVt4XSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbeSArIDRdW3hdID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVt5ICsgNV1beF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyA2XVt4XSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKE1hc2tVdGlsLmlzV2hpdGVWZXJ0aWNhbChhcnJheSwgeCwgeSAtIDQsIHkpIHx8IE1hc2tVdGlsLmlzV2hpdGVWZXJ0aWNhbChhcnJheSwgeCwgeSArIDcsIHkgKyAxMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1QZW5hbHRpZXMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW1QZW5hbHRpZXMgKiBNYXNrVXRpbC5OMztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXNXaGl0ZUhvcml6b250YWwocm93QXJyYXksIGZyb20gLyppbnQqLywgdG8gLyppbnQqLykge1xuICAgICAgICAgICAgZnJvbSA9IE1hdGgubWF4KGZyb20sIDApO1xuICAgICAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgcm93QXJyYXkubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChyb3dBcnJheVtpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGlzV2hpdGVWZXJ0aWNhbChhcnJheSwgY29sIC8qaW50Ki8sIGZyb20gLyppbnQqLywgdG8gLyppbnQqLykge1xuICAgICAgICAgICAgZnJvbSA9IE1hdGgubWF4KGZyb20sIDApO1xuICAgICAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJheVtpXVtjb2xdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgbWFzayBwZW5hbHR5IHJ1bGUgNCBhbmQgcmV0dXJuIHRoZSBwZW5hbHR5LiBDYWxjdWxhdGUgdGhlIHJhdGlvIG9mIGRhcmsgY2VsbHMgYW5kIGdpdmVcbiAgICAgICAgICogcGVuYWx0eSBpZiB0aGUgcmF0aW8gaXMgZmFyIGZyb20gNTAlLiBJdCBnaXZlcyAxMCBwZW5hbHR5IGZvciA1JSBkaXN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBseU1hc2tQZW5hbHR5UnVsZTQobWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgbnVtRGFya0NlbGxzID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IG1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5WSA9IGFycmF5W3ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXlZW3hdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1EYXJrQ2VsbHMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG51bVRvdGFsQ2VsbHMgPSBtYXRyaXguZ2V0SGVpZ2h0KCkgKiBtYXRyaXguZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpdmVQZXJjZW50VmFyaWFuY2VzID0gTWF0aC5mbG9vcihNYXRoLmFicyhudW1EYXJrQ2VsbHMgKiAyIC0gbnVtVG90YWxDZWxscykgKiAxMCAvIG51bVRvdGFsQ2VsbHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZpdmVQZXJjZW50VmFyaWFuY2VzICogTWFza1V0aWwuTjQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgbWFzayBiaXQgZm9yIFwiZ2V0TWFza1BhdHRlcm5cIiBhdCBcInhcIiBhbmQgXCJ5XCIuIFNlZSA4Ljggb2YgSklTWDA1MTA6MjAwNCBmb3IgbWFza1xuICAgICAgICAgKiBwYXR0ZXJuIGNvbmRpdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0RGF0YU1hc2tCaXQobWFza1BhdHRlcm4gLyppbnQqLywgeCAvKmludCovLCB5IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGxldCBpbnRlcm1lZGlhdGU7IC8qaW50Ki9cbiAgICAgICAgICAgIGxldCB0ZW1wOyAvKmludCovXG4gICAgICAgICAgICBzd2l0Y2ggKG1hc2tQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUgPSAoeSArIHgpICYgMHgxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9IHkgJiAweDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0geCAlIDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gKHkgKyB4KSAlIDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gKE1hdGguZmxvb3IoeSAvIDIpICsgTWF0aC5mbG9vcih4IC8gMykpICYgMHgxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSB5ICogeDtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gKHRlbXAgJiAweDEpICsgKHRlbXAgJSAzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0geSAqIHg7XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9ICgodGVtcCAmIDB4MSkgKyAodGVtcCAlIDMpKSAmIDB4MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0geSAqIHg7XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9ICgodGVtcCAlIDMpICsgKCh5ICsgeCkgJiAweDEpKSAmIDB4MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignSW52YWxpZCBtYXNrIHBhdHRlcm46ICcgKyBtYXNrUGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJtZWRpYXRlID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGFwcGx5TWFza1BlbmFsdHlSdWxlMS4gV2UgbmVlZCB0aGlzIGZvciBkb2luZyB0aGlzIGNhbGN1bGF0aW9uIGluIGJvdGhcbiAgICAgICAgICogdmVydGljYWwgYW5kIGhvcml6b250YWwgb3JkZXJzIHJlc3BlY3RpdmVseS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBseU1hc2tQZW5hbHR5UnVsZTFJbnRlcm5hbChtYXRyaXgsIGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgbGV0IHBlbmFsdHkgPSAwO1xuICAgICAgICAgICAgY29uc3QgaUxpbWl0ID0gaXNIb3Jpem9udGFsID8gbWF0cml4LmdldEhlaWdodCgpIDogbWF0cml4LmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBqTGltaXQgPSBpc0hvcml6b250YWwgPyBtYXRyaXguZ2V0V2lkdGgoKSA6IG1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlMaW1pdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG51bVNhbWVCaXRDZWxscyA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZCaXQgPSAtMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGpMaW1pdDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdCA9IGlzSG9yaXpvbnRhbCA/IGFycmF5W2ldW2pdIDogYXJyYXlbal1baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaXQgPT09IHByZXZCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVNhbWVCaXRDZWxscysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bVNhbWVCaXRDZWxscyA+PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuYWx0eSArPSBNYXNrVXRpbC5OMSArIChudW1TYW1lQml0Q2VsbHMgLSA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVNhbWVCaXRDZWxscyA9IDE7IC8vIEluY2x1ZGUgdGhlIGNlbGwgaXRzZWxmLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkJpdCA9IGJpdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobnVtU2FtZUJpdENlbGxzID49IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuYWx0eSArPSBNYXNrVXRpbC5OMSArIChudW1TYW1lQml0Q2VsbHMgLSA1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGVuYWx0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQZW5hbHR5IHdlaWdodHMgZnJvbSBzZWN0aW9uIDYuOC4yLjFcbiAgICBNYXNrVXRpbC5OMSA9IDM7XG4gICAgTWFza1V0aWwuTjIgPSAzO1xuICAgIE1hc2tVdGlsLk4zID0gNDA7XG4gICAgTWFza1V0aWwuTjQgPSAxMDtcblxuICAgIC8qKlxuICAgICAqIEpBVkFQT1JUOiBUaGUgb3JpZ2luYWwgY29kZSB3YXMgYSAyRCBhcnJheSBvZiBpbnRzLCBidXQgc2luY2UgaXQgb25seSBldmVyIGdldHMgYXNzaWduZWRcbiAgICAgKiAtMSwgMCwgYW5kIDEsIEknbSBnb2luZyB0byB1c2UgbGVzcyBtZW1vcnkgYW5kIGdvIHdpdGggYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIEJ5dGVNYXRyaXgge1xuICAgICAgICBjb25zdHJ1Y3Rvcih3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBBcnJheShoZWlnaHQpOyAvLyBbaGVpZ2h0XVt3aWR0aF1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gbmV3IFVpbnQ4QXJyYXkod2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGdldCh4IC8qaW50Ki8sIHkgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNbeV1beF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gYW4gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gYXMgYnl0ZXMsIGluIHJvdy1tYWpvciBvcmRlci4gYXJyYXlbeV1beF0gcmVwcmVzZW50cyBwb2ludCAoeCx5KVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogcHJlZmZlciB0byBsZXQgdHdvIG1ldGhvZHMgaW5zdGVhZCBvZiBvdmVycmlkZSB0byBhdm9pZCB0eXBlIGNvbXBhcmlzb24gaW5zaWRlXG4gICAgICAgIHNldE51bWJlcih4IC8qaW50Ki8sIHkgLyppbnQqLywgdmFsdWUgLypieXRlfGludCovKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVzW3ldW3hdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHVibGljIHNldCh4OiBudW1iZXIgLyppbnQqLywgeTogbnVtYmVyIC8qaW50Ki8sIHZhbHVlOiBudW1iZXIgLyppbnQqLyk6IHZvaWQge1xuICAgICAgICAvLyAgIGJ5dGVzW3ldW3hdID0gKGJ5dGUpIHZhbHVlXG4gICAgICAgIC8vIH1cbiAgICAgICAgc2V0Qm9vbGVhbih4IC8qaW50Ki8sIHkgLyppbnQqLywgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNbeV1beF0gPSAvKihieXRlKSAqLyAodmFsdWUgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXIodmFsdWUgLypieXRlKi8pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYUJ5dGUgb2YgdGhpcy5ieXRlcykge1xuICAgICAgICAgICAgICAgIEFycmF5cy5maWxsKGFCeXRlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBCeXRlTWF0cml4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0gbztcbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoICE9PSBvdGhlci53aWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCAhPT0gb3RoZXIuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDAsIGhlaWdodCA9IHRoaXMuaGVpZ2h0OyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlc1kgPSB0aGlzLmJ5dGVzW3ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQnl0ZXNZID0gb3RoZXIuYnl0ZXNbeV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDAsIHdpZHRoID0gdGhpcy53aWR0aDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzWVt4XSAhPT0gb3RoZXJCeXRlc1lbeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcigpOyAvLyAoMiAqIHdpZHRoICogaGVpZ2h0ICsgMilcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwLCBoZWlnaHQgPSB0aGlzLmhlaWdodDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXNZID0gdGhpcy5ieXRlc1t5XTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMCwgd2lkdGggPSB0aGlzLndpZHRoOyB4IDwgd2lkdGg7ICsreCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJ5dGVzWVt4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJyAwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnIDEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnICAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhdXRob3Igc2F0b3J1eEBnb29nbGUuY29tIChTYXRvcnUgVGFrYWJheWFzaGkpIC0gY3JlYXRvclxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pIC0gcG9ydGVkIGZyb20gQysrXG4gICAgICovXG4gICAgY2xhc3MgUVJDb2RlIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLm1hc2tQYXR0ZXJuID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TW9kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RUNMZXZlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmVyc2lvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TWFza1BhdHRlcm4oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXNrUGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICBnZXRNYXRyaXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7IC8vICgyMDApXG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKCc8PFxcbicpO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnIG1vZGU6ICcpO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0aGlzLm1vZGUgPyB0aGlzLm1vZGUudG9TdHJpbmcoKSA6ICdudWxsJyk7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdcXG4gZWNMZXZlbDogJyk7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKHRoaXMuZWNMZXZlbCA/IHRoaXMuZWNMZXZlbC50b1N0cmluZygpIDogJ251bGwnKTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbiB2ZXJzaW9uOiAnKTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodGhpcy52ZXJzaW9uID8gdGhpcy52ZXJzaW9uLnRvU3RyaW5nKCkgOiAnbnVsbCcpO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxuIG1hc2tQYXR0ZXJuOiAnKTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodGhpcy5tYXNrUGF0dGVybi50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbiBtYXRyaXg6XFxuJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0aGlzLm1hdHJpeC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbiBtYXRyaXg6IG51bGxcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJz4+XFxuJyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TW9kZSh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RUNMZXZlbCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5lY0xldmVsID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHNldE1hc2tQYXR0ZXJuKHZhbHVlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMubWFza1BhdHRlcm4gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRNYXRyaXgodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubWF0cml4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgXCJtYXNrX3BhdHRlcm5cIiBpcyB2YWxpZC5cbiAgICAgICAgc3RhdGljIGlzVmFsaWRNYXNrUGF0dGVybihtYXNrUGF0dGVybiAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFza1BhdHRlcm4gPj0gMCAmJiBtYXNrUGF0dGVybiA8IFFSQ29kZS5OVU1fTUFTS19QQVRURVJOUztcbiAgICAgICAgfVxuICAgIH1cbiAgICBRUkNvZGUuTlVNX01BU0tfUEFUVEVSTlMgPSA4O1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFdyaXRlckV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIFdyaXRlckV4Y2VwdGlvbi5raW5kID0gJ1dyaXRlckV4Y2VwdGlvbic7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHNhdG9ydXhAZ29vZ2xlLmNvbSAoU2F0b3J1IFRha2FiYXlhc2hpKSAtIGNyZWF0b3JcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKSAtIHBvcnRlZCBmcm9tIEMrK1xuICAgICAqL1xuICAgIGNsYXNzIE1hdHJpeFV0aWwge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgYWxsIGNlbGxzIHRvIC0xIChUWVBFU0NSSVBUUE9SVDogMjU1KS4gIC0xIChUWVBFU0NSSVBUUE9SVDogMjU1KSBtZWFucyB0aGF0IHRoZSBjZWxsIGlzIGVtcHR5IChub3Qgc2V0IHlldCkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEpBVkFQT1JUOiBXZSBzaG91bGRuJ3QgbmVlZCB0byBkbyB0aGlzIGF0IGFsbC4gVGhlIGNvZGUgc2hvdWxkIGJlIHJld3JpdHRlbiB0byBiZWdpbiBlbmNvZGluZ1xuICAgICAgICAvLyB3aXRoIHRoZSBCeXRlTWF0cml4IGluaXRpYWxpemVkIGFsbCB0byB6ZXJvLlxuICAgICAgICBzdGF0aWMgY2xlYXJNYXRyaXgobWF0cml4KSB7XG4gICAgICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogd2UgdXNlIFVpbnRBcnJheSBzZSBjaGFuZ2VkIGhlcmUgZnJvbSAtMSB0byAyNTVcbiAgICAgICAgICAgIG1hdHJpeC5jbGVhcigvKihieXRlKSAqLyAvKi0xKi8gMjU1KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCAyRCBtYXRyaXggb2YgUVIgQ29kZSBmcm9tIFwiZGF0YUJpdHNcIiB3aXRoIFwiZWNMZXZlbFwiLCBcInZlcnNpb25cIiBhbmQgXCJnZXRNYXNrUGF0dGVyblwiLiBPblxuICAgICAgICAvLyBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluIFwibWF0cml4XCIgYW5kIHJldHVybiB0cnVlLlxuICAgICAgICBzdGF0aWMgYnVpbGRNYXRyaXgoZGF0YUJpdHMsIGVjTGV2ZWwsIHZlcnNpb24sIG1hc2tQYXR0ZXJuIC8qaW50Ki8sIG1hdHJpeCkge1xuICAgICAgICAgICAgTWF0cml4VXRpbC5jbGVhck1hdHJpeChtYXRyaXgpO1xuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZEJhc2ljUGF0dGVybnModmVyc2lvbiwgbWF0cml4KTtcbiAgICAgICAgICAgIC8vIFR5cGUgaW5mb3JtYXRpb24gYXBwZWFyIHdpdGggYW55IHZlcnNpb24uXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkVHlwZUluZm8oZWNMZXZlbCwgbWFza1BhdHRlcm4sIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBWZXJzaW9uIGluZm8gYXBwZWFyIGlmIHZlcnNpb24gPj0gNy5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwubWF5YmVFbWJlZFZlcnNpb25JbmZvKHZlcnNpb24sIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBEYXRhIHNob3VsZCBiZSBlbWJlZGRlZCBhdCBlbmQuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkRGF0YUJpdHMoZGF0YUJpdHMsIG1hc2tQYXR0ZXJuLCBtYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVtYmVkIGJhc2ljIHBhdHRlcm5zLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeCBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgIC8vIFRoZSBiYXNpYyBwYXR0ZXJucyBhcmU6XG4gICAgICAgIC8vIC0gUG9zaXRpb24gZGV0ZWN0aW9uIHBhdHRlcm5zXG4gICAgICAgIC8vIC0gVGltaW5nIHBhdHRlcm5zXG4gICAgICAgIC8vIC0gRGFyayBkb3QgYXQgdGhlIGxlZnQgYm90dG9tIGNvcm5lclxuICAgICAgICAvLyAtIFBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybnMsIGlmIG5lZWQgYmVcbiAgICAgICAgc3RhdGljIGVtYmVkQmFzaWNQYXR0ZXJucyh2ZXJzaW9uLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIC8vIExldCdzIGdldCBzdGFydGVkIHdpdGggZW1iZWRkaW5nIGJpZyBzcXVhcmVzIGF0IGNvcm5lcnMuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkUG9zaXRpb25EZXRlY3Rpb25QYXR0ZXJuc0FuZFNlcGFyYXRvcnMobWF0cml4KTtcbiAgICAgICAgICAgIC8vIFRoZW4sIGVtYmVkIHRoZSBkYXJrIGRvdCBhdCB0aGUgbGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZERhcmtEb3RBdExlZnRCb3R0b21Db3JuZXIobWF0cml4KTtcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybnMgYXBwZWFyIGlmIHZlcnNpb24gPj0gMi5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwubWF5YmVFbWJlZFBvc2l0aW9uQWRqdXN0bWVudFBhdHRlcm5zKHZlcnNpb24sIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBUaW1pbmcgcGF0dGVybnMgc2hvdWxkIGJlIGVtYmVkZGVkIGFmdGVyIHBvc2l0aW9uIGFkai4gcGF0dGVybnMuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkVGltaW5nUGF0dGVybnMobWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbWJlZCB0eXBlIGluZm9ybWF0aW9uLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeC5cbiAgICAgICAgc3RhdGljIGVtYmVkVHlwZUluZm8oZWNMZXZlbCwgbWFza1BhdHRlcm4gLyppbnQqLywgbWF0cml4KSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlSW5mb0JpdHMgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIE1hdHJpeFV0aWwubWFrZVR5cGVJbmZvQml0cyhlY0xldmVsLCBtYXNrUGF0dGVybiwgdHlwZUluZm9CaXRzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzaXplID0gdHlwZUluZm9CaXRzLmdldFNpemUoKTsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIFBsYWNlIGJpdHMgaW4gTFNCIHRvIE1TQiBvcmRlci4gIExTQiAobGVhc3Qgc2lnbmlmaWNhbnQgYml0KSBpcyB0aGUgbGFzdCB2YWx1ZSBpblxuICAgICAgICAgICAgICAgIC8vIFwidHlwZUluZm9CaXRzXCIuXG4gICAgICAgICAgICAgICAgY29uc3QgYml0ID0gdHlwZUluZm9CaXRzLmdldCh0eXBlSW5mb0JpdHMuZ2V0U2l6ZSgpIC0gMSAtIGkpO1xuICAgICAgICAgICAgICAgIC8vIFR5cGUgaW5mbyBiaXRzIGF0IHRoZSBsZWZ0IHRvcCBjb3JuZXIuIFNlZSA4Ljkgb2YgSklTWDA1MTA6MjAwNCAocC40NikuXG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBNYXRyaXhVdGlsLlRZUEVfSU5GT19DT09SRElOQVRFU1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCB4MSA9IGNvb3JkaW5hdGVzWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkxID0gY29vcmRpbmF0ZXNbMV07XG4gICAgICAgICAgICAgICAgbWF0cml4LnNldEJvb2xlYW4oeDEsIHkxLCBiaXQpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgOCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4MiA9IG1hdHJpeC5nZXRXaWR0aCgpIC0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gODtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldEJvb2xlYW4oeDIsIHkyLCBiaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4MiA9IDg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gbWF0cml4LmdldEhlaWdodCgpIC0gNyArIChpIC0gOCk7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKHgyLCB5MiwgYml0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1iZWQgdmVyc2lvbiBpbmZvcm1hdGlvbiBpZiBuZWVkIGJlLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeCBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgIC8vIFNlZSA4LjEwIG9mIEpJU1gwNTEwOjIwMDQgKHAuNDcpIGZvciBob3cgdG8gZW1iZWQgdmVyc2lvbiBpbmZvcm1hdGlvbi5cbiAgICAgICAgc3RhdGljIG1heWJlRW1iZWRWZXJzaW9uSW5mbyh2ZXJzaW9uLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSA8IDcpIHsgLy8gVmVyc2lvbiBpbmZvIGlzIG5lY2Vzc2FyeSBpZiB2ZXJzaW9uID49IDcuXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBEb24ndCBuZWVkIHZlcnNpb24gaW5mby5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb25JbmZvQml0cyA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgTWF0cml4VXRpbC5tYWtlVmVyc2lvbkluZm9CaXRzKHZlcnNpb24sIHZlcnNpb25JbmZvQml0cyk7XG4gICAgICAgICAgICBsZXQgYml0SW5kZXggPSA2ICogMyAtIDE7IC8vIEl0IHdpbGwgZGVjcmVhc2UgZnJvbSAxNyB0byAwLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAvLyBQbGFjZSBiaXRzIGluIExTQiAobGVhc3Qgc2lnbmlmaWNhbnQgYml0KSB0byBNU0Igb3JkZXIuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdCA9IHZlcnNpb25JbmZvQml0cy5nZXQoYml0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiaXRJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKGksIG1hdHJpeC5nZXRIZWlnaHQoKSAtIDExICsgaiwgYml0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmlnaHQgYm90dG9tIGNvcm5lci5cbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldEJvb2xlYW4obWF0cml4LmdldEhlaWdodCgpIC0gMTEgKyBqLCBpLCBiaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFbWJlZCBcImRhdGFCaXRzXCIgdXNpbmcgXCJnZXRNYXNrUGF0dGVyblwiLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeCBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgIC8vIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMsIGl0IHNraXBzIG1hc2tpbmcgcHJvY2VzcyBpZiBcImdldE1hc2tQYXR0ZXJuXCIgaXMgLTEoVFlQRVNDUklQVFBPUlQ6IDI1NSkuXG4gICAgICAgIC8vIFNlZSA4Ljcgb2YgSklTWDA1MTA6MjAwNCAocC4zOCkgZm9yIGhvdyB0byBlbWJlZCBkYXRhIGJpdHMuXG4gICAgICAgIHN0YXRpYyBlbWJlZERhdGFCaXRzKGRhdGFCaXRzLCBtYXNrUGF0dGVybiAvKmludCovLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCBiaXRJbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgZGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICAvLyBTdGFydCBmcm9tIHRoZSByaWdodCBib3R0b20gY2VsbC5cbiAgICAgICAgICAgIGxldCB4ID0gbWF0cml4LmdldFdpZHRoKCkgLSAxO1xuICAgICAgICAgICAgbGV0IHkgPSBtYXRyaXguZ2V0SGVpZ2h0KCkgLSAxO1xuICAgICAgICAgICAgd2hpbGUgKHggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB0aGUgdmVydGljYWwgdGltaW5nIHBhdHRlcm4uXG4gICAgICAgICAgICAgICAgaWYgKHggPT09IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgeCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoeSA+PSAwICYmIHkgPCBtYXRyaXguZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHh4ID0geCAtIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHRoZSBjZWxsIGlmIGl0J3Mgbm90IGVtcHR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFNYXRyaXhVdGlsLmlzRW1wdHkobWF0cml4LmdldCh4eCwgeSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYml0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdEluZGV4IDwgZGF0YUJpdHMuZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0ID0gZGF0YUJpdHMuZ2V0KGJpdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2JpdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFkZGluZyBiaXQuIElmIHRoZXJlIGlzIG5vIGJpdCBsZWZ0LCB3ZSdsbCBmaWxsIHRoZSBsZWZ0IGNlbGxzIHdpdGggMCwgYXMgZGVzY3JpYmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gOC40Ljkgb2YgSklTWDA1MTA6MjAwNCAocC4gMjQpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBtYXNraW5nIGlmIG1hc2tfcGF0dGVybiBpcyAtMSAoVFlQRVNDUklQVFBPUlQ6IDI1NSkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1BhdHRlcm4gIT09IDI1NSAmJiBNYXNrVXRpbC5nZXREYXRhTWFza0JpdChtYXNrUGF0dGVybiwgeHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0ID0gIWJpdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKHh4LCB5LCBiaXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAtZGlyZWN0aW9uOyAvLyBSZXZlcnNlIHRoZSBkaXJlY3Rpb24uXG4gICAgICAgICAgICAgICAgeSArPSBkaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgeCAtPSAyOyAvLyBNb3ZlIHRvIHRoZSBsZWZ0LlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWxsIGJpdHMgc2hvdWxkIGJlIGNvbnN1bWVkLlxuICAgICAgICAgICAgaWYgKGJpdEluZGV4ICE9PSBkYXRhQml0cy5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdOb3QgYWxsIGJpdHMgY29uc3VtZWQ6ICcgKyBiaXRJbmRleCArICcvJyArIGRhdGFCaXRzLmdldFNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgc2V0IChvbmU6IHRvKSBpbiB0aGUgXCJ2YWx1ZVwiLiBUaGUgbW9zdFxuICAgICAgICAvLyBzaWduaWZpY2FudCBiaXQgaXMgcG9zaXRpb24gMzIuIElmIHRoZXJlIGlzIG5vIGJpdCBzZXQsIHJldHVybiAwLiBFeGFtcGxlczpcbiAgICAgICAgLy8gLSBmaW5kTVNCU2V0KDApID0+IDBcbiAgICAgICAgLy8gLSBmaW5kTVNCU2V0KDEpID0+IDFcbiAgICAgICAgLy8gLSBmaW5kTVNCU2V0KDI1NSkgPT4gOFxuICAgICAgICBzdGF0aWMgZmluZE1TQlNldCh2YWx1ZSAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gMzIgLSBJbnRlZ2VyLm51bWJlck9mTGVhZGluZ1plcm9zKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgQkNIIChCb3NlLUNoYXVkaHVyaS1Ib2NxdWVuZ2hlbSkgY29kZSBmb3IgXCJ2YWx1ZVwiIHVzaW5nIHBvbHlub21pYWwgXCJwb2x5XCIuIFRoZSBCQ0hcbiAgICAgICAgLy8gY29kZSBpcyB1c2VkIGZvciBlbmNvZGluZyB0eXBlIGluZm9ybWF0aW9uIGFuZCB2ZXJzaW9uIGluZm9ybWF0aW9uLlxuICAgICAgICAvLyBFeGFtcGxlOiBDYWxjdWxhdGlvbiBvZiB2ZXJzaW9uIGluZm9ybWF0aW9uIG9mIDcuXG4gICAgICAgIC8vIGYoeCkgaXMgY3JlYXRlZCBmcm9tIDcuXG4gICAgICAgIC8vICAgLSA3ID0gMDAwMTExIGluIDYgYml0c1xuICAgICAgICAvLyAgIC0gZih4KSA9IHheMiArIHheMSArIHheMFxuICAgICAgICAvLyBnKHgpIGlzIGdpdmVuIGJ5IHRoZSBzdGFuZGFyZCAocC4gNjcpXG4gICAgICAgIC8vICAgLSBnKHgpID0geF4xMiArIHheMTEgKyB4XjEwICsgeF45ICsgeF44ICsgeF41ICsgeF4yICsgMVxuICAgICAgICAvLyBNdWx0aXBseSBmKHgpIGJ5IHheKDE4IC0gNilcbiAgICAgICAgLy8gICAtIGYnKHgpID0gZih4KSAqIHheKDE4IC0gNilcbiAgICAgICAgLy8gICAtIGYnKHgpID0geF4xNCArIHheMTMgKyB4XjEyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcmVtYWluZGVyIG9mIGYnKHgpIC8gZyh4KVxuICAgICAgICAvLyAgICAgICAgIHheMlxuICAgICAgICAvLyAgICAgICAgIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXG4gICAgICAgIC8vICAgZyh4KSApeF4xNCArIHheMTMgKyB4XjEyXG4gICAgICAgIC8vICAgICAgICAgeF4xNCArIHheMTMgKyB4XjEyICsgeF4xMSArIHheMTAgKyB4XjcgKyB4XjQgKyB4XjJcbiAgICAgICAgLy8gICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHheMTEgKyB4XjEwICsgeF43ICsgeF40ICsgeF4yXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSByZW1haW5kZXIgaXMgeF4xMSArIHheMTAgKyB4XjcgKyB4XjQgKyB4XjJcbiAgICAgICAgLy8gRW5jb2RlIGl0IGluIGJpbmFyeTogMTEwMDEwMDEwMTAwXG4gICAgICAgIC8vIFRoZSByZXR1cm4gdmFsdWUgaXMgMHhjOTQgKDExMDAgMTAwMSAwMTAwKVxuICAgICAgICAvL1xuICAgICAgICAvLyBTaW5jZSBhbGwgY29lZmZpY2llbnRzIGluIHRoZSBwb2x5bm9taWFscyBhcmUgMSBvciAwLCB3ZSBjYW4gZG8gdGhlIGNhbGN1bGF0aW9uIGJ5IGJpdFxuICAgICAgICAvLyBvcGVyYXRpb25zLiBXZSBkb24ndCBjYXJlIGlmIGNvZWZmaWNpZW50cyBhcmUgcG9zaXRpdmUgb3IgbmVnYXRpdmUuXG4gICAgICAgIHN0YXRpYyBjYWxjdWxhdGVCQ0hDb2RlKHZhbHVlIC8qaW50Ki8sIHBvbHkgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKHBvbHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCcwIHBvbHlub21pYWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHBvbHkgaXMgXCIxIDExMTEgMDAxMCAwMTAxXCIgKHZlcnNpb24gaW5mbyBwb2x5KSwgbXNiU2V0SW5Qb2x5IGlzIDEzLiBXZSdsbCBzdWJ0cmFjdCAxXG4gICAgICAgICAgICAvLyBmcm9tIDEzIHRvIG1ha2UgaXQgMTIuXG4gICAgICAgICAgICBjb25zdCBtc2JTZXRJblBvbHkgPSBNYXRyaXhVdGlsLmZpbmRNU0JTZXQocG9seSk7XG4gICAgICAgICAgICB2YWx1ZSA8PD0gbXNiU2V0SW5Qb2x5IC0gMTtcbiAgICAgICAgICAgIC8vIERvIHRoZSBkaXZpc2lvbiBidXNpbmVzcyB1c2luZyBleGNsdXNpdmUtb3Igb3BlcmF0aW9ucy5cbiAgICAgICAgICAgIHdoaWxlIChNYXRyaXhVdGlsLmZpbmRNU0JTZXQodmFsdWUpID49IG1zYlNldEluUG9seSkge1xuICAgICAgICAgICAgICAgIHZhbHVlIF49IHBvbHkgPDwgKE1hdHJpeFV0aWwuZmluZE1TQlNldCh2YWx1ZSkgLSBtc2JTZXRJblBvbHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IHRoZSBcInZhbHVlXCIgaXMgdGhlIHJlbWFpbmRlciAoaS5lLiB0aGUgQkNIIGNvZGUpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBiaXQgdmVjdG9yIG9mIHR5cGUgaW5mb3JtYXRpb24uIE9uIHN1Y2Nlc3MsIHN0b3JlIHRoZSByZXN1bHQgaW4gXCJiaXRzXCIgYW5kIHJldHVybiB0cnVlLlxuICAgICAgICAvLyBFbmNvZGUgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCBhbmQgbWFzayBwYXR0ZXJuLiBTZWUgOC45IG9mXG4gICAgICAgIC8vIEpJU1gwNTEwOjIwMDQgKHAuNDUpIGZvciBkZXRhaWxzLlxuICAgICAgICBzdGF0aWMgbWFrZVR5cGVJbmZvQml0cyhlY0xldmVsLCBtYXNrUGF0dGVybiAvKmludCovLCBiaXRzKSB7XG4gICAgICAgICAgICBpZiAoIVFSQ29kZS5pc1ZhbGlkTWFza1BhdHRlcm4obWFza1BhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignSW52YWxpZCBtYXNrIHBhdHRlcm4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGVJbmZvID0gKGVjTGV2ZWwuZ2V0Qml0cygpIDw8IDMpIHwgbWFza1BhdHRlcm47XG4gICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHModHlwZUluZm8sIDUpO1xuICAgICAgICAgICAgY29uc3QgYmNoQ29kZSA9IE1hdHJpeFV0aWwuY2FsY3VsYXRlQkNIQ29kZSh0eXBlSW5mbywgTWF0cml4VXRpbC5UWVBFX0lORk9fUE9MWSk7XG4gICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMoYmNoQ29kZSwgMTApO1xuICAgICAgICAgICAgY29uc3QgbWFza0JpdHMgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIG1hc2tCaXRzLmFwcGVuZEJpdHMoTWF0cml4VXRpbC5UWVBFX0lORk9fTUFTS19QQVRURVJOLCAxNSk7XG4gICAgICAgICAgICBiaXRzLnhvcihtYXNrQml0cyk7XG4gICAgICAgICAgICBpZiAoYml0cy5nZXRTaXplKCkgIT09IDE1KSB7IC8vIEp1c3QgaW4gY2FzZS5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdzaG91bGQgbm90IGhhcHBlbiBidXQgd2UgZ290OiAnICsgYml0cy5nZXRTaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2UgYml0IHZlY3RvciBvZiB2ZXJzaW9uIGluZm9ybWF0aW9uLiBPbiBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluIFwiYml0c1wiIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAgICAgLy8gU2VlIDguMTAgb2YgSklTWDA1MTA6MjAwNCAocC40NSkgZm9yIGRldGFpbHMuXG4gICAgICAgIHN0YXRpYyBtYWtlVmVyc2lvbkluZm9CaXRzKHZlcnNpb24sIGJpdHMpIHtcbiAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSwgNik7XG4gICAgICAgICAgICBjb25zdCBiY2hDb2RlID0gTWF0cml4VXRpbC5jYWxjdWxhdGVCQ0hDb2RlKHZlcnNpb24uZ2V0VmVyc2lvbk51bWJlcigpLCBNYXRyaXhVdGlsLlZFUlNJT05fSU5GT19QT0xZKTtcbiAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhiY2hDb2RlLCAxMik7XG4gICAgICAgICAgICBpZiAoYml0cy5nZXRTaXplKCkgIT09IDE4KSB7IC8vIEp1c3QgaW4gY2FzZS5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdzaG91bGQgbm90IGhhcHBlbiBidXQgd2UgZ290OiAnICsgYml0cy5nZXRTaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIFwidmFsdWVcIiBpcyBlbXB0eS5cbiAgICAgICAgc3RhdGljIGlzRW1wdHkodmFsdWUgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSAyNTU7IC8vIC0xXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVtYmVkVGltaW5nUGF0dGVybnMobWF0cml4KSB7XG4gICAgICAgICAgICAvLyAtOCBpcyBmb3Igc2tpcHBpbmcgcG9zaXRpb24gZGV0ZWN0aW9uIHBhdHRlcm5zICg3OiBzaXplKSwgYW5kIHR3byBob3Jpem9udGFsL3ZlcnRpY2FsXG4gICAgICAgICAgICAvLyBzZXBhcmF0aW9uIHBhdHRlcm5zICgxOiBzaXplKS4gVGh1cywgOCA9IDcgKyAxLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDg7IGkgPCBtYXRyaXguZ2V0V2lkdGgoKSAtIDg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpdCA9IChpICsgMSkgJSAyO1xuICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgbGluZS5cbiAgICAgICAgICAgICAgICBpZiAoTWF0cml4VXRpbC5pc0VtcHR5KG1hdHJpeC5nZXQoaSwgNikpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXROdW1iZXIoaSwgNiwgYml0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVmVydGljYWwgbGluZS5cbiAgICAgICAgICAgICAgICBpZiAoTWF0cml4VXRpbC5pc0VtcHR5KG1hdHJpeC5nZXQoNiwgaSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXROdW1iZXIoNiwgaSwgYml0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1iZWQgdGhlIGxvbmVseSBkYXJrIGRvdCBhdCBsZWZ0IGJvdHRvbSBjb3JuZXIuIEpJU1gwNTEwOjIwMDQgKHAuNDYpXG4gICAgICAgIHN0YXRpYyBlbWJlZERhcmtEb3RBdExlZnRCb3R0b21Db3JuZXIobWF0cml4KSB7XG4gICAgICAgICAgICBpZiAobWF0cml4LmdldCg4LCBtYXRyaXguZ2V0SGVpZ2h0KCkgLSA4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdHJpeC5zZXROdW1iZXIoOCwgbWF0cml4LmdldEhlaWdodCgpIC0gOCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVtYmVkSG9yaXpvbnRhbFNlcGFyYXRpb25QYXR0ZXJuKHhTdGFydCAvKmludCovLCB5U3RhcnQgLyppbnQqLywgbWF0cml4KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDg7ICsreCkge1xuICAgICAgICAgICAgICAgIGlmICghTWF0cml4VXRpbC5pc0VtcHR5KG1hdHJpeC5nZXQoeFN0YXJ0ICsgeCwgeVN0YXJ0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKHhTdGFydCArIHgsIHlTdGFydCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVtYmVkVmVydGljYWxTZXBhcmF0aW9uUGF0dGVybih4U3RhcnQgLyppbnQqLywgeVN0YXJ0IC8qaW50Ki8sIG1hdHJpeCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA3OyArK3kpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU1hdHJpeFV0aWwuaXNFbXB0eShtYXRyaXguZ2V0KHhTdGFydCwgeVN0YXJ0ICsgeSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0cml4LnNldE51bWJlcih4U3RhcnQsIHlTdGFydCArIHksIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBlbWJlZFBvc2l0aW9uQWRqdXN0bWVudFBhdHRlcm4oeFN0YXJ0IC8qaW50Ki8sIHlTdGFydCAvKmludCovLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTsgKyt5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVyblkgPSBNYXRyaXhVdGlsLlBPU0lUSU9OX0FESlVTVE1FTlRfUEFUVEVSTlt5XTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDU7ICsreCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKHhTdGFydCArIHgsIHlTdGFydCArIHksIHBhdHRlcm5ZW3hdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVtYmVkUG9zaXRpb25EZXRlY3Rpb25QYXR0ZXJuKHhTdGFydCAvKmludCovLCB5U3RhcnQgLyppbnQqLywgbWF0cml4KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDc7ICsreSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5ZID0gTWF0cml4VXRpbC5QT1NJVElPTl9ERVRFQ1RJT05fUEFUVEVSTlt5XTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDc7ICsreCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKHhTdGFydCArIHgsIHlTdGFydCArIHksIHBhdHRlcm5ZW3hdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1iZWQgcG9zaXRpb24gZGV0ZWN0aW9uIHBhdHRlcm5zIGFuZCBzdXJyb3VuZGluZyB2ZXJ0aWNhbC9ob3Jpem9udGFsIHNlcGFyYXRvcnMuXG4gICAgICAgIHN0YXRpYyBlbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybnNBbmRTZXBhcmF0b3JzKG1hdHJpeCkge1xuICAgICAgICAgICAgLy8gRW1iZWQgdGhyZWUgYmlnIHNxdWFyZXMgYXQgY29ybmVycy5cbiAgICAgICAgICAgIGNvbnN0IHBkcFdpZHRoID0gTWF0cml4VXRpbC5QT1NJVElPTl9ERVRFQ1RJT05fUEFUVEVSTlswXS5sZW5ndGg7XG4gICAgICAgICAgICAvLyBMZWZ0IHRvcCBjb3JuZXIuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkUG9zaXRpb25EZXRlY3Rpb25QYXR0ZXJuKDAsIDAsIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybihtYXRyaXguZ2V0V2lkdGgoKSAtIHBkcFdpZHRoLCAwLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gTGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybigwLCBtYXRyaXguZ2V0V2lkdGgoKSAtIHBkcFdpZHRoLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gRW1iZWQgaG9yaXpvbnRhbCBzZXBhcmF0aW9uIHBhdHRlcm5zIGFyb3VuZCB0aGUgc3F1YXJlcy5cbiAgICAgICAgICAgIGNvbnN0IGhzcFdpZHRoID0gODtcbiAgICAgICAgICAgIC8vIExlZnQgdG9wIGNvcm5lci5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWRIb3Jpem9udGFsU2VwYXJhdGlvblBhdHRlcm4oMCwgaHNwV2lkdGggLSAxLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gUmlnaHQgdG9wIGNvcm5lci5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWRIb3Jpem9udGFsU2VwYXJhdGlvblBhdHRlcm4obWF0cml4LmdldFdpZHRoKCkgLSBoc3BXaWR0aCwgaHNwV2lkdGggLSAxLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gTGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZEhvcml6b250YWxTZXBhcmF0aW9uUGF0dGVybigwLCBtYXRyaXguZ2V0V2lkdGgoKSAtIGhzcFdpZHRoLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gRW1iZWQgdmVydGljYWwgc2VwYXJhdGlvbiBwYXR0ZXJucyBhcm91bmQgdGhlIHNxdWFyZXMuXG4gICAgICAgICAgICBjb25zdCB2c3BTaXplID0gNztcbiAgICAgICAgICAgIC8vIExlZnQgdG9wIGNvcm5lci5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWRWZXJ0aWNhbFNlcGFyYXRpb25QYXR0ZXJuKHZzcFNpemUsIDAsIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFZlcnRpY2FsU2VwYXJhdGlvblBhdHRlcm4obWF0cml4LmdldEhlaWdodCgpIC0gdnNwU2l6ZSAtIDEsIDAsIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkVmVydGljYWxTZXBhcmF0aW9uUGF0dGVybih2c3BTaXplLCBtYXRyaXguZ2V0SGVpZ2h0KCkgLSB2c3BTaXplLCBtYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVtYmVkIHBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybnMgaWYgbmVlZCBiZS5cbiAgICAgICAgc3RhdGljIG1heWJlRW1iZWRQb3NpdGlvbkFkanVzdG1lbnRQYXR0ZXJucyh2ZXJzaW9uLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSA8IDIpIHsgLy8gVGhlIHBhdHRlcm5zIGFwcGVhciBpZiB2ZXJzaW9uID49IDJcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHZlcnNpb24uZ2V0VmVyc2lvbk51bWJlcigpIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gTWF0cml4VXRpbC5QT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk5fQ09PUkRJTkFURV9UQUJMRVtpbmRleF07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpICE9PSBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoeSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBsZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IGNvb3JkaW5hdGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggPj0gMCAmJiBNYXRyaXhVdGlsLmlzRW1wdHkobWF0cml4LmdldCh4LCB5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2VsbCBpcyB1bnNldCwgd2UgZW1iZWQgdGhlIHBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybiBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0yIGlzIG5lY2Vzc2FyeSBzaW5jZSB0aGUgeC95IGNvb3JkaW5hdGVzIHBvaW50IHRvIHRoZSBjZW50ZXIgb2YgdGhlIHBhdHRlcm4sIG5vdCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZWZ0IHRvcCBjb3JuZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFBvc2l0aW9uQWRqdXN0bWVudFBhdHRlcm4oeCAtIDIsIHkgLSAyLCBtYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIE1hdHJpeFV0aWwuUE9TSVRJT05fREVURUNUSU9OX1BBVFRFUk4gPSBBcnJheS5mcm9tKFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMCwgMCwgMCwgMCwgMCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDAsIDEsIDEsIDEsIDAsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAxLCAxLCAxLCAwLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMCwgMSwgMSwgMSwgMCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDAsIDAsIDAsIDAsIDAsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxLCAxLCAxXSksXG4gICAgXSk7XG4gICAgTWF0cml4VXRpbC5QT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk4gPSBBcnJheS5mcm9tKFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMCwgMCwgMCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDAsIDEsIDAsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAwLCAwLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMSwgMV0pLFxuICAgIF0pO1xuICAgIC8vIEZyb20gQXBwZW5kaXggRS4gVGFibGUgMSwgSklTMDUxMFg6MjAwNCAoNzE6IHApLiBUaGUgdGFibGUgd2FzIGRvdWJsZS1jaGVja2VkIGJ5IGtvbWF0c3UuXG4gICAgTWF0cml4VXRpbC5QT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk5fQ09PUkRJTkFURV9UQUJMRSA9IEFycmF5LmZyb20oW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWy0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMTgsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDIyLCAtMSwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgLTEsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCAtMSwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyMiwgMzgsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjQsIDQyLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA0NiwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTAsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMyLCA1OCwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjIsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDQ2LCA2NiwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA0OCwgNzAsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0LCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NiwgODIsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI4LCA1MCwgNzIsIDk0LCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0LCA5OCwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTQsIDgwLCAxMDYsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMyLCA1OCwgODQsIDExMCwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0LCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjIsIDkwLCAxMTgsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1MCwgNzQsIDk4LCAxMjIsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDUyLCA3OCwgMTA0LCAxMzAsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU2LCA4MiwgMTA4LCAxMzQsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzgsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDIsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgMTE4LCAxNDYsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI0LCA1MCwgNzYsIDEwMiwgMTI4LCAxNTRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTQsIDgwLCAxMDYsIDEzMiwgMTU4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzIsIDU4LCA4NCwgMTEwLCAxMzYsIDE2Ml0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1NCwgODIsIDExMCwgMTM4LCAxNjZdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXSksXG4gICAgXSk7XG4gICAgLy8gVHlwZSBpbmZvIGNlbGxzIGF0IHRoZSBsZWZ0IHRvcCBjb3JuZXIuXG4gICAgTWF0cml4VXRpbC5UWVBFX0lORk9fQ09PUkRJTkFURVMgPSBBcnJheS5mcm9tKFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCAwXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbOCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzgsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbOCwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzgsIDVdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCA3XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbOCwgOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzcsIDhdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs1LCA4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDhdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCA4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzAsIDhdKSxcbiAgICBdKTtcbiAgICAvLyBGcm9tIEFwcGVuZGl4IEQgaW4gSklTWDA1MTA6MjAwNCAocC4gNjcpXG4gICAgTWF0cml4VXRpbC5WRVJTSU9OX0lORk9fUE9MWSA9IDB4MWYyNTsgLy8gMSAxMTExIDAwMTAgMDEwMVxuICAgIC8vIEZyb20gQXBwZW5kaXggQyBpbiBKSVNYMDUxMDoyMDA0IChwLjY1KS5cbiAgICBNYXRyaXhVdGlsLlRZUEVfSU5GT19QT0xZID0gMHg1Mzc7XG4gICAgTWF0cml4VXRpbC5UWVBFX0lORk9fTUFTS19QQVRURVJOID0gMHg1NDEyO1xuXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZW5jb2RlciB7Ki9cbiAgICBjbGFzcyBCbG9ja1BhaXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihkYXRhQnl0ZXMsIGVycm9yQ29ycmVjdGlvbkJ5dGVzKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFCeXRlcyA9IGRhdGFCeXRlcztcbiAgICAgICAgICAgIHRoaXMuZXJyb3JDb3JyZWN0aW9uQnl0ZXMgPSBlcnJvckNvcnJlY3Rpb25CeXRlcztcbiAgICAgICAgfVxuICAgICAgICBnZXREYXRhQnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RXJyb3JDb3JyZWN0aW9uQnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvcnJlY3Rpb25CeXRlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qaW1wb3J0IGphdmEuaW8uVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbjsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbjsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHNhdG9ydXhAZ29vZ2xlLmNvbSAoU2F0b3J1IFRha2FiYXlhc2hpKSAtIGNyZWF0b3JcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKSAtIHBvcnRlZCBmcm9tIEMrK1xuICAgICAqL1xuICAgIGNsYXNzIEVuY29kZXIge1xuICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogY2hhbmdlZCB0byBVVEY4LCB0aGUgZGVmYXVsdCBmb3IganNcbiAgICAgICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAgICAgLy8gVGhlIG1hc2sgcGVuYWx0eSBjYWxjdWxhdGlvbiBpcyBjb21wbGljYXRlZC4gIFNlZSBUYWJsZSAyMSBvZiBKSVNYMDUxMDoyMDA0IChwLjQ1KSBmb3IgZGV0YWlscy5cbiAgICAgICAgLy8gQmFzaWNhbGx5IGl0IGFwcGxpZXMgZm91ciBydWxlcyBhbmQgc3VtbWF0ZSBhbGwgcGVuYWx0aWVzLlxuICAgICAgICBzdGF0aWMgY2FsY3VsYXRlTWFza1BlbmFsdHkobWF0cml4KSB7XG4gICAgICAgICAgICByZXR1cm4gTWFza1V0aWwuYXBwbHlNYXNrUGVuYWx0eVJ1bGUxKG1hdHJpeClcbiAgICAgICAgICAgICAgICArIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlMihtYXRyaXgpXG4gICAgICAgICAgICAgICAgKyBNYXNrVXRpbC5hcHBseU1hc2tQZW5hbHR5UnVsZTMobWF0cml4KVxuICAgICAgICAgICAgICAgICsgTWFza1V0aWwuYXBwbHlNYXNrUGVuYWx0eVJ1bGU0KG1hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBjb250ZW50IHRleHQgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSBlY0xldmVsIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwgdG8gdXNlXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIFFSQ29kZX0gcmVwcmVzZW50aW5nIHRoZSBlbmNvZGVkIFFSIGNvZGVcbiAgICAgICAgICogQHRocm93cyBXcml0ZXJFeGNlcHRpb24gaWYgZW5jb2RpbmcgY2FuJ3Qgc3VjY2VlZCwgYmVjYXVzZSBvZiBmb3IgZXhhbXBsZSBpbnZhbGlkIGNvbnRlbnRcbiAgICAgICAgICogICBvciBjb25maWd1cmF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgc3RhdGljIGVuY29kZShjb250ZW50OiBzdHJpbmcsIGVjTGV2ZWw6IEVycm9yQ29ycmVjdGlvbkxldmVsKTogUVJDb2RlIC8qdGhyb3dzIFdyaXRlckV4Y2VwdGlvbiovIHtcbiAgICAgICAgLy8gICByZXR1cm4gZW5jb2RlKGNvbnRlbnQsIGVjTGV2ZWwsIG51bGwpXG4gICAgICAgIC8vIH1cbiAgICAgICAgc3RhdGljIGVuY29kZShjb250ZW50LCBlY0xldmVsLCBoaW50cyA9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGF0IGNoYXJhY3RlciBlbmNvZGluZyBoYXMgYmVlbiBzcGVjaWZpZWQgYnkgdGhlIGNhbGxlciwgaWYgYW55XG4gICAgICAgICAgICBsZXQgZW5jb2RpbmcgPSBFbmNvZGVyLkRFRkFVTFRfQllURV9NT0RFX0VOQ09ESU5HO1xuICAgICAgICAgICAgY29uc3QgaGFzRW5jb2RpbmdIaW50ID0gaGludHMgIT09IG51bGwgJiYgdW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5DSEFSQUNURVJfU0VUKTtcbiAgICAgICAgICAgIGlmIChoYXNFbmNvZGluZ0hpbnQpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLkNIQVJBQ1RFUl9TRVQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQaWNrIGFuIGVuY29kaW5nIG1vZGUgYXBwcm9wcmlhdGUgZm9yIHRoZSBjb250ZW50LiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBhdHRlbXB0IHRvIHVzZVxuICAgICAgICAgICAgLy8gbXVsdGlwbGUgbW9kZXMgLyBzZWdtZW50cyBldmVuIGlmIHRoYXQgd2VyZSBtb3JlIGVmZmljaWVudC4gVHdvdWxkIGJlIG5pY2UuXG4gICAgICAgICAgICBjb25zdCBtb2RlID0gdGhpcy5jaG9vc2VNb2RlKGNvbnRlbnQsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBzdG9yZSB0aGUgaGVhZGVyIGluZm9ybWF0aW9uLCBsaWtlIG1vZGUgYW5kXG4gICAgICAgICAgICAvLyBsZW5ndGgsIGFzIHdlbGwgYXMgXCJoZWFkZXJcIiBzZWdtZW50cyBsaWtlIGFuIEVDSSBzZWdtZW50LlxuICAgICAgICAgICAgY29uc3QgaGVhZGVyQml0cyA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgLy8gQXBwZW5kIEVDSSBzZWdtZW50IGlmIGFwcGxpY2FibGVcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBNb2RlJDEuQllURSAmJiAoaGFzRW5jb2RpbmdIaW50IHx8IEVuY29kZXIuREVGQVVMVF9CWVRFX01PREVfRU5DT0RJTkcgIT09IGVuY29kaW5nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVjaSA9IENoYXJhY3RlclNldEVDSS5nZXRDaGFyYWN0ZXJTZXRFQ0lCeU5hbWUoZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIGlmIChlY2kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVDSShlY2ksIGhlYWRlckJpdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIChXaXRoIEVDSSBpbiBwbGFjZSwpIFdyaXRlIHRoZSBtb2RlIG1hcmtlclxuICAgICAgICAgICAgdGhpcy5hcHBlbmRNb2RlSW5mbyhtb2RlLCBoZWFkZXJCaXRzKTtcbiAgICAgICAgICAgIC8vIENvbGxlY3QgZGF0YSB3aXRoaW4gdGhlIG1haW4gc2VnbWVudCwgc2VwYXJhdGVseSwgdG8gY291bnQgaXRzIHNpemUgaWYgbmVlZGVkLiBEb24ndCBhZGQgaXQgdG9cbiAgICAgICAgICAgIC8vIG1haW4gcGF5bG9hZCB5ZXQuXG4gICAgICAgICAgICBjb25zdCBkYXRhQml0cyA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRCeXRlcyhjb250ZW50LCBtb2RlLCBkYXRhQml0cywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgbGV0IHZlcnNpb247XG4gICAgICAgICAgICBpZiAoaGludHMgIT09IG51bGwgJiYgdW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5RUl9WRVJTSU9OKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25OdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuUVJfVkVSU0lPTikudG9TdHJpbmcoKSwgMTApO1xuICAgICAgICAgICAgICAgIHZlcnNpb24gPSBWZXJzaW9uJDEuZ2V0VmVyc2lvbkZvck51bWJlcih2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiaXRzTmVlZGVkID0gdGhpcy5jYWxjdWxhdGVCaXRzTmVlZGVkKG1vZGUsIGhlYWRlckJpdHMsIGRhdGFCaXRzLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2lsbEZpdChiaXRzTmVlZGVkLCB2ZXJzaW9uLCBlY0xldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdEYXRhIHRvbyBiaWcgZm9yIHJlcXVlc3RlZCB2ZXJzaW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbiA9IHRoaXMucmVjb21tZW5kVmVyc2lvbihlY0xldmVsLCBtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJBbmREYXRhQml0cyA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgaGVhZGVyQW5kRGF0YUJpdHMuYXBwZW5kQml0QXJyYXkoaGVhZGVyQml0cyk7XG4gICAgICAgICAgICAvLyBGaW5kIFwibGVuZ3RoXCIgb2YgbWFpbiBzZWdtZW50IGFuZCB3cml0ZSBpdFxuICAgICAgICAgICAgY29uc3QgbnVtTGV0dGVycyA9IG1vZGUgPT09IE1vZGUkMS5CWVRFID8gZGF0YUJpdHMuZ2V0U2l6ZUluQnl0ZXMoKSA6IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRMZW5ndGhJbmZvKG51bUxldHRlcnMsIHZlcnNpb24sIG1vZGUsIGhlYWRlckFuZERhdGFCaXRzKTtcbiAgICAgICAgICAgIC8vIFB1dCBkYXRhIHRvZ2V0aGVyIGludG8gdGhlIG92ZXJhbGwgcGF5bG9hZFxuICAgICAgICAgICAgaGVhZGVyQW5kRGF0YUJpdHMuYXBwZW5kQml0QXJyYXkoZGF0YUJpdHMpO1xuICAgICAgICAgICAgY29uc3QgZWNCbG9ja3MgPSB2ZXJzaW9uLmdldEVDQmxvY2tzRm9yTGV2ZWwoZWNMZXZlbCk7XG4gICAgICAgICAgICBjb25zdCBudW1EYXRhQnl0ZXMgPSB2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkgLSBlY0Jsb2Nrcy5nZXRUb3RhbEVDQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAvLyBUZXJtaW5hdGUgdGhlIGJpdHMgcHJvcGVybHkuXG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZUJpdHMobnVtRGF0YUJ5dGVzLCBoZWFkZXJBbmREYXRhQml0cyk7XG4gICAgICAgICAgICAvLyBJbnRlcmxlYXZlIGRhdGEgYml0cyB3aXRoIGVycm9yIGNvcnJlY3Rpb24gY29kZS5cbiAgICAgICAgICAgIGNvbnN0IGZpbmFsQml0cyA9IHRoaXMuaW50ZXJsZWF2ZVdpdGhFQ0J5dGVzKGhlYWRlckFuZERhdGFCaXRzLCB2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCksIG51bURhdGFCeXRlcywgZWNCbG9ja3MuZ2V0TnVtQmxvY2tzKCkpO1xuICAgICAgICAgICAgY29uc3QgcXJDb2RlID0gbmV3IFFSQ29kZSgpO1xuICAgICAgICAgICAgcXJDb2RlLnNldEVDTGV2ZWwoZWNMZXZlbCk7XG4gICAgICAgICAgICBxckNvZGUuc2V0TW9kZShtb2RlKTtcbiAgICAgICAgICAgIHFyQ29kZS5zZXRWZXJzaW9uKHZlcnNpb24pO1xuICAgICAgICAgICAgLy8gIENob29zZSB0aGUgbWFzayBwYXR0ZXJuIGFuZCBzZXQgdG8gXCJxckNvZGVcIi5cbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHZlcnNpb24uZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpO1xuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IEJ5dGVNYXRyaXgoZGltZW5zaW9uLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgY29uc3QgbWFza1BhdHRlcm4gPSB0aGlzLmNob29zZU1hc2tQYXR0ZXJuKGZpbmFsQml0cywgZWNMZXZlbCwgdmVyc2lvbiwgbWF0cml4KTtcbiAgICAgICAgICAgIHFyQ29kZS5zZXRNYXNrUGF0dGVybihtYXNrUGF0dGVybik7XG4gICAgICAgICAgICAvLyBCdWlsZCB0aGUgbWF0cml4IGFuZCBzZXQgaXQgdG8gXCJxckNvZGVcIi5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuYnVpbGRNYXRyaXgoZmluYWxCaXRzLCBlY0xldmVsLCB2ZXJzaW9uLCBtYXNrUGF0dGVybiwgbWF0cml4KTtcbiAgICAgICAgICAgIHFyQ29kZS5zZXRNYXRyaXgobWF0cml4KTtcbiAgICAgICAgICAgIHJldHVybiBxckNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY2lkZXMgdGhlIHNtYWxsZXN0IHZlcnNpb24gb2YgUVIgY29kZSB0aGF0IHdpbGwgY29udGFpbiBhbGwgb2YgdGhlIHByb3ZpZGVkIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgV3JpdGVyRXhjZXB0aW9uIGlmIHRoZSBkYXRhIGNhbm5vdCBmaXQgaW4gYW55IHZlcnNpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyByZWNvbW1lbmRWZXJzaW9uKGVjTGV2ZWwsIG1vZGUsIGhlYWRlckJpdHMsIGRhdGFCaXRzKSB7XG4gICAgICAgICAgICAvLyBIYXJkIHBhcnQ6IG5lZWQgdG8ga25vdyB2ZXJzaW9uIHRvIGtub3cgaG93IG1hbnkgYml0cyBsZW5ndGggdGFrZXMuIEJ1dCBuZWVkIHRvIGtub3cgaG93IG1hbnlcbiAgICAgICAgICAgIC8vIGJpdHMgaXQgdGFrZXMgdG8ga25vdyB2ZXJzaW9uLiBGaXJzdCB3ZSB0YWtlIGEgZ3Vlc3MgYXQgdmVyc2lvbiBieSBhc3N1bWluZyB2ZXJzaW9uIHdpbGwgYmVcbiAgICAgICAgICAgIC8vIHRoZSBtaW5pbXVtLCAxOlxuICAgICAgICAgICAgY29uc3QgcHJvdmlzaW9uYWxCaXRzTmVlZGVkID0gdGhpcy5jYWxjdWxhdGVCaXRzTmVlZGVkKG1vZGUsIGhlYWRlckJpdHMsIGRhdGFCaXRzLCBWZXJzaW9uJDEuZ2V0VmVyc2lvbkZvck51bWJlcigxKSk7XG4gICAgICAgICAgICBjb25zdCBwcm92aXNpb25hbFZlcnNpb24gPSB0aGlzLmNob29zZVZlcnNpb24ocHJvdmlzaW9uYWxCaXRzTmVlZGVkLCBlY0xldmVsKTtcbiAgICAgICAgICAgIC8vIFVzZSB0aGF0IGd1ZXNzIHRvIGNhbGN1bGF0ZSB0aGUgcmlnaHQgdmVyc2lvbi4gSSBhbSBzdGlsbCBub3Qgc3VyZSB0aGlzIHdvcmtzIGluIDEwMCUgb2YgY2FzZXMuXG4gICAgICAgICAgICBjb25zdCBiaXRzTmVlZGVkID0gdGhpcy5jYWxjdWxhdGVCaXRzTmVlZGVkKG1vZGUsIGhlYWRlckJpdHMsIGRhdGFCaXRzLCBwcm92aXNpb25hbFZlcnNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hvb3NlVmVyc2lvbihiaXRzTmVlZGVkLCBlY0xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2FsY3VsYXRlQml0c05lZWRlZChtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cywgdmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlckJpdHMuZ2V0U2l6ZSgpICsgbW9kZS5nZXRDaGFyYWN0ZXJDb3VudEJpdHModmVyc2lvbikgKyBkYXRhQml0cy5nZXRTaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdGhlIGNvZGUgcG9pbnQgb2YgdGhlIHRhYmxlIHVzZWQgaW4gYWxwaGFudW1lcmljIG1vZGUgb3JcbiAgICAgICAgICogIC0xIGlmIHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgY29kZSBpbiB0aGUgdGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0QWxwaGFudW1lcmljQ29kZShjb2RlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChjb2RlIDwgRW5jb2Rlci5BTFBIQU5VTUVSSUNfVEFCTEUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVuY29kZXIuQUxQSEFOVU1FUklDX1RBQkxFW2NvZGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIHB1YmxpYyBzdGF0aWMgY2hvb3NlTW9kZShjb250ZW50OiBzdHJpbmcpOiBNb2RlIHtcbiAgICAgICAgLy8gICByZXR1cm4gY2hvb3NlTW9kZShjb250ZW50LCBudWxsKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hvb3NlIHRoZSBiZXN0IG1vZGUgYnkgZXhhbWluaW5nIHRoZSBjb250ZW50LiBOb3RlIHRoYXQgJ2VuY29kaW5nJyBpcyB1c2VkIGFzIGEgaGludDtcbiAgICAgICAgICogaWYgaXQgaXMgU2hpZnRfSklTLCBhbmQgdGhlIGlucHV0IGlzIG9ubHkgZG91YmxlLWJ5dGUgS2FuamksIHRoZW4gd2UgcmV0dXJuIHtAbGluayBNb2RlI0tBTkpJfS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjaG9vc2VNb2RlKGNvbnRlbnQsIGVuY29kaW5nID0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKENoYXJhY3RlclNldEVDSS5TSklTLmdldE5hbWUoKSA9PT0gZW5jb2RpbmcgJiYgdGhpcy5pc09ubHlEb3VibGVCeXRlS2FuamkoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBDaG9vc2UgS2FuamkgbW9kZSBpZiBhbGwgaW5wdXQgYXJlIGRvdWJsZS1ieXRlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICByZXR1cm4gTW9kZSQxLktBTkpJO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhhc051bWVyaWMgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBoYXNBbHBoYW51bWVyaWMgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBjb250ZW50Lmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGNvbnRlbnQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChFbmNvZGVyLmlzRGlnaXQoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTnVtZXJpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZ2V0QWxwaGFudW1lcmljQ29kZShjLmNoYXJDb2RlQXQoMCkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNBbHBoYW51bWVyaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUkMS5CWVRFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNBbHBoYW51bWVyaWMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTW9kZSQxLkFMUEhBTlVNRVJJQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNOdW1lcmljKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUkMS5OVU1FUklDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE1vZGUkMS5CWVRFO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpc09ubHlEb3VibGVCeXRlS2FuamkoY29udGVudCkge1xuICAgICAgICAgICAgbGV0IGJ5dGVzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBieXRlcyA9IFN0cmluZ0VuY29kaW5nLmVuY29kZShjb250ZW50LCBDaGFyYWN0ZXJTZXRFQ0kuU0pJUyk7IC8vIGNvbnRlbnQuZ2V0Qnl0ZXMoXCJTaGlmdF9KSVNcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCAvKjogVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBieXRlc1tpXSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgaWYgKChieXRlMSA8IDB4ODEgfHwgYnl0ZTEgPiAweDlGKSAmJiAoYnl0ZTEgPCAweEUwIHx8IGJ5dGUxID4gMHhFQikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjaG9vc2VNYXNrUGF0dGVybihiaXRzLCBlY0xldmVsLCB2ZXJzaW9uLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCBtaW5QZW5hbHR5ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7IC8vIExvd2VyIHBlbmFsdHkgaXMgYmV0dGVyLlxuICAgICAgICAgICAgbGV0IGJlc3RNYXNrUGF0dGVybiA9IC0xO1xuICAgICAgICAgICAgLy8gV2UgdHJ5IGFsbCBtYXNrIHBhdHRlcm5zIHRvIGNob29zZSB0aGUgYmVzdCBvbmUuXG4gICAgICAgICAgICBmb3IgKGxldCBtYXNrUGF0dGVybiA9IDA7IG1hc2tQYXR0ZXJuIDwgUVJDb2RlLk5VTV9NQVNLX1BBVFRFUk5TOyBtYXNrUGF0dGVybisrKSB7XG4gICAgICAgICAgICAgICAgTWF0cml4VXRpbC5idWlsZE1hdHJpeChiaXRzLCBlY0xldmVsLCB2ZXJzaW9uLCBtYXNrUGF0dGVybiwgbWF0cml4KTtcbiAgICAgICAgICAgICAgICBsZXQgcGVuYWx0eSA9IHRoaXMuY2FsY3VsYXRlTWFza1BlbmFsdHkobWF0cml4KTtcbiAgICAgICAgICAgICAgICBpZiAocGVuYWx0eSA8IG1pblBlbmFsdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluUGVuYWx0eSA9IHBlbmFsdHk7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXNrUGF0dGVybiA9IG1hc2tQYXR0ZXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiZXN0TWFza1BhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNob29zZVZlcnNpb24obnVtSW5wdXRCaXRzIC8qaW50Ki8sIGVjTGV2ZWwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHZlcnNpb25OdW0gPSAxOyB2ZXJzaW9uTnVtIDw9IDQwOyB2ZXJzaW9uTnVtKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gVmVyc2lvbiQxLmdldFZlcnNpb25Gb3JOdW1iZXIodmVyc2lvbk51bSk7XG4gICAgICAgICAgICAgICAgaWYgKEVuY29kZXIud2lsbEZpdChudW1JbnB1dEJpdHMsIHZlcnNpb24sIGVjTGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0RhdGEgdG9vIGJpZycpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIG51bWJlciBvZiBpbnB1dCBiaXRzIHdpbGwgZml0IGluIGEgY29kZSB3aXRoIHRoZSBzcGVjaWZpZWQgdmVyc2lvbiBhbmRcbiAgICAgICAgICogZXJyb3IgY29ycmVjdGlvbiBsZXZlbC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyB3aWxsRml0KG51bUlucHV0Qml0cyAvKmludCovLCB2ZXJzaW9uLCBlY0xldmVsKSB7XG4gICAgICAgICAgICAvLyBJbiB0aGUgZm9sbG93aW5nIGNvbW1lbnRzLCB3ZSB1c2UgbnVtYmVycyBvZiBWZXJzaW9uIDctSC5cbiAgICAgICAgICAgIC8vIG51bUJ5dGVzID0gMTk2XG4gICAgICAgICAgICBjb25zdCBudW1CeXRlcyA9IHZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIC8vIGdldE51bUVDQnl0ZXMgPSAxMzBcbiAgICAgICAgICAgIGNvbnN0IGVjQmxvY2tzID0gdmVyc2lvbi5nZXRFQ0Jsb2Nrc0ZvckxldmVsKGVjTGV2ZWwpO1xuICAgICAgICAgICAgY29uc3QgbnVtRWNCeXRlcyA9IGVjQmxvY2tzLmdldFRvdGFsRUNDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIC8vIGdldE51bURhdGFCeXRlcyA9IDE5NiAtIDEzMCA9IDY2XG4gICAgICAgICAgICBjb25zdCBudW1EYXRhQnl0ZXMgPSBudW1CeXRlcyAtIG51bUVjQnl0ZXM7XG4gICAgICAgICAgICBjb25zdCB0b3RhbElucHV0Qnl0ZXMgPSAobnVtSW5wdXRCaXRzICsgNykgLyA4O1xuICAgICAgICAgICAgcmV0dXJuIG51bURhdGFCeXRlcyA+PSB0b3RhbElucHV0Qnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlcm1pbmF0ZSBiaXRzIGFzIGRlc2NyaWJlZCBpbiA4LjQuOCBhbmQgOC40Ljkgb2YgSklTWDA1MTA6MjAwNCAocC4yNCkuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgdGVybWluYXRlQml0cyhudW1EYXRhQnl0ZXMgLyppbnQqLywgYml0cykge1xuICAgICAgICAgICAgY29uc3QgY2FwYWNpdHkgPSBudW1EYXRhQnl0ZXMgKiA4O1xuICAgICAgICAgICAgaWYgKGJpdHMuZ2V0U2l6ZSgpID4gY2FwYWNpdHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdkYXRhIGJpdHMgY2Fubm90IGZpdCBpbiB0aGUgUVIgQ29kZScgKyBiaXRzLmdldFNpemUoKSArICcgPiAnICtcbiAgICAgICAgICAgICAgICAgICAgY2FwYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0ICYmIGJpdHMuZ2V0U2l6ZSgpIDwgY2FwYWNpdHk7ICsraSkge1xuICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0ZXJtaW5hdGlvbiBiaXRzLiBTZWUgOC40Ljggb2YgSklTWDA1MTA6MjAwNCAocC4yNCkgZm9yIGRldGFpbHMuXG4gICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBieXRlIGlzbid0IDgtYml0IGFsaWduZWQsIHdlJ2xsIGFkZCBwYWRkaW5nIGJpdHMuXG4gICAgICAgICAgICBjb25zdCBudW1CaXRzSW5MYXN0Qnl0ZSA9IGJpdHMuZ2V0U2l6ZSgpICYgMHgwNztcbiAgICAgICAgICAgIGlmIChudW1CaXRzSW5MYXN0Qnl0ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbnVtQml0c0luTGFzdEJ5dGU7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSBzcGFjZSwgd2UnbGwgZmlsbCB0aGUgc3BhY2Ugd2l0aCBwYWRkaW5nIHBhdHRlcm5zIGRlZmluZWQgaW4gOC40LjkgKHAuMjQpLlxuICAgICAgICAgICAgY29uc3QgbnVtUGFkZGluZ0J5dGVzID0gbnVtRGF0YUJ5dGVzIC0gYml0cy5nZXRTaXplSW5CeXRlcygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1QYWRkaW5nQnl0ZXM7ICsraSkge1xuICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cygoaSAmIDB4MDEpID09PSAwID8gMHhFQyA6IDB4MTEsIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpdHMuZ2V0U2l6ZSgpICE9PSBjYXBhY2l0eSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0JpdHMgc2l6ZSBkb2VzIG5vdCBlcXVhbCBjYXBhY2l0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgbnVtYmVyIG9mIGRhdGEgYnl0ZXMgYW5kIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGJ5dGVzIGZvciBibG9jayBpZCBcImJsb2NrSURcIi4gU3RvcmVcbiAgICAgICAgICogdGhlIHJlc3VsdCBpbiBcIm51bURhdGFCeXRlc0luQmxvY2tcIiwgYW5kIFwibnVtRUNCeXRlc0luQmxvY2tcIi4gU2VlIHRhYmxlIDEyIGluIDguNS4xIG9mXG4gICAgICAgICAqIEpJU1gwNTEwOjIwMDQgKHAuMzApXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0TnVtRGF0YUJ5dGVzQW5kTnVtRUNCeXRlc0ZvckJsb2NrSUQobnVtVG90YWxCeXRlcyAvKmludCovLCBudW1EYXRhQnl0ZXMgLyppbnQqLywgbnVtUlNCbG9ja3MgLyppbnQqLywgYmxvY2tJRCAvKmludCovLCBudW1EYXRhQnl0ZXNJbkJsb2NrLCBudW1FQ0J5dGVzSW5CbG9jaykge1xuICAgICAgICAgICAgaWYgKGJsb2NrSUQgPj0gbnVtUlNCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdCbG9jayBJRCB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG51bVJzQmxvY2tzSW5Hcm91cDIgPSAxOTYgJSA1ID0gMVxuICAgICAgICAgICAgY29uc3QgbnVtUnNCbG9ja3NJbkdyb3VwMiA9IG51bVRvdGFsQnl0ZXMgJSBudW1SU0Jsb2NrcztcbiAgICAgICAgICAgIC8vIG51bVJzQmxvY2tzSW5Hcm91cDEgPSA1IC0gMSA9IDRcbiAgICAgICAgICAgIGNvbnN0IG51bVJzQmxvY2tzSW5Hcm91cDEgPSBudW1SU0Jsb2NrcyAtIG51bVJzQmxvY2tzSW5Hcm91cDI7XG4gICAgICAgICAgICAvLyBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgPSAxOTYgLyA1ID0gMzlcbiAgICAgICAgICAgIGNvbnN0IG51bVRvdGFsQnl0ZXNJbkdyb3VwMSA9IE1hdGguZmxvb3IobnVtVG90YWxCeXRlcyAvIG51bVJTQmxvY2tzKTtcbiAgICAgICAgICAgIC8vIG51bVRvdGFsQnl0ZXNJbkdyb3VwMiA9IDM5ICsgMSA9IDQwXG4gICAgICAgICAgICBjb25zdCBudW1Ub3RhbEJ5dGVzSW5Hcm91cDIgPSBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgKyAxO1xuICAgICAgICAgICAgLy8gbnVtRGF0YUJ5dGVzSW5Hcm91cDEgPSA2NiAvIDUgPSAxM1xuICAgICAgICAgICAgY29uc3QgbnVtRGF0YUJ5dGVzSW5Hcm91cDEgPSBNYXRoLmZsb29yKG51bURhdGFCeXRlcyAvIG51bVJTQmxvY2tzKTtcbiAgICAgICAgICAgIC8vIG51bURhdGFCeXRlc0luR3JvdXAyID0gMTMgKyAxID0gMTRcbiAgICAgICAgICAgIGNvbnN0IG51bURhdGFCeXRlc0luR3JvdXAyID0gbnVtRGF0YUJ5dGVzSW5Hcm91cDEgKyAxO1xuICAgICAgICAgICAgLy8gbnVtRWNCeXRlc0luR3JvdXAxID0gMzkgLSAxMyA9IDI2XG4gICAgICAgICAgICBjb25zdCBudW1FY0J5dGVzSW5Hcm91cDEgPSBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgLSBudW1EYXRhQnl0ZXNJbkdyb3VwMTtcbiAgICAgICAgICAgIC8vIG51bUVjQnl0ZXNJbkdyb3VwMiA9IDQwIC0gMTQgPSAyNlxuICAgICAgICAgICAgY29uc3QgbnVtRWNCeXRlc0luR3JvdXAyID0gbnVtVG90YWxCeXRlc0luR3JvdXAyIC0gbnVtRGF0YUJ5dGVzSW5Hcm91cDI7XG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2tzLlxuICAgICAgICAgICAgLy8gMjYgPSAyNlxuICAgICAgICAgICAgaWYgKG51bUVjQnl0ZXNJbkdyb3VwMSAhPT0gbnVtRWNCeXRlc0luR3JvdXAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignRUMgYnl0ZXMgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDUgPSA0ICsgMS5cbiAgICAgICAgICAgIGlmIChudW1SU0Jsb2NrcyAhPT0gbnVtUnNCbG9ja3NJbkdyb3VwMSArIG51bVJzQmxvY2tzSW5Hcm91cDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdSUyBibG9ja3MgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDE5NiA9ICgxMyArIDI2KSAqIDQgKyAoMTQgKyAyNikgKiAxXG4gICAgICAgICAgICBpZiAobnVtVG90YWxCeXRlcyAhPT1cbiAgICAgICAgICAgICAgICAoKG51bURhdGFCeXRlc0luR3JvdXAxICsgbnVtRWNCeXRlc0luR3JvdXAxKSAqXG4gICAgICAgICAgICAgICAgICAgIG51bVJzQmxvY2tzSW5Hcm91cDEpICtcbiAgICAgICAgICAgICAgICAgICAgKChudW1EYXRhQnl0ZXNJbkdyb3VwMiArIG51bUVjQnl0ZXNJbkdyb3VwMikgKlxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtUnNCbG9ja3NJbkdyb3VwMikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdUb3RhbCBieXRlcyBtaXNtYXRjaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSUQgPCBudW1Sc0Jsb2Nrc0luR3JvdXAxKSB7XG4gICAgICAgICAgICAgICAgbnVtRGF0YUJ5dGVzSW5CbG9ja1swXSA9IG51bURhdGFCeXRlc0luR3JvdXAxO1xuICAgICAgICAgICAgICAgIG51bUVDQnl0ZXNJbkJsb2NrWzBdID0gbnVtRWNCeXRlc0luR3JvdXAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbnVtRGF0YUJ5dGVzSW5CbG9ja1swXSA9IG51bURhdGFCeXRlc0luR3JvdXAyO1xuICAgICAgICAgICAgICAgIG51bUVDQnl0ZXNJbkJsb2NrWzBdID0gbnVtRWNCeXRlc0luR3JvdXAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcmxlYXZlIFwiYml0c1wiIHdpdGggY29ycmVzcG9uZGluZyBlcnJvciBjb3JyZWN0aW9uIGJ5dGVzLiBPbiBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluXG4gICAgICAgICAqIFwicmVzdWx0XCIuIFRoZSBpbnRlcmxlYXZlIHJ1bGUgaXMgY29tcGxpY2F0ZWQuIFNlZSA4LjYgb2YgSklTWDA1MTA6MjAwNCAocC4zNykgZm9yIGRldGFpbHMuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgaW50ZXJsZWF2ZVdpdGhFQ0J5dGVzKGJpdHMsIG51bVRvdGFsQnl0ZXMgLyppbnQqLywgbnVtRGF0YUJ5dGVzIC8qaW50Ki8sIG51bVJTQmxvY2tzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIC8vIFwiYml0c1wiIG11c3QgaGF2ZSBcImdldE51bURhdGFCeXRlc1wiIGJ5dGVzIG9mIGRhdGEuXG4gICAgICAgICAgICBpZiAoYml0cy5nZXRTaXplSW5CeXRlcygpICE9PSBudW1EYXRhQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdOdW1iZXIgb2YgYml0cyBhbmQgZGF0YSBieXRlcyBkb2VzIG5vdCBtYXRjaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RlcCAxLiAgRGl2aWRlIGRhdGEgYnl0ZXMgaW50byBibG9ja3MgYW5kIGdlbmVyYXRlIGVycm9yIGNvcnJlY3Rpb24gYnl0ZXMgZm9yIHRoZW0uIFdlJ2xsXG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgZGl2aWRlZCBkYXRhIGJ5dGVzIGJsb2NrcyBhbmQgZXJyb3IgY29ycmVjdGlvbiBieXRlcyBibG9ja3MgaW50byBcImJsb2Nrc1wiLlxuICAgICAgICAgICAgbGV0IGRhdGFCeXRlc09mZnNldCA9IDA7XG4gICAgICAgICAgICBsZXQgbWF4TnVtRGF0YUJ5dGVzID0gMDtcbiAgICAgICAgICAgIGxldCBtYXhOdW1FY0J5dGVzID0gMDtcbiAgICAgICAgICAgIC8vIFNpbmNlLCB3ZSBrbm93IHRoZSBudW1iZXIgb2YgcmVlZHNvbG1vbiBibG9ja3MsIHdlIGNhbiBpbml0aWFsaXplIHRoZSB2ZWN0b3Igd2l0aCB0aGUgbnVtYmVyLlxuICAgICAgICAgICAgY29uc3QgYmxvY2tzID0gbmV3IEFycmF5KCk7IC8vIG5ldyBBcnJheTxCbG9ja1BhaXI+KG51bVJTQmxvY2tzKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1SU0Jsb2NrczsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtRGF0YUJ5dGVzSW5CbG9jayA9IG5ldyBJbnQzMkFycmF5KDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bUVjQnl0ZXNJbkJsb2NrID0gbmV3IEludDMyQXJyYXkoMSk7XG4gICAgICAgICAgICAgICAgRW5jb2Rlci5nZXROdW1EYXRhQnl0ZXNBbmROdW1FQ0J5dGVzRm9yQmxvY2tJRChudW1Ub3RhbEJ5dGVzLCBudW1EYXRhQnl0ZXMsIG51bVJTQmxvY2tzLCBpLCBudW1EYXRhQnl0ZXNJbkJsb2NrLCBudW1FY0J5dGVzSW5CbG9jayk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IG51bURhdGFCeXRlc0luQmxvY2tbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICAgICAgYml0cy50b0J5dGVzKDggKiBkYXRhQnl0ZXNPZmZzZXQsIGRhdGFCeXRlcywgMCwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZWNCeXRlcyA9IEVuY29kZXIuZ2VuZXJhdGVFQ0J5dGVzKGRhdGFCeXRlcywgbnVtRWNCeXRlc0luQmxvY2tbMF0pO1xuICAgICAgICAgICAgICAgIGJsb2Nrcy5wdXNoKG5ldyBCbG9ja1BhaXIoZGF0YUJ5dGVzLCBlY0J5dGVzKSk7XG4gICAgICAgICAgICAgICAgbWF4TnVtRGF0YUJ5dGVzID0gTWF0aC5tYXgobWF4TnVtRGF0YUJ5dGVzLCBzaXplKTtcbiAgICAgICAgICAgICAgICBtYXhOdW1FY0J5dGVzID0gTWF0aC5tYXgobWF4TnVtRWNCeXRlcywgZWNCeXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGRhdGFCeXRlc09mZnNldCArPSBudW1EYXRhQnl0ZXNJbkJsb2NrWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bURhdGFCeXRlcyAhPT0gZGF0YUJ5dGVzT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignRGF0YSBieXRlcyBkb2VzIG5vdCBtYXRjaCBvZmZzZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgLy8gRmlyc3QsIHBsYWNlIGRhdGEgYmxvY2tzLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhOdW1EYXRhQnl0ZXM7ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmxvY2sgb2YgYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFCeXRlcyA9IGJsb2NrLmdldERhdGFCeXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGRhdGFCeXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRCaXRzKGRhdGFCeXRlc1tpXSwgOCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGVuLCBwbGFjZSBlcnJvciBjb3JyZWN0aW9uIGJsb2Nrcy5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4TnVtRWNCeXRlczsgKytpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBibG9jayBvZiBibG9ja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNCeXRlcyA9IGJsb2NrLmdldEVycm9yQ29ycmVjdGlvbkJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgZWNCeXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRCaXRzKGVjQnl0ZXNbaV0sIDgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bVRvdGFsQnl0ZXMgIT09IHJlc3VsdC5nZXRTaXplSW5CeXRlcygpKSB7IC8vIFNob3VsZCBiZSBzYW1lLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0ludGVybGVhdmluZyBlcnJvcjogJyArIG51bVRvdGFsQnl0ZXMgKyAnIGFuZCAnICtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmdldFNpemVJbkJ5dGVzKCkgKyAnIGRpZmZlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdlbmVyYXRlRUNCeXRlcyhkYXRhQnl0ZXMsIG51bUVjQnl0ZXNJbkJsb2NrIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IG51bURhdGFCeXRlcyA9IGRhdGFCeXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB0b0VuY29kZSA9IG5ldyBJbnQzMkFycmF5KG51bURhdGFCeXRlcyArIG51bUVjQnl0ZXNJbkJsb2NrKTsgLy8gaW50W251bURhdGFCeXRlcyArIG51bUVjQnl0ZXNJbkJsb2NrXVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1EYXRhQnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIHRvRW5jb2RlW2ldID0gZGF0YUJ5dGVzW2ldICYgMHhGRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ldyBSZWVkU29sb21vbkVuY29kZXIoR2VuZXJpY0dGLlFSX0NPREVfRklFTERfMjU2KS5lbmNvZGUodG9FbmNvZGUsIG51bUVjQnl0ZXNJbkJsb2NrKTtcbiAgICAgICAgICAgIGNvbnN0IGVjQnl0ZXMgPSBuZXcgVWludDhBcnJheShudW1FY0J5dGVzSW5CbG9jayk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUVjQnl0ZXNJbkJsb2NrOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlY0J5dGVzW2ldID0gLyooYnl0ZSkgKi8gdG9FbmNvZGVbbnVtRGF0YUJ5dGVzICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWNCeXRlcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZW5kIG1vZGUgaW5mby4gT24gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpbiBcImJpdHNcIi5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBlbmRNb2RlSW5mbyhtb2RlLCBiaXRzKSB7XG4gICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMobW9kZS5nZXRCaXRzKCksIDQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmQgbGVuZ3RoIGluZm8uIE9uIHN1Y2Nlc3MsIHN0b3JlIHRoZSByZXN1bHQgaW4gXCJiaXRzXCIuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYXBwZW5kTGVuZ3RoSW5mbyhudW1MZXR0ZXJzIC8qaW50Ki8sIHZlcnNpb24sIG1vZGUsIGJpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bUJpdHMgPSBtb2RlLmdldENoYXJhY3RlckNvdW50Qml0cyh2ZXJzaW9uKTtcbiAgICAgICAgICAgIGlmIChudW1MZXR0ZXJzID49ICgxIDw8IG51bUJpdHMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbihudW1MZXR0ZXJzICsgJyBpcyBiaWdnZXIgdGhhbiAnICsgKCgxIDw8IG51bUJpdHMpIC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKG51bUxldHRlcnMsIG51bUJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmQgXCJieXRlc1wiIGluIFwibW9kZVwiIG1vZGUgKGVuY29kaW5nKSBpbnRvIFwiYml0c1wiLiBPbiBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluIFwiYml0c1wiLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGFwcGVuZEJ5dGVzKGNvbnRlbnQsIG1vZGUsIGJpdHMsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5OVU1FUklDOlxuICAgICAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZE51bWVyaWNCeXRlcyhjb250ZW50LCBiaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuQUxQSEFOVU1FUklDOlxuICAgICAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZEFscGhhbnVtZXJpY0J5dGVzKGNvbnRlbnQsIGJpdHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5CWVRFOlxuICAgICAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZDhCaXRCeXRlcyhjb250ZW50LCBiaXRzLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLktBTkpJOlxuICAgICAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZEthbmppQnl0ZXMoY29udGVudCwgYml0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0ludmFsaWQgbW9kZTogJyArIG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXREaWdpdChzaW5nbGVDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5nbGVDaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSAtIDQ4O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpc0RpZ2l0KHNpbmdsZUNoYXJhY3Rlcikge1xuICAgICAgICAgICAgY29uc3QgY24gPSBFbmNvZGVyLmdldERpZ2l0KHNpbmdsZUNoYXJhY3Rlcik7XG4gICAgICAgICAgICByZXR1cm4gY24gPj0gMCAmJiBjbiA8PSA5O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhcHBlbmROdW1lcmljQnl0ZXMoY29udGVudCwgYml0cykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bTEgPSBFbmNvZGVyLmdldERpZ2l0KGNvbnRlbnQuY2hhckF0KGkpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIHRocmVlIG51bWVyaWMgbGV0dGVycyBpbiB0ZW4gYml0cy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtMiA9IEVuY29kZXIuZ2V0RGlnaXQoY29udGVudC5jaGFyQXQoaSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtMyA9IEVuY29kZXIuZ2V0RGlnaXQoY29udGVudC5jaGFyQXQoaSArIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKG51bTEgKiAxMDAgKyBudW0yICogMTAgKyBudW0zLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSArIDEgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIHR3byBudW1lcmljIGxldHRlcnMgaW4gc2V2ZW4gYml0cy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtMiA9IEVuY29kZXIuZ2V0RGlnaXQoY29udGVudC5jaGFyQXQoaSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKG51bTEgKiAxMCArIG51bTIsIDcpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmNvZGUgb25lIG51bWVyaWMgbGV0dGVyIGluIGZvdXIgYml0cy5cbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKG51bTEsIDQpO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhcHBlbmRBbHBoYW51bWVyaWNCeXRlcyhjb250ZW50LCBiaXRzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZTEgPSBFbmNvZGVyLmdldEFscGhhbnVtZXJpY0NvZGUoY29udGVudC5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZTEgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUyID0gRW5jb2Rlci5nZXRBbHBoYW51bWVyaWNDb2RlKGNvbnRlbnQuY2hhckNvZGVBdChpICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZTIgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIHR3byBhbHBoYW51bWVyaWMgbGV0dGVycyBpbiAxMSBiaXRzLlxuICAgICAgICAgICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMoY29kZTEgKiA0NSArIGNvZGUyLCAxMSk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuY29kZSBvbmUgYWxwaGFudW1lcmljIGxldHRlciBpbiBzaXggYml0cy5cbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKGNvZGUxLCA2KTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYXBwZW5kOEJpdEJ5dGVzKGNvbnRlbnQsIGJpdHMsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICBsZXQgYnl0ZXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gU3RyaW5nRW5jb2RpbmcuZW5jb2RlKGNvbnRlbnQsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoICh1ZWUgLyo6IFVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24odWVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBieXRlcy5sZW5ndGg7IGkgIT09IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhiLCA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHRocm93cyBXcml0ZXJFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBlbmRLYW5qaUJ5dGVzKGNvbnRlbnQsIGJpdHMpIHtcbiAgICAgICAgICAgIGxldCBieXRlcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBTdHJpbmdFbmNvZGluZy5lbmNvZGUoY29udGVudCwgQ2hhcmFjdGVyU2V0RUNJLlNKSVMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKHVlZSAvKjogVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbih1ZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGUxID0gYnl0ZXNbaV0gJiAweEZGO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGUyID0gYnl0ZXNbaSArIDFdICYgMHhGRjtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gKChieXRlMSA8PCA4KSAmIDB4RkZGRkZGRkYpIHwgYnl0ZTI7XG4gICAgICAgICAgICAgICAgbGV0IHN1YnRyYWN0ZWQgPSAtMTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA+PSAweDgxNDAgJiYgY29kZSA8PSAweDlmZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHJhY3RlZCA9IGNvZGUgLSAweDgxNDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPj0gMHhlMDQwICYmIGNvZGUgPD0gMHhlYmJmKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0ZWQgPSBjb2RlIC0gMHhjMTQwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3VidHJhY3RlZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZWQgPSAoKHN1YnRyYWN0ZWQgPj4gOCkgKiAweGMwKSArIChzdWJ0cmFjdGVkICYgMHhmZik7XG4gICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKGVuY29kZWQsIDEzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYXBwZW5kRUNJKGVjaSwgYml0cykge1xuICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKE1vZGUkMS5FQ0kuZ2V0Qml0cygpLCA0KTtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgY29ycmVjdCBmb3IgdmFsdWVzIHVwIHRvIDEyNywgd2hpY2ggaXMgYWxsIHdlIG5lZWQgbm93LlxuICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKGVjaS5nZXRWYWx1ZSgpLCA4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGUgb3JpZ2luYWwgdGFibGUgaXMgZGVmaW5lZCBpbiB0aGUgdGFibGUgNSBvZiBKSVNYMDUxMDoyMDA0IChwLjE5KS5cbiAgICBFbmNvZGVyLkFMUEhBTlVNRVJJQ19UQUJMRSA9IEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgICAgICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgICAgICAgMzYsIC0xLCAtMSwgLTEsIDM3LCAzOCwgLTEsIC0xLCAtMSwgLTEsIDM5LCA0MCwgLTEsIDQxLCA0MiwgNDMsXG4gICAgICAgIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDQ0LCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gICAgICAgIC0xLCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LFxuICAgICAgICAyNSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSwgMzIsIDMzLCAzNCwgMzUsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgICBdKTtcbiAgICBFbmNvZGVyLkRFRkFVTFRfQllURV9NT0RFX0VOQ09ESU5HID0gQ2hhcmFjdGVyU2V0RUNJLlVURjguZ2V0TmFtZSgpOyAvLyBcIklTTy04ODU5LTFcIlxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICovXG4gICAgY2xhc3MgQnJvd3NlclFSQ29kZVN2Z1dyaXRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgYW5kIHJlbmRlcnMgYSBRUkNvZGUgU1ZHIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb250ZW50c1xuICAgICAgICAgKiBAcGFyYW0gd2lkdGhcbiAgICAgICAgICogQHBhcmFtIGhlaWdodFxuICAgICAgICAgKiBAcGFyYW0gaGludHNcbiAgICAgICAgICovXG4gICAgICAgIHdyaXRlKGNvbnRlbnRzLCB3aWR0aCwgaGVpZ2h0LCBoaW50cyA9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdGb3VuZCBlbXB0eSBjb250ZW50cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgKGZvcm1hdCAhPSBCYXJjb2RlRm9ybWF0LlFSX0NPREUpIHtcbiAgICAgICAgICAgIC8vICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIkNhbiBvbmx5IGVuY29kZSBRUl9DT0RFLCBidXQgZ290IFwiICsgZm9ybWF0KVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMCB8fCBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUmVxdWVzdGVkIGRpbWVuc2lvbnMgYXJlIHRvbyBzbWFsbDogJyArIHdpZHRoICsgJ3gnICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVycm9yQ29ycmVjdGlvbkxldmVsLkw7XG4gICAgICAgICAgICBsZXQgcXVpZXRab25lID0gQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5RVUlFVF9aT05FX1NJWkU7XG4gICAgICAgICAgICBpZiAoaGludHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVycm9yQ29ycmVjdGlvbkxldmVsLmZyb21TdHJpbmcoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuRVJST1JfQ09SUkVDVElPTikudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLk1BUkdJTikpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVpZXRab25lID0gTnVtYmVyLnBhcnNlSW50KGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLk1BUkdJTikudG9TdHJpbmcoKSwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBFbmNvZGVyLmVuY29kZShjb250ZW50cywgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIGhpbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclJlc3VsdChjb2RlLCB3aWR0aCwgaGVpZ2h0LCBxdWlldFpvbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXJzIHRoZSByZXN1bHQgYW5kIHRoZW4gYXBwZW5kcyBpdCB0byB0aGUgRE9NLlxuICAgICAgICAgKi9cbiAgICAgICAgd3JpdGVUb0RvbShjb250YWluZXJFbGVtZW50LCBjb250ZW50cywgd2lkdGgsIGhlaWdodCwgaGludHMgPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRhaW5lckVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdmdFbGVtZW50ID0gdGhpcy53cml0ZShjb250ZW50cywgd2lkdGgsIGhlaWdodCwgaGludHMpO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lckVsZW1lbnQpXG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChzdmdFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm90ZSB0aGF0IHRoZSBpbnB1dCBtYXRyaXggdXNlcyAwID09IHdoaXRlLCAxID09IGJsYWNrLlxuICAgICAgICAgKiBUaGUgb3V0cHV0IG1hdHJpeCB1c2VzIDAgPT0gYmxhY2ssIDI1NSA9PSB3aGl0ZSAoaS5lLiBhbiA4IGJpdCBncmV5c2NhbGUgYml0bWFwKS5cbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlclJlc3VsdChjb2RlLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgcXVpZXRab25lIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gY29kZS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlucHV0V2lkdGggPSBpbnB1dC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRIZWlnaHQgPSBpbnB1dC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHFyV2lkdGggPSBpbnB1dFdpZHRoICsgKHF1aWV0Wm9uZSAqIDIpO1xuICAgICAgICAgICAgY29uc3QgcXJIZWlnaHQgPSBpbnB1dEhlaWdodCArIChxdWlldFpvbmUgKiAyKTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dFdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHFyV2lkdGgpO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0SGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBxckhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBtdWx0aXBsZSA9IE1hdGgubWluKE1hdGguZmxvb3Iob3V0cHV0V2lkdGggLyBxcldpZHRoKSwgTWF0aC5mbG9vcihvdXRwdXRIZWlnaHQgLyBxckhlaWdodCkpO1xuICAgICAgICAgICAgLy8gUGFkZGluZyBpbmNsdWRlcyBib3RoIHRoZSBxdWlldCB6b25lIGFuZCB0aGUgZXh0cmEgd2hpdGUgcGl4ZWxzIHRvIGFjY29tbW9kYXRlIHRoZSByZXF1ZXN0ZWRcbiAgICAgICAgICAgIC8vIGRpbWVuc2lvbnMuIEZvciBleGFtcGxlLCBpZiBpbnB1dCBpcyAyNXgyNSB0aGUgUVIgd2lsbCBiZSAzM3gzMyBpbmNsdWRpbmcgdGhlIHF1aWV0IHpvbmUuXG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdGVkIHNpemUgaXMgMjAweDE2MCwgdGhlIG11bHRpcGxlIHdpbGwgYmUgNCwgZm9yIGEgUVIgb2YgMTMyeDEzMi4gVGhlc2Ugd2lsbFxuICAgICAgICAgICAgLy8gaGFuZGxlIGFsbCB0aGUgcGFkZGluZyBmcm9tIDEwMHgxMDAgKHRoZSBhY3R1YWwgUVIpIHVwIHRvIDIwMHgxNjAuXG4gICAgICAgICAgICBjb25zdCBsZWZ0UGFkZGluZyA9IE1hdGguZmxvb3IoKG91dHB1dFdpZHRoIC0gKGlucHV0V2lkdGggKiBtdWx0aXBsZSkpIC8gMik7XG4gICAgICAgICAgICBjb25zdCB0b3BQYWRkaW5nID0gTWF0aC5mbG9vcigob3V0cHV0SGVpZ2h0IC0gKGlucHV0SGVpZ2h0ICogbXVsdGlwbGUpKSAvIDIpO1xuICAgICAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IHRoaXMuY3JlYXRlU1ZHRWxlbWVudChvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGlucHV0WSA9IDAsIG91dHB1dFkgPSB0b3BQYWRkaW5nOyBpbnB1dFkgPCBpbnB1dEhlaWdodDsgaW5wdXRZKyssIG91dHB1dFkgKz0gbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXcml0ZSB0aGUgY29udGVudHMgb2YgdGhpcyByb3cgb2YgdGhlIGJhcmNvZGVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbnB1dFggPSAwLCBvdXRwdXRYID0gbGVmdFBhZGRpbmc7IGlucHV0WCA8IGlucHV0V2lkdGg7IGlucHV0WCsrLCBvdXRwdXRYICs9IG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5nZXQoaW5wdXRYLCBpbnB1dFkpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdmdSZWN0RWxlbWVudCA9IHRoaXMuY3JlYXRlU3ZnUmVjdEVsZW1lbnQob3V0cHV0WCwgb3V0cHV0WSwgbXVsdGlwbGUsIG11bHRpcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnUmVjdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN2Z0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBTVkcgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHcgU1ZHJ3Mgd2lkdGggYXR0cmlidXRlXG4gICAgICAgICAqIEBwYXJhbSBoIFNWRydzIGhlaWdodCBhdHRyaWJ1dGVcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVNWR0VsZW1lbnQodywgaCkge1xuICAgICAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhCcm93c2VyUVJDb2RlU3ZnV3JpdGVyLlNWR19OUywgJ3N2ZycpO1xuICAgICAgICAgICAgc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0Jywgdy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgaC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJldHVybiBzdmdFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgU1ZHIHJlY3QgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHggRWxlbWVudCdzIHggY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0geSBFbGVtZW50J3MgeSBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSB3IEVsZW1lbnQncyB3aWR0aCBhdHRyaWJ1dGVcbiAgICAgICAgICogQHBhcmFtIGggRWxlbWVudCdzIGhlaWdodCBhdHRyaWJ1dGVcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVN2Z1JlY3RFbGVtZW50KHgsIHksIHcsIGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5TVkdfTlMsICdyZWN0Jyk7XG4gICAgICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JywgeC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLCB5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0Jywgdy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgaC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnIzAwMDAwMCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5RVUlFVF9aT05FX1NJWkUgPSA0O1xuICAgIC8qKlxuICAgICAqIFNWRyBtYXJrdXAgTmFtZVNwYWNlXG4gICAgICovXG4gICAgQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5TVkdfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG4gICAgLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgb2JqZWN0IHJlbmRlcnMgYSBRUiBDb2RlIGFzIGEgQml0TWF0cml4IDJEIGFycmF5IG9mIGdyZXlzY2FsZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIFFSQ29kZVdyaXRlciB7XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgLy8gcHVibGljIGVuY29kZShjb250ZW50czogc3RyaW5nLCBmb3JtYXQ6IEJhcmNvZGVGb3JtYXQsIHdpZHRoOiBudW1iZXIgLyppbnQqLywgaGVpZ2h0OiBudW1iZXIgLyppbnQqLyk6IEJpdE1hdHJpeFxuICAgICAgICAvLyAgICAgLyp0aHJvd3MgV3JpdGVyRXhjZXB0aW9uICovIHtcbiAgICAgICAgLy8gICByZXR1cm4gZW5jb2RlKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIG51bGwpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBlbmNvZGUoY29udGVudHMsIGZvcm1hdCwgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8sIGhpbnRzKSB7XG4gICAgICAgICAgICBpZiAoY29udGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignRm91bmQgZW1wdHkgY29udGVudHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgIT09IEJhcmNvZGVGb3JtYXQkMS5RUl9DT0RFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQ2FuIG9ubHkgZW5jb2RlIFFSX0NPREUsIGJ1dCBnb3QgJyArIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2lkdGggPCAwIHx8IGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKGBSZXF1ZXN0ZWQgZGltZW5zaW9ucyBhcmUgdG9vIHNtYWxsOiAke3dpZHRofXgke2hlaWdodH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVycm9yQ29ycmVjdGlvbkxldmVsLkw7XG4gICAgICAgICAgICBsZXQgcXVpZXRab25lID0gUVJDb2RlV3JpdGVyLlFVSUVUX1pPTkVfU0laRTtcbiAgICAgICAgICAgIGlmIChoaW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLkVSUk9SX0NPUlJFQ1RJT04pKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ29ycmVjdGlvbkxldmVsID0gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuZnJvbVN0cmluZyhoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuTUFSR0lOKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWlldFpvbmUgPSBOdW1iZXIucGFyc2VJbnQoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuTUFSR0lOKS50b1N0cmluZygpLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29kZSA9IEVuY29kZXIuZW5jb2RlKGNvbnRlbnRzLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgaGludHMpO1xuICAgICAgICAgICAgcmV0dXJuIFFSQ29kZVdyaXRlci5yZW5kZXJSZXN1bHQoY29kZSwgd2lkdGgsIGhlaWdodCwgcXVpZXRab25lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIGlucHV0IG1hdHJpeCB1c2VzIDAgPT0gd2hpdGUsIDEgPT0gYmxhY2ssIHdoaWxlIHRoZSBvdXRwdXQgbWF0cml4IHVzZXNcbiAgICAgICAgLy8gMCA9PSBibGFjaywgMjU1ID09IHdoaXRlIChpLmUuIGFuIDggYml0IGdyZXlzY2FsZSBiaXRtYXApLlxuICAgICAgICBzdGF0aWMgcmVuZGVyUmVzdWx0KGNvZGUsIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBxdWlldFpvbmUgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBjb2RlLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5wdXRXaWR0aCA9IGlucHV0LmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBpbnB1dEhlaWdodCA9IGlucHV0LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgY29uc3QgcXJXaWR0aCA9IGlucHV0V2lkdGggKyAocXVpZXRab25lICogMik7XG4gICAgICAgICAgICBjb25zdCBxckhlaWdodCA9IGlucHV0SGVpZ2h0ICsgKHF1aWV0Wm9uZSAqIDIpO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0V2lkdGggPSBNYXRoLm1heCh3aWR0aCwgcXJXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIHFySGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IG11bHRpcGxlID0gTWF0aC5taW4oTWF0aC5mbG9vcihvdXRwdXRXaWR0aCAvIHFyV2lkdGgpLCBNYXRoLmZsb29yKG91dHB1dEhlaWdodCAvIHFySGVpZ2h0KSk7XG4gICAgICAgICAgICAvLyBQYWRkaW5nIGluY2x1ZGVzIGJvdGggdGhlIHF1aWV0IHpvbmUgYW5kIHRoZSBleHRyYSB3aGl0ZSBwaXhlbHMgdG8gYWNjb21tb2RhdGUgdGhlIHJlcXVlc3RlZFxuICAgICAgICAgICAgLy8gZGltZW5zaW9ucy4gRm9yIGV4YW1wbGUsIGlmIGlucHV0IGlzIDI1eDI1IHRoZSBRUiB3aWxsIGJlIDMzeDMzIGluY2x1ZGluZyB0aGUgcXVpZXQgem9uZS5cbiAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0ZWQgc2l6ZSBpcyAyMDB4MTYwLCB0aGUgbXVsdGlwbGUgd2lsbCBiZSA0LCBmb3IgYSBRUiBvZiAxMzJ4MTMyLiBUaGVzZSB3aWxsXG4gICAgICAgICAgICAvLyBoYW5kbGUgYWxsIHRoZSBwYWRkaW5nIGZyb20gMTAweDEwMCAodGhlIGFjdHVhbCBRUikgdXAgdG8gMjAweDE2MC5cbiAgICAgICAgICAgIGNvbnN0IGxlZnRQYWRkaW5nID0gTWF0aC5mbG9vcigob3V0cHV0V2lkdGggLSAoaW5wdXRXaWR0aCAqIG11bHRpcGxlKSkgLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IHRvcFBhZGRpbmcgPSBNYXRoLmZsb29yKChvdXRwdXRIZWlnaHQgLSAoaW5wdXRIZWlnaHQgKiBtdWx0aXBsZSkpIC8gMik7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBuZXcgQml0TWF0cml4KG91dHB1dFdpZHRoLCBvdXRwdXRIZWlnaHQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaW5wdXRZID0gMCwgb3V0cHV0WSA9IHRvcFBhZGRpbmc7IGlucHV0WSA8IGlucHV0SGVpZ2h0OyBpbnB1dFkrKywgb3V0cHV0WSArPSBtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBjb250ZW50cyBvZiB0aGlzIHJvdyBvZiB0aGUgYmFyY29kZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlucHV0WCA9IDAsIG91dHB1dFggPSBsZWZ0UGFkZGluZzsgaW5wdXRYIDwgaW5wdXRXaWR0aDsgaW5wdXRYKyssIG91dHB1dFggKz0gbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmdldChpbnB1dFgsIGlucHV0WSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXRSZWdpb24ob3V0cHV0WCwgb3V0cHV0WSwgbXVsdGlwbGUsIG11bHRpcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUVJDb2RlV3JpdGVyLlFVSUVUX1pPTkVfU0laRSA9IDQ7XG5cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGZhY3RvcnkgY2xhc3Mgd2hpY2ggZmluZHMgdGhlIGFwcHJvcHJpYXRlIFdyaXRlciBzdWJjbGFzcyBmb3IgdGhlIEJhcmNvZGVGb3JtYXRcbiAgICAgKiByZXF1ZXN0ZWQgYW5kIGVuY29kZXMgdGhlIGJhcmNvZGUgd2l0aCB0aGUgc3VwcGxpZWQgY29udGVudHMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIE11bHRpRm9ybWF0V3JpdGVyIHtcbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICAvLyBwdWJsaWMgZW5jb2RlKGNvbnRlbnRzOiBzdHJpbmcsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogQmFyY29kZUZvcm1hdCxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG51bWJlciAvKmludCovLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG51bWJlciAvKmludCovKTogQml0TWF0cml4IC8qdGhyb3dzIFdyaXRlckV4Y2VwdGlvbiAqLyB7XG4gICAgICAgIC8vICAgcmV0dXJuIGVuY29kZShjb250ZW50cywgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBudWxsKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZW5jb2RlKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBoaW50cykge1xuICAgICAgICAgICAgbGV0IHdyaXRlcjtcbiAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkVBTl84OlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IEVBTjhXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuVVBDX0U6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgVVBDRVdyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5FQU5fMTM6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgRUFOMTNXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuVVBDX0E6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgVVBDQVdyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgQmFyY29kZUZvcm1hdCQxLlFSX0NPREU6XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlciA9IG5ldyBRUkNvZGVXcml0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkNPREVfMzk6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgQ29kZTM5V3JpdGVyKClcbiAgICAgICAgICAgICAgICAvLyAgIGJyZWFrXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkNPREVfOTM6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgQ29kZTkzV3JpdGVyKClcbiAgICAgICAgICAgICAgICAvLyAgIGJyZWFrXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkNPREVfMTI4OlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IENvZGUxMjhXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuSVRGOlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IElURldyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5QREZfNDE3OlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IFBERjQxN1dyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5DT0RBQkFSOlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IENvZGFCYXJXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuREFUQV9NQVRSSVg6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgRGF0YU1hdHJpeFdyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5BWlRFQzpcbiAgICAgICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBBenRlY1dyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ05vIGVuY29kZXIgYXZhaWxhYmxlIGZvciBmb3JtYXQgJyArIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyLmVuY29kZShjb250ZW50cywgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBoaW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgb2JqZWN0IGV4dGVuZHMgTHVtaW5hbmNlU291cmNlIGFyb3VuZCBhbiBhcnJheSBvZiBZVVYgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBjYW1lcmEgZHJpdmVyLFxuICAgICAqIHdpdGggdGhlIG9wdGlvbiB0byBjcm9wIHRvIGEgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgZnVsbCBkYXRhLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGV4Y2x1ZGVcbiAgICAgKiBzdXBlcmZsdW91cyBwaXhlbHMgYXJvdW5kIHRoZSBwZXJpbWV0ZXIgYW5kIHNwZWVkIHVwIGRlY29kaW5nLlxuICAgICAqXG4gICAgICogSXQgd29ya3MgZm9yIGFueSBwaXhlbCBmb3JtYXQgd2hlcmUgdGhlIFkgY2hhbm5lbCBpcyBwbGFuYXIgYW5kIGFwcGVhcnMgZmlyc3QsIGluY2x1ZGluZ1xuICAgICAqIFlDYkNyXzQyMF9TUCBhbmQgWUNiQ3JfNDIyX1NQLlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKi9cbiAgICBjbGFzcyBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UgZXh0ZW5kcyBMdW1pbmFuY2VTb3VyY2Uge1xuICAgICAgICBjb25zdHJ1Y3Rvcih5dXZEYXRhLCBkYXRhV2lkdGggLyppbnQqLywgZGF0YUhlaWdodCAvKmludCovLCBsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgcmV2ZXJzZUhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy55dXZEYXRhID0geXV2RGF0YTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVdpZHRoID0gZGF0YVdpZHRoO1xuICAgICAgICAgICAgdGhpcy5kYXRhSGVpZ2h0ID0gZGF0YUhlaWdodDtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPiBkYXRhV2lkdGggfHwgdG9wICsgaGVpZ2h0ID4gZGF0YUhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0Nyb3AgcmVjdGFuZ2xlIGRvZXMgbm90IGZpdCB3aXRoaW4gaW1hZ2UgZGF0YS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXZlcnNlSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJzZUhvcml6b250YWwod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBnZXRSb3coeSAvKmludCovLCByb3cpIHtcbiAgICAgICAgICAgIGlmICh5IDwgMCB8fCB5ID49IHRoaXMuZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdSZXF1ZXN0ZWQgcm93IGlzIG91dHNpZGUgdGhlIGltYWdlOiAnICsgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGlmIChyb3cgPT09IG51bGwgfHwgcm93ID09PSB1bmRlZmluZWQgfHwgcm93Lmxlbmd0aCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9ICh5ICsgdGhpcy50b3ApICogdGhpcy5kYXRhV2lkdGggKyB0aGlzLmxlZnQ7XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHRoaXMueXV2RGF0YSwgb2Zmc2V0LCByb3csIDAsIHdpZHRoKTtcbiAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBnZXRNYXRyaXgoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2FsbGVyIGFza3MgZm9yIHRoZSBlbnRpcmUgdW5kZXJseWluZyBpbWFnZSwgc2F2ZSB0aGUgY29weSBhbmQgZ2l2ZSB0aGVtIHRoZVxuICAgICAgICAgICAgLy8gb3JpZ2luYWwgZGF0YS4gVGhlIGRvY3Mgc3BlY2lmaWNhbGx5IHdhcm4gdGhhdCByZXN1bHQubGVuZ3RoIG11c3QgYmUgaWdub3JlZC5cbiAgICAgICAgICAgIGlmICh3aWR0aCA9PT0gdGhpcy5kYXRhV2lkdGggJiYgaGVpZ2h0ID09PSB0aGlzLmRhdGFIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55dXZEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJlYSA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGFyZWEpO1xuICAgICAgICAgICAgbGV0IGlucHV0T2Zmc2V0ID0gdGhpcy50b3AgKiB0aGlzLmRhdGFXaWR0aCArIHRoaXMubGVmdDtcbiAgICAgICAgICAgIC8vIElmIHRoZSB3aWR0aCBtYXRjaGVzIHRoZSBmdWxsIHdpZHRoIG9mIHRoZSB1bmRlcmx5aW5nIGRhdGEsIHBlcmZvcm0gYSBzaW5nbGUgY29weS5cbiAgICAgICAgICAgIGlmICh3aWR0aCA9PT0gdGhpcy5kYXRhV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHRoaXMueXV2RGF0YSwgaW5wdXRPZmZzZXQsIG1hdHJpeCwgMCwgYXJlYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjb3B5IG9uZSBjcm9wcGVkIHJvdyBhdCBhIHRpbWUuXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0T2Zmc2V0ID0geSAqIHdpZHRoO1xuICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkodGhpcy55dXZEYXRhLCBpbnB1dE9mZnNldCwgbWF0cml4LCBvdXRwdXRPZmZzZXQsIHdpZHRoKTtcbiAgICAgICAgICAgICAgICBpbnB1dE9mZnNldCArPSB0aGlzLmRhdGFXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBpc0Nyb3BTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGNyb3AobGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlKHRoaXMueXV2RGF0YSwgdGhpcy5kYXRhV2lkdGgsIHRoaXMuZGF0YUhlaWdodCwgdGhpcy5sZWZ0ICsgbGVmdCwgdGhpcy50b3AgKyB0b3AsIHdpZHRoLCBoZWlnaHQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJUaHVtYm5haWwoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSAvIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKSAvIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SO1xuICAgICAgICAgICAgY29uc3QgcGl4ZWxzID0gbmV3IEludDMyQXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgeXV2ID0gdGhpcy55dXZEYXRhO1xuICAgICAgICAgICAgbGV0IGlucHV0T2Zmc2V0ID0gdGhpcy50b3AgKiB0aGlzLmRhdGFXaWR0aCArIHRoaXMubGVmdDtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRPZmZzZXQgPSB5ICogd2lkdGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyZXkgPSB5dXZbaW5wdXRPZmZzZXQgKyB4ICogUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlLlRIVU1CTkFJTF9TQ0FMRV9GQUNUT1JdICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW291dHB1dE9mZnNldCArIHhdID0gMHhGRjAwMDAwMCB8IChncmV5ICogMHgwMDAxMDEwMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlucHV0T2Zmc2V0ICs9IHRoaXMuZGF0YVdpZHRoICogUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlLlRIVU1CTkFJTF9TQ0FMRV9GQUNUT1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGl4ZWxzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHdpZHRoIG9mIGltYWdlIGZyb20ge0BsaW5rICNyZW5kZXJUaHVtYm5haWwoKX1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRodW1ibmFpbFdpZHRoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSAvIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGhlaWdodCBvZiBpbWFnZSBmcm9tIHtAbGluayAjcmVuZGVyVGh1bWJuYWlsKCl9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUaHVtYm5haWxIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWlnaHQoKSAvIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SO1xuICAgICAgICB9XG4gICAgICAgIHJldmVyc2VIb3Jpem9udGFsKHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCB5dXZEYXRhID0gdGhpcy55dXZEYXRhO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDAsIHJvd1N0YXJ0ID0gdGhpcy50b3AgKiB0aGlzLmRhdGFXaWR0aCArIHRoaXMubGVmdDsgeSA8IGhlaWdodDsgeSsrLCByb3dTdGFydCArPSB0aGlzLmRhdGFXaWR0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pZGRsZSA9IHJvd1N0YXJ0ICsgd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHgxID0gcm93U3RhcnQsIHgyID0gcm93U3RhcnQgKyB3aWR0aCAtIDE7IHgxIDwgbWlkZGxlOyB4MSsrLCB4Mi0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSB5dXZEYXRhW3gxXTtcbiAgICAgICAgICAgICAgICAgICAgeXV2RGF0YVt4MV0gPSB5dXZEYXRhW3gyXTtcbiAgICAgICAgICAgICAgICAgICAgeXV2RGF0YVt4Ml0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbnZlcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SID0gMjtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGhlbHAgZGVjb2RlIGltYWdlcyBmcm9tIGZpbGVzIHdoaWNoIGFycml2ZSBhcyBSR0IgZGF0YSBmcm9tXG4gICAgICogYW4gQVJHQiBwaXhlbCBhcnJheS4gSXQgZG9lcyBub3Qgc3VwcG9ydCByb3RhdGlvbi5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBCZXRhbWlub3NcbiAgICAgKi9cbiAgICBjbGFzcyBSR0JMdW1pbmFuY2VTb3VyY2UgZXh0ZW5kcyBMdW1pbmFuY2VTb3VyY2Uge1xuICAgICAgICBjb25zdHJ1Y3RvcihsdW1pbmFuY2VzLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgZGF0YVdpZHRoIC8qaW50Ki8sIGRhdGFIZWlnaHQgLyppbnQqLywgbGVmdCAvKmludCovLCB0b3AgLyppbnQqLykge1xuICAgICAgICAgICAgc3VwZXIod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmRhdGFXaWR0aCA9IGRhdGFXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuZGF0YUhlaWdodCA9IGRhdGFIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgICAgICBpZiAobHVtaW5hbmNlcy5CWVRFU19QRVJfRUxFTUVOVCA9PT0gNCkgeyAvLyBJbnQzMkFycmF5XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGx1bWluYW5jZXNVaW50OEFycmF5ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHNpemUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IHNpemU7IG9mZnNldCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0gbHVtaW5hbmNlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gKHBpeGVsID4+IDE2KSAmIDB4ZmY7IC8vIHJlZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBnMiA9IChwaXhlbCA+PiA3KSAmIDB4MWZlOyAvLyAyICogZ3JlZW5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IHBpeGVsICYgMHhmZjsgLy8gYmx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgZ3JlZW4tZmF2b3VyaW5nIGF2ZXJhZ2UgY2hlYXBseVxuICAgICAgICAgICAgICAgICAgICBsdW1pbmFuY2VzVWludDhBcnJheVtvZmZzZXRdID0gLyooYnl0ZSkgKi8gKChyICsgZzIgKyBiKSAvIDQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sdW1pbmFuY2VzID0gbHVtaW5hbmNlc1VpbnQ4QXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmx1bWluYW5jZXMgPSBsdW1pbmFuY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gZGF0YVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhV2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGRhdGFIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBsZWZ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHRvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgKyB3aWR0aCA+IHRoaXMuZGF0YVdpZHRoIHx8IHRoaXMudG9wICsgaGVpZ2h0ID4gdGhpcy5kYXRhSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQ3JvcCByZWN0YW5nbGUgZG9lcyBub3QgZml0IHdpdGhpbiBpbWFnZSBkYXRhLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0Um93KHkgLyppbnQqLywgcm93KSB7XG4gICAgICAgICAgICBpZiAoeSA8IDAgfHwgeSA+PSB0aGlzLmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUmVxdWVzdGVkIHJvdyBpcyBvdXRzaWRlIHRoZSBpbWFnZTogJyArIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBpZiAocm93ID09PSBudWxsIHx8IHJvdyA9PT0gdW5kZWZpbmVkIHx8IHJvdy5sZW5ndGggPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHJvdyA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSAoeSArIHRoaXMudG9wKSAqIHRoaXMuZGF0YVdpZHRoICsgdGhpcy5sZWZ0O1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0aGlzLmx1bWluYW5jZXMsIG9mZnNldCwgcm93LCAwLCB3aWR0aCk7XG4gICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0TWF0cml4KCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNhbGxlciBhc2tzIGZvciB0aGUgZW50aXJlIHVuZGVybHlpbmcgaW1hZ2UsIHNhdmUgdGhlIGNvcHkgYW5kIGdpdmUgdGhlbSB0aGVcbiAgICAgICAgICAgIC8vIG9yaWdpbmFsIGRhdGEuIFRoZSBkb2NzIHNwZWNpZmljYWxseSB3YXJuIHRoYXQgcmVzdWx0Lmxlbmd0aCBtdXN0IGJlIGlnbm9yZWQuXG4gICAgICAgICAgICBpZiAod2lkdGggPT09IHRoaXMuZGF0YVdpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5kYXRhSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubHVtaW5hbmNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSB3aWR0aCAqIGhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBVaW50OENsYW1wZWRBcnJheShhcmVhKTtcbiAgICAgICAgICAgIGxldCBpbnB1dE9mZnNldCA9IHRoaXMudG9wICogdGhpcy5kYXRhV2lkdGggKyB0aGlzLmxlZnQ7XG4gICAgICAgICAgICAvLyBJZiB0aGUgd2lkdGggbWF0Y2hlcyB0aGUgZnVsbCB3aWR0aCBvZiB0aGUgdW5kZXJseWluZyBkYXRhLCBwZXJmb3JtIGEgc2luZ2xlIGNvcHkuXG4gICAgICAgICAgICBpZiAod2lkdGggPT09IHRoaXMuZGF0YVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0aGlzLmx1bWluYW5jZXMsIGlucHV0T2Zmc2V0LCBtYXRyaXgsIDAsIGFyZWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgY29weSBvbmUgY3JvcHBlZCByb3cgYXQgYSB0aW1lLlxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dE9mZnNldCA9IHkgKiB3aWR0aDtcbiAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHRoaXMubHVtaW5hbmNlcywgaW5wdXRPZmZzZXQsIG1hdHJpeCwgb3V0cHV0T2Zmc2V0LCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgaW5wdXRPZmZzZXQgKz0gdGhpcy5kYXRhV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgaXNDcm9wU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBjcm9wKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJHQkx1bWluYW5jZVNvdXJjZSh0aGlzLmx1bWluYW5jZXMsIHdpZHRoLCBoZWlnaHQsIHRoaXMuZGF0YVdpZHRoLCB0aGlzLmRhdGFIZWlnaHQsIHRoaXMubGVmdCArIGxlZnQsIHRoaXMudG9wICsgdG9wKTtcbiAgICAgICAgfVxuICAgICAgICBpbnZlcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSnVzdCB0byBtYWtlIGEgc2hvcnRjdXQgYmV0d2VlbiBKYXZhIGNvZGUgYW5kIFRTIGNvZGUuXG4gICAgICovXG4gICAgY2xhc3MgQ2hhcnNldCBleHRlbmRzIENoYXJhY3RlclNldEVDSSB7XG4gICAgICAgIHN0YXRpYyBmb3JOYW1lKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENoYXJhY3RlclNldEVDSUJ5TmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEp1c3QgdG8gbWFrZSBhIHNob3J0Y3V0IGJldHdlZW4gSmF2YSBjb2RlIGFuZCBUUyBjb2RlLlxuICAgICAqL1xuICAgIGNsYXNzIFN0YW5kYXJkQ2hhcnNldHMge1xuICAgIH1cbiAgICBTdGFuZGFyZENoYXJzZXRzLklTT184ODU5XzEgPSBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xO1xuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLyoqXG4gICAgICogQXp0ZWMgMkQgY29kZSByZXByZXNlbnRhdGlvblxuICAgICAqXG4gICAgICogQGF1dGhvciBSdXN0YW0gQWJkdWxsYWV2XG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBBenRlY0NvZGUge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QGNvZGUgdHJ1ZX0gaWYgY29tcGFjdCBpbnN0ZWFkIG9mIGZ1bGwgbW9kZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNDb21wYWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFjdDtcbiAgICAgICAgfVxuICAgICAgICBzZXRDb21wYWN0KGNvbXBhY3QpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gc2l6ZSBpbiBwaXhlbHMgKHdpZHRoIGFuZCBoZWlnaHQpXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRTaXplKHNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGxldmVsc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzO1xuICAgICAgICB9XG4gICAgICAgIHNldExheWVycyhsYXllcnMpIHtcbiAgICAgICAgICAgIHRoaXMubGF5ZXJzID0gbGF5ZXJzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBkYXRhIGNvZGV3b3Jkc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29kZVdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29kZVdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIHNldENvZGVXb3Jkcyhjb2RlV29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZVdvcmRzID0gY29kZVdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBzeW1ib2wgaW1hZ2VcbiAgICAgICAgICovXG4gICAgICAgIGdldE1hdHJpeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICBzZXRNYXRyaXgobWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIENvbGxlY3Rpb25zIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaW5nbGV0b25MaXN0KFQpIG1ldGhvZCBpcyB1c2VkIHRvIHJldHVybiBhbiBpbW11dGFibGUgbGlzdCBjb250YWluaW5nIG9ubHkgdGhlIHNwZWNpZmllZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgc2luZ2xldG9uTGlzdChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gW2l0ZW1dO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWluKENvbGxlY3Rpb248PyBleHRlbmRzIFQ+LCBDb21wYXJhdG9yPD8gc3VwZXIgVD4pIG1ldGhvZCBpcyB1c2VkIHRvIHJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IG9mIHRoZSBnaXZlbiBjb2xsZWN0aW9uLCBhY2NvcmRpbmcgdG8gdGhlIG9yZGVyIGluZHVjZWQgYnkgdGhlIHNwZWNpZmllZCBjb21wYXJhdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG1pbihjb2xsZWN0aW9uLCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5zb3J0KGNvbXBhcmF0b3IpWzBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgY2xhc3MgVG9rZW4ge1xuICAgICAgICBjb25zdHJ1Y3RvcihwcmV2aW91cykge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIGdldFByZXZpb3VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICpcbiAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAqXG4gICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICpcbiAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cbiAgICAvKmZpbmFsKi8gY2xhc3MgU2ltcGxlVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByZXZpb3VzLCB2YWx1ZSwgYml0Q291bnQpIHtcbiAgICAgICAgICAgIHN1cGVyKHByZXZpb3VzKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuYml0Q291bnQgPSBiaXRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQE92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRUbyhiaXRBcnJheSwgdGV4dCkge1xuICAgICAgICAgICAgYml0QXJyYXkuYXBwZW5kQml0cyh0aGlzLnZhbHVlLCB0aGlzLmJpdENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBhZGQodmFsdWUsIGJpdENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVRva2VuKHRoaXMsIHZhbHVlLCBiaXRDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkQmluYXJ5U2hpZnQoc3RhcnQsIGJ5dGVDb3VudCkge1xuICAgICAgICAgICAgLy8gbm8tb3AgY2FuJ3QgYmluYXJ5IHNoaWZ0IGEgc2ltcGxlIHRva2VuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FkZEJpbmFyeVNoaWZ0IG9uIFNpbXBsZVRva2VuLCB0aGlzIHNpbXBseSByZXR1cm5zIGEgY29weSBvZiB0aGlzIHRva2VuJyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVRva2VuKHRoaXMsIHN0YXJ0LCBieXRlQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAT3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy52YWx1ZSAmICgoMSA8PCB0aGlzLmJpdENvdW50KSAtIDEpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMSA8PCB0aGlzLmJpdENvdW50O1xuICAgICAgICAgICAgcmV0dXJuICc8JyArIEludGVnZXIudG9CaW5hcnlTdHJpbmcodmFsdWUgfCAoMSA8PCB0aGlzLmJpdENvdW50KSkuc3Vic3RyaW5nKDEpICsgJz4nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIEJpbmFyeVNoaWZ0VG9rZW4gZXh0ZW5kcyBTaW1wbGVUb2tlbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByZXZpb3VzLCBiaW5hcnlTaGlmdFN0YXJ0LCBiaW5hcnlTaGlmdEJ5dGVDb3VudCkge1xuICAgICAgICAgICAgc3VwZXIocHJldmlvdXMsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5iaW5hcnlTaGlmdFN0YXJ0ID0gYmluYXJ5U2hpZnRTdGFydDtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPSBiaW5hcnlTaGlmdEJ5dGVDb3VudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQE92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRUbyhiaXRBcnJheSwgdGV4dCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCAoaSA9PT0gMzEgJiYgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCA8PSA2MikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCBhIGhlYWRlciBiZWZvcmUgdGhlIGZpcnN0IGNoYXJhY3RlciwgYW5kIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIgMzEgd2hlbiB0aGUgdG90YWwgYnl0ZSBjb2RlIGlzIDw9IDYyXG4gICAgICAgICAgICAgICAgICAgIGJpdEFycmF5LmFwcGVuZEJpdHMoMzEsIDUpOyAvLyBCSU5BUllfU0hJRlRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPiA2Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYml0QXJyYXkuYXBwZW5kQml0cyh0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50IC0gMzEsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAxIDw9IGJpbmFyeVNoaWZ0Qnl0ZUNvZGUgPD0gNjJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdEFycmF5LmFwcGVuZEJpdHMoTWF0aC5taW4odGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCwgMzEpLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMyIDw9IGJpbmFyeVNoaWZ0Q291bnQgPD0gNjIgYW5kIGkgPT0gMzFcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdEFycmF5LmFwcGVuZEJpdHModGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCAtIDMxLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiaXRBcnJheS5hcHBlbmRCaXRzKHRleHRbdGhpcy5iaW5hcnlTaGlmdFN0YXJ0ICsgaV0sIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZEJpbmFyeVNoaWZ0KHN0YXJ0LCBieXRlQ291bnQpIHtcbiAgICAgICAgICAgIC8vIGludCBiaXRDb3VudCA9IChieXRlQ291bnQgKiA4KSArIChieXRlQ291bnQgPD0gMzEgPyAxMCA6IGJ5dGVDb3VudCA8PSA2MiA/IDIwIDogMjEpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlTaGlmdFRva2VuKHRoaXMsIHN0YXJ0LCBieXRlQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAT3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICc8JyArIHRoaXMuYmluYXJ5U2hpZnRTdGFydCArICc6OicgKyAodGhpcy5iaW5hcnlTaGlmdFN0YXJ0ICsgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCAtIDEpICsgJz4nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQmluYXJ5U2hpZnQodG9rZW4sIHN0YXJ0LCBieXRlQ291bnQpIHtcbiAgICAgICAgLy8gaW50IGJpdENvdW50ID0gKGJ5dGVDb3VudCAqIDgpICsgKGJ5dGVDb3VudCA8PSAzMSA/IDEwIDogYnl0ZUNvdW50IDw9IDYyID8gMjAgOiAyMSk7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5U2hpZnRUb2tlbih0b2tlbiwgc3RhcnQsIGJ5dGVDb3VudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZCh0b2tlbiwgdmFsdWUsIGJpdENvdW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlVG9rZW4odG9rZW4sIHZhbHVlLCBiaXRDb3VudCk7XG4gICAgfVxuXG4gICAgY29uc3QgLypmaW5hbCovIE1PREVfTkFNRVMgPSBbXG4gICAgICAgICdVUFBFUicsXG4gICAgICAgICdMT1dFUicsXG4gICAgICAgICdESUdJVCcsXG4gICAgICAgICdNSVhFRCcsXG4gICAgICAgICdQVU5DVCdcbiAgICBdO1xuICAgIGNvbnN0IC8qZmluYWwqLyBNT0RFX1VQUEVSID0gMDsgLy8gNSBiaXRzXG4gICAgY29uc3QgLypmaW5hbCovIE1PREVfTE9XRVIgPSAxOyAvLyA1IGJpdHNcbiAgICBjb25zdCAvKmZpbmFsKi8gTU9ERV9ESUdJVCA9IDI7IC8vIDQgYml0c1xuICAgIGNvbnN0IC8qZmluYWwqLyBNT0RFX01JWEVEID0gMzsgLy8gNSBiaXRzXG4gICAgY29uc3QgLypmaW5hbCovIE1PREVfUFVOQ1QgPSA0OyAvLyA1IGJpdHNcbiAgICBjb25zdCBFTVBUWV9UT0tFTiA9IG5ldyBTaW1wbGVUb2tlbihudWxsLCAwLCAwKTtcblxuICAgIC8vIFRoZSBMYXRjaCBUYWJsZSBzaG93cywgZm9yIGVhY2ggcGFpciBvZiBNb2RlcywgdGhlIG9wdGltYWwgbWV0aG9kIGZvclxuICAgIC8vIGdldHRpbmcgZnJvbSBvbmUgbW9kZSB0byBhbm90aGVyLiAgSW4gdGhlIHdvcnN0IHBvc3NpYmxlIGNhc2UsIHRoaXMgY2FuXG4gICAgLy8gYmUgdXAgdG8gMTQgYml0cy4gIEluIHRoZSBiZXN0IHBvc3NpYmxlIGNhc2UsIHdlIGFyZSBhbHJlYWR5IHRoZXJlIVxuICAgIC8vIFRoZSBoaWdoIGhhbGYtd29yZCBvZiBlYWNoIGVudHJ5IGdpdmVzIHRoZSBudW1iZXIgb2YgYml0cy5cbiAgICAvLyBUaGUgbG93IGhhbGYtd29yZCBvZiBlYWNoIGVudHJ5IGFyZSB0aGUgYWN0dWFsIGJpdHMgbmVjZXNzYXJ5IHRvIGNoYW5nZVxuICAgIGNvbnN0IExBVENIX1RBQkxFID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICg1IDw8IDE2KSArIDI4LFxuICAgICAgICAgICAgKDUgPDwgMTYpICsgMzAsXG4gICAgICAgICAgICAoNSA8PCAxNikgKyAyOSxcbiAgICAgICAgICAgICgxMCA8PCAxNikgKyAoMjkgPDwgNSkgKyAzMCAvLyBVUFBFUiAtPiBNSVhFRCAtPiBQVU5DVFxuICAgICAgICBdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgICAgICg5IDw8IDE2KSArICgzMCA8PCA0KSArIDE0LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICg1IDw8IDE2KSArIDMwLFxuICAgICAgICAgICAgKDUgPDwgMTYpICsgMjksXG4gICAgICAgICAgICAoMTAgPDwgMTYpICsgKDI5IDw8IDUpICsgMzAgLy8gTE9XRVIgLT4gTUlYRUQgLT4gUFVOQ1RcbiAgICAgICAgXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgICAgICAoNCA8PCAxNikgKyAxNCxcbiAgICAgICAgICAgICg5IDw8IDE2KSArICgxNCA8PCA1KSArIDI4LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICg5IDw8IDE2KSArICgxNCA8PCA1KSArIDI5LFxuICAgICAgICAgICAgKDE0IDw8IDE2KSArICgxNCA8PCAxMCkgKyAoMjkgPDwgNSkgKyAzMFxuICAgICAgICAgICAgLy8gRElHSVQgLT4gVVBQRVIgLT4gTUlYRUQgLT4gUFVOQ1RcbiAgICAgICAgXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgICAgICAoNSA8PCAxNikgKyAyOSxcbiAgICAgICAgICAgICg1IDw8IDE2KSArIDI4LFxuICAgICAgICAgICAgKDEwIDw8IDE2KSArICgyOSA8PCA1KSArIDMwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICg1IDw8IDE2KSArIDMwIC8vIE1JWEVEIC0+IFBVTkNUXG4gICAgICAgIF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAgICAgKDUgPDwgMTYpICsgMzEsXG4gICAgICAgICAgICAoMTAgPDwgMTYpICsgKDMxIDw8IDUpICsgMjgsXG4gICAgICAgICAgICAoMTAgPDwgMTYpICsgKDMxIDw8IDUpICsgMzAsXG4gICAgICAgICAgICAoMTAgPDwgMTYpICsgKDMxIDw8IDUpICsgMjksXG4gICAgICAgICAgICAwXG4gICAgICAgIF0pXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIHN0YXRpY19TSElGVF9UQUJMRShTSElGVF9UQUJMRSkge1xuICAgICAgICBmb3IgKGxldCB0YWJsZSAvKkludDMyQXJyYXkqLyBvZiBTSElGVF9UQUJMRSkge1xuICAgICAgICAgICAgQXJyYXlzLmZpbGwodGFibGUsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBTSElGVF9UQUJMRVtNT0RFX1VQUEVSXVtNT0RFX1BVTkNUXSA9IDA7XG4gICAgICAgIFNISUZUX1RBQkxFW01PREVfTE9XRVJdW01PREVfUFVOQ1RdID0gMDtcbiAgICAgICAgU0hJRlRfVEFCTEVbTU9ERV9MT1dFUl1bTU9ERV9VUFBFUl0gPSAyODtcbiAgICAgICAgU0hJRlRfVEFCTEVbTU9ERV9NSVhFRF1bTU9ERV9QVU5DVF0gPSAwO1xuICAgICAgICBTSElGVF9UQUJMRVtNT0RFX0RJR0lUXVtNT0RFX1BVTkNUXSA9IDA7XG4gICAgICAgIFNISUZUX1RBQkxFW01PREVfRElHSVRdW01PREVfVVBQRVJdID0gMTU7XG4gICAgICAgIHJldHVybiBTSElGVF9UQUJMRTtcbiAgICB9XG4gICAgY29uc3QgLypmaW5hbCovIFNISUZUX1RBQkxFID0gc3RhdGljX1NISUZUX1RBQkxFKEFycmF5cy5jcmVhdGVJbnQzMkFycmF5KDYsIDYpKTsgLy8gbW9kZSBzaGlmdCBjb2RlcywgcGVyIHRhYmxlXG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFN0YXRlIHJlcHJlc2VudHMgYWxsIGluZm9ybWF0aW9uIGFib3V0IGEgc2VxdWVuY2UgbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIHRoZSBjdXJyZW50IG91dHB1dC5cbiAgICAgKiBOb3RlIHRoYXQgYSBzdGF0ZSBpcyBpbW11dGFibGUuXG4gICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIFN0YXRlIHtcbiAgICAgICAgY29uc3RydWN0b3IodG9rZW4sIG1vZGUsIGJpbmFyeUJ5dGVzLCBiaXRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPSBiaW5hcnlCeXRlcztcbiAgICAgICAgICAgIHRoaXMuYml0Q291bnQgPSBiaXRDb3VudDtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBtYXRjaCB0aGUgdG9rZW5cbiAgICAgICAgICAgIC8vIGludCBiaW5hcnlTaGlmdEJpdENvdW50ID0gKGJpbmFyeVNoaWZ0Qnl0ZUNvdW50ICogOCkgK1xuICAgICAgICAgICAgLy8gICAgKGJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSAwID8gMCA6XG4gICAgICAgICAgICAvLyAgICAgYmluYXJ5U2hpZnRCeXRlQ291bnQgPD0gMzEgPyAxMCA6XG4gICAgICAgICAgICAvLyAgICAgYmluYXJ5U2hpZnRCeXRlQ291bnQgPD0gNjIgPyAyMCA6IDIxKTtcbiAgICAgICAgICAgIC8vIGFzc2VydCB0aGlzLmJpdENvdW50ID09PSB0b2tlbi5nZXRUb3RhbEJpdENvdW50KCkgKyBiaW5hcnlTaGlmdEJpdENvdW50O1xuICAgICAgICB9XG4gICAgICAgIGdldE1vZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlO1xuICAgICAgICB9XG4gICAgICAgIGdldFRva2VuKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QmluYXJ5U2hpZnRCeXRlQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBnZXRCaXRDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpdENvdW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdGF0ZSByZXByZXNlbnRpbmcgdGhpcyBzdGF0ZSB3aXRoIGEgbGF0Y2ggdG8gYSAobm90XG4gICAgICAgIC8vIG5lY2Vzc2FyeSBkaWZmZXJlbnQpIG1vZGUsIGFuZCB0aGVuIGEgY29kZS5cbiAgICAgICAgbGF0Y2hBbmRBcHBlbmQobW9kZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGFzc2VydCBiaW5hcnlTaGlmdEJ5dGVDb3VudCA9PT0gMDtcbiAgICAgICAgICAgIGxldCBiaXRDb3VudCA9IHRoaXMuYml0Q291bnQ7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICAgICAgaWYgKG1vZGUgIT09IHRoaXMubW9kZSkge1xuICAgICAgICAgICAgICAgIGxldCBsYXRjaCA9IExBVENIX1RBQkxFW3RoaXMubW9kZV1bbW9kZV07XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBhZGQodG9rZW4sIGxhdGNoICYgMHhmZmZmLCBsYXRjaCA+PiAxNik7XG4gICAgICAgICAgICAgICAgYml0Q291bnQgKz0gbGF0Y2ggPj4gMTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGF0Y2hNb2RlQml0Q291bnQgPSBtb2RlID09PSBNT0RFX0RJR0lUID8gNCA6IDU7XG4gICAgICAgICAgICB0b2tlbiA9IGFkZCh0b2tlbiwgdmFsdWUsIGxhdGNoTW9kZUJpdENvdW50KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhdGUodG9rZW4sIG1vZGUsIDAsIGJpdENvdW50ICsgbGF0Y2hNb2RlQml0Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdGF0ZSByZXByZXNlbnRpbmcgdGhpcyBzdGF0ZSwgd2l0aCBhIHRlbXBvcmFyeSBzaGlmdFxuICAgICAgICAvLyB0byBhIGRpZmZlcmVudCBtb2RlIHRvIG91dHB1dCBhIHNpbmdsZSB2YWx1ZS5cbiAgICAgICAgc2hpZnRBbmRBcHBlbmQobW9kZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGFzc2VydCBiaW5hcnlTaGlmdEJ5dGVDb3VudCA9PT0gMCAmJiB0aGlzLm1vZGUgIT09IG1vZGU7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICAgICAgbGV0IHRoaXNNb2RlQml0Q291bnQgPSB0aGlzLm1vZGUgPT09IE1PREVfRElHSVQgPyA0IDogNTtcbiAgICAgICAgICAgIC8vIFNoaWZ0cyBleGlzdCBvbmx5IHRvIFVQUEVSIGFuZCBQVU5DVCwgYm90aCB3aXRoIHRva2VucyBzaXplIDUuXG4gICAgICAgICAgICB0b2tlbiA9IGFkZCh0b2tlbiwgU0hJRlRfVEFCTEVbdGhpcy5tb2RlXVttb2RlXSwgdGhpc01vZGVCaXRDb3VudCk7XG4gICAgICAgICAgICB0b2tlbiA9IGFkZCh0b2tlbiwgdmFsdWUsIDUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZSh0b2tlbiwgdGhpcy5tb2RlLCAwLCB0aGlzLmJpdENvdW50ICsgdGhpc01vZGVCaXRDb3VudCArIDUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdGF0ZSByZXByZXNlbnRpbmcgdGhpcyBzdGF0ZSwgYnV0IGFuIGFkZGl0aW9uYWwgY2hhcmFjdGVyXG4gICAgICAgIC8vIG91dHB1dCBpbiBCaW5hcnkgU2hpZnQgbW9kZS5cbiAgICAgICAgYWRkQmluYXJ5U2hpZnRDaGFyKGluZGV4KSB7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICAgICAgbGV0IG1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICAgICAgICBsZXQgYml0Q291bnQgPSB0aGlzLmJpdENvdW50O1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gTU9ERV9QVU5DVCB8fCB0aGlzLm1vZGUgPT09IE1PREVfRElHSVQpIHtcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQgYmluYXJ5U2hpZnRCeXRlQ291bnQgPT09IDA7XG4gICAgICAgICAgICAgICAgbGV0IGxhdGNoID0gTEFUQ0hfVEFCTEVbbW9kZV1bTU9ERV9VUFBFUl07XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBhZGQodG9rZW4sIGxhdGNoICYgMHhmZmZmLCBsYXRjaCA+PiAxNik7XG4gICAgICAgICAgICAgICAgYml0Q291bnQgKz0gbGF0Y2ggPj4gMTY7XG4gICAgICAgICAgICAgICAgbW9kZSA9IE1PREVfVVBQRVI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGVsdGFCaXRDb3VudCA9IHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPT09IDAgfHwgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCA9PT0gMzFcbiAgICAgICAgICAgICAgICA/IDE4XG4gICAgICAgICAgICAgICAgOiB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSA2MlxuICAgICAgICAgICAgICAgICAgICA/IDlcbiAgICAgICAgICAgICAgICAgICAgOiA4O1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBTdGF0ZSh0b2tlbiwgbW9kZSwgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCArIDEsIGJpdENvdW50ICsgZGVsdGFCaXRDb3VudCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSAyMDQ3ICsgMzEpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc3RyaW5nIGlzIGFzIGxvbmcgYXMgaXQncyBhbGxvd2VkIHRvIGJlLiAgV2Ugc2hvdWxkIGVuZCBpdC5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZW5kQmluYXJ5U2hpZnQoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBzdGF0ZSBpZGVudGljYWwgdG8gdGhpcyBvbmUsIGJ1dCB3ZSBhcmUgbm8gbG9uZ2VyIGluXG4gICAgICAgIC8vIEJpbmFyeSBTaGlmdCBtb2RlLlxuICAgICAgICBlbmRCaW5hcnlTaGlmdChpbmRleCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b2tlbiA9IHRoaXMudG9rZW47XG4gICAgICAgICAgICB0b2tlbiA9IGFkZEJpbmFyeVNoaWZ0KHRva2VuLCBpbmRleCAtIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQsIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0IHRva2VuLmdldFRvdGFsQml0Q291bnQoKSA9PT0gdGhpcy5iaXRDb3VudDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhdGUodG9rZW4sIHRoaXMubW9kZSwgMCwgdGhpcy5iaXRDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIFwidGhpc1wiIHN0YXRlIGlzIGJldHRlciAoZXF1YWw6IG9yKSB0byBiZSBpbiB0aGFuIFwidGhhdFwiXG4gICAgICAgIC8vIHN0YXRlIHVuZGVyIGFsbCBwb3NzaWJsZSBjaXJjdW1zdGFuY2VzLlxuICAgICAgICBpc0JldHRlclRoYW5PckVxdWFsVG8ob3RoZXIpIHtcbiAgICAgICAgICAgIGxldCBuZXdNb2RlQml0Q291bnQgPSB0aGlzLmJpdENvdW50ICsgKExBVENIX1RBQkxFW3RoaXMubW9kZV1bb3RoZXIubW9kZV0gPj4gMTYpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPCBvdGhlci5iaW5hcnlTaGlmdEJ5dGVDb3VudCkge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBhZGRpdGlvbmFsIEIvUyBlbmNvZGluZyBjb3N0IG9mIG90aGVyLCBpZiBhbnlcbiAgICAgICAgICAgICAgICBuZXdNb2RlQml0Q291bnQgKz1cbiAgICAgICAgICAgICAgICAgICAgU3RhdGUuY2FsY3VsYXRlQmluYXJ5U2hpZnRDb3N0KG90aGVyKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICBTdGF0ZS5jYWxjdWxhdGVCaW5hcnlTaGlmdENvc3QodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID4gb3RoZXIuYmluYXJ5U2hpZnRCeXRlQ291bnQgJiZcbiAgICAgICAgICAgICAgICBvdGhlci5iaW5hcnlTaGlmdEJ5dGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBtYXhpbXVtIHBvc3NpYmxlIGFkZGl0aW9uYWwgY29zdCAoaXQ6IGgpXG4gICAgICAgICAgICAgICAgbmV3TW9kZUJpdENvdW50ICs9IDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld01vZGVCaXRDb3VudCA8PSBvdGhlci5iaXRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICB0b0JpdEFycmF5KHRleHQpIHtcbiAgICAgICAgICAgIC8vIFJldmVyc2UgdGhlIHRva2Vucywgc28gdGhhdCB0aGV5IGFyZSBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZFxuICAgICAgICAgICAgLy8gYmUgb3V0cHV0XG4gICAgICAgICAgICBsZXQgc3ltYm9scyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9rZW4gPSB0aGlzLmVuZEJpbmFyeVNoaWZ0KHRleHQubGVuZ3RoKS50b2tlbjsgdG9rZW4gIT09IG51bGw7IHRva2VuID0gdG9rZW4uZ2V0UHJldmlvdXMoKSkge1xuICAgICAgICAgICAgICAgIHN5bWJvbHMudW5zaGlmdCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYml0QXJyYXkgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIC8vIEFkZCBlYWNoIHRva2VuIHRvIHRoZSByZXN1bHQuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN5bWJvbCBvZiBzeW1ib2xzKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sLmFwcGVuZFRvKGJpdEFycmF5LCB0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFzc2VydCBiaXRBcnJheS5nZXRTaXplKCkgPT09IHRoaXMuYml0Q291bnQ7XG4gICAgICAgICAgICByZXR1cm4gYml0QXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBPdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuZm9ybWF0KCclcyBiaXRzPSVkIGJ5dGVzPSVkJywgTU9ERV9OQU1FU1t0aGlzLm1vZGVdLCB0aGlzLmJpdENvdW50LCB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2FsY3VsYXRlQmluYXJ5U2hpZnRDb3N0KHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYmluYXJ5U2hpZnRCeXRlQ291bnQgPiA2Mikge1xuICAgICAgICAgICAgICAgIHJldHVybiAyMTsgLy8gQi9TIHdpdGggZXh0ZW5kZWQgbGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuYmluYXJ5U2hpZnRCeXRlQ291bnQgPiAzMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAyMDsgLy8gdHdvIEIvU1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxMDsgLy8gb25lIEIvU1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU3RhdGUuSU5JVElBTF9TVEFURSA9IG5ldyBTdGF0ZShFTVBUWV9UT0tFTiwgTU9ERV9VUFBFUiwgMCwgMCk7XG5cbiAgICBmdW5jdGlvbiBzdGF0aWNfQ0hBUl9NQVAoQ0hBUl9NQVApIHtcbiAgICAgICAgY29uc3Qgc3BhY2VDaGFyQ29kZSA9IFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCcgJyk7XG4gICAgICAgIGNvbnN0IHBvaW50Q2hhckNvZGUgPSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnLicpO1xuICAgICAgICBjb25zdCBjb21tYUNoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJywnKTtcbiAgICAgICAgQ0hBUl9NQVBbTU9ERV9VUFBFUl1bc3BhY2VDaGFyQ29kZV0gPSAxO1xuICAgICAgICBjb25zdCB6VXBwZXJDaGFyQ29kZSA9IFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCdaJyk7XG4gICAgICAgIGNvbnN0IGFVcHBlckNoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJ0EnKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IGFVcHBlckNoYXJDb2RlOyBjIDw9IHpVcHBlckNoYXJDb2RlOyBjKyspIHtcbiAgICAgICAgICAgIENIQVJfTUFQW01PREVfVVBQRVJdW2NdID0gYyAtIGFVcHBlckNoYXJDb2RlICsgMjtcbiAgICAgICAgfVxuICAgICAgICBDSEFSX01BUFtNT0RFX0xPV0VSXVtzcGFjZUNoYXJDb2RlXSA9IDE7XG4gICAgICAgIGNvbnN0IHpMb3dlckNoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJ3onKTtcbiAgICAgICAgY29uc3QgYUxvd2VyQ2hhckNvZGUgPSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnYScpO1xuICAgICAgICBmb3IgKGxldCBjID0gYUxvd2VyQ2hhckNvZGU7IGMgPD0gekxvd2VyQ2hhckNvZGU7IGMrKykge1xuICAgICAgICAgICAgQ0hBUl9NQVBbTU9ERV9MT1dFUl1bY10gPSBjIC0gYUxvd2VyQ2hhckNvZGUgKyAyO1xuICAgICAgICB9XG4gICAgICAgIENIQVJfTUFQW01PREVfRElHSVRdW3NwYWNlQ2hhckNvZGVdID0gMTtcbiAgICAgICAgY29uc3QgbmluZUNoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJzknKTtcbiAgICAgICAgY29uc3QgemVyb0NoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJzAnKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IHplcm9DaGFyQ29kZTsgYyA8PSBuaW5lQ2hhckNvZGU7IGMrKykge1xuICAgICAgICAgICAgQ0hBUl9NQVBbTU9ERV9ESUdJVF1bY10gPSBjIC0gemVyb0NoYXJDb2RlICsgMjtcbiAgICAgICAgfVxuICAgICAgICBDSEFSX01BUFtNT0RFX0RJR0lUXVtjb21tYUNoYXJDb2RlXSA9IDEyO1xuICAgICAgICBDSEFSX01BUFtNT0RFX0RJR0lUXVtwb2ludENoYXJDb2RlXSA9IDEzO1xuICAgICAgICBjb25zdCBtaXhlZFRhYmxlID0gW1xuICAgICAgICAgICAgJ1xceDAwJyxcbiAgICAgICAgICAgICcgJyxcbiAgICAgICAgICAgICdcXHgwMScsXG4gICAgICAgICAgICAnXFx4MDInLFxuICAgICAgICAgICAgJ1xceDAzJyxcbiAgICAgICAgICAgICdcXHgwNCcsXG4gICAgICAgICAgICAnXFx4MDUnLFxuICAgICAgICAgICAgJ1xceDA2JyxcbiAgICAgICAgICAgICdcXHgwNycsXG4gICAgICAgICAgICAnXFxiJyxcbiAgICAgICAgICAgICdcXHQnLFxuICAgICAgICAgICAgJ1xcbicsXG4gICAgICAgICAgICAnXFx4MGInLFxuICAgICAgICAgICAgJ1xcZicsXG4gICAgICAgICAgICAnXFxyJyxcbiAgICAgICAgICAgICdcXHgxYicsXG4gICAgICAgICAgICAnXFx4MWMnLFxuICAgICAgICAgICAgJ1xceDFkJyxcbiAgICAgICAgICAgICdcXHgxZScsXG4gICAgICAgICAgICAnXFx4MWYnLFxuICAgICAgICAgICAgJ0AnLFxuICAgICAgICAgICAgJ1xcXFwnLFxuICAgICAgICAgICAgJ14nLFxuICAgICAgICAgICAgJ18nLFxuICAgICAgICAgICAgJ2AnLFxuICAgICAgICAgICAgJ3wnLFxuICAgICAgICAgICAgJ34nLFxuICAgICAgICAgICAgJ1xceDdmJ1xuICAgICAgICBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1peGVkVGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIENIQVJfTUFQW01PREVfTUlYRURdW1N0cmluZ1V0aWxzLmdldENoYXJDb2RlKG1peGVkVGFibGVbaV0pXSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVuY3RUYWJsZSA9IFtcbiAgICAgICAgICAgICdcXHgwMCcsXG4gICAgICAgICAgICAnXFxyJyxcbiAgICAgICAgICAgICdcXHgwMCcsXG4gICAgICAgICAgICAnXFx4MDAnLFxuICAgICAgICAgICAgJ1xceDAwJyxcbiAgICAgICAgICAgICdcXHgwMCcsXG4gICAgICAgICAgICAnIScsXG4gICAgICAgICAgICAnXFwnJyxcbiAgICAgICAgICAgICcjJyxcbiAgICAgICAgICAgICckJyxcbiAgICAgICAgICAgICclJyxcbiAgICAgICAgICAgICcmJyxcbiAgICAgICAgICAgICdcXCcnLFxuICAgICAgICAgICAgJygnLFxuICAgICAgICAgICAgJyknLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgJysnLFxuICAgICAgICAgICAgJywnLFxuICAgICAgICAgICAgJy0nLFxuICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgJy8nLFxuICAgICAgICAgICAgJzonLFxuICAgICAgICAgICAgJzsnLFxuICAgICAgICAgICAgJzwnLFxuICAgICAgICAgICAgJz0nLFxuICAgICAgICAgICAgJz4nLFxuICAgICAgICAgICAgJz8nLFxuICAgICAgICAgICAgJ1snLFxuICAgICAgICAgICAgJ10nLFxuICAgICAgICAgICAgJ3snLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHVuY3RUYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKHB1bmN0VGFibGVbaV0pID4gMCkge1xuICAgICAgICAgICAgICAgIENIQVJfTUFQW01PREVfUFVOQ1RdW1N0cmluZ1V0aWxzLmdldENoYXJDb2RlKHB1bmN0VGFibGVbaV0pXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENIQVJfTUFQO1xuICAgIH1cbiAgICBjb25zdCBDSEFSX01BUCA9IHN0YXRpY19DSEFSX01BUChBcnJheXMuY3JlYXRlSW50MzJBcnJheSg1LCAyNTYpKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBwcm9kdWNlcyBuZWFybHkgb3B0aW1hbCBlbmNvZGluZ3Mgb2YgdGV4dCBpbnRvIHRoZSBmaXJzdC1sZXZlbCBvZlxuICAgICAqIGVuY29kaW5nIHVzZWQgYnkgQXp0ZWMgY29kZS5cbiAgICAgKlxuICAgICAqIEl0IHVzZXMgYSBkeW5hbWljIGFsZ29yaXRobS4gIEZvciBlYWNoIHByZWZpeCBvZiB0aGUgc3RyaW5nLCBpdCBkZXRlcm1pbmVzXG4gICAgICogYSBzZXQgb2YgZW5jb2RpbmdzIHRoYXQgY291bGQgbGVhZCB0byB0aGlzIHByZWZpeC4gIFdlIHJlcGVhdGVkbHkgYWRkIGFcbiAgICAgKiBjaGFyYWN0ZXIgYW5kIGdlbmVyYXRlIGEgbmV3IHNldCBvZiBvcHRpbWFsIGVuY29kaW5ncyB1bnRpbCB3ZSBoYXZlIHJlYWRcbiAgICAgKiB0aHJvdWdoIHRoZSBlbnRpcmUgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIEZyYW5rIFllbGxpblxuICAgICAqIEBhdXRob3IgUnVzdGFtIEFiZHVsbGFldlxuICAgICAqL1xuICAgIC8qcHVibGljIGZpbmFsKi8gY2xhc3MgSGlnaExldmVsRW5jb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdGV4dCByZXByZXNlbnRlZCBieSB0aGlzIGVuY29kZXIgZW5jb2RlZCBhcyBhIHtAbGluayBCaXRBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGVuY29kZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwYWNlQ2hhckNvZGUgPSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnICcpO1xuICAgICAgICAgICAgY29uc3QgbGluZUJyZWFrQ2hhckNvZGUgPSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnXFxuJyk7XG4gICAgICAgICAgICBsZXQgc3RhdGVzID0gQ29sbGVjdGlvbnMuc2luZ2xldG9uTGlzdChTdGF0ZS5JTklUSUFMX1NUQVRFKTtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnRleHQubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhaXJDb2RlO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0Q2hhciA9IGluZGV4ICsgMSA8IHRoaXMudGV4dC5sZW5ndGggPyB0aGlzLnRleHRbaW5kZXggKyAxXSA6IDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnRleHRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJ1xccicpOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpckNvZGUgPSBuZXh0Q2hhciA9PT0gbGluZUJyZWFrQ2hhckNvZGUgPyAyIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCcuJyk6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyQ29kZSA9IG5leHRDaGFyID09PSBzcGFjZUNoYXJDb2RlID8gMyA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnLCcpOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpckNvZGUgPSBuZXh0Q2hhciA9PT0gc3BhY2VDaGFyQ29kZSA/IDQgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJzonKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJDb2RlID0gbmV4dENoYXIgPT09IHNwYWNlQ2hhckNvZGUgPyA1IDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpckNvZGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFpckNvZGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgb25lIG9mIHRoZSBmb3VyIHNwZWNpYWwgUFVOQ1QgcGFpcnMuICBUcmVhdCB0aGVtIHNwZWNpYWxseS5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGEgbmV3IHNldCBvZiBzdGF0ZXMgZm9yIHRoZSB0d28gbmV3IGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlcyA9IEhpZ2hMZXZlbEVuY29kZXIudXBkYXRlU3RhdGVMaXN0Rm9yUGFpcihzdGF0ZXMsIGluZGV4LCBwYWlyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBuZXcgc2V0IG9mIHN0YXRlcyBmb3IgdGhlIG5ldyBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlcyA9IHRoaXMudXBkYXRlU3RhdGVMaXN0Rm9yQ2hhcihzdGF0ZXMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBhcmUgbGVmdCB3aXRoIGEgc2V0IG9mIHN0YXRlcy4gIEZpbmQgdGhlIHNob3J0ZXN0IG9uZS5cbiAgICAgICAgICAgIGNvbnN0IG1pblN0YXRlID0gQ29sbGVjdGlvbnMubWluKHN0YXRlcywgKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5nZXRCaXRDb3VudCgpIC0gYi5nZXRCaXRDb3VudCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGl0IHRvIGEgYml0IGFycmF5LCBhbmQgcmV0dXJuLlxuICAgICAgICAgICAgcmV0dXJuIG1pblN0YXRlLnRvQml0QXJyYXkodGhpcy50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSB1cGRhdGUgYSBzZXQgb2Ygc3RhdGVzIGZvciBhIG5ldyBjaGFyYWN0ZXIgYnkgdXBkYXRpbmcgZWFjaCBzdGF0ZVxuICAgICAgICAvLyBmb3IgdGhlIG5ldyBjaGFyYWN0ZXIsIG1lcmdpbmcgdGhlIHJlc3VsdHMsIGFuZCB0aGVuIHJlbW92aW5nIHRoZVxuICAgICAgICAvLyBub24tb3B0aW1hbCBzdGF0ZXMuXG4gICAgICAgIHVwZGF0ZVN0YXRlTGlzdEZvckNoYXIoc3RhdGVzLCBpbmRleCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBzdGF0ZSAvKlN0YXRlKi8gb2Ygc3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUZvckNoYXIoc3RhdGUsIGluZGV4LCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEhpZ2hMZXZlbEVuY29kZXIuc2ltcGxpZnlTdGF0ZXMocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gYSBzZXQgb2Ygc3RhdGVzIHRoYXQgcmVwcmVzZW50IHRoZSBwb3NzaWJsZSB3YXlzIG9mIHVwZGF0aW5nIHRoaXNcbiAgICAgICAgLy8gc3RhdGUgZm9yIHRoZSBuZXh0IGNoYXJhY3Rlci4gIFRoZSByZXN1bHRpbmcgc2V0IG9mIHN0YXRlcyBhcmUgYWRkZWQgdG9cbiAgICAgICAgLy8gdGhlIFwicmVzdWx0XCIgbGlzdC5cbiAgICAgICAgdXBkYXRlU3RhdGVGb3JDaGFyKHN0YXRlLCBpbmRleCwgcmVzdWx0KSB7XG4gICAgICAgICAgICBsZXQgY2ggPSAodGhpcy50ZXh0W2luZGV4XSAmIDB4ZmYpO1xuICAgICAgICAgICAgbGV0IGNoYXJJbkN1cnJlbnRUYWJsZSA9IENIQVJfTUFQW3N0YXRlLmdldE1vZGUoKV1bY2hdID4gMDtcbiAgICAgICAgICAgIGxldCBzdGF0ZU5vQmluYXJ5ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IG1vZGUgLyppbnQqLyA9IDA7IG1vZGUgPD0gTU9ERV9QVU5DVDsgbW9kZSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoYXJJbk1vZGUgPSBDSEFSX01BUFttb2RlXVtjaF07XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJJbk1vZGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZU5vQmluYXJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgY3JlYXRlIHN0YXRlTm9CaW5hcnkgdGhlIGZpcnN0IHRpbWUgaXQncyByZXF1aXJlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTm9CaW5hcnkgPSBzdGF0ZS5lbmRCaW5hcnlTaGlmdChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGdlbmVyYXRpbmcgdGhlIGNoYXJhY3RlciBieSBsYXRjaGluZyB0byBpdHMgbW9kZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoYXJJbkN1cnJlbnRUYWJsZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9PT0gc3RhdGUuZ2V0TW9kZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID09PSBNT0RFX0RJR0lUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGluIHRoZSBjdXJyZW50IHRhYmxlLCB3ZSBkb24ndCB3YW50IHRvIGxhdGNoIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbnkgb3RoZXIgbW9kZSBleGNlcHQgcG9zc2libHkgZGlnaXQgKHdoaWNoIHVzZXMgb25seSA0IGJpdHMpLiAgQW55XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlciBsYXRjaCB3b3VsZCBiZSBlcXVhbGx5IHN1Y2Nlc3NmdWwgKmFmdGVyKiB0aGlzIGNoYXJhY3RlciwgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3b3VsZG4ndCBzYXZlIGFueSBiaXRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF0Y2hTdGF0ZSA9IHN0YXRlTm9CaW5hcnkubGF0Y2hBbmRBcHBlbmQobW9kZSwgY2hhckluTW9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsYXRjaFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgZ2VuZXJhdGluZyB0aGUgY2hhcmFjdGVyIGJ5IHN3aXRjaGluZyB0byBpdHMgbW9kZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGFySW5DdXJyZW50VGFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFNISUZUX1RBQkxFW3N0YXRlLmdldE1vZGUoKV1bbW9kZV0gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQgbmV2ZXIgbWFrZXMgc2Vuc2UgdG8gdGVtcG9yYXJpbHkgc2hpZnQgdG8gYW5vdGhlciBtb2RlIGlmIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyIGV4aXN0cyBpbiB0aGUgY3VycmVudCBtb2RlLiAgVGhhdCBjYW4gbmV2ZXIgc2F2ZSBiaXRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hpZnRTdGF0ZSA9IHN0YXRlTm9CaW5hcnkuc2hpZnRBbmRBcHBlbmQobW9kZSwgY2hhckluTW9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzaGlmdFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5nZXRCaW5hcnlTaGlmdEJ5dGVDb3VudCgpID4gMCB8fFxuICAgICAgICAgICAgICAgIENIQVJfTUFQW3N0YXRlLmdldE1vZGUoKV1bY2hdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBuZXZlciB3b3J0aHdoaWxlIHRvIGdvIGludG8gYmluYXJ5IHNoaWZ0IG1vZGUgaWYgeW91J3JlIG5vdCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gaW4gYmluYXJ5IHNoaWZ0IG1vZGUsIGFuZCB0aGUgY2hhcmFjdGVyIGV4aXN0cyBpbiB5b3VyIGN1cnJlbnQgbW9kZS5cbiAgICAgICAgICAgICAgICAvLyBUaGF0IGNhbiBuZXZlciBzYXZlIGJpdHMgb3ZlciBqdXN0IG91dHB1dHRpbmcgdGhlIGNoYXIgaW4gdGhlIGN1cnJlbnQgbW9kZS5cbiAgICAgICAgICAgICAgICBsZXQgYmluYXJ5U3RhdGUgPSBzdGF0ZS5hZGRCaW5hcnlTaGlmdENoYXIoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpbmFyeVN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgdXBkYXRlU3RhdGVMaXN0Rm9yUGFpcihzdGF0ZXMsIGluZGV4LCBwYWlyQ29kZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBzdGF0ZSAvKlN0YXRlKi8gb2Ygc3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUZvclBhaXIoc3RhdGUsIGluZGV4LCBwYWlyQ29kZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpbXBsaWZ5U3RhdGVzKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHVwZGF0ZVN0YXRlRm9yUGFpcihzdGF0ZSwgaW5kZXgsIHBhaXJDb2RlLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZU5vQmluYXJ5ID0gc3RhdGUuZW5kQmluYXJ5U2hpZnQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gUG9zc2liaWxpdHkgMS4gIExhdGNoIHRvIEMuTU9ERV9QVU5DVCwgYW5kIHRoZW4gYXBwZW5kIHRoaXMgY29kZVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhdGVOb0JpbmFyeS5sYXRjaEFuZEFwcGVuZChNT0RFX1BVTkNULCBwYWlyQ29kZSkpO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmdldE1vZGUoKSAhPT0gTU9ERV9QVU5DVCkge1xuICAgICAgICAgICAgICAgIC8vIFBvc3NpYmlsaXR5IDIuICBTaGlmdCB0byBDLk1PREVfUFVOQ1QsIGFuZCB0aGVuIGFwcGVuZCB0aGlzIGNvZGUuXG4gICAgICAgICAgICAgICAgLy8gRXZlcnkgc3RhdGUgZXhjZXB0IEMuTU9ERV9QVU5DVCAoaGFuZGxlZCBhYm92ZSkgY2FuIHNoaWZ0XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhdGVOb0JpbmFyeS5zaGlmdEFuZEFwcGVuZChNT0RFX1BVTkNULCBwYWlyQ29kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhaXJDb2RlID09PSAzIHx8IHBhaXJDb2RlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgLy8gYm90aCBjaGFyYWN0ZXJzIGFyZSBpbiBESUdJVFMuICBTb21ldGltZXMgYmV0dGVyIHRvIGp1c3QgYWRkIHR3byBkaWdpdHNcbiAgICAgICAgICAgICAgICBsZXQgZGlnaXRTdGF0ZSA9IHN0YXRlTm9CaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgLmxhdGNoQW5kQXBwZW5kKE1PREVfRElHSVQsIDE2IC0gcGFpckNvZGUpIC8vIHBlcmlvZCBvciBjb21tYSBpbiBESUdJVFxuICAgICAgICAgICAgICAgICAgICAubGF0Y2hBbmRBcHBlbmQoTU9ERV9ESUdJVCwgMSk7IC8vIHNwYWNlIGluIERJR0lUXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZGlnaXRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZ2V0QmluYXJ5U2hpZnRCeXRlQ291bnQoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBvbmx5IG1ha2VzIHNlbnNlIHRvIGRvIHRoZSBjaGFyYWN0ZXJzIGFzIGJpbmFyeSBpZiB3ZSdyZSBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gaW4gYmluYXJ5IG1vZGUuXG4gICAgICAgICAgICAgICAgbGV0IGJpbmFyeVN0YXRlID0gc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgLmFkZEJpbmFyeVNoaWZ0Q2hhcihpbmRleClcbiAgICAgICAgICAgICAgICAgICAgLmFkZEJpbmFyeVNoaWZ0Q2hhcihpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpbmFyeVN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgc2ltcGxpZnlTdGF0ZXMoc3RhdGVzKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5ld1N0YXRlIG9mIHN0YXRlcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb2xkU3RhdGUgb2YgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRTdGF0ZS5pc0JldHRlclRoYW5PckVxdWFsVG8obmV3U3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZS5pc0JldHRlclRoYW5PckVxdWFsVG8ob2xkU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRvci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoeCA9PiB4ICE9PSBvbGRTdGF0ZSk7IC8vIHJlbW92ZSBvbGQgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcuYXp0ZWMuZW5jb2RlcjtcbiAgICAvLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5jb21tb24uQml0QXJyYXk7XG4gICAgLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuY29tbW9uLkJpdE1hdHJpeDtcbiAgICAvLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5jb21tb24ucmVlZHNvbG9tb24uR2VuZXJpY0dGO1xuICAgIC8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5yZWVkc29sb21vbi5SZWVkU29sb21vbkVuY29kZXI7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIEF6dGVjIDJEIGJhcmNvZGVzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBSdXN0YW0gQWJkdWxsYWV2XG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBFbmNvZGVyJDEge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gYmluYXJ5IGNvbnRlbnQgYXMgYW4gQXp0ZWMgc3ltYm9sXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIGlucHV0IGRhdGEgc3RyaW5nXG4gICAgICAgICAqIEByZXR1cm4gQXp0ZWMgc3ltYm9sIG1hdHJpeCB3aXRoIG1ldGFkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZW5jb2RlQnl0ZXMoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIEVuY29kZXIkMS5lbmNvZGUoZGF0YSwgRW5jb2RlciQxLkRFRkFVTFRfRUNfUEVSQ0VOVCwgRW5jb2RlciQxLkRFRkFVTFRfQVpURUNfTEFZRVJTKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gYmluYXJ5IGNvbnRlbnQgYXMgYW4gQXp0ZWMgc3ltYm9sXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIGlucHV0IGRhdGEgc3RyaW5nXG4gICAgICAgICAqIEBwYXJhbSBtaW5FQ0NQZXJjZW50IG1pbmltYWwgcGVyY2VudGFnZSBvZiBlcnJvciBjaGVjayB3b3JkcyAoQWNjb3JkaW5nIHRvIElTTy9JRUMgMjQ3Nzg6MjAwOCxcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgYSBtaW5pbXVtIG9mIDIzJSArIDMgd29yZHMgaXMgcmVjb21tZW5kZWQpXG4gICAgICAgICAqIEBwYXJhbSB1c2VyU3BlY2lmaWVkTGF5ZXJzIGlmIG5vbi16ZXJvLCBhIHVzZXItc3BlY2lmaWVkIHZhbHVlIGZvciB0aGUgbnVtYmVyIG9mIGxheWVyc1xuICAgICAgICAgKiBAcmV0dXJuIEF6dGVjIHN5bWJvbCBtYXRyaXggd2l0aCBtZXRhZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGVuY29kZShkYXRhLCBtaW5FQ0NQZXJjZW50LCB1c2VyU3BlY2lmaWVkTGF5ZXJzKSB7XG4gICAgICAgICAgICAvLyBIaWdoLWxldmVsIGVuY29kZVxuICAgICAgICAgICAgbGV0IGJpdHMgPSBuZXcgSGlnaExldmVsRW5jb2RlcihkYXRhKS5lbmNvZGUoKTtcbiAgICAgICAgICAgIC8vIHN0dWZmIGJpdHMgYW5kIGNob29zZSBzeW1ib2wgc2l6ZVxuICAgICAgICAgICAgbGV0IGVjY0JpdHMgPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24oKGJpdHMuZ2V0U2l6ZSgpICogbWluRUNDUGVyY2VudCksIDEwMCkgKyAxMTtcbiAgICAgICAgICAgIGxldCB0b3RhbFNpemVCaXRzID0gYml0cy5nZXRTaXplKCkgKyBlY2NCaXRzO1xuICAgICAgICAgICAgbGV0IGNvbXBhY3Q7XG4gICAgICAgICAgICBsZXQgbGF5ZXJzO1xuICAgICAgICAgICAgbGV0IHRvdGFsQml0c0luTGF5ZXI7XG4gICAgICAgICAgICBsZXQgd29yZFNpemU7XG4gICAgICAgICAgICBsZXQgc3R1ZmZlZEJpdHM7XG4gICAgICAgICAgICBpZiAodXNlclNwZWNpZmllZExheWVycyAhPT0gRW5jb2RlciQxLkRFRkFVTFRfQVpURUNfTEFZRVJTKSB7XG4gICAgICAgICAgICAgICAgY29tcGFjdCA9IHVzZXJTcGVjaWZpZWRMYXllcnMgPCAwO1xuICAgICAgICAgICAgICAgIGxheWVycyA9IE1hdGguYWJzKHVzZXJTcGVjaWZpZWRMYXllcnMpO1xuICAgICAgICAgICAgICAgIGlmIChsYXllcnMgPiAoY29tcGFjdCA/IEVuY29kZXIkMS5NQVhfTkJfQklUU19DT01QQUNUIDogRW5jb2RlciQxLk1BWF9OQl9CSVRTKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFN0cmluZ1V0aWxzLmZvcm1hdCgnSWxsZWdhbCB2YWx1ZSAlcyBmb3IgbGF5ZXJzJywgdXNlclNwZWNpZmllZExheWVycykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3RhbEJpdHNJbkxheWVyID0gRW5jb2RlciQxLnRvdGFsQml0c0luTGF5ZXIobGF5ZXJzLCBjb21wYWN0KTtcbiAgICAgICAgICAgICAgICB3b3JkU2l6ZSA9IEVuY29kZXIkMS5XT1JEX1NJWkVbbGF5ZXJzXTtcbiAgICAgICAgICAgICAgICBsZXQgdXNhYmxlQml0c0luTGF5ZXJzID0gdG90YWxCaXRzSW5MYXllciAtICh0b3RhbEJpdHNJbkxheWVyICUgd29yZFNpemUpO1xuICAgICAgICAgICAgICAgIHN0dWZmZWRCaXRzID0gRW5jb2RlciQxLnN0dWZmQml0cyhiaXRzLCB3b3JkU2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0dWZmZWRCaXRzLmdldFNpemUoKSArIGVjY0JpdHMgPiB1c2FibGVCaXRzSW5MYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignRGF0YSB0byBsYXJnZSBmb3IgdXNlciBzcGVjaWZpZWQgbGF5ZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhY3QgJiYgc3R1ZmZlZEJpdHMuZ2V0U2l6ZSgpID4gd29yZFNpemUgKiA2NCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21wYWN0IGZvcm1hdCBvbmx5IGFsbG93cyA2NCBkYXRhIHdvcmRzLCB0aG91Z2ggQzQgY2FuIGhvbGQgbW9yZSB3b3JkcyB0aGFuIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignRGF0YSB0byBsYXJnZSBmb3IgdXNlciBzcGVjaWZpZWQgbGF5ZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3b3JkU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgc3R1ZmZlZEJpdHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIFdlIGxvb2sgYXQgdGhlIHBvc3NpYmxlIHRhYmxlIHNpemVzIGluIHRoZSBvcmRlciBDb21wYWN0MSwgQ29tcGFjdDIsIENvbXBhY3QzLFxuICAgICAgICAgICAgICAgIC8vIENvbXBhY3Q0LCBOb3JtYWw0LC4uLiAgTm9ybWFsKGkpIGZvciBpIDwgNCBpc24ndCB0eXBpY2FsbHkgdXNlZCBzaW5jZSBDb21wYWN0KGkrMSlcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGUgc2FtZSBzaXplLCBidXQgaGFzIG1vcmUgZGF0YS5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gRW5jb2RlciQxLk1BWF9OQl9CSVRTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdEYXRhIHRvbyBsYXJnZSBmb3IgYW4gQXp0ZWMgY29kZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3QgPSBpIDw9IDM7XG4gICAgICAgICAgICAgICAgICAgIGxheWVycyA9IGNvbXBhY3QgPyBpICsgMSA6IGk7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsQml0c0luTGF5ZXIgPSBFbmNvZGVyJDEudG90YWxCaXRzSW5MYXllcihsYXllcnMsIGNvbXBhY3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxTaXplQml0cyA+IHRvdGFsQml0c0luTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFtSZV1zdHVmZiB0aGUgYml0cyBpZiB0aGlzIGlzIHRoZSBmaXJzdCBvcHBvcnR1bml0eSwgb3IgaWYgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvcmRTaXplIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHVmZmVkQml0cyA9PSBudWxsIHx8IHdvcmRTaXplICE9PSBFbmNvZGVyJDEuV09SRF9TSVpFW2xheWVyc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRTaXplID0gRW5jb2RlciQxLldPUkRfU0laRVtsYXllcnNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R1ZmZlZEJpdHMgPSBFbmNvZGVyJDEuc3R1ZmZCaXRzKGJpdHMsIHdvcmRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgdXNhYmxlQml0c0luTGF5ZXJzID0gdG90YWxCaXRzSW5MYXllciAtICh0b3RhbEJpdHNJbkxheWVyICUgd29yZFNpemUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFjdCAmJiBzdHVmZmVkQml0cy5nZXRTaXplKCkgPiB3b3JkU2l6ZSAqIDY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wYWN0IGZvcm1hdCBvbmx5IGFsbG93cyA2NCBkYXRhIHdvcmRzLCB0aG91Z2ggQzQgY2FuIGhvbGQgbW9yZSB3b3JkcyB0aGFuIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHVmZmVkQml0cy5nZXRTaXplKCkgKyBlY2NCaXRzIDw9IHVzYWJsZUJpdHNJbkxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWVzc2FnZUJpdHMgPSBFbmNvZGVyJDEuZ2VuZXJhdGVDaGVja1dvcmRzKHN0dWZmZWRCaXRzLCB0b3RhbEJpdHNJbkxheWVyLCB3b3JkU2l6ZSk7XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBtb2RlIG1lc3NhZ2VcbiAgICAgICAgICAgIGxldCBtZXNzYWdlU2l6ZUluV29yZHMgPSBzdHVmZmVkQml0cy5nZXRTaXplKCkgLyB3b3JkU2l6ZTtcbiAgICAgICAgICAgIGxldCBtb2RlTWVzc2FnZSA9IEVuY29kZXIkMS5nZW5lcmF0ZU1vZGVNZXNzYWdlKGNvbXBhY3QsIGxheWVycywgbWVzc2FnZVNpemVJbldvcmRzKTtcbiAgICAgICAgICAgIC8vIGFsbG9jYXRlIHN5bWJvbFxuICAgICAgICAgICAgbGV0IGJhc2VNYXRyaXhTaXplID0gKGNvbXBhY3QgPyAxMSA6IDE0KSArIGxheWVycyAqIDQ7IC8vIG5vdCBpbmNsdWRpbmcgYWxpZ25tZW50IGxpbmVzXG4gICAgICAgICAgICBsZXQgYWxpZ25tZW50TWFwID0gbmV3IEludDMyQXJyYXkoYmFzZU1hdHJpeFNpemUpO1xuICAgICAgICAgICAgbGV0IG1hdHJpeFNpemU7XG4gICAgICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGFsaWdubWVudCBtYXJrcyBpbiBjb21wYWN0IG1vZGUsIGFsaWdubWVudE1hcCBpcyBhIG5vLW9wXG4gICAgICAgICAgICAgICAgbWF0cml4U2l6ZSA9IGJhc2VNYXRyaXhTaXplO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBhbGlnbm1lbnRNYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50TWFwW2ldID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRyaXhTaXplID0gYmFzZU1hdHJpeFNpemUgKyAxICsgMiAqIEludGVnZXIudHJ1bmNEaXZpc2lvbigoSW50ZWdlci50cnVuY0RpdmlzaW9uKGJhc2VNYXRyaXhTaXplLCAyKSAtIDEpLCAxNSk7XG4gICAgICAgICAgICAgICAgbGV0IG9yaWdDZW50ZXIgPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24oYmFzZU1hdHJpeFNpemUsIDIpO1xuICAgICAgICAgICAgICAgIGxldCBjZW50ZXIgPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IG9yaWdDZW50ZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3T2Zmc2V0ID0gaSArIEludGVnZXIudHJ1bmNEaXZpc2lvbihpLCAxNSk7XG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudE1hcFtvcmlnQ2VudGVyIC0gaSAtIDFdID0gY2VudGVyIC0gbmV3T2Zmc2V0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50TWFwW29yaWdDZW50ZXIgKyBpXSA9IGNlbnRlciArIG5ld09mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1hdHJpeCA9IG5ldyBCaXRNYXRyaXgobWF0cml4U2l6ZSk7XG4gICAgICAgICAgICAvLyBkcmF3IGRhdGEgYml0c1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMCwgcm93T2Zmc2V0ID0gMDsgaSA8IGxheWVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvd1NpemUgPSAobGF5ZXJzIC0gaSkgKiA0ICsgKGNvbXBhY3QgPyA5IDogMTIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogLyppbnQqLyA9IDA7IGogPCByb3dTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbHVtbk9mZnNldCA9IGogKiAyO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrIC8qaW50Ki8gPSAwOyBrIDwgMjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZUJpdHMuZ2V0KHJvd09mZnNldCArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChhbGlnbm1lbnRNYXBbaSAqIDIgKyBrXSwgYWxpZ25tZW50TWFwW2kgKiAyICsgal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VCaXRzLmdldChyb3dPZmZzZXQgKyByb3dTaXplICogMiArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChhbGlnbm1lbnRNYXBbaSAqIDIgKyBqXSwgYWxpZ25tZW50TWFwW2Jhc2VNYXRyaXhTaXplIC0gMSAtIGkgKiAyIC0ga10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VCaXRzLmdldChyb3dPZmZzZXQgKyByb3dTaXplICogNCArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChhbGlnbm1lbnRNYXBbYmFzZU1hdHJpeFNpemUgLSAxIC0gaSAqIDIgLSBrXSwgYWxpZ25tZW50TWFwW2Jhc2VNYXRyaXhTaXplIC0gMSAtIGkgKiAyIC0gal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VCaXRzLmdldChyb3dPZmZzZXQgKyByb3dTaXplICogNiArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChhbGlnbm1lbnRNYXBbYmFzZU1hdHJpeFNpemUgLSAxIC0gaSAqIDIgLSBqXSwgYWxpZ25tZW50TWFwW2kgKiAyICsga10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSByb3dTaXplICogODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRyYXcgbW9kZSBtZXNzYWdlXG4gICAgICAgICAgICBFbmNvZGVyJDEuZHJhd01vZGVNZXNzYWdlKG1hdHJpeCwgY29tcGFjdCwgbWF0cml4U2l6ZSwgbW9kZU1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gZHJhdyBhbGlnbm1lbnQgbWFya3NcbiAgICAgICAgICAgIGlmIChjb21wYWN0KSB7XG4gICAgICAgICAgICAgICAgRW5jb2RlciQxLmRyYXdCdWxsc0V5ZShtYXRyaXgsIEludGVnZXIudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKSwgNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBFbmNvZGVyJDEuZHJhd0J1bGxzRXllKG1hdHJpeCwgSW50ZWdlci50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpLCA3KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwLCBqID0gMDsgaSA8IEludGVnZXIudHJ1bmNEaXZpc2lvbihiYXNlTWF0cml4U2l6ZSwgMikgLSAxOyBpICs9IDE1LCBqICs9IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgLyppbnQqLyA9IEludGVnZXIudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKSAmIDE7IGsgPCBtYXRyaXhTaXplOyBrICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoSW50ZWdlci50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpIC0gaiwgayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KEludGVnZXIudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKSArIGosIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChrLCBJbnRlZ2VyLnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMikgLSBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoaywgSW50ZWdlci50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpICsgaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYXp0ZWMgPSBuZXcgQXp0ZWNDb2RlKCk7XG4gICAgICAgICAgICBhenRlYy5zZXRDb21wYWN0KGNvbXBhY3QpO1xuICAgICAgICAgICAgYXp0ZWMuc2V0U2l6ZShtYXRyaXhTaXplKTtcbiAgICAgICAgICAgIGF6dGVjLnNldExheWVycyhsYXllcnMpO1xuICAgICAgICAgICAgYXp0ZWMuc2V0Q29kZVdvcmRzKG1lc3NhZ2VTaXplSW5Xb3Jkcyk7XG4gICAgICAgICAgICBhenRlYy5zZXRNYXRyaXgobWF0cml4KTtcbiAgICAgICAgICAgIHJldHVybiBhenRlYztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZHJhd0J1bGxzRXllKG1hdHJpeCwgY2VudGVyLCBzaXplKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgc2l6ZTsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiAvKmludCovID0gY2VudGVyIC0gaTsgaiA8PSBjZW50ZXIgKyBpOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChqLCBjZW50ZXIgLSBpKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChqLCBjZW50ZXIgKyBpKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgLSBpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgKyBpLCBqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRyaXguc2V0KGNlbnRlciAtIHNpemUsIGNlbnRlciAtIHNpemUpO1xuICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgLSBzaXplICsgMSwgY2VudGVyIC0gc2l6ZSk7XG4gICAgICAgICAgICBtYXRyaXguc2V0KGNlbnRlciAtIHNpemUsIGNlbnRlciAtIHNpemUgKyAxKTtcbiAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyICsgc2l6ZSwgY2VudGVyIC0gc2l6ZSk7XG4gICAgICAgICAgICBtYXRyaXguc2V0KGNlbnRlciArIHNpemUsIGNlbnRlciAtIHNpemUgKyAxKTtcbiAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyICsgc2l6ZSwgY2VudGVyICsgc2l6ZSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZW5lcmF0ZU1vZGVNZXNzYWdlKGNvbXBhY3QsIGxheWVycywgbWVzc2FnZVNpemVJbldvcmRzKSB7XG4gICAgICAgICAgICBsZXQgbW9kZU1lc3NhZ2UgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIGlmIChjb21wYWN0KSB7XG4gICAgICAgICAgICAgICAgbW9kZU1lc3NhZ2UuYXBwZW5kQml0cyhsYXllcnMgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICBtb2RlTWVzc2FnZS5hcHBlbmRCaXRzKG1lc3NhZ2VTaXplSW5Xb3JkcyAtIDEsIDYpO1xuICAgICAgICAgICAgICAgIG1vZGVNZXNzYWdlID0gRW5jb2RlciQxLmdlbmVyYXRlQ2hlY2tXb3Jkcyhtb2RlTWVzc2FnZSwgMjgsIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9kZU1lc3NhZ2UuYXBwZW5kQml0cyhsYXllcnMgLSAxLCA1KTtcbiAgICAgICAgICAgICAgICBtb2RlTWVzc2FnZS5hcHBlbmRCaXRzKG1lc3NhZ2VTaXplSW5Xb3JkcyAtIDEsIDExKTtcbiAgICAgICAgICAgICAgICBtb2RlTWVzc2FnZSA9IEVuY29kZXIkMS5nZW5lcmF0ZUNoZWNrV29yZHMobW9kZU1lc3NhZ2UsIDQwLCA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2RlTWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZHJhd01vZGVNZXNzYWdlKG1hdHJpeCwgY29tcGFjdCwgbWF0cml4U2l6ZSwgbW9kZU1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGxldCBjZW50ZXIgPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMik7XG4gICAgICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGNlbnRlciAtIDMgKyBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KG9mZnNldCwgY2VudGVyIC0gNSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVNZXNzYWdlLmdldChpICsgNykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyICsgNSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KDIwIC0gaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQob2Zmc2V0LCBjZW50ZXIgKyA1KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KDI3IC0gaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyIC0gNSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBjZW50ZXIgLSA1ICsgaSArIEludGVnZXIudHJ1bmNEaXZpc2lvbihpLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVNZXNzYWdlLmdldChpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChvZmZzZXQsIGNlbnRlciAtIDcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlTWVzc2FnZS5nZXQoaSArIDEwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgKyA3LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlTWVzc2FnZS5nZXQoMjkgLSBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChvZmZzZXQsIGNlbnRlciArIDcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlTWVzc2FnZS5nZXQoMzkgLSBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgLSA3LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZW5lcmF0ZUNoZWNrV29yZHMoYml0QXJyYXksIHRvdGFsQml0cywgd29yZFNpemUpIHtcbiAgICAgICAgICAgIC8vIGJpdEFycmF5IGlzIGd1YXJhbnRlZWQgdG8gYmUgYSBtdWx0aXBsZSBvZiB0aGUgd29yZFNpemUsIHNvIG5vIHBhZGRpbmcgbmVlZGVkXG4gICAgICAgICAgICBsZXQgbWVzc2FnZVNpemVJbldvcmRzID0gYml0QXJyYXkuZ2V0U2l6ZSgpIC8gd29yZFNpemU7XG4gICAgICAgICAgICBsZXQgcnMgPSBuZXcgUmVlZFNvbG9tb25FbmNvZGVyKEVuY29kZXIkMS5nZXRHRih3b3JkU2l6ZSkpO1xuICAgICAgICAgICAgbGV0IHRvdGFsV29yZHMgPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24odG90YWxCaXRzLCB3b3JkU2l6ZSk7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZVdvcmRzID0gRW5jb2RlciQxLmJpdHNUb1dvcmRzKGJpdEFycmF5LCB3b3JkU2l6ZSwgdG90YWxXb3Jkcyk7XG4gICAgICAgICAgICBycy5lbmNvZGUobWVzc2FnZVdvcmRzLCB0b3RhbFdvcmRzIC0gbWVzc2FnZVNpemVJbldvcmRzKTtcbiAgICAgICAgICAgIGxldCBzdGFydFBhZCA9IHRvdGFsQml0cyAlIHdvcmRTaXplO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VCaXRzID0gbmV3IEJpdEFycmF5KCk7XG4gICAgICAgICAgICBtZXNzYWdlQml0cy5hcHBlbmRCaXRzKDAsIHN0YXJ0UGFkKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZVdvcmQgLyo6IGludCovIG9mIEFycmF5LmZyb20obWVzc2FnZVdvcmRzKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VCaXRzLmFwcGVuZEJpdHMobWVzc2FnZVdvcmQsIHdvcmRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlQml0cztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYml0c1RvV29yZHMoc3R1ZmZlZEJpdHMsIHdvcmRTaXplLCB0b3RhbFdvcmRzKSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IG5ldyBJbnQzMkFycmF5KHRvdGFsV29yZHMpO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBzdHVmZmVkQml0cy5nZXRTaXplKCkgLyB3b3JkU2l6ZTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiAvKmludCovID0gMDsgaiA8IHdvcmRTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgfD0gc3R1ZmZlZEJpdHMuZ2V0KGkgKiB3b3JkU2l6ZSArIGopID8gKDEgPDwgd29yZFNpemUgLSBqIC0gMSkgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXNzYWdlW2ldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0R0Yod29yZFNpemUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAod29yZFNpemUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBHZW5lcmljR0YuQVpURUNfUEFSQU07XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gR2VuZXJpY0dGLkFaVEVDX0RBVEFfNjtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBHZW5lcmljR0YuQVpURUNfREFUQV84O1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBHZW5lcmljR0YuQVpURUNfREFUQV8xMDtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gR2VuZXJpY0dGLkFaVEVDX0RBVEFfMTI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgd29yZCBzaXplICcgKyB3b3JkU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHN0dWZmQml0cyhiaXRzLCB3b3JkU2l6ZSkge1xuICAgICAgICAgICAgbGV0IG91dCA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgbGV0IG4gPSBiaXRzLmdldFNpemUoKTtcbiAgICAgICAgICAgIGxldCBtYXNrID0gKDEgPDwgd29yZFNpemUpIC0gMjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBuOyBpICs9IHdvcmRTaXplKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdvcmQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogLyppbnQqLyA9IDA7IGogPCB3b3JkU2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgaiA+PSBuIHx8IGJpdHMuZ2V0KGkgKyBqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29yZCB8PSAxIDw8ICh3b3JkU2l6ZSAtIDEgLSBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHdvcmQgJiBtYXNrKSA9PT0gbWFzaykge1xuICAgICAgICAgICAgICAgICAgICBvdXQuYXBwZW5kQml0cyh3b3JkICYgbWFzaywgd29yZFNpemUpO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh3b3JkICYgbWFzaykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmFwcGVuZEJpdHMod29yZCB8IDEsIHdvcmRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmFwcGVuZEJpdHMod29yZCwgd29yZFNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHRvdGFsQml0c0luTGF5ZXIobGF5ZXJzLCBjb21wYWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKChjb21wYWN0ID8gODggOiAxMTIpICsgMTYgKiBsYXllcnMpICogbGF5ZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIEVuY29kZXIkMS5ERUZBVUxUX0VDX1BFUkNFTlQgPSAzMzsgLy8gZGVmYXVsdCBtaW5pbWFsIHBlcmNlbnRhZ2Ugb2YgZXJyb3IgY2hlY2sgd29yZHNcbiAgICBFbmNvZGVyJDEuREVGQVVMVF9BWlRFQ19MQVlFUlMgPSAwO1xuICAgIEVuY29kZXIkMS5NQVhfTkJfQklUUyA9IDMyO1xuICAgIEVuY29kZXIkMS5NQVhfTkJfQklUU19DT01QQUNUID0gNDtcbiAgICBFbmNvZGVyJDEuV09SRF9TSVpFID0gSW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgNCwgNiwgNiwgOCwgOCwgOCwgOCwgOCwgOCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLFxuICAgICAgICAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMlxuICAgIF0pO1xuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbiBBenRlYyBjb2RlIGFzIGEge0BsaW5rIEJpdE1hdHJpeH0uXG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBBenRlY1dyaXRlciB7XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBlbmNvZGUoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlV2l0aEhpbnRzKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBlbmNvZGVXaXRoSGludHMoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgaGludHMpIHtcbiAgICAgICAgICAgIGxldCBjaGFyc2V0ID0gU3RhbmRhcmRDaGFyc2V0cy5JU09fODg1OV8xO1xuICAgICAgICAgICAgbGV0IGVjY1BlcmNlbnQgPSBFbmNvZGVyJDEuREVGQVVMVF9FQ19QRVJDRU5UO1xuICAgICAgICAgICAgbGV0IGxheWVycyA9IEVuY29kZXIkMS5ERUZBVUxUX0FaVEVDX0xBWUVSUztcbiAgICAgICAgICAgIGlmIChoaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhpbnRzLmhhcyhFbmNvZGVIaW50VHlwZSQxLkNIQVJBQ1RFUl9TRVQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzZXQgPSBDaGFyc2V0LmZvck5hbWUoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuQ0hBUkFDVEVSX1NFVCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoaW50cy5oYXMoRW5jb2RlSGludFR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OKSkge1xuICAgICAgICAgICAgICAgICAgICBlY2NQZXJjZW50ID0gSW50ZWdlci5wYXJzZUludChoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhpbnRzLmhhcyhFbmNvZGVIaW50VHlwZSQxLkFaVEVDX0xBWUVSUykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJzID0gSW50ZWdlci5wYXJzZUludChoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5BWlRFQ19MQVlFUlMpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBenRlY1dyaXRlci5lbmNvZGVMYXllcnMoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgY2hhcnNldCwgZWNjUGVyY2VudCwgbGF5ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZW5jb2RlTGF5ZXJzKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGNoYXJzZXQsIGVjY1BlcmNlbnQsIGxheWVycykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCAhPT0gQmFyY29kZUZvcm1hdCQxLkFaVEVDKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQ2FuIG9ubHkgZW5jb2RlIEFaVEVDLCBidXQgZ290ICcgKyBmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGF6dGVjID0gRW5jb2RlciQxLmVuY29kZShTdHJpbmdVdGlscy5nZXRCeXRlcyhjb250ZW50cywgY2hhcnNldCksIGVjY1BlcmNlbnQsIGxheWVycyk7XG4gICAgICAgICAgICByZXR1cm4gQXp0ZWNXcml0ZXIucmVuZGVyUmVzdWx0KGF6dGVjLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcmVuZGVyUmVzdWx0KGNvZGUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGNvZGUuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbnB1dFdpZHRoID0gaW5wdXQuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGxldCBpbnB1dEhlaWdodCA9IGlucHV0LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgbGV0IG91dHB1dFdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGlucHV0V2lkdGgpO1xuICAgICAgICAgICAgbGV0IG91dHB1dEhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgaW5wdXRIZWlnaHQpO1xuICAgICAgICAgICAgbGV0IG11bHRpcGxlID0gTWF0aC5taW4ob3V0cHV0V2lkdGggLyBpbnB1dFdpZHRoLCBvdXRwdXRIZWlnaHQgLyBpbnB1dEhlaWdodCk7XG4gICAgICAgICAgICBsZXQgbGVmdFBhZGRpbmcgPSAob3V0cHV0V2lkdGggLSAoaW5wdXRXaWR0aCAqIG11bHRpcGxlKSkgLyAyO1xuICAgICAgICAgICAgbGV0IHRvcFBhZGRpbmcgPSAob3V0cHV0SGVpZ2h0IC0gKGlucHV0SGVpZ2h0ICogbXVsdGlwbGUpKSAvIDI7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gbmV3IEJpdE1hdHJpeChvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGlucHV0WSAvKmludCovID0gMCwgb3V0cHV0WSA9IHRvcFBhZGRpbmc7IGlucHV0WSA8IGlucHV0SGVpZ2h0OyBpbnB1dFkrKywgb3V0cHV0WSArPSBtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBjb250ZW50cyBvZiB0aGlzIHJvdyBvZiB0aGUgYmFyY29kZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlucHV0WCAvKmludCovID0gMCwgb3V0cHV0WCA9IGxlZnRQYWRkaW5nOyBpbnB1dFggPCBpbnB1dFdpZHRoOyBpbnB1dFgrKywgb3V0cHV0WCArPSBtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZ2V0KGlucHV0WCwgaW5wdXRZKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldFJlZ2lvbihvdXRwdXRYLCBvdXRwdXRZLCBtdWx0aXBsZSwgbXVsdGlwbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHMuQWJzdHJhY3RFeHBhbmRlZERlY29kZXIgPSBBYnN0cmFjdEV4cGFuZGVkRGVjb2RlcjtcbiAgICBleHBvcnRzLkFyZ3VtZW50RXhjZXB0aW9uID0gQXJndW1lbnRFeGNlcHRpb247XG4gICAgZXhwb3J0cy5Bcml0aG1ldGljRXhjZXB0aW9uID0gQXJpdGhtZXRpY0V4Y2VwdGlvbjtcbiAgICBleHBvcnRzLkF6dGVjQ29kZSA9IEF6dGVjQ29kZTtcbiAgICBleHBvcnRzLkF6dGVjQ29kZVJlYWRlciA9IEF6dGVjUmVhZGVyO1xuICAgIGV4cG9ydHMuQXp0ZWNDb2RlV3JpdGVyID0gQXp0ZWNXcml0ZXI7XG4gICAgZXhwb3J0cy5BenRlY0RlY29kZXIgPSBEZWNvZGVyO1xuICAgIGV4cG9ydHMuQXp0ZWNEZXRlY3RvciA9IERldGVjdG9yO1xuICAgIGV4cG9ydHMuQXp0ZWNEZXRlY3RvclJlc3VsdCA9IEF6dGVjRGV0ZWN0b3JSZXN1bHQ7XG4gICAgZXhwb3J0cy5BenRlY0VuY29kZXIgPSBFbmNvZGVyJDE7XG4gICAgZXhwb3J0cy5BenRlY0hpZ2hMZXZlbEVuY29kZXIgPSBIaWdoTGV2ZWxFbmNvZGVyO1xuICAgIGV4cG9ydHMuQXp0ZWNQb2ludCA9IFBvaW50O1xuICAgIGV4cG9ydHMuQmFyY29kZUZvcm1hdCA9IEJhcmNvZGVGb3JtYXQkMTtcbiAgICBleHBvcnRzLkJpbmFyaXplciA9IEJpbmFyaXplcjtcbiAgICBleHBvcnRzLkJpbmFyeUJpdG1hcCA9IEJpbmFyeUJpdG1hcDtcbiAgICBleHBvcnRzLkJpdEFycmF5ID0gQml0QXJyYXk7XG4gICAgZXhwb3J0cy5CaXRNYXRyaXggPSBCaXRNYXRyaXg7XG4gICAgZXhwb3J0cy5CaXRTb3VyY2UgPSBCaXRTb3VyY2U7XG4gICAgZXhwb3J0cy5Ccm93c2VyQXp0ZWNDb2RlUmVhZGVyID0gQnJvd3NlckF6dGVjQ29kZVJlYWRlcjtcbiAgICBleHBvcnRzLkJyb3dzZXJCYXJjb2RlUmVhZGVyID0gQnJvd3NlckJhcmNvZGVSZWFkZXI7XG4gICAgZXhwb3J0cy5Ccm93c2VyQ29kZVJlYWRlciA9IEJyb3dzZXJDb2RlUmVhZGVyO1xuICAgIGV4cG9ydHMuQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyID0gQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyO1xuICAgIGV4cG9ydHMuQnJvd3Nlck11bHRpRm9ybWF0UmVhZGVyID0gQnJvd3Nlck11bHRpRm9ybWF0UmVhZGVyO1xuICAgIGV4cG9ydHMuQnJvd3NlclBERjQxN1JlYWRlciA9IEJyb3dzZXJQREY0MTdSZWFkZXI7XG4gICAgZXhwb3J0cy5Ccm93c2VyUVJDb2RlUmVhZGVyID0gQnJvd3NlclFSQ29kZVJlYWRlcjtcbiAgICBleHBvcnRzLkJyb3dzZXJRUkNvZGVTdmdXcml0ZXIgPSBCcm93c2VyUVJDb2RlU3ZnV3JpdGVyO1xuICAgIGV4cG9ydHMuQ2hhcmFjdGVyU2V0RUNJID0gQ2hhcmFjdGVyU2V0RUNJO1xuICAgIGV4cG9ydHMuQ2hlY2tzdW1FeGNlcHRpb24gPSBDaGVja3N1bUV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLkNvZGUxMjhSZWFkZXIgPSBDb2RlMTI4UmVhZGVyO1xuICAgIGV4cG9ydHMuQ29kZTM5UmVhZGVyID0gQ29kZTM5UmVhZGVyO1xuICAgIGV4cG9ydHMuRGF0YU1hdHJpeERlY29kZWRCaXRTdHJlYW1QYXJzZXIgPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyO1xuICAgIGV4cG9ydHMuRGF0YU1hdHJpeFJlYWRlciA9IERhdGFNYXRyaXhSZWFkZXI7XG4gICAgZXhwb3J0cy5EZWNvZGVIaW50VHlwZSA9IERlY29kZUhpbnRUeXBlJDE7XG4gICAgZXhwb3J0cy5EZWNvZGVyUmVzdWx0ID0gRGVjb2RlclJlc3VsdDtcbiAgICBleHBvcnRzLkRlZmF1bHRHcmlkU2FtcGxlciA9IERlZmF1bHRHcmlkU2FtcGxlcjtcbiAgICBleHBvcnRzLkRldGVjdG9yUmVzdWx0ID0gRGV0ZWN0b3JSZXN1bHQ7XG4gICAgZXhwb3J0cy5FQU4xM1JlYWRlciA9IEVBTjEzUmVhZGVyO1xuICAgIGV4cG9ydHMuRW5jb2RlSGludFR5cGUgPSBFbmNvZGVIaW50VHlwZSQxO1xuICAgIGV4cG9ydHMuRXhjZXB0aW9uID0gRXhjZXB0aW9uO1xuICAgIGV4cG9ydHMuRm9ybWF0RXhjZXB0aW9uID0gRm9ybWF0RXhjZXB0aW9uO1xuICAgIGV4cG9ydHMuR2VuZXJpY0dGID0gR2VuZXJpY0dGO1xuICAgIGV4cG9ydHMuR2VuZXJpY0dGUG9seSA9IEdlbmVyaWNHRlBvbHk7XG4gICAgZXhwb3J0cy5HbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIgPSBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXI7XG4gICAgZXhwb3J0cy5HcmlkU2FtcGxlciA9IEdyaWRTYW1wbGVyO1xuICAgIGV4cG9ydHMuR3JpZFNhbXBsZXJJbnN0YW5jZSA9IEdyaWRTYW1wbGVySW5zdGFuY2U7XG4gICAgZXhwb3J0cy5IVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZSA9IEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlO1xuICAgIGV4cG9ydHMuSHlicmlkQmluYXJpemVyID0gSHlicmlkQmluYXJpemVyO1xuICAgIGV4cG9ydHMuSVRGUmVhZGVyID0gSVRGUmVhZGVyO1xuICAgIGV4cG9ydHMuSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uID0gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uO1xuICAgIGV4cG9ydHMuSWxsZWdhbFN0YXRlRXhjZXB0aW9uID0gSWxsZWdhbFN0YXRlRXhjZXB0aW9uO1xuICAgIGV4cG9ydHMuSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UgPSBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZTtcbiAgICBleHBvcnRzLkx1bWluYW5jZVNvdXJjZSA9IEx1bWluYW5jZVNvdXJjZTtcbiAgICBleHBvcnRzLk1hdGhVdGlscyA9IE1hdGhVdGlscztcbiAgICBleHBvcnRzLk11bHRpRm9ybWF0T25lRFJlYWRlciA9IE11bHRpRm9ybWF0T25lRFJlYWRlcjtcbiAgICBleHBvcnRzLk11bHRpRm9ybWF0UmVhZGVyID0gTXVsdGlGb3JtYXRSZWFkZXI7XG4gICAgZXhwb3J0cy5NdWx0aUZvcm1hdFdyaXRlciA9IE11bHRpRm9ybWF0V3JpdGVyO1xuICAgIGV4cG9ydHMuTm90Rm91bmRFeGNlcHRpb24gPSBOb3RGb3VuZEV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLk9uZURSZWFkZXIgPSBPbmVEUmVhZGVyO1xuICAgIGV4cG9ydHMuUERGNDE3RGVjb2RlZEJpdFN0cmVhbVBhcnNlciA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMjtcbiAgICBleHBvcnRzLlBERjQxN0RlY29kZXJFcnJvckNvcnJlY3Rpb24gPSBFcnJvckNvcnJlY3Rpb247XG4gICAgZXhwb3J0cy5QREY0MTdSZWFkZXIgPSBQREY0MTdSZWFkZXI7XG4gICAgZXhwb3J0cy5QREY0MTdSZXN1bHRNZXRhZGF0YSA9IFBERjQxN1Jlc3VsdE1ldGFkYXRhO1xuICAgIGV4cG9ydHMuUGVyc3BlY3RpdmVUcmFuc2Zvcm0gPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybTtcbiAgICBleHBvcnRzLlBsYW5hcllVVkx1bWluYW5jZVNvdXJjZSA9IFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZTtcbiAgICBleHBvcnRzLlFSQ29kZUJ5dGVNYXRyaXggPSBCeXRlTWF0cml4O1xuICAgIGV4cG9ydHMuUVJDb2RlRGF0YU1hc2sgPSBEYXRhTWFzaztcbiAgICBleHBvcnRzLlFSQ29kZURlY29kZWRCaXRTdHJlYW1QYXJzZXIgPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDE7XG4gICAgZXhwb3J0cy5RUkNvZGVEZWNvZGVyRXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBFcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICBleHBvcnRzLlFSQ29kZURlY29kZXJGb3JtYXRJbmZvcm1hdGlvbiA9IEZvcm1hdEluZm9ybWF0aW9uO1xuICAgIGV4cG9ydHMuUVJDb2RlRW5jb2RlciA9IEVuY29kZXI7XG4gICAgZXhwb3J0cy5RUkNvZGVFbmNvZGVyUVJDb2RlID0gUVJDb2RlO1xuICAgIGV4cG9ydHMuUVJDb2RlTWFza1V0aWwgPSBNYXNrVXRpbDtcbiAgICBleHBvcnRzLlFSQ29kZU1hdHJpeFV0aWwgPSBNYXRyaXhVdGlsO1xuICAgIGV4cG9ydHMuUVJDb2RlTW9kZSA9IE1vZGUkMTtcbiAgICBleHBvcnRzLlFSQ29kZVJlYWRlciA9IFFSQ29kZVJlYWRlcjtcbiAgICBleHBvcnRzLlFSQ29kZVZlcnNpb24gPSBWZXJzaW9uJDE7XG4gICAgZXhwb3J0cy5RUkNvZGVXcml0ZXIgPSBRUkNvZGVXcml0ZXI7XG4gICAgZXhwb3J0cy5SR0JMdW1pbmFuY2VTb3VyY2UgPSBSR0JMdW1pbmFuY2VTb3VyY2U7XG4gICAgZXhwb3J0cy5SU1MxNFJlYWRlciA9IFJTUzE0UmVhZGVyO1xuICAgIGV4cG9ydHMuUlNTRXhwYW5kZWRSZWFkZXIgPSBSU1NFeHBhbmRlZFJlYWRlcjtcbiAgICBleHBvcnRzLlJlYWRlckV4Y2VwdGlvbiA9IFJlYWRlckV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLlJlZWRTb2xvbW9uRGVjb2RlciA9IFJlZWRTb2xvbW9uRGVjb2RlcjtcbiAgICBleHBvcnRzLlJlZWRTb2xvbW9uRW5jb2RlciA9IFJlZWRTb2xvbW9uRW5jb2RlcjtcbiAgICBleHBvcnRzLlJlZWRTb2xvbW9uRXhjZXB0aW9uID0gUmVlZFNvbG9tb25FeGNlcHRpb247XG4gICAgZXhwb3J0cy5SZXN1bHQgPSBSZXN1bHQ7XG4gICAgZXhwb3J0cy5SZXN1bHRNZXRhZGF0YVR5cGUgPSBSZXN1bHRNZXRhZGF0YVR5cGUkMTtcbiAgICBleHBvcnRzLlJlc3VsdFBvaW50ID0gUmVzdWx0UG9pbnQ7XG4gICAgZXhwb3J0cy5TdHJpbmdVdGlscyA9IFN0cmluZ1V0aWxzO1xuICAgIGV4cG9ydHMuVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24gPSBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLlZpZGVvSW5wdXREZXZpY2UgPSBWaWRlb0lucHV0RGV2aWNlO1xuICAgIGV4cG9ydHMuV2hpdGVSZWN0YW5nbGVEZXRlY3RvciA9IFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3I7XG4gICAgZXhwb3J0cy5Xcml0ZXJFeGNlcHRpb24gPSBXcml0ZXJFeGNlcHRpb247XG4gICAgZXhwb3J0cy5aWGluZ0FycmF5cyA9IEFycmF5cztcbiAgICBleHBvcnRzLlpYaW5nQ2hhcnNldCA9IENoYXJzZXQ7XG4gICAgZXhwb3J0cy5aWGluZ0ludGVnZXIgPSBJbnRlZ2VyO1xuICAgIGV4cG9ydHMuWlhpbmdTdGFuZGFyZENoYXJzZXRzID0gU3RhbmRhcmRDaGFyc2V0cztcbiAgICBleHBvcnRzLlpYaW5nU3RyaW5nQnVpbGRlciA9IFN0cmluZ0J1aWxkZXI7XG4gICAgZXhwb3J0cy5aWGluZ1N0cmluZ0VuY29kaW5nID0gU3RyaW5nRW5jb2Rpbmc7XG4gICAgZXhwb3J0cy5aWGluZ1N5c3RlbSA9IFN5c3RlbTtcbiAgICBleHBvcnRzLmNyZWF0ZUFic3RyYWN0RXhwYW5kZWREZWNvZGVyID0gY3JlYXRlRGVjb2RlcjtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html5-qrcode/third_party/zxing-js.umd.js\n"));

/***/ }),

/***/ "./components/QRScanner.tsx":
/*!**********************************!*\
  !*** ./components/QRScanner.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var html5_qrcode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! html5-qrcode */ \"./node_modules/html5-qrcode/esm/index.js\");\n// components/QRScanner.tsx\n\nvar _s = $RefreshSig$();\n\n\nconst QRScanner = ()=>{\n    _s();\n    const qrCodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const scanner = new html5_qrcode__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScanner(qrCodeRef.current, {\n            fps: 10,\n            qrbox: 250\n        }, false);\n        scanner.render((result)=>{\n            console.log(result);\n        }, (error)=>{\n            console.warn(error);\n        });\n        return ()=>{\n            scanner.clear();\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: qrCodeRef,\n        style: {\n            width: \"300px\",\n            height: \"300px\"\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\victo\\\\caminos\\\\components\\\\QRScanner.tsx\",\n        lineNumber: 29,\n        columnNumber: 10\n    }, undefined);\n};\n_s(QRScanner, \"n3XkxOz+52xEjzVIwTG6aG740uY=\");\n_c = QRScanner;\n/* harmony default export */ __webpack_exports__[\"default\"] = (QRScanner);\nvar _c;\n$RefreshReg$(_c, \"QRScanner\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1FSU2Nhbm5lci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMkJBQTJCOzs7QUFDc0I7QUFDQztBQUVsRCxNQUFNSSxZQUFZOztJQUNoQixNQUFNQyxZQUFZSiw2Q0FBTUEsQ0FBd0I7SUFFaERDLGdEQUFTQSxDQUFDO1FBQ1IsTUFBTUksVUFBVSxJQUFJSCw0REFBa0JBLENBQ3BDRSxVQUFVRSxPQUFPLEVBQ2pCO1lBQUVDLEtBQUs7WUFBSUMsT0FBTztRQUFJLEdBQ3RCO1FBR0ZILFFBQVFJLE1BQU0sQ0FDWixDQUFDQztZQUNDQyxRQUFRQyxHQUFHLENBQUNGO1FBQ2QsR0FDQSxDQUFDRztZQUNDRixRQUFRRyxJQUFJLENBQUNEO1FBQ2Y7UUFHRixPQUFPO1lBQ0xSLFFBQVFVLEtBQUs7UUFDZjtJQUNGLEdBQUcsRUFBRTtJQUVMLHFCQUFPLDhEQUFDQztRQUFJQyxLQUFLYjtRQUFXYyxPQUFPO1lBQUVDLE9BQU87WUFBU0MsUUFBUTtRQUFROzs7Ozs7QUFDdkU7R0F6Qk1qQjtLQUFBQTtBQTJCTiwrREFBZUEsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1FSU2Nhbm5lci50c3g/ZjIyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb21wb25lbnRzL1FSU2Nhbm5lci50c3hcclxuaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBIdG1sNVFyY29kZVNjYW5uZXIgfSBmcm9tICdodG1sNS1xcmNvZGUnO1xyXG5cclxuY29uc3QgUVJTY2FubmVyID0gKCkgPT4ge1xyXG4gIGNvbnN0IHFyQ29kZVJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudCB8IG51bGw+KG51bGwpO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3Qgc2Nhbm5lciA9IG5ldyBIdG1sNVFyY29kZVNjYW5uZXIoXHJcbiAgICAgIHFyQ29kZVJlZi5jdXJyZW50ISxcclxuICAgICAgeyBmcHM6IDEwLCBxcmJveDogMjUwIH0sXHJcbiAgICAgIGZhbHNlXHJcbiAgICApO1xyXG5cclxuICAgIHNjYW5uZXIucmVuZGVyKFxyXG4gICAgICAocmVzdWx0KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcclxuICAgICAgfSxcclxuICAgICAgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBzY2FubmVyLmNsZWFyKCk7XHJcbiAgICB9O1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgcmV0dXJuIDxkaXYgcmVmPXtxckNvZGVSZWZ9IHN0eWxlPXt7IHdpZHRoOiAnMzAwcHgnLCBoZWlnaHQ6ICczMDBweCcgfX0gLz47XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBRUlNjYW5uZXI7XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVJlZiIsInVzZUVmZmVjdCIsIkh0bWw1UXJjb2RlU2Nhbm5lciIsIlFSU2Nhbm5lciIsInFyQ29kZVJlZiIsInNjYW5uZXIiLCJjdXJyZW50IiwiZnBzIiwicXJib3giLCJyZW5kZXIiLCJyZXN1bHQiLCJjb25zb2xlIiwibG9nIiwiZXJyb3IiLCJ3YXJuIiwiY2xlYXIiLCJkaXYiLCJyZWYiLCJzdHlsZSIsIndpZHRoIiwiaGVpZ2h0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/QRScanner.tsx\n"));

/***/ })

}]);